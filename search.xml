<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js]]></title>
    <url>%2F2019%2F01%2F08%2Ftext-14%2F</url>
    <content type="text"><![CDATA[Node中的模块系统使用Node编写应用程序主要就是使用： ECMSCRIPT 编码规范 和浏览器不一样，在node中没有BOM/DOM 核心模块 文件操作 fs http 服务的 http url 路径操作模块 path路径处理模块 os操作系统信息 第三方模块 art-template 必须通过npm来下载使用 自定义模块 自己写的文件 什么是模块化 文件作用域 通信规则 加载 require 导出 CommonJS在node中的JavaScript还有一个很重要的概念系统：模块系统 模块作用域 使用require方法来加载模块 使用exports接口对象用来导出模块中的成员 加载 require1var 自定义变量名称 = require('模块'); 两个作用 执行被加载模块的代码 得到被夹在模块中的exports导出接口对象 require 加载规则 优先从缓存加载（避免重复加载，提高效率） 判断模块标识 导出exports node是模块作用域，默认文件中所有成员只能在当前文件模块有效 对于希望可以被其他模块访问的成员，需要将这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员必须在对象中 12345678exports.a = 123;exports.b ='hello';exports.c = functon()&#123; console.log(1);&#125;exports.d = &#123; foo:'bar',&#125; 导出单个成员（拿到的就是函数、字符串、obj）如上例所示，a,b,c,d 1module.exports = 'hello'; 以下情况会覆盖： 12345module.exports = 'hello';//add方法会覆盖字符串'hello'module.exports = function add (x,y)&#123; return x + y;&#125;; 利用module导出多个属性 123456module.exports = &#123; add : function (x,y)&#123; return x + y; &#125;, str:'hello';&#125; 12345678910//main.js// fooExpotrs 为foo.js 中 exports 对象var fooExpotrs = require('./foo.js');console.log(fooExports.add(1,2)) //3//foo.js//exports 是一个对象exports.add = funcion(x,y)&#123; return x + y;&#125; 1234567//如果一个模块需要直接导出某个成员，而非挂载的方式//则使用es6 中的module导出// foo.jsfunction add (x,y)&#123; return x + y;&#125; moudle.exports = add; 在node中，每个模块内部都有一个自己的moudle对象 在module对象中，有一个成员叫exports 也是一个对象 如果需要对外导出成员，只需要把导出的成员挂载到module.exports中去，node为了简化操作，专门提供了一个变量exports = module.exports 12345var moudle = &#123; exports:&#123; &#125;&#125; 12345678console.log(exports === module.exports) // true//结果等价，说明可以用任意一方来导出exports.str = 'hello';module.exports.add = function(x,y)&#123; return x + y;&#125;//&#123;add:[function],str:'hello'&#125;; 谁require，谁得到module.exports，其中exports相当于是module.exports的一个引用 最后程序中相当于 return module.exports 而不是expotrs，所以给exports重新赋值不管用 123456789101112131415exports.foo = 'bar';moudle.exports.a = 123;exports = &#123; a: 456,&#125;module.exports.foo = 'hello';exports.c = 'wordl';exports = moudle.exportsexports.a = 789;// &#123;foo:'hello',a:789&#125;module.exports = function ()&#123; console.log(1);&#125;//Function Express原生的http在某些方面表现不足以应对我们的开发需求，所以需要使用框架来加快开发，所以引入express框架 12345678//首先安装express//npm install express --save//加载模块资源const express = require('express');const app = express();app.get('/',(res,req)=&gt;&#123; req.send('hello expresss'); &#125;); express 官方文档]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module]]></title>
    <url>%2F2018%2F11%2F08%2Ftext-13%2F</url>
    <content type="text"><![CDATA[简介JavaScript一直没有模块(module)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，在ES6之前只能通过script标签引入一个js文件，与文件一起编译，无法做到模块化加载。ES6引入了Moudle，Moudle功能则是为了解决上述问题而提出的。ES6模块(module)不是对象，而是通过export命令显示指定输出的代码，输入时也采用静态命令的形式。 严格模式ES6的模块自动采用严格模式，不管有没有在模块头部加上“use strict”。严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性 不能使用with语句 不能对只读属性赋值 不能使用前缀0表示八进制数 不能删除不可删除属性 不能删除变量（delete prop），只能删除属性（delete global[prop]） eval 不会再其外层作用域引入变量 eval 和arguments 不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee，arguments.caller 禁止使用this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加保留字（static,protected,interface） export与importES6 模块体系是由export和import两个命令构成，export是定义需要导出的模块对外接口，import则是需要导入的模块接口1234567891011// 创建test.js,在test.js中导出变量和函数export var name = &apos;aaron&apos;;export function test()&#123; console.log(name);&#125;//在index.html中引入test.js&lt;script type=&quot;text/javascript&quot;&gt; import &#123;name,test&#125; from &apos;../js/test.js&apos;; test(); console.log(name);&lt;script&gt; 以上代码输出为aaron(test())，aaron (console.log(name)); import 对于待导入的模块的属性和方法，需要用{}括起来在index.html的js代码中不能出现同名属性或方法，否则会报错 使用export{属性,方法…}，用{}把属性，方法打包一并导出123456789101112// 创建test.js,在test.js中导出变量和函数var name = &apos;aaron&apos;;function test()&#123; console.log(name);&#125;export &#123;name,test&#125;;//在index.html中引入test.js&lt;script type=&quot;text/javascript&quot;&gt; import &#123;name,test&#125; from &apos;../js/test.js&apos;; test(); console.log(name);&lt;script&gt; 使用(*)表示一个对象，整体导入123456789101112// 创建test.js,在test.js中导出变量和函数var name = &apos;aaron&apos;;function test()&#123; console.log(name);&#125;export &#123;name,test&#125;;//在index.html中引入test.js&lt;script type=&quot;text/javascript&quot;&gt; import * as test from &apos;../js/test.js&apos;; test.test(); console.log(test.name);&lt;script&gt; import命令具有提升效果，会提升到整个模块的头部首先执行，所以import执行早于代码 export default从先前的例子可以看出，使用import命令时用户需要知道所要加载的变量名或函数名，否则无法加载。export default命令，为模块指定默认输出，default表示的是默认接口，从import导入时可以忽略对象的名字，任意命名，如下：1234567export default function()&#123; console.log(&apos;aaron&apos;);&#125;&lt;script type=&quot;text/javascript&quot;&gt; import test from &apos;../js/test.js&apos;; test();&lt;script&gt; 上面是默认输出一个函数，import 命令可以为这个匿名函数指定任意名字。这是import命令可以使用任意名称指向test.js输出的任意方法，这是就可以不用知道原模块输出的函数名。需要注意的是这是import命令后面不能使用花括号注：默认接口只能是一个，其余的只能通过export 导出接口 1234567891011var name = &apos;aaron&apos;;export default function()&#123; console.log(&apos;aaron&apos;);&#125;export &#123;name&#125;;&lt;script type=&quot;text/javascript&quot;&gt; import test from &apos;../js/test.js&apos;; import &#123;name&#125; from &apos;../js/test.js&apos;; test(); //aaron console.log(name); //aaron&lt;script&gt; 以上代码通过export default导出默认匿名函数，在index.html中引入当前默认接口并命名为test，test指代的就是匿名函数，然而在index.html中有引入name，是在当前的test.js中需要导出的一个变量，那么在index.html 中引入name变量就只能在test.js具名导出，在index.html中接收当前参数 声明本篇大部分来源于ES6标准入门（第二版）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class]]></title>
    <url>%2F2018%2F11%2F06%2Ftext-12%2F</url>
    <content type="text"><![CDATA[Class简介JavaScript 语言的传统方法是通过构造函数定义并生成新对象1234567function Point(x,y)&#123; this.x = x; this.y = y;&#125;Point.prototype.toSting = function()&#123; return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;&#125; 上面这种写法和传统的面向对象语言（Java）差异很大，所以ES6提供了更接近传统的写法，引入Class 这个概念作为对象的模板。通过class关键字可以定义类。基本上，ES6中的class可以看作是一个语法糖，它的绝大部分功能ES5都能做到，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。123456789class Point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;; &#125;&#125; 上面的代码定义了一个类，可以看到constructor方法，这就是构造方法，而this关键字则代表的是实例对象犀牛书P205页对constructor有一个简单描述：“每个JavaScript函数（ECMAScript 5中的Function.bind()方法返回的函数除外）都自动拥有一个prototype属性。这个属性的值是一个对象，这个对象的包含唯一一个不可枚举属性constructor。constructor属性的值是一个函数对象：1234var F = function()&#123;&#125;; // 这是一个函数对象var p = F.prototype; // F 相关联的原型对象var c = p.constructor; // 这是与原型对象相关联的函数c === F // =&gt; true: 对于任意函数F.prototype.constructor === F 可以看到构造函数的原型中存在预先定义好的constructor属性，这意味着对象通常继承的constructor均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个constructor属性为对象提供了类12var o = new F(); // 创建类F的一个对象o.constructor === F // =&gt; true,constructor 属性指代这个类 简单来说在ES5中，实例继承类的原型，原型(prototype)则反向引用构造函数(constructor),原型最初只包括constructor属性，而该属性也是共享的，因此可以通过对象实例访问。 ES6中class的定义在ES6中类的定义则可以看作构造函数的的另一种写法：12345class Ponit&#123; // ...&#125;typeof Ponit //&quot;function&quot;Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是原型。类本身就是指向构造函数。构造函数的prototype属性在ES6的“类”上继续存在。事实上，类的所有方法都定义在类的prototype属性上123456789101112131415161718class Point&#123; constructor()&#123; &#125; toString()&#123; &#125; toValue()&#123; &#125; &#125;// 等同于Point.prototype = &#123; constructor()&#123;&#125;, toString()&#123;&#125;, toValue()&#123;&#125;,&#125; 在类的实例上调用方法，其实就是调用原型上的方法12let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B的实例，它的constructor方法就是B类的原型constructor方法。由于类的方法除了constructor以外都是定在在prototype对象上，所以类的新方法可以添加在prototype对象上。 Object.assign方法很方便地一次向类中添加多个方法类内部定义的==所有==方法都是不可枚举的(enumerable) constructor方法constructor方法是类的默认方法，通过new命令生成对象时自动调用该方法。一个类中必须要拥有constructor方法，如果没有显式定义，将会默认添加一个空的constructor方法constructor方法默认返回实例对象(即this)，不过完全可以指定返回另一个对象123456class Foo&#123; constructor()&#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo // false 上面的代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例 Class 表达式与函数一样，Class 也可以使用表达式的形式来定义12345const MyClass = class Me&#123; getClassName()&#123; return Me.name &#125;&#125; 上面代码中使用表达式定义了一个类。需要注意到是，这个类的名字是Myclass而不是Me，Me只在class内部代码可用，指代当前类。 不存在变量提升Class不存在变量提升，在ES6中规定不会将变量声明提升到代码头部。因为当需要继承时，必须要保证子类在父类之后定义,如果存在Class的提升，下面的代码将报错，因为let命令是不提升变量的12345&#123; let Foo = class&#123;&#125; class Bar extends Foo&#123; &#125;&#125; Class 的继承基本用法Class之间可以通过extends关键字实现继承123456789101112131415161718class Point&#123; constructor (x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return this.x + &quot; &quot; + this.y; &#125;&#125;class ColorPoint extends Ponit&#123; constructor(x,y,color)&#123; super(x,y); //调用父类的constructor(x,y) this.color = color; &#125; toString()&#123; return this.color + &apos; &apos; +super.toString(); //调用父类的toString() &#125;&#125; 上面的代码中出现了super关键字，它指代的是父类的实例（即父类的this对象）子类必须在constructor方法（构造方法）中调用super方法，否则在新建实例会报错。这是因为子类没有自己的this对象，而是继承了父类的this对象，然后对其加工。如果不调用super方法，子类就得不到this对象。ES5的继承实质上是创建子类的实例对象this，然后再将父类的方法添加到this上(Parent.apply(this))。ES6的继承机制则完全不同，实质上先创造父类的实例对象this(所以必须先调用super方法)，然后用子类的constructor方法修改this 在子类的构造函数中，只有调用super方法之后，才可以使用this关键字,否则会报错。这是因为子类实例的构建基于对父类实例的加工，只有super方法才能返回父类实例 类的prototype属性和proto属性大多数浏览器的ES5实现中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和proto属性，因为此时同时存在两条继承链 子类的proto属性表示构造函数的继承，总是指向父类 子类的prototype属性的proto属性表示方法的继承，总是指向父类的prototype属性 super关键字在子类中，super关键字代表父类实例12345678910111213141516171819class A&#123; constructor()&#123; this.p = 21; &#125; get _p()&#123; return this.p; &#125;&#125;class B extends A&#123; get m()&#123; return this._p * super._p; //this._p 是在当前子类中继承的方法，super._p 则是调用父类的实例 &#125; set m(it)&#123; //set 方法需要加上参数 throw new Error(&quot;该属性只读&quot;); &#125;&#125;var test = new B();test.m;test.m = &quot;test&quot;; 以上代码，子类通过super关键字调用了父类的实例，由于对象总是继承其他对象的，所以可以在任意对象中使用super关键字。 js 父类中的构造函数设置初值，在子类中父类的属性就已经在子类中了，console.log(test)得到的是如下12345B &#123;p: 21&#125;p: 21m: (...)_p: (...)__proto__: A 这就表示了B继承了A的所有属性，如果想要得到A中属性则在get m()方法中 使用this关键字则能返回p的默认值，用super.p则返回undefined，原因是父类原型（_super.prototype）上不存在p这个属性，当前属性已经在子类上，这与Java类的继承不太相同，Java需要输出父类的属性就可以super.属性就可以获取父类中的默认属性详情请见此博客：由一篇ES6继承文章引发对于super关键字的思考 Class的取值函数(getter)和存值函数(setter)存值取值函数在ES5中已经普及了1234567891011121314class Myclass&#123; constructor()&#123; &#125; get prop()&#123; return &apos;getter&apos;; &#125; set prop(value)&#123; console.log(&quot;setter is :&quot; + value); &#125;&#125;let test = new Myclass();test.prop // getter;test.prop = 123; //setter is : 123; 上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了 Class的静态方法12345678class Foo&#123; static classMethod()&#123; return &quot;hello&quot;; &#125;&#125;Foo.classMethod(); //hellolet a = new Foo();a.classMethod(); //TypeError:a.classMethod is not a function 上面的代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用(Foo.classMethod()),而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示没有这个方法。父类的静态方法可以被子类继承，静态方法也可以用super对象上调用123456789class Foo&#123; static classMethod()&#123; return &quot;hello&quot;; &#125;&#125;class Bar extends Foo&#123; &#125;Bar.classMethod() // hello 声明本篇大部分来源于ES6标准入门（第二版）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async]]></title>
    <url>%2F2018%2F11%2F02%2Ftext-11%2F</url>
    <content type="text"><![CDATA[简介由于JavaScript只有一个线程(单线程)，如果不引入异步操作，都是同步操作，那么将会一直等待上一个任务执行完成之后才能进行下一个任务，最大的问题就在于如果上一个任务耗时很长很长，下一个任务只需要1ms就执行完，那么不得不等待上一个任务执行完成之后再执行下一个任务，所以才不得不引入异步编程。异步简单的来说就是将一个任务分成几段，先执行一段，然后转而执行其他任务，等做好准备再回头执行另一段，直到执行完。ES6之前，异步编程解决方案大概有下面4种： 回调函数 事件监听 发布/订阅 Promise对象 为什么要解决异步编程呢？因为在异步编程中，可能你在执行某段代码的时候，因为异步可能引起变量没有值，比如当你在用ajax方法请求服务器，可能服务器还没有返回数据，而你却将数据填充到html中，所以需要解决诸如此类问题，引入了解决异步编程的方案，当数据到达之后再调用下一个任务，而不是同时执行，导致某些变量没有值 在ES6中引入了Generator函数，统一了Promise对象的API，在未统一规范之前使用ajax请求服务器则是使用callback(回调函数)来完成异步操作，可以想象在回调操作中，如果要依次读取多个文件，那么则会出现回调地狱(callback hell)为了解决这个问题，引入了Promise对象，利用then方法，执行异步操作，但是Promise最大的问题在于代码冗余。例如12345678910111213141516171819function testAsync(x)&#123; return new Promise((resolve,reject)=&gt;&#123; if(x&lt;=2) resolve(x); else reject(new Error(&quot;x&gt;2&quot;)); &#125;);&#125;testAsync(1).then((value)=&gt;&#123; console.log(value); return testAsync(2);&#125;).then((value)=&gt;&#123; console.log(value); return(testAsync(3));&#125;).catch((e)=&gt;&#123; console.log(e);&#125;); 以上代码是由于一直调用then方法，原来的任务被Promise包装了一下，不管怎么操作，一眼看去都是一堆then，原来的语法变得很不清楚但是可以参考ES6中的Generator函数,Generator函数其实相当于是一个“协程”，意思是多个线程互相协作，完成异步任务。Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权，整个Generator函数就是一个封装的异步任务。异步操作需要暂停的地方，都用yield语句标明 async函数什么是async函数在ES7中提供了async函数，使得异步操作更加简便，简单来说，async函数就是Generator的语法糖async函数对Generator函数的改进体现在一下5点： 内置执行器。Generator函数的执行必须靠执行器，所以才有co模块，而async函数自带执行器。也就是说，async函数的执行与普通函数一模一样，只要一行 1var result = async testAsync(); 上面的代码调用了async testAsync 函数，然后它会自动执行，输出最后的结果。完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正的执行，从而得到真正执行，从而得到最终结果 更好的语义。async和await比起星号和yield，语义更清楚，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等到结果。 更广的适用性。co模式约定，yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令可以是Promise对象和原始类型的值（数值、字符串、布尔值，普通函数，但这时等同于同步操作（这里的同步操作指的是不处理异步操作）） 返回值是Promise。async函数的返回值时Promise对象，这比Generator函数的返回值时Iterator对象方便多了。 进一步说，async函数完全可以看作由多个异步操作包装成的一个Promise对象，而await命令就是内部的then命令的语法糖。 async函数的用法1234567async function helloWorld()&#123; return &quot;Hello World&quot;;&#125;helloWorld().then((value)=&gt;&#123; console.log(value); //Hello World&#125;); await命令用法在Generator中，yield关键字只能使用在Generator函数中，同样，await关键字也不能单独使用，是需要使用在async方法中。 await字面意思是”等待”，等待后面表达式的执行结果123456789101112131415function testAsync()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(&quot;testAsync&quot;); &#125;,1000); resolve(); &#125;);&#125;async function helloWorld()&#123; await testAsync(); console.log(&quot;hello World&quot;);&#125;helloWorld(); 以上代码testAsync()方法中返回一个Promise对象,用setTimeout模拟一个异步过程，即1s后打印”testAsync”，helloWorld()方法中 await testAsync()，表示阻塞当前主线程，完成testAsync这个异步操作之后并返回结果才继续执行下面的代码，打印“hello world”由于await命令后面是Promise对象，可能运行结果会是Rejectd，所以最好是将await放在try…catch块中12345678910111213async function helloWorld()&#123; try&#123; await testAsync(); &#125;catch(e)&#123; console.log(e); &#125;&#125;//或者async function helloWorld()&#123; await testAsync().catch((e)=&gt;&#123; console.log(e); &#125;);&#125; 应用在Generator函数中最后的应用有一个B准备，A执行，B结束的案例，下面用async实现12345678910111213141516171819202122232425262728293031323334function BPrepare()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(&quot;B准备&quot;); resolve(); &#125;,500); &#125;);&#125;function AStart()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(&quot;A执行&quot;); resolve(); &#125;,500); &#125;);&#125;function BEnding()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(&quot;B结束&quot;); //reject(new Error(&quot;B不能结束&quot;)); &#125;,500); &#125;);&#125;async function task()&#123; try&#123; await BPrepare(); await AStart(); await BEnding(); &#125;catch(e)&#123; throw e; &#125;&#125;task(); 以上代码首先先生成相应的Promise对象，利用await命令阻塞执行过程，从而达到完美异步过程 声明本篇大部分来源于ES6标准入门（第二版）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2018%2F11%2F01%2Ftext-10%2F</url>
    <content type="text"><![CDATA[简介Promise，其实是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常指一个异步操作），并且这个事件提供统一的API，可供进一步处理。Promise对象有以下两个特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending、Resolved、Rejectd、只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 Promise对象的状态改变只有两种可能：从Pending变为Resolved，或者从Pending变为Rejectd。只要其中之一发生，状态就凝固了，不会再变，会一直保持这个结果。就算改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同。事件的特点是，如果你错过了它，再去监听是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 基本用法创建一个Promise实例12345678var promise = new Promise(function(resolve,reject)&#123; //code; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;) Promise实例生成之后，可以用then方法分别指定Resolved，Rejectd状态的回调函数12345promise.then(function(value)&#123; //success&#125;,function(value)&#123; //failure&#125;); 使用Promise对象实现AJAX操作12345678910111213141516171819202122232425function getJson(url)&#123; var promise = new Promise(function(resolve,reject)&#123; var client = new XMLHttpRequest(); client.open(&quot;GET&quot;,url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accpet&quot;,&quot;application/json&quot;); client.send(null); function handler()&#123; if(this.readyState != 4) return; if(this.status == 200) resolve(this.response); else reject(new Error(this.statusText)); &#125; &#125;); return promise;&#125;;getJson(&quot;/post/js&quot;).then((data)=&gt;&#123; console.log(data);&#125;,(error)=&gt;&#123; console.log(error);&#125;); Promise.prototype.then()Promise实例具有then方法。也就是说，then方法是定义在原型对象Promise.Prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数是Rejectd状态的回调函数。then方法返回的是一个新的Promise实例(不是原来那个Promise实例)，因此可以采用链式写法，即then方法后面再调用新的then方法12345getJson(parameter).then(function(data)&#123; reurn data.post;&#125;).then(function(post)&#123; // ...&#125;) 采用链式的then可以指定一组按照次序调用的回调函数。这时，前一个回调函数有可能返回的还是一个Promise实例（即有异步操作），而后一个回调函数就会等待Promise对象的状态发生变化，再被调用 Promise.prototype.catch()Promise.protype.catch()方法是.then(null,rejection)的别名，用于指定发生错误时的回调函数。一般来说不要在then方法中定义Rejectd的回调函数（即then的第二个参数）12345promise.then((data)=&gt;&#123; success&#125;).catch((err)=&gt;&#123; error&#125;); Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获，等于没有抛出Promise的catch()方法与传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，promise对象抛出的错误不会传递到外层代码，即不会有任何反应 Promise.all()Promise.all 方法用于将多个Promise实例包装成一个新的Promise实例1var p = Promise.all([p1,p2,p3]); 上面的代码中，Promise.all 方法接受一个数组作为参数，p1,p2,p3都是Promise对象的实例；如果不是，就会先调用Promise.resolve方法，将参数转为Promise实例，再进一步处理，（Promise.all方法的参数不一定是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise实例）p 的状态由p1,p2,p3决定，分两种情况 只有p1,p2,p3的状态都变成Fulfilled(Resolved), p的状态才会Fulfilled(Resolved)，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数 只要p1,p2,p3中有一个被Rejecd，p的状态就变成Rejected,此时第一个被Rejected的实例的返回值会传递给p的回调函数总的来说就是p1,p2,p3必须是 Promise实例，Promise.all方法中p的状态类似于p1&amp;&amp;p2&amp;&amp;p3 12345678var promises = [2,3,5,7,11,13].map(function(id)&#123; return getJson(&quot;/post/&quot;+ id +&quot;/.json&quot;);&#125;);Promise.all(promises).then(function(posts)&#123; //...&#125;).catch(function(reason)&#123; //...&#125;); Promise.race()Promise.race方法也是将多个Promise实例包装成一个新的Promise实例1var p = Promise.race([p1,p2,p3]); 上面的代码中只要p1,p2,p3中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值就传递给p，类似于p1||p2||p3,当p1率先改变状态，那么p就等于p1例：12345678910var p = [new Promise(function(resolve,reject)&#123; setTimeout(()=&gt; resolve(&quot;异步响应&quot;),1500);&#125;),new Promise(function(resolve,reject)&#123; setTimeout(()=&gt; reject(new Error(&quot;error&quot;)),1000);&#125;)];Promise.race(p).then((data)=&gt;&#123; console.log(data);&#125;).catch((error)=&gt;&#123; console.log(error);&#125;); 123consoleError: error at eval (Home.vue?5584:366) 以上代码假设了两个参数一个异步操作(p1)和一个捕获异常(p2)，异步响应需要1500ms，但是错误处理是在1000ms之后执行，当1000ms之后那么在Promise.race()方法中，p2先响应，那么p就等于p2，状态为Rejectd,所以捕获到异常。那么当p1操作的时间小于1000ms，p1首先响应，p的状态就是p1的状态（Resolved），控制台打印的则是 异步响应 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用1234var p = Promise.resolve(&apos;Hello&apos;);p.then(function(s)&#123; console.log(s); //Hello&#125;); 上面的代码生成了一个新的Promise对象的实例p。由于字符串“Hello”不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法会同时传给回调函数Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。1234var p = Promise.resolve();p.then(()=&gt;&#123; //...&#125;); 其中变量p就是一个Promise对象，如果Promise.resolve方法的参数是一个Promise实例，则会原封不动的返回 Promise.reject()Promise.reject(reason)方法也会返回一个新的Promise实例，状态为Rejected。Promise.reject方法的参数reason会被传递给实例的回调函数，效果同Promise.resolve() Additional Methodsdone()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到(因为Promise内部的错误不会冒泡到全局)。为此，可以使用done()方法，总是处于回调链的尾端，保证抛出任何可能出现的错误123456Promise.prototype.done = function(onFulfilled,onRejected)&#123; this.then(onFulfilled,onRejected) .catch((reason)=&gt;&#123; setTimeout(()=&gt;&#123;throw reason&#125;,0); &#125;);&#125;; done方法可以像then方法那样用，提供Fulfilled,Rejected 状态的回调函数，也可以不提供任何参数，但是done方法可以捕捉到任何可能出现的错误，并向全局抛出例：1234567891011121314151617181920function getPromise(data)&#123; let promise = new Promise(function(resolve,reject)&#123; if(data != 1) resolve(data+2); else reject(new Error(&quot;test error&quot;)) &#125;); return promise;&#125;getPromise(1).then((data)=&gt;&#123; console.log(data); &#125;).catch((error)=&gt;&#123; console.log(error); &#125;);getPromise(1).done = (resolve,reject)=&gt;&#123; this.catch((error)=&gt;&#123; throw error; &#125;);&#125;; 以上代码执行会抛出两个异常，第一个异常就是catch()方法捕获到的异常，字体为黑色，还有一个done()方法抛出的全局异常,如下图所示，所以done方法可以捕捉到任何可能出现的错误，并全局抛出，字体为红色 finally()finally方法用于指定不管Promise对象最后状态如何都会执行的操作，提供Fulifilled和Rejected状态的回调函数。它与done方法最大的区别在于，它接受一个普通的回调函数作为参数，该函数不管怎样都会执行 Generator函数与Promise结合1234567891011121314151617181920212223242526272829function getFoo()&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(&quot;foo&quot;); &#125;);&#125;function* gen()&#123; try&#123; var foo = yield getFoo(); console.log(foo); &#125;catch(e)&#123; console.log(e); &#125;&#125;function run(gen)&#123; var it = gen(); function go(result)&#123; if(result.done) return result.value; else&#123; result.value.then((value)=&gt;&#123; go(it.next(value)); &#125;).catch((error)=&gt;&#123; console.log(error); &#125;); &#125; &#125; go(it.next());&#125;run(gen); 以上代码执行run()方法，将Generator函数传入，在go方法中第一个result的value值是Promise对象，再将其中的value值传入next()方法中，在gen函数中foo变量等于’foo’,再将其打印出来，总的来说getFoo是一个异步操作，返回Promise对象，再用run方法处理这个Promise对象，并调用next方法，使gen函数输出foo变量的值 声明本篇大部分来源于ES6标准入门（第二版）]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2018%2F10%2F28%2Ftext-9%2F</url>
    <content type="text"><![CDATA[简介首先将Generator函数理解成为一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说Generator函数除了是状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Genrator函数中的每一个状态。形式上Generator是一个普通函数，但是它有两个特征：一是function命令与函数名之间有一个星号（*）；二是函数内部使用yield 语句定义不同的内部状态。 什么是Generator函数12345function* helloWordGenerator()&#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125; 上面的代码定义了一个helloWorldGenerator函数，它内部有两个yield语句 ’hello‘，’world‘，该函数有三个状态，即 hello、world、return语句(结束执行)。但是当我们执行这个函数的时候（helloWorldGenerator()），发现该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的一个指针对象（Iterator Object）。所以说，Generator函数是分段执行函数，yield语句是暂时执行的标记，而next方法可以恢复执行。123456789var hwG = helloWorldGenerator();hwG.next();// &#123;value: &quot;hello&quot;, done: false&#125;hwG.next();//&#123;value: &quot;world&quot;, done: false&#125;hwG.next();//&#123;value: &quot;ending&quot;, done: true&#125;hwG.next();//&#123;value: &quot;undefined&quot;, done: true&#125; Generator函数开始执行过程：第一次调用直到遇到第一条yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值（hello），done属性为false表示还没有遍历完。第二次调用从上次yield语句停下的地方，一直执行到下一条yield语句，next方法返回一个对象，它的value属性就是当前yield语句的值（world），done属性为false表示还没有遍历完。第三次调用从上次yield语句停下的地方，一直执行到return语句（如果没有return就执行到函数结束），next方法返回一个对象，它的value值就是当前return赋予的值（如果return没有值，那么它的value值则会是一个），done属性为true表示已经遍历完了。第四次调用时，已经遍历完成了，next方法返回一个对象，它的value值是undefined，done属性为true总的来说，调用Generator函数，返回一个遍历器对象，代表Generator函数内部指针，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象，value属性表示当前内部状态的值，是yield语句后面那个表达式的值，done属性时一个布尔值，表示是否遍历结束。 yield语句yield语句其实是提供了一种可以暂停执行的语法，是一个暂停标志。 1.遇到yield语句就暂停执行后面的操作，并将紧跟yield后的表达式的值作为返回的对象的value值 2.下一次调用next方法时再继续往下执行，直到遇到下一个yield语句 3.如果没有遇到新的yield语句，就一直运行到return语句为止，并将return语句的值作为返回对象的value值 4.如果该函数没有return值，那么返回的对象value值为undefined总结一下，Generator函数是ES6提供的一种异步编程解决方案。通过yield标识位和next()方法调用，实现函数的分段执行。 yield 语句不能放在普通函数中 next方法的参数yield语句本身没有返回值，或者说总是返回undefined，next方法可以带一个参数，该参数会被当做上一条 yield语句的返回值1234567891011121314function* gen(x)&#123; var y = 2 * (yield(x+1)); var z = yield(y/3); return x + y + z;&#125;var a = gen(5);a.next(); //&#123;value:6,done:false&#125;a.next();//&#123;value:NaN,done:false&#125;a.next();//&#123;value:NaN,done:true&#125;var b = gen(5);b.nexr(); //&#123;value:6,done:false&#125;b.next(12);//&#123;value:8,done:false&#125;b.next(13);//&#123;value:42,done:true&#125; 在上面的代码中，分析a 的执行过程：a = gen(5) 传入参数5,执行next方法 执行紧跟yield语句的表达式，当前value为6第二个next方法，没有传入任何值，导致 y = 2 * undefined(即NaN); yield(NaN/3) 还是NaN;第三个next方法，没有传入任何值，导致 z = undefined，x+y+z = NaN 所以value = NaN； 分析b的执行过程 b = gen(5) 传入参数5,执行next方法 执行紧跟yield语句的表达式，当前value为6第二个next方法，传入12，则y = 2 * 12(即24); yield(24/3) 那么value = 8;第三个next方法，传入13，导致 z = 13，x+y+z = 5+24+13 = 42所以value = 42； for…of 循环for…of 循环可以自动遍历Generator函数，且此时不需要调用next方法123456789101112function* foo()&#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125;for(let value of foo())&#123; console.log(value);&#125;// 1,2,3,4,5 对象（Object）的for…of之前学习Iterator的时候，是在创建对象的时候加上[Symobol.iterator]方法，现在使用Genrator函数实现12345678910111213function* objectEntries(obj)&#123; let propKeys = Reflect.ownKeys(obj); for(let propkey of propKeys)&#123; yield [propkey,obj[propkey]]; &#125;&#125;var obj = &#123;0:&apos;1&apos;,1:&apos;2&apos;&#125;;for(let [key,value] of objectEntries(obj))&#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`);&#125;//0:1//1:2 另一种写法：123456789101112131415function* objectEntries()&#123; let self = this; let propKeys = Object.keys(self); for(let propkey of propKeys)&#123; yield [propkey,self[propkey]]; &#125;&#125;var obj = &#123;0:&apos;1&apos;,1:&apos;2&apos;&#125;;obj[Symbol.iterator] = objectEntries;for(let [key,value] of obj)&#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`);&#125;//0:1//1:2 yield*如果在Generator函数内部调用另一个Generator函数，默认情况下是没有效果的使用yield* 语句遍历完全二叉树12345678910111213141516171819202122function tree(left,label,right)&#123; this.left = left; this.label = label; this.right = right; &#125; function* inorder(t)&#123; yield (t.left); yield (t.right); yield (t.label); &#125; function makeTree(array)&#123; // 创建完全二叉树 if(array.length == 1) return new tree(null,(array[0]),null); return new tree(makeTree(array[0]),array[1],makeTree(array[2])); &#125; let Tree = makeTree([[[&apos;a&apos;],&apos;b&apos;,[&apos;c&apos;]],&apos;d&apos;,[[&apos;e&apos;],&apos;f&apos;,[&apos;g&apos;]]]); var result = []; for(let value of inorder(Tree))&#123; result.push(value); &#125;// result:a,c,b,e,g,f,d(先序遍历) 应用讲了这么多，那么Generator函数用在什么场景呢？要回答这个问题，首先我们总结Generator它的特点，一句话：可以随心所欲的交出和恢复函数的执行权，yield交出执行权，next()恢复执行权。我们举几个应用场景的实例。1、协程 协程可以理解成多线程间的协作，比如说A，B两个线程根据实际逻辑控制共同完成某个任务，A运行一段时间后，暂缓执行，交由B运行，B运行一段时间后，再交回A运行，直到运行任务完成。对于JavaScript单线程来说，我们可以理解为函数间的协作，由多个函数间相互配合完成某个任务。例两个人完成一项工作 A要在B准备之后才能执行，B要在A执行之后才能结束1234567891011121314151617181920212223function* Awork()&#123; console.log(&apos;A执行&apos;); yield &apos;B&apos;;&#125;function* Bwork()&#123; console.log(&apos;B准备&apos;); yield &apos;A&apos;; console.log(&apos;B结束&apos;);&#125;var A = Awork();var B = Bwork();function run(fn)&#123; var f = fn.next(); if(f.value == &apos;A&apos;)&#123; run(A); &#125;else if(f.value == &apos;B&apos;)&#123; run(B); &#125;&#125;run(B);//B准备//A执行//B结束 2.异步编程 Generator函数，官方给的定义是”Generator函数是ES6提供的一种异步编程解决方案”。我认为它解决异步编程的两大问题 回调地狱 异步流控 回调模式下写 两个人完成一项工作 A要在B准备之后才能执行，B要在A执行之后才能结束123456789setTimeout(function()&#123; console.log(&apos;B准备&apos;); setTimeout(function()&#123; console.log(&apos;A执行&apos;); setTimeout(function()&#123; console.log(&apos;B结束&apos;) &#125;,500); &#125;,500);&#125;,500); 这种模式下如果流程比较复杂，就会一直往下层调，不便于维护代码对于Generator异步操作123456789101112131415161718192021222324252627282930313233343536function AStart(success)&#123; setTimeout(function()&#123; console.log(&apos;A执行&apos;); success(); &#125;,500);&#125;function BPrepare(success)&#123; setTimeout(function()&#123; console.log(&apos;B准备&apos;); success(); &#125;,500);&#125;function BEnding(success)&#123; setTimeout(function()&#123; console.log(&apos;B结束&apos;); success(); &#125;,500);&#125;function run(fn)&#123; const gen = fn(); function next()&#123; const result = gen.next(); if(result.done) return ; result.value(next); &#125; next();&#125;function* task()&#123; yield BPrepare; yield AStart; yield BEnding; return &apos;ending&apos;;&#125;run(task); 声明本篇大部分来源于ES6标准入门第15章（第二版）部分受启示于此博客]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator]]></title>
    <url>%2F2018%2F10%2F26%2Ftext-8%2F</url>
    <content type="text"><![CDATA[比较JavaScript的遍历方法forfor循环基本语法1234for(let index = 0,len = myArray.length;index&lt;len;index++)&#123; console.log(myArray[index]);&#125; for循环是最原始的写法，由于这种写法比较麻烦，所以数组提供了内置的forEach方法 forEach123myArray.forEach((item,index)=&gt;&#123; console.log(item);&#125;); forEach的问题在于，无法中途跳出forEach循环，break，continue都不能奏效 for…in (ES5)for…in 循环可以遍历数组的键名123for(var index in myArray)&#123; console.log(myArray[index]);&#125; for…in 循环有几个缺点 数组的键名是数字，但是for…in循环是以字符串作为键名，”1” ,”2” ,”3” 等 for…in 不仅遍历数字键名，还会遍历手动添加的其他值，甚至包括原型链上的键 某些情况下for…in 循环会以任意顺序遍历键名总之，for…in 循环主要是为遍历对象而设计的，不适用于遍历数组 for…offor…of 循环相比上面几种做法有一些显著的优点 123for(let value in myArray)&#123; console.log(value);&#125; 有着for…in 一样的简洁语法，但没有for…in 那些缺点 不同于forEach方法，它可以与break,continue,和 return 配合使用 提供遍历所有数据结构的统一操作接口for…of12345var myArray = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];for(let value of myArray)&#123; console.log(value);&#125; 此处输出的value是”a”, “b” , “c” ，但是如果使用for-in输出的value 是索引值。其中for…of不仅能对数组字符串进行遍历，还可以适用于Map,Set,NodeList 迭代器（Iterator）实现原理for…of 对数组，字符串，Map，Set，NodeList 进行遍历，那么可不可以对对象进行遍历？12345678var obj = &#123; 0:&apos;aa&apos;, 1:&apos;bb&apos;&#125;for(var value of obj)&#123; console.log(value); //TypeError: [object Object] is not iterable!&#125; 上述代码报错，表示object没有Iterator，但是在Array，String 的原型上实现了Iterator 的接口，而object并没有实现Iterator接口，在object上实现迭代器(Iterator)接口，只需要在这个对象中实现[Symbol.iterator]属性方法，Symbol是ES6表示唯一性的标识符，标准委员会是为了避免命名的冲突，所以才这样命名。修改如下12345678910111213141516171819202122232425var obj = &#123; 0:&apos;aa&apos;, 1:&apos;bb&apos;, [Symbol.iterator]()&#123; const self = this; let index = 0; return&#123; next()&#123; if(index&lt;2)&#123; return&#123; value:self[index++], done:false, &#125;//end if return &#125;// end if else&#123; return&#123;value:undefined,done:true&#125; &#125;// end else &#125; // end function next() &#125;// end return &#125;// end [Symbol.iterator]&#125;;for(var value of obj)&#123; console.log(value);&#125; 此时正确打印出了’aa’,’bb’, 在for…of以外打印出obj[Symbol.iterator] 看到是一个匿名函数如下12345678910ƒ () &#123; var self = this; var index = 0; return &#123; next: function next() &#123; if (index &lt; 2) &#123; return &#123; value: self[index++], done: false … 执行这个匿名函数之后有返回对象，对象中有一个next函数，我们定义一个变量来执行这个函数，然后执行next函数，看看会有什么效果1234var it = obj[Symbol.iterator]();console.log(it.next()); //&#123;value: &quot;aa&quot;, done: false&#125;cosole.log(it.next()); //&#123;value: &quot;bb&quot;, done: false&#125;console.log(it.next());//&#123;value: undefined, done: true&#125; 在此可以知道next()函数实际上是在调用的next方法时会返回一个值同时自动将内部指针移动到下一个实例,那么这个self指代的是什么呢？self 指代的是 当前调用的这个对象 =&gt;‘{0: “aa”, 1: “bb”, Symbol(Symbol.iterator): ƒ}’所以当这个“野”object要变成可用for…of遍历的对象,只需要给object添加Iterator接口 for…of 实现break,continue,returnES6标准入门阮一峰老师也说了for…of 比 for…in 要强大很多，那么怎么遍历object时使用break,continue,return 呢？例1234567891011121314151617181920212223242526272829var obj = &#123; 0:&apos;aa&apos;, 1:&apos;bb&apos;, [Symbol.iterator]()&#123; const self = this; let index = 0; return&#123; next()&#123; if(index&lt;2)&#123; return&#123; value:self[index++], done:false, &#125;//end if return &#125;// end if else&#123; return&#123;value:undefined,done:true&#125; &#125;// end else &#125;,// end function next() return()&#123; //增加return,支持continue以及break return&#123;done:true&#125;; &#125; &#125;// end return &#125;// end [Symbol.iterator]&#125;;for(var value of obj)&#123; console.log(value); break；&#125; 此程序输出是’aa’;]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The question of this]]></title>
    <url>%2F2018%2F09%2F30%2Ftext-7%2F</url>
    <content type="text"><![CDATA[在犀牛书中对this并没有太多详细的讲解，红皮书里7.2.2节对this做了一个简单的阐述，但是在实际情况下this的调用方法确实是很迷的。 关于this对象this对象是在运行时基于函数的执行环境绑定的；在全局函数中，this等于window，而当函数作为某个对象的方法调用时，this等于那个对象。不过匿名函数 的执行环境具有全局性，因此其this对象通常指向window。例如：1234567891011var name = &apos;The window&apos;;var object = &#123; name : &quot;the obj&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125; &#125;&#125;console.log(object.getNameFunc()());//&quot;The window&quot; (非严格模式下) 当燃为什么在控制台打印出来是“The window”呢，分析代码，首先创建了一个全局变量name，紧接着object对象里也创建了一个name属性，以及getNameFunc方法，在这个方法中还包含一个闭包(这个匿名函数),并返回this.name。当我们在调用object对象中的getNameFunc方法时，实际是返回一个方法，这个方法就是这个匿名函数。每个函数在被调用的时候都会自动取得两个特殊变量：this，arguments。内部函数在搜索这两个变量的时候，只会搜索到其活动位置为止，因此永远不可能直接访问外部函数中这两个变量。不过把外部作用域中的this对象保存在一个闭包能够访问的变量里，就可以让闭包访问到该对象。由于上例调用object.getNameFunc之后，返回的方法取得的特殊变量this不会访问外部函数中object.name，所以this指向的是window，在window.name则会去搜索全局变量name，所以打印出The window如果把外部作用域的this对象保存在这个闭包能够访问的变量里，就可以访问到这个对象形如：123456789101112var name = &apos;The window&apos;;var object = &#123; name : &quot;the obj&quot;, getNameFunc : function()&#123; var self = this; return function()&#123; return self.name; &#125; &#125;&#125;console.log(object.getNameFunc()());//&quot;the obj&quot; 当前代码与前一个例子的代码不同之处在于，在定义匿名函数之前，定义一个self来存储this对象，而在定义闭包之后，闭包也可以访问到这个变量，因为self是包含函数中特意声明的一个变量，即使在函数返回之后，self也引用着object，所以调用object.getNameFunc()()返回的则是“the obj”当然this 和arguments存在同样的问题，如果想访问作用域中的arguments对象，必须将改对象的引用存到另一个闭包能访问的变量中。 例：12345678910111213var myObject = &#123; foo : &quot;bar&quot;, func: function()&#123; var self = this; console.log(this.foo); console.log(self.foo); (function()&#123; console.log(this.foo); console.log(self.foo); &#125;()); &#125;,&#125;;myObject.func(); 以上程序输出的结果依次为 bar bar undefined bar执行的作用域在myObject，调用的是myObject中的func方法，在func方法里还有一个匿名立即执行函数，分析调用myObject.func()时，在当前作用域（myObject中），定义了一个属性foo，所以在func方法中this 是指向这个对象（myObject）， 所以在func方法里this指向的myObject的foo，当在func的匿名立即执行函数中，这个匿名函数中的this不能访问到到外部函数的this，所以通过查询只能找到window，所以this指向的是window，所以this.foo指向的是window.bar,window.bar没有定义，所以是undefined，但是self 是在包含函数中特意声明的一个变量，用来存储指向myObject对象的对象，所以在这个匿名执行函数中，当找不到self时往上查询找到self是指向myObject，所以self.foo指向的是myObject.foo。 当例：1234567891011121314var client = &#123; fullname : &quot;NOT SET&quot;, setUserName : function(firstname,lastname)&#123; this.fullname = firstname + &quot; &quot; + lastname; return this.fullname; &#125;&#125;function getUserInput(firstname,lastname,callback)&#123; return callback(firstname,lastname);&#125;getUserInput(&quot;aaron&quot;,&quot;luo&quot;,client.setUserName); // aaron luoconsole.log(client.fullname);//NOT SETconsole.log(fullname); //aaron luo 以上代码传入的方法看似是指向的client对象，但其实在传入client.setUsername作为回调的时候，我们实际是用的getUserInput方法的作用域，由于getUserInput被 挂载在window，这个作用域中this指向的是window，所以在打印client.fullname时其实并没有改变它的值，而是在window中创建了一个全局变量fullname，并将“aaron luo”赋值给fullname如果想要改变this指向于client而不是window，那么需要将client传入getUserInput方法中，并用call或者apply方法固定this，来表示this指向的是client代码：1234567891011121314var client = &#123; fullname : &quot;NOT SET&quot;, setUserName : function(firstname,lastname)&#123; this.fullname = firstname + &quot; &quot; + lastname; return this.fullname; &#125;&#125;function getUserInput(firstname,lastname,callback,object)&#123; return callback.call(object,firstname,lastname);&#125;getUserInput(&quot;aaron&quot;,&quot;luo&quot;,client.setUserName,client); // aaron luoconsole.log(client.fullname);//aaron luo console.log(fullname); // Uncaught ReferenceError: fullname is not defined 这样一来我们通过修改作用域就可以避免变量污染，但是要明确了解this到底指向那个作用域，简单来讲就是谁的作用域调用，this指向谁，具体情况具体分析。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS回调函数（深入理解）]]></title>
    <url>%2F2018%2F09%2F20%2Ftext-6%2F</url>
    <content type="text"><![CDATA[在JavaScript中，函数也是对象; 也就是说，函数属于Object类型，它们可以像任何其他对象（String，Array，Number等）一样以第一类方式使用，因为它们实际上是对象本身。它们可以“存储在变量中，作为参数传递给新函数，在函数中创建，并从函数返回” 什么是回调函数或者高阶函数所谓高阶函数（higher-order function) 就是操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新的函数。例：12345678910111213//这个高阶函数返回一个新的函数，这个新函数将它的实参传入f()//并返回f的返回值var even = function(a,b,c)&#123; return a+b+c;&#125;function add(f)&#123; return function()&#123; //返回一个新的函数 var result = f.apply(this,arguments); // 调用f(),result == even(a,b,c)返回的数据 return result; 返回result &#125;&#125;// 调用函数add(even)(1,2,3); // add(even)返回的是一个函数 console.log(add(even)(1,2,3)) 为 6 上面的add()函数就是一个高阶函数。因此它接收一个函数作为参数，并返回一个新函数一个回调函数，是一个被作为参数的函数传递给另一个函数(我们把另一个函数叫做’otherFunction’)的函数，回调函数在otherFunction中被调用。一个回调函数本质上是一种编程模式(为一个常见问题创建的解决方案)，因此回调函数也叫做回调模式 经典回调函数例子：在js中1234// onclick 是一个函数，而不是一个变量，并且在这个匿名函数中可以加入参数document.getElementById(&apos;id&apos;).onclick = function()&#123; alert(&quot;btn is clicked&quot;);&#125; jQuery中123$(&apos;#btn&apos;).click(function()&#123; alert(&quot;btn was clicked&quot;);&#125;); 正如你在前面的例子中看到的，我们将一个函数作为参数传递给了click方法。click方法会调用（或者执行）我们传递给它的函数。这是Javascript中回调函数的典型用法，它在jQuery中广泛被使用。 1234var friends = [&apos;Mike&apos;,&apos;stacy&apos;,&apos;Andy&apos;,&apos;Rick&apos;];friends.forEach(function(item,index)&#123; console.log(indx+1+&quot;. &quot;+item); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick&#125;); 在forEach方法中，我们将一个匿名函数(no name’s function)作为参数传递给了forEach方法。到目前为止，我们将匿名函数作为参数传递给了另一个函数或者方法，我们先来理解回调函数是怎么运作的。 回调函数是如何运作的？因为函数在Javascript中是第一类对象，我们像对待对象一样对待函数，因此我们能像传递变量一样传递函数，在函数中返回函数，在其他函数中使用函数。当我们将一个回调函数作为参数传递给另一个函数，我们仅仅传递了函数定义，并没有在参数中执行函数。但是我们并不传递像平时执行函数一样带有一对执行小括号()的函数，而只是将otherFunction的函数名作为参数放入函数中，以用来回调。 需要注意的很重要的一点是回调函数并不会马上被执行。它会在包含它的函数内的某个特定时间点被“回调”（就像它的名字一样）。经典回调函数例子：1234var friends = [&apos;Mike&apos;,&apos;stacy&apos;,&apos;Andy&apos;,&apos;Rick&apos;];friends.forEach(function(item,index)&#123; console.log(indx+1+&quot;. &quot;+item); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick&#125;); 这个匿名函数稍后会在函数体内被调用。即使有名字，它依然在包含它的函数内通过arguments对象获取 回调函数是闭包什么是闭包？函数对象可以通过作用域链相互关联起来，函数体内部的变量可以保存在函数的作用域中，这种特性在计算机科学文献中被称为“闭包”。闭包这个术语非常古老，是指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量“包裹”了起来。 为什么说回调函数是闭包？一个回调函数作为变量传递给另一个函数时，这个回调函数在包含它的函数内的某一点执行，就好像这个回调函数是在包含它的函数中定义的一样，这意味着回调函数本质上是一个闭包。正如闭包的定义一样，闭包能访问它的函数作用域，因此回调函数能够访问到包含于它函数中的变量以及全局作用域中的变量 实现回调函数的基本原理使用命名或匿名函数作为回调在前面的forEach的例子中，我们使用了再参数位置定义的匿名函数作为回调函数。另一种常见的模式则是定义一个明明函数将函数名作为参数传递给执行函数exm:123456789101112131415161718192021222324// 全局变量var allUserData = [];// 普通的logStuff函数，将内容打印在控制台function logStuff(userData)&#123; if(typeof userData === &quot;string&quot;)&#123; console.log(userData); &#125;else if(typeof userData === &quot;object&quot;)&#123; for(item in userData)&#123; console.log(item + &quot;: &quot;+ userData[item]); &#125; &#125;&#125;// 包含两个参数的函数，其中最后一个参数是一个回调函数function getInput(options,callback)&#123; allUserData.push[options]; callback(options);&#125;//当我们调用getInput函数时，我们将logStuff作为一个参数传递给它//因此logStuff将会在getInput函数内被回调（或者执行）getInput(&#123;name:&quot;Rich&quot;,speciality:&quot;JavaScript&quot;&#125;，logStuff);//name: Richspeciality: JavaScript 传递参数给回调函数既然回调函数在执行中仅仅是一个普通函数，那么这个函数可以接收参数。我们能够传递任何包含于它的函数属性或者全局变量作为回调函数的参数。在前面的示例中，我们将选项作为参数传递给回调函数,来试着让我们传递一个全局变量和一个局部变量：1234567// 全局变量var generalLastname = &apos;Cliton&apos;;function getInput(options,callback)&#123; allUserData.push(options); callback(generalLastname,options);&#125; 确保回调函数是function一个函数在调用参数之前应该检查这个回调函数是否是一个function。此外最好将回调函数设置为可选。重构前一个例子中的getInput函数1234567function getInput(options，callback)&#123; allUserData.push(options); // 检查callback是否是function if(typeof callback ===&apos;function&apos;)&#123; callback(options); &#125;&#125; 如果没有检查，如果调用getInput函数要么没有回调函数作为参数，要么代替函数传递非函数，我们的代码将导致运行时错误。 回调函数this问题当回调函数作为一个方法使用this属性时，我们一定要改变回调函数的方法来保证this的上下文。否则回调函数会被传递一个全局变量，或者指向当前方法的对象code12345678910111213// 定义一个具有一些属性和一个方法的objectvar clientData = &#123; id : 094545, fullname : &quot;Not Set&quot;, setUserName : function(firstName,lastName)&#123; this.fullname = firstName + &quot; &quot; + lastName; &#125;&#125;function getUserInput(firstName,lastName,callback)&#123; //执行一些确认firstName or lastName的操作 //执行方法 callback(firstName,lastName);&#125; 在上面的例子中，当clientData.setUsername（callback）被执行时，this.fullName并没有设置clientData对象中的fullName属性。相反，它将设置window对象中的fullName属性，因为getUserInput是一个全局函数。这是因为全局函数中的this对象指向window对象。1234567getUserInput(&quot;Barack&quot;,&quot;Obama&quot;,clientData.setUserName);console.log(clientData.fullName); //Not Set//fullName属性将在window对象中被初始化,其中this指向windowconsole.log(window.fullName); //Barack Obama 使用apply,call来保存this我们可以使用Call或者Apply函数来修复上面你的问题。到目前为止，我们知道了每个Javascript中的函数都有两个方法:Call 和 Apply。这些方法被用来设置函数内部的this对象以及给此函数传递变量。call接收的第一个参数为被用来在函数内部当做this的对象，传递给函数的参数被挨个传递（当然使用逗号分开）。Apply函数的第一个参数也是在函数内部作为this的对象，然而最后一个参数确是传递给函数的值的数组。1234// 增加新的参数&apos;callbackObj&apos;作为回调对象function getUserInput(firstName,lastName,callback,callbackObj)&#123; callbacj(callbackObj,[firstName,lastName]);&#125; 使用apply()函数正确设置了this对象，我们现在正确的执行了callback并在clientData对象中正确设置了fullName属性：1234//我们将clientData.setUserName方法和clientData对象作为参数，clientData对象会被apply方法使用来设置this对象getUserInput(&quot;Barack&quot;,&quot;Obama&quot;,clientData.setUserName，clientData);console.log(clientData.fullName); //Barack Obamaconsole.log(this.fullName) //undefined //this指向window 允许多重调用callbackl函数我们可以传递不止一个回调函数作为参数传递给一个函数，就像我们在一个函数中可以传递不止一个变量一样，例如在jQuery中的ajax方法123456789101112function successCallback()&#123;&#125;function completeCallback()&#123;&#125;function errorCallback()&#123;&#125;$.ajax(&#123;url:&quot;&quot;;success: successCallback,complete: completeCallback,error: errorCallback,&#125;); 创建属于你自己的回调函数既然你已经完全理解了关于Javascript中回调函数的一切（我认为你已经理解了，如果没有那么快速的重读以便），你看到了使用回调函数是如此的简单而强大，你应该查看你的代码看看有没有能使用回调函数的地方。回调函数将在以下几个方面帮助你： 避免重复代码 在你拥有更多多功能函数的地方实现更好的抽象（依然能保持所有功能） 让代码具有更好的可维护性 使代码更容易阅读 编写更多特定功能的函数 创建你的回调函数非常简单。在下面的例子中，我将创建一个函数完成以下工作：读取用户信息，用数据创建一首通用的诗，并且欢迎用户。这本来是个非常复杂的函数因为它包含很多if/else语句并且，它将在调用那些用户数据需要的功能方面有诸多限制和不兼容性。相反，我用回调函数实现了添加功能，这样一来获取用户信息的主函数便可以通过简单的将用户全名和性别作为参数传递给回调函数并执行来完成任何任务。简单来讲，getUserInput函数是多功能的：它能执行具有各种功能的回调函数12345678910111213141516//First,setup the generic poem creator function;it will be the callback function in the getUserInput function belowfunction genericPoemMaker(name,gender)&#123; console.log(name + &quot; is finer than fine wine.&quot;); console.log(&quot;Altruistic and noble for the modern time.&quot;); console.log(&quot;Always admirably adorned with the latest style.&quot;); console.log(&quot; A &quot; + gender + &quot; of unfortunate tragedies who still manages a perpetual smile&quot;);&#125;//The callback, which is the last item in the parameter, will be our genericPoemMaker function we defined above.function getUserInput(firstName,lastName,gender,callback)&#123; var fullName = firstName + &quot; &quot; + lastName; //Make sure callback is a function if(typeof callback === &apos;function&apos;)&#123; //Execute the callback function and pass the parameters to it callback(fullName,gender); &#125;&#125; Call the getUserInput function and pass the genericPoemMaker function as a callback:1234567getUserInput(&quot;Michael&quot;, &quot;Fassbender&quot;, &quot;Man&quot;, genericPoemMake);// Output/* Michael Fassbender is finer than fine wine.Altruistic and noble for the modern time.Always admirably adorned with the latest style.A Man of unfortunate tragedies who still manages a perpetual smile.*/ 因为getUserInput函数仅仅只负责提取数据，我们可以把任意回调函数传递给它。例如，我们可以传递一个greetUser函数：123456function greetUser(customerName,sex)&#123; var salutation == sex &amp;&amp; sex === &quot;Man&quot; ? &quot;Mr.&quot; : &quot;Ms.&quot;; console.log(&quot;hello,&quot;+ salutation + &quot; &quot; + customerName);&#125;// 在getUserInput方法中通过传递greetUser方法作为一个回调函数getUserInput(&quot;Bill&quot;,&quot;Gates&quot;,&quot;Man&quot;,greetUser); // hello,Mr. Bill Gates 我们调用了完全相同的getUserInput函数，但是这次完成了一个完全不同的任务正如你所见，回调函数很神奇。即使前面的例子相对简单，想象一下能节省多少工作量，你的代码将会变得更加的抽象，这一切只需要你开始使用回调函数 在Javascript编程中回调函数经常以几种方式被使用，尤其是在现代web应用开发以及库和框架中： 异步调用（例如读取文件，进行HTTP请求，等等） 时间监听器/处理器 setTimeout和setInterval方法 一般情况：精简代码 结束语Javascript回调函数非常美妙且功能强大，它们为你的web应用和代码提供了诸多好处。你应该在有需求时使用它；或者为了代码的抽象性，可维护性以及可读性而使用回调函数来重构你的代码。 声明 本文根据本人的理解以及参考 understand Javascript callback functions and use them 原文中关于“回调地狱”问题本人暂未解决，原文地址，详情请点击查看]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Practice]]></title>
    <url>%2F2018%2F09%2F16%2Ftext-5%2F</url>
    <content type="text"><![CDATA[学习总结 数组查找数组元素位置题目描述：找出元素 item 在给定数组 arr 中的位置输出描述：如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1；方法一：1234567891011121314function indexOf(arr, item) &#123; var count = 0; for(var i = 0;i&lt;arr.length;i++)&#123; if(item === arr[i])&#123; return i; &#125; else&#123; count ++; &#125; &#125; if(count == arr.length)&#123; return -1; &#125;&#125; 方法二：123function indexOf(arr,item)&#123; return arr.indexOf(item);&#125; 数组求和题目描述：计算给定数组 arr 中所有元素的总和输出描述：数组中的元素均为 Number 类型方法一：常规循环1234567function sum(arr)&#123; var sum = 0; for(var i = 0;i&lt;arr.length;i++)&#123; sum += arr[i]; &#125; return sum;&#125; 方法二：ES5 array.reduce()方法，该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。12345function sum(arr)&#123; return arr.reduce(function(previousValue,currentValue,index,arr)&#123; return previousValue + currentValue; &#125;);&#125; 方法三：forEach循环（牛客网居然不支持ES5的写法）1234567function sum(arr)&#123; var sum = 0; arr.forEach((item)=&gt;&#123; // arr.forEach(function(item,index)&#123;code&#125;); sum += item; &#125;); return sum;&#125; 移除数组中的元素题目描述：移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组方法一： 12345678function remove(arr, item) &#123; var array = new Array(); for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i] != item) array.push(arr[i]); &#125; return array;&#125; 方法二：ES5 Array.filter()，该函数把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素(不修改原数组arr)。12345function remove(arr, item) &#123; return arr.filter(function(e)&#123; // return arr.filter((e)=&gt;&#123;code&#125;); return item != e; &#125;);&#125; 移除数组中的元素题目描述：移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 123456789function removeWithoutCopy(arr, item) &#123; for(var i=0,len = arr.length;i&lt;len;i++)&#123; if(arr[i]==item)&#123; arr.splice(i,1); i--; &#125; &#125; return arr;&#125; 添加元素题目描述：在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：123456789function append(arr, item) &#123; var array = new Array(); //array = arr.slice(0);// 浅拷贝,不需要for循环 for(var i =0,len=arr.length;i&lt;len;i++)&#123; array.push(arr[i]); &#125; // 若使用slice()方法，不用for循环，直接push array.push(item); return array;&#125; 方法二：123function append(arr,item)&#123; return arr.concat(item);&#125; 方法三：12345function append(arr,item)&#123; var newArr = [item]; [].unshift.apply(newArr,arr); return newArr;&#125; 删除数组的最后一个元素题目描述：删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组方法一：1234567function truncate(arr) &#123; var array = new Array(); for(var i = 0,len = arr.length;i&lt;len;i++) array.push(arr[i]); array.pop(); return array;&#125; 方法二：array.filter12345function truncate(arr)&#123; return arr.filter(function(e,index)&#123; // return arr.filter((e,index)=&gt;&#123;code&#125;); return index != arr.length-1; &#125;);&#125; 方法三：slice(),浅拷贝123function truncate(arr)&#123; return arr.slice(0,-1);&#125; 方法四：concat+pop();12345function truncate(arr)&#123; var array = arr.concat(); array.pop(); return array;&#125; 添加元素题目描述：在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：123456789function prepend(arr,item)&#123; var array = new Array(); for(var i=0,len=arr.length;i&lt;len;i++)&#123; if(i===0)&#123; array.push(item); &#125; array.push(arr[i]); &#125;&#125; 方法二：unshift12345function prepend(arr,item)&#123; var newArr = arr.slice(0);//浅拷贝 newArr.unshift(item); return newArr;&#125; 方法三：1234function prepend(arr,item)&#123; var newArr = [item]; return newArr.concat(arr);&#125; 删除数组的第一个元素题目描述：删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 方法一：123456789function curtail(arr) &#123; var array = new Array(); for(var i = 0,len = arr.length;i&lt;len;i++)&#123; if(i === 1) array.pop(); array.push(arr[i]); &#125; return array;&#125; 方法二：123function curtail(arr)&#123; return arr.slice(1);&#125; 方法三：filter12345function curtail(arr)&#123; return arr.filter(function(e,index)&#123; return index != 0; &#125;);&#125; 数组合并题目描述：合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组123function concat(arr1,arr2)&#123; return arr1.concat(arr2);&#125; 添加元素 题目描述:在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：12345function inset(arr,item,index)&#123; var array = [].concat(arr); array.splice(index,0,item); return array;&#125; 方法二：concat123function inset(arr,item,index)&#123; return arr.slice(0,index).concat(item,arr.slice(index));&#125; 计数题目描述：统计数组 arr 中值等于 item 的元素出现的次数方法一：123456789function count(arr,item)&#123; var count = 0; for(var i=0,len = arr.length;i&lt;len;i++)&#123; if(arr[i] == item)&#123; count++; &#125; &#125; return count;&#125; 方法二：filter123456function count(arr,item)&#123; var count = 0; return arr.filter(function(e)&#123; // return arr.filter((e)=&gt;&#123;code&#125;); return e == item; &#125;).length；&#125; 方法三：map123456789function count(arr,item)&#123; var count = 0; arr.map(function(e)&#123; // arr.map((e)=&gt;&#123;code&#125;); if(e===item)&#123; count++; &#125; &#125;); return count;&#125; 查找重复元素题目描述：找出数组 arr 中重复出现过的元素方法一：123456789101112function duplicates(arr)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var array = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i]==arr[i+1]&amp;&amp;arr[i]!=arr[i-1])&#123; // if(arr[i]==arr[i+1]&amp;&amp;array.indexOf(arr[i])==-1) array.push(arr[i]); &#125; &#125; return array;&#125; 方法二：1234567891011function duplicates(arr)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var array = []; for(var obj in arr)&#123; if(arr[obj]==arr[obj-1]&amp;&amp;array.indexOf(arr[obj])==-1)&#123; //for-in遍历时不能取到arr[obj+1]，其为undefined，循环每次将一个可枚举的属性名赋值给循环变量，不存在的索引不会遍历到 array.push(arr[obj]); &#125; &#125;&#125; 方法三：索引值（index）123456789function duplicates(arr)&#123; var array = []; arr.forEach((item,index)=&gt;&#123; if(arr.indexOf(item) != arr.lastIndexOf(item)&amp;&amp; array.indexOf(item) == -1)&#123; array.push(item); &#125; &#125;); return array;&#125; 方法四：123456789101112131415161718192021function duplicates(arr) &#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var obj = &#123;&#125;; var result = []; //遍历数组，将数组的值作为obj的索引，出现次数为值 arr.forEach(function(item)&#123; if(obj[item])&#123; obj[item] += 1; &#125;else&#123; obj[item] = 1; &#125; &#125;); for(var item in obj)&#123; //遍历对象，将重复的元素取出 if(obj[item]&gt;1)&#123; result.push(parseInt(item)); &#125; &#125; return result;&#125; 求二次方题目描述：为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组方法一：map12345function square(arr) &#123; return arr.map((e)=&gt;&#123; // return arr.map(function(e)&#123;code&#125;) return Number(e)*Number(e); //return Math.pow(Number(e),2); &#125;);&#125; 方法二：forEach1234567function square(arr)&#123; var array = []; arr.forEach((item)=&gt;&#123; array.push(Math.pow(Number(item),2)); &#125;); return array;&#125; 查找元素位置题目描述：在数组 arr 中，查找值与 item 相等的元素出现的所有位置1234567891011function findAllOccurrences(arr, target) &#123; var arr1=[]; var j=0; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===target)&#123; arr1.push(arr.indexOf(arr[i],j)); j++; &#125; &#125; return arr1;&#125; 编码规范避免全局变量题目描述：给定的 js 代码中存在全局变量，请修复1234567function globals() &#123; var myObject = &#123; name : &apos;Jory&apos; &#125;; return myObject;&#125; 正确的函数定义题目描述: 请修复给定的 js 代码中，函数定义存在的问题12345678function functions(flag) &#123; if (flag) &#123; return &apos;a&apos;; &#125; else &#123; return &apos;b&apos;; &#125; return;&#125; 正确的使用parseInt()题目描述：修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例123function parse2Int(num) &#123; return parseInt(num,10);&#125; 完全等同题目描述：判断val1和val2是否完全相同123456function identity(val1, val2) &#123; if(val1 === val2)&#123; return true; &#125; return false;&#125; 计数计时器题目描述：实现一个打点计时器，要求1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 1234567891011121314function count(start, end) &#123; console.log(start); var timer = setInterval(function()&#123; if(start&lt;end)&#123; console.log(++start); &#125; &#125;,100); function cancel()&#123; clearInterval(timer); &#125; //在外部用来clearInterval停止操作 return &#123; cancel:cancel &#125; //返回Object&#125; 流程控制流程控制题目描述：实现 fizzBuzz 函数，参数 num 与返回值的关系如下：1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz2、如果 num 能被 3 整除，返回字符串 fizz3、如果 num 能被 5 整除，返回字符串 buzz4、如果参数为空或者不是 Number 类型，返回 false5、其余情况，返回参数 num1234567891011121314function fizzBuzz(num) &#123; if(num%3==0&amp;&amp;num%5==0)&#123; return &apos;fizzbuzz&apos;; &#125;else if(num%3==0)&#123; return &apos;fizz&apos;; &#125;else if(num%5==0)&#123; return &apos;buzz&apos;; &#125;else if(num==undefined||typeof(num)!=&apos;number&apos;)&#123; //不能使用 num instanceof Number,因为num是数字，不是对象类型 ，instanceof 是只会给对象返回true or false; return false; &#125;else&#123; return num; &#125;&#125; 函数函数传参题目描述：将数组 arr 中的元素作为调用函数 fn 的参数123function argsAsArray(fn, arr) &#123; return fn.apply(this,arr);//this 指代当前对象&#125; 在ES5的严格模式中call(),apply()的第一个实参是调用函数的母对象，在函数体内通过调用this来获得对它的引用，对于call()第一个调用上下文实参之后的所有实参就是要传入待调用函数的值，例如以对象o的方法的形式调用函数f()，并传入两个参数，f.call(0,1,2);apply()与call()类似，但传入实参是一个数组形式 f.apply(o,[1,2]); 函数的上下文题目描述：将函数 fn 的执行上下文改为 obj 对象123function speak(fn, obj) &#123; return fn.apply(obj,obj);// return fn.apply(obj);&#125; 返回函数题目描述：实现函数 functionFunction，调用之后满足如下条件：1、返回值为一个函数 f2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘3、所有函数的参数数量为 1，且均为 String 类型输入：1functionFunction(&apos;Hello&apos;)(&apos;world&apos;) 输出：1Hello, world 12345function functionFunction(str) &#123; return function(str1)&#123; return str+&quot;, &quot;+str1; // 最好加上 if(typeof(str)==&quot;string&quot; &amp;&amp; typeof(str1)==&quot;string&quot;)&#123;code&#125; &#125;&#125; 使用闭包题目描述实现函数 makeClosures，调用之后满足如下条件：1、返回一个函数数组 result，长度与 arr 相同2、运行 result 中第 i 个函数，即 result[i]（）,结果与 fn(arr[i]) 相同输入：123[1, 2, 3], function (x) &#123; return x * x; &#125; 输出：14 1234567function makeClosures(arr, fn) &#123; return arr.map(function(e)&#123; // return arr.map((e)=&gt;&#123;code&#125;); return function&#123; return fn(e); &#125; &#125;);&#125; 二次封装函数题目描述：已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：1、返回一个函数 result，该函数接受一个参数2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致输入：1var sayIt = function(greeting, name, punctuation) &#123; return greeting + &apos;, &apos; + name + (punctuation || &apos;!&apos;); &#125;; partial(sayIt, &apos;Hello&apos;, &apos;Ellie&apos;)(&apos;!!!&apos;); 输出：1Hello, Ellie!!! 12345function partial(fn,str1,str2)&#123; return function(str3)&#123; return fn(str1,str2,str3); &#125;&#125; 执行partial(sayIt,’Hello’,Ellie’)方法的时候，返回的是一个function()，其中这个function需要一个参数(‘str3’),然后执行function函数的调用函数 fn(str1.str2,str3); 使用arguments题目描述：函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。输入：11,2,3,4 输出：110 1234567function useArguments()&#123; var sum = 0; for(var i=0,len=arguments.length;i&lt;len;i++)&#123; sum += argumnets[i]; &#125; return sum;&#125; 调用此函数的时候给了参数，但是我们function中并没有将参数写入，就使用arguments数组将参数依依读取 使用apply调用函数题目描述：实现函数 callIt，调用之后满足如下条件1、返回的结果为调用 fn 之后的结果2、fn 的调用参数为 callIt 的第一个参数之后的全部参数123function callIt(fn)&#123; return fn.apply(this,Array.prototype.slice.call(arguments,1)); // typeof arguments == Object&#125; Array.prototype.slice(),Array.prototype是一个空数组，调用slice()，会返回一个数组，并且slice()是一个数组方法，所以使用call(),或者apply()将arguments 传入slice 方法中，并返回给数组原型 二次封装函数_2题目描述：实现函数 partialUsingArguments，调用之后满足如下条件：1、返回一个函数 result2、调用 result 之后，返回的结果与调用函数 fn 的结果一致3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数1234567function partialUsingArguments(fn)&#123; var arr = []; var args = arr.slice.call(arguments,1); return function()&#123; return fn.apply(this,args.concat(arr.slice.call(arguments,0))); &#125;&#125; 柯里化题目描述：已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 13、调用 b 之后，返回一个函数 c, c 的 length 属性值为 14、调用 c 之后，返回的结果与调用 fn 的返回值一致5、fn 的参数依次为函数 a, b, c 的调用参数输入：1var fn = function (a, b, c) &#123;return a + b + c&#125;; curryIt(fn)(1)(2)(3); 输出：16 123456789101112function curryIt(fn)&#123; var len = fn.length; var args = []; return function(arg)&#123; args.push(arg); if(args.length&lt;len)&#123; return arguments.callee //callee指代当前执行的函数，在当前匿名函数中通过callee来递归调用自身 &#125;else&#123; return fn.apply(this,args); &#125; &#125;&#125; 逻辑操作或运算题目描述：返回参数 a 和 b 的逻辑或运算结果输入：1false true 输出：1true 123function or(a,b)&#123; return a||b;&#125; 且运算题目描述：返回参数a和b的逻辑且运算结果输入：1false true 输出：1true 123function and(a,b)&#123; return a&amp;&amp;b;&#125; 模块模块题目描述:完成函数 createModule，调用之后满足如下要求：1、返回一个对象2、对象的 greeting 属性值等于 str1， name 属性值等于 str23、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值123456789function createModule(str1,str2)&#123; var obj = new Object(); obj.greeting = str1; obj.name = str2; obj.sayIt = function()&#123; return this.greeting+&apos;, &apos;+this.name; &#125; return obj;&#125; Number二进制转换_1题目描述：获取数字 num 二进制形式第 bit 位的值。注意：1、bit 从 1 开始2、返回 0 或 13、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1输入：1128,8 输出：11 12345function valueBit(num,bit)&#123; var str = num.toString(2); var value = str.split(&quot;&quot;); return value.(value.length-bit);&#125; 二进制转换_2题目描述：给定二进制字符串，将其换算成对应的十进制数字输入：1&apos;11000000&apos; 输出1192 123function base10(str)&#123; return parseInt(str.toString(2),2);&#125; 二进制转换_3题目描述：将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。输入：165 输出：101000001 1234567function convertToBinary(num)&#123; var str = num.toString(2); if(str.length&lt;8)&#123; return (&apos;00000000&apos;+str).substr(-8); //假如&apos;00000000&apos;+str 有12位，那么substr(-8)表示从截取12-8 = 4处开始截取（仅当负数小于总长度） &#125; return str;&#125; 乘法题目描述：求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题输入：13,0.0001 输出：10.0003 12345function multiply(a,b)&#123; var str_a = a.toString; var str_b = b.toString; var len = Math.max(str_a.length-str_a.indexOf(&apos;.&apos;)-1,str_b.length-str_b.indexOf(&apos;.&apos;)-1)&#125; 对象改变上下文题目描述：将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值输入：1alterContext(function() &#123;return this.greeting + &apos;, &apos; + this.name + &apos;!&apos;; &#125;, &#123;name: &apos;Rebecca&apos;, greeting: &apos;Yo&apos; &#125;) 输出：1Yo, Rebecca! 123456function alertContext(fn,obj)&#123; return fn.apply(obj,obj); //return fn.apply(obj); //return fn.call(obj); //return fn.call(obj,obj)&#125; 批量改变对象的属性题目描述：给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。输入：123var C = function(name) &#123;this.name = name; return this;&#125;; var obj1 = new C(&apos;Rebecca&apos;); alterObjects(C, &apos;What\&apos;s up&apos;); obj1.greeting; 输出:1What&apos;s up 123function alterObjects(constructor, greeting) &#123; constructor.prototype.greeting = greeting;&#125; 属性遍历题目描述：找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)1、返回数组，格式为 key: value2、结果数组不要求顺序输入：123var C = function() &#123;this.foo = &apos;bar&apos;; this.baz = &apos;bim&apos;;&#125;; C.prototype.bop = &apos;bip&apos;; iterate(new C()); 输出：1[&quot;foo: bar&quot;, &quot;baz: bim&quot;] 123456789function iterate(obj)&#123; var arr = []; for(var i in obj)&#123; if(obj.hasOwnProperty(i))&#123; // for-in 遍历object， hasOwnPropetry判断是否在原型 arr.push(i+&quot;: &quot;+obj[i]); &#125; &#125; return arr;&#125; 正则判断是否包含数字题目描述：给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false输入：1&apos;abc123&apos; 输出：1true 1234function containsNumber(str) &#123; var b = /\d/; return b.test(str);&#125; 检查重复字符串题目描述：给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false输入：1&apos;rattler&apos; 输出：1true 1234function containsRepeatingLetter(str) &#123; var b = /([a-zA-Z])\1/; return b.test(str);&#125; 判断是否以元音字母结尾题目描述：给定字符串 str，检查其是否以元音字母结尾1、元音字母包括 a，e，i，o，u，以及对应的大写2、包含返回 true，否则返回 false输入：12&apos;gorilla&apos;` 输出：1true 1234function endsWithVowel(str) &#123; var b = /[a,e,i,o,u]$/i; return b.test(str);&#125; 获取指定字符串题目描述：给定字符串 str，检查其是否包含 连续3个数字1、如果包含，返回最新出现的 3 个数字的字符串2、如果不包含，返回 false输入：1&apos;9876543&apos; 输出:1987 12345678function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false;&#125; 判断是否符合指定格式题目描述：给定字符串 str，检查其是否符合如下格式1、XXX-XXX-XXXX2、其中 X 为 Number 类型输入：1&apos;800-555-1212&apos; 输出：1true 123function matchesPattern(str) &#123; return /^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 判断是否符合USD格式题目描述：给定字符串 str，检查其是否符合美元书写格式1、以 $ 开始2、整数部分，从个位起，满 3 个数字用 , 分隔3、如果为小数，则小数部分长度为 24、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3输入：1&apos;$20,933,209.93&apos; 输出：1true 123function isUSD(str) &#123; return /^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/.test(str);&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scroll]]></title>
    <url>%2F2018%2F09%2F07%2Ftext-4%2F</url>
    <content type="text"><![CDATA[纯JS滚动（给控件注册锚点）犀牛书15.8 (P390)查询窗口滚动条的位置12345678910111213141516// 以一个对象的x,y属性的方式返回滚动条的偏移量function getScrollOffsets(window)&#123; //使用指定窗口，如果不带参数则使用当前窗口 window = window || window; //除了IE8及更早版本以外，其他浏览器都能使用 if(window.pageXOffset!=null)&#123; return &#123;x:window.pageXOffset,y:window.pageYOffset&#125;; &#125; //对标准模式下的IE(或任何浏览器) var d = window.document; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; return&#123;x:d.documentElement.scrollLeft,y:d.documentElement.scrollTop&#125;; &#125; //对于怪异模式下的浏览器 return &#123;x:d.body.scrollLeft,y:d.body.scrollTop&#125;;&#125; 获取之后可以注册监听器实时监控滚动条的位置 判定元素在某点getBoundingClientRect() 方法使我们能在视口中判定元素的位置，如果判定视口中的指定位置有什么元素可以使用Document对象的elementFromPoint()方法来判定。传递X和Y坐标（使用视口坐标而非文档坐标），该方法返回在一个指定位置的元素上 滚动在主窗口 window中如果知道scrollLeft、scrollTop属性可以设置让浏览器滚动123456789101112131415161718192021222324252627282930313233// HTML&lt;button id=&quot;button_id_Click&quot;&gt;点击&lt;/button&gt;// 点击button从顶部到&lt;div&gt;456&lt;/div&gt;处&lt;div style=&quot;height: 1000px;&quot;&gt;123&lt;/div&gt;// 设置div高度为1000px;&lt;div style=&quot;height: 300px;&quot; id=&quot;div_id_Height&quot;&gt;456&lt;/div&gt;&lt;button id=&quot;button_id_ClickBack&quot;&gt;返回&lt;/button&gt;// 点击button从任意位置返回到顶部//JSvar height = document.getElementById(&quot;div_id_Height&quot;).getBoundingClientRect();console.log(height);document.getElementById(&quot;button_id_Click&quot;).onclick = function()&#123; window.scrollTo(0,height.y);&#125;document.getElementById(&quot;button_id_ClickBack&quot;).onclick = function()&#123; var obj = new Object(); obj = getScrollOffsets(window); console.log(obj.y);//观察滚动条的偏移量 window.scrollTo(0,0);&#125;// 以一个对象的x,y属性的方式返回滚动条的偏移量function getScrollOffsets(window)&#123; //使用指定窗口，如果不带参数则使用当前窗口 window = window || window; //除了IE8及更早版本以外，其他浏览器都能使用 if(window.pageXOffset!=null)&#123; return &#123;x:window.pageXOffset,y:window.pageYOffset&#125;; &#125; //对标准模式下的IE(或任何浏览器) var d = window.document; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; return&#123;x:d.documentElement.scrollLeft,y:d.documentElement.scrollTop&#125;; &#125; //对于怪异模式下的浏览器 return &#123;x:d.body.scrollLeft,y:d.body.scrollTop&#125;;&#125; 但其实这种滑动效果不是很好，没有过渡效果，那么用js如何使用加载过渡效果呢？ 注 MDN web docs123456789//将以上window.scrollTo(x-coord,y-coord)的代码更改为window.scrollTo(&#123; top:0, // 从浏览器任意位置返回至0 behavior:&quot;smooth&quot;,&#125;);window.scrollTo(&#123; top:height.y，// 返回注册锚点处 behavior:&quot;smooth&quot;,&#125;); 注 window.scrollTo中 参数 x-coord 是文档中的横轴坐标。 y-coord 是文档中的纵轴坐标。 options 是一个包含三个属性的对象: top 等同于 y-coord left 等同于 x-coord behavior 类型String,表示滚动行为,支持参数 smooth(平滑滚动),instant(瞬间滚动),默认值auto,实测效果等同于instant该函数实际上和 window.scroll是一样的。 相对滚动可以参考 window.scrollBy，window.scrollByLines，和 window.scrollByPages。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用javaScript,ajax,SpringBoot 实现前后台交互]]></title>
    <url>%2F2018%2F08%2F13%2Ftext-3%2F</url>
    <content type="text"><![CDATA[使用JavaScript配合ajax响应GET请求本地服务器url是http://localhost:8080（因为我的浏览器是IE7+，所以创建XMLHttpRequest对象） 注：首先实现前后台互通 12345678910111213// 前台js&lt;script&gt;var xmlHttp;function getRequest()&#123; var url = &apos;http://localhost:8080/hello&apos;; xmlHttp = new XMLHttpRequest();//ie7+以上支持 xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState == 4 &amp;&amp;xmlHttp.status == 200)&#123; //状态正常时 console.log(xmlHttp.responseText); // 返回服务器返回的数据 &#125; &#125;&#125;&lt;/script&gt; 12345678910//后台spring boot//HelloController@RestControllerpublic class HelloController&#123; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) public String say()&#123; return &quot;hello world&quot; &#125;&#125; 前台请求之后会出现跨域问题 在console里会出现1Failed to load http://localhost:8080/hello: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://127.0.0.1:8020&apos; is therefore not allowed access. 解决跨域问题的博客 附上修改之后的代码1234567891011121314151617//创建一个Class WebMvcConfig@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; /** * 跨域支持 * @return */ @Bean public WebMvcConfigurer corsConfigurer()&#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;).allowedMethods(&quot;*&quot;); &#125; &#125;; &#125;&#125; 然后请求服务器在console里就会返回”hello world” 配置数据库 mysql 数据库 在pom.xml 添加数据库的相关依赖，并在application.properties 文件里构建相关属性 123456789101112//application.properties#spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/wuxiaonashabispring.datasource.username=rootspring.datasource.password=****** //这里填入你的mysql的密码#spring.jpa.database = MYSQLspring.jpa.hibernate.ddl-auto=update // update 每次启动项目不会新建表spring.jpa.show-sql=true#spring.jackson.serialization.indent_output=true 创建一个类 Girl12345678910111213141516171819202122232425262728293031323334353637383940// class Girl@Entity public class Girl &#123; @Id @GeneratedValue private Integer id; private String name; private String age; public Girl()&#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 1234//创建 名为GirlRepository 接口public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt; &#123;&#125; 重启服务器，并刷新数据库会创建一个名为girl的表 由于我之前post添加了数据所以数据库里存在两条数据,如果测试get请求，findAll()方法，在数据库里手动添加数据 从数据库返回数据列表给前台12345678910111213// js&lt;script&gt;var xmlHttp;function getRequest()&#123; var url = &quot;http://localhost:8080/girls&quot;; xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState == 4 &amp;&amp;xmlHttp.status == 200)&#123; //状态正常时 console.log(xmlHttp.responseText); // 返回服务器返回的数据 &#125; &#125;&#125;&lt;/script&gt; 1234567891011// spring boot//创建一个class GirlControllerpublic class GirlController&#123; @Autowired private GirlRepository girlRespository; @GetMapping(value = &quot;/girls&quot;) public List&lt;Girl&gt; girlList()&#123; return girlRespository.findAll(); &#125;&#125; 前台console显示 使用JavaScript配合ajax响应POST请求问题：怎样向后台发送json格式数据，单纯将object对象转换为json格式就可以吗？前台js代码123456789101112131415161718192021222324//js&lt;script type=&quot;text/javascript&quot;&gt; var xmlHttp; var data; function getRequest() &#123; var url = &apos;http://localhost:8080/girls&apos;; xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; data = xmlHttp.responseText; console.log(data); &#125; &#125; var obj = new Object(); obj = &#123; name: &quot;Bob&quot;, age: &quot;22&quot;, &#125; xmlHttp.open(&apos;POST&apos;, url); xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/Json&quot;);//添加请求头 obj = JSON.stringify(obj); xmlHttp.send(obj); &#125; 后台java代码123456789101112131415161718192021222324// spring bootpublic class GirlController&#123; @Autowired private GirlRepository girlRespository; @GetMapping(value = &quot;/girls&quot;) public List&lt;Girl&gt; girlList()&#123; return girlRespository.findAll(); &#125; /** * * @param name * @param age * @return */// @RequestMapping(value=&quot;/girls&quot;,method = RequestMethod.POST) @PostMapping(value=&quot;/girls&quot;) public Girl girlAdd(@RequestBody Girl cgirl)&#123; Girl girl = new Girl(); girl.setName(cgirl.getName()); girl.setAge(cgirl.getAge()); return girlRespository.save(girl); &#125;&#125; 响应结果 前端包装数据存在的问题json数据包后端接收数据是json格式，在前台传送数据的时候将object对象转换成json格式123456var obj = new Object(); obj = &#123; name: &quot;Bob&quot;, age: &quot;22&quot;, &#125;obj = JSON.stringify(obj); 错误原因这个表是传送的数据格式不正确，后台希望的是一个json格式，而不是一个文本“text/plain” 解决方案 需要传送的数据更改为application/Json12345// jsxmlHttp.open(&apos;POST&apos;, url);xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/Json&quot;);//添加请求头obj = JSON.stringify(obj);xmlHttp.send(obj); 123456789101112131415//jQuery 处理方法$.ajax(&#123; type: &apos;POST&apos;, //请求方式 contentType: &quot;application/json&quot;, // 设置传输数据格式 url: &quot;http://localhost:8080/girls&quot;, data: JSON.stringify(obj), // 传送数据 dataType: &apos;json&apos;, //接收数据类型 cache: true, //异常处理 success: function(data)&#123; //回调 console.log(data); &#125;, error: function(e)&#123; //回调 console.log(e); &#125;&#125;);]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>-javaScript-ajax-SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue上使用sass]]></title>
    <url>%2F2018%2F06%2F27%2Ftest-2%2F</url>
    <content type="text"><![CDATA[如何安装SassSass、gem安装教程当安装完成后在终端输入1sass -v 如下sass常用更新、查看版本、帮助等命令12345678// 更新sassgem update sass//查看版本sass -v//查看sass帮助sass -h 如何在vue.js中安装sass的依赖的两种方法1. 在当前项目的目录下引入123cnpm install sass-loader -Dcnpm install node-sass -D 引入完成之后在package.json中会有如下两个依赖“node-sass”: “^4.9.0”,“sass-loader”: “^7.0.3”,这样这个项目就配置好了sass 如果运行项目之后不能使用sass那么就在webpack.base.conf.js中的module：的rules：[ ] 下添加：12345678910&#123; test: /\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; scss: &apos;style-loader!css-loader!sass-loader&apos;, sass: &apos;style-loader!css-loader!sass-loader?indentedSyntax&apos;, &#125;, &#125;, &#125;, 2. 官方Sass Loader的引入方法sass Loade官方仓库]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery配合vue.js注册锚点实现动画过渡效果]]></title>
    <url>%2F2018%2F06%2F23%2Ftext-1%2F</url>
    <content type="text"><![CDATA[问题：如何利用jQuery实现网页导航栏注册锚点并有过渡效果引言：jquery库 - 特性jQuery 是一个 JavaScript 函数库。 jQuery 库包含以下特性： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 为什么要实现点击导航栏到当前组件要有过渡效果：目前大多数官网首页都是各种炫酷的动画，如果仅仅只是在a标签的herf里添加#id,然后在组件里添加id，虽然会实现到滑到页面，但是是真的丑陋至极，毫无违和感，而且当你刷新的时候会自动在你的路由下添加一个路径，然后就出现空白，着实很烦。如何实现： 利用vue.js和jQuery，因为vue.js写好组件然后通过组件直接显示页面这样各个组件不会相互干扰。 在vue.js 里配置jQuery 和bootstrap（由于我需要bootstrap 做响应式布局这里我也介绍吧）jQuery 引用 第一步1cnpm install jquery --save 第二步在build/webpack.base.conf.js里加入1var webpack = require(&quot;webpack&quot;) 第三步同样build/webpack.base.conf.js中在module.exports的最后加入1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;) ], 第四步在main.js 引入import $ from ‘jquery’1import $ from &apos;jquery&apos; 第五步重启本地服务器1cnpm run dev bootstrap引用第一步1cnpm install bootstrap --save 第二步在main.js中直接引入 12import &apos;../node_modules/bootstrap/dist/css/bootstrap.min.css&apos;;import &apos;../node_modules/bootstrap/dist/js/bootstrap.min.js&apos;; 第三步1cnpm run dev 代码12345678910111213141516171819202122HTML:&lt;ul class=&quot;nav navbar-nav ul_class_after&quot; v-for=&quot;(item,index) in navigation&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; class = &quot;a_class_jump&quot; @click=&quot;jump(item.item)&quot;&gt;&#123;&#123;item.item&#125;&#125;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;About id=&quot;About&quot;&gt;&lt;/About&gt;&lt;div id = &quot;Services&quot; style=&quot;height: 1000px&quot;&gt;2222&lt;/div&gt;js:jump(item)&#123; var top = $(&apos;#&apos;+item).offset().top; //获取当前id距离顶部距离 if(item == &apos;Home&apos;)&#123; &#125; else if(item == &apos;About&apos;)&#123; $(&apos;html,body&apos;).animate(&#123;scrollTop:top&#125;,1500); &#125; else&#123; $(&apos;html,body&apos;).animate(&#123;scrollTop:top&#125;,2000); //滚动条跳到当前id的位置，完成此操作需要2s &#125;&#125; 这样就会有一个过渡效果并且在2s内完成跳转，然候如果第一次进入这个锚点会有一个动画效果 12345678910111213141516171819202122232425262728293031323334353637383940HTML: &lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item1&quot;&gt;内容&lt;/div&gt;&lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item2&quot;&gt;内容&lt;/div&gt;&lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item3&quot;&gt;内容&lt;/div&gt;需要添加的css：.animate_positive&#123; animation:route 2s; animation-fill-mode:forwards; animation-direction:alternate;&#125;@-webkit-keyframes route&#123; from &#123; margin-left: -60em; &#125; to&#123;margin-left: 0em ; &#125;&#125;@keyframe route&#123; from &#123; margin-left: -60em; &#125; to&#123;margin-left: 0em ; &#125;&#125;js:function loadAnimation(container_Id,aimation_name,offset)&#123; var contain_To_Top,window_ScrooTop,window_height,offset_To_Top; offset_To_Top=$(container_Id).offset().top; ontain_To_Top=eval(offset_To_Top + offset); //字符串相加 window_ScrooTop =$(window).scrollTop(); //窗口滚动高度 window_height=$(window).height();//窗口高度 if(window_ScrooTop + window_height&gt;contain_To_Top)&#123; $((container_Id)).addClass((aimation_name)); &#125;&#125;$(document).ready(function(e)&#123; $(window).scroll(function()&#123; loadAnimation(&quot;#div_id_item3&quot;,&quot;animate_positive&quot;,0); loadAnimation(&quot;#div_id_item2&quot;,&quot;animate_positive&quot;,0); loadAnimation(&quot;#div_id_item1&quot;,&quot;animate_positive&quot;,0); &#125;);&#125;); 码云demo 以上就是做一个简单的jQuery配合vue.js 做的一个过渡效果]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F23%2FHello-World%2F</url>
    <content type="text"><![CDATA[前言经过一天的努力终于在github创建了自己的博客，那我就来一篇Hello World吧，分享分享小编的踩过的坑。(此博客是基于安装了node.js以及git哦) 过程小编今天写了一天的js代码，晚上开始配置，看了许多教程，都没能搞明白，所以请教了隔壁大佬，帮小编解决了这些问题。 注册GitHub账号官网创建仓库1.登陆GitHub2.点击创建仓库 3.填写仓库信息仓库名称必须是 用户名+github.io，比如我的username是byAaronLuo，name我的仓库名称就是byAaronLuo.github.io(小编这里偷懒，copy大佬的图片，因为现在真的很晚了。。。) 配置SSH1.设置username 和email : 注意：这里一定要安装git 12git config --global user.name &quot;your GitHub&apos;s username&quot;git config --global user.name &quot;your GitHub&apos;s E-mail&quot; 2生成SSH密钥1ssh-keygen -t rsa -C &quot;your GitHub&apos;s E-mail &quot; 一般这种情况下是不需要密码的，所以一直回车就好 成功后，在C盘用户-&gt;Administrator 文件夹下就会有一个新的文件夹 .ssh，里面就有刚刚创建的ssh密钥文件id_rsa和id_rsa_pub 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。 3.添加公钥到GitHub点击用户头像，然后再点击Settings选项 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key 将 id_rsa.pub 的内容复制到Key 文本框中，再点击Add SSH key 4.测试SSH1ssh -T git@github.com 接下来会显示出下面的确认信息 12345The authenticity of host &apos;github.com (192.30.255.112)&apos; can&apos;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 输入yes然后回车，你会看见 1Hi byAaronLuo! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Hexo安装hexo安装好Node.js环境后，就可以通过node的npm包管理工具安装Hexo，执行以下指令(当然cnpm可以换成npm，这里使用淘宝镜像会更快，因为小编学习vue.js时配置过node.js，无论实在Linux、Pc、Macos 都是很好配置的哦) 1cnpm install hexo-cli -g hexo全局安装一次就够了，后面可以直接使用hexo相关的操作。 创建博客文件夹在此目录下管理自己的博客代码 12mkdir blogcd blog 初始化Hexo1hexo init 安装依赖包1cnpm install 生成静态页面1hexo g 启动本地服务器（在本地的localhost:4000）查看代码1hexo s 上传GitHub 这里小编习惯用git命令上传至仓库 完成上述操作后，在根目录中会出现一个public文件，在终端进入public文件，然后执行以下操作1234git remote add origin &lt;url&gt;git add .git commit -m &quot;ss&quot;git push -u origin master 域名配置现在已经可以通过https://yourname.github.io 来访问自己的博客站点啦。这时可能有人会说了，大家都通过github.io来访问，好没个性，能不能配置用自己的域名来访问自己的站点。答案当然可以。 首先，你得有个自己的域名，如果还没，那就去买个。 1.进域名控制台在解析里面添加一条CNAME记录，指向yourname.github.io即可。 2.打开项目，选择 setting 3.找到GitHub Pages （每次deploy过后都需要修改一次） 这样你就可以通过自己的域名访问了 其他基础命令123456789101112131415hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo clean #清除生成内容hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到指定空间hexo help # 查看帮助hexo version #查看Hexo的版本 hexo 命令缩写1234567hexo g：hexo generatehexo c：hexo cleanhexo s：hexo serverhexo d：hexo deploy hexo 命令组合123hexo clean &amp;&amp; hexo g -s #清除、生成、启动hexo clean &amp;&amp; hexo g -d #清除、生成、部署]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
