<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Practice]]></title>
    <url>%2F2018%2F09%2F16%2Ftext-5%2F</url>
    <content type="text"><![CDATA[学习总结 数组查找数组元素位置题目描述：找出元素 item 在给定数组 arr 中的位置输出描述：如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1；方法一：1234567891011121314function indexOf(arr, item) &#123; var count = 0; for(var i = 0;i&lt;arr.length;i++)&#123; if(item === arr[i])&#123; return i; &#125; else&#123; count ++; &#125; &#125; if(count == arr.length)&#123; return -1; &#125;&#125; 方法二：123function indexOf(arr,item)&#123; return arr.indexOf(item);&#125; 数组求和题目描述：计算给定数组 arr 中所有元素的总和输出描述：数组中的元素均为 Number 类型方法一：常规循环1234567function sum(arr)&#123; var sum = 0; for(var i = 0;i&lt;arr.length;i++)&#123; sum += arr[i]; &#125; return sum;&#125; 方法二：ES5 array.reduce()方法，该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。12345function sum(arr)&#123; return arr.reduce(function(previousValue,currentValue,index,arr)&#123; return previousValue + currentValue; &#125;);&#125; 方法三：forEach循环（牛客网居然不支持ES5的写法）1234567function sum(arr)&#123; var sum = 0; arr.forEach((item)=&gt;&#123; // arr.forEach(function(item,index)&#123;code&#125;); sum += item; &#125;); return sum;&#125; 移除数组中的元素题目描述：移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组方法一： 12345678function remove(arr, item) &#123; var array = new Array(); for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i] != item) array.push(arr[i]); &#125; return array;&#125; 方法二：ES5 Array.filter()，该函数把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素(不修改原数组arr)。12345function remove(arr, item) &#123; return arr.filter(function(e)&#123; // return arr.filter((e)=&gt;&#123;code&#125;); return item != e; &#125;);&#125; 移除数组中的元素题目描述：移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 123456789function removeWithoutCopy(arr, item) &#123; for(var i=0,len = arr.length;i&lt;len;i++)&#123; if(arr[i]==item)&#123; arr.splice(i,1); i--; &#125; &#125; return arr;&#125; 添加元素题目描述：在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：123456789function append(arr, item) &#123; var array = new Array(); //array = arr.slice(0);// 浅拷贝,不需要for循环 for(var i =0,len=arr.length;i&lt;len;i++)&#123; array.push(arr[i]); &#125; // 若使用slice()方法，不用for循环，直接push array.push(item); return array;&#125; 方法二：123function append(arr,item)&#123; return arr.concat(item);&#125; 方法三：12345function append(arr,item)&#123; var newArr = [item]; [].unshift.apply(newArr,arr); return newArr;&#125; 删除数组的最后一个元素题目描述：删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组方法一：1234567function truncate(arr) &#123; var array = new Array(); for(var i = 0,len = arr.length;i&lt;len;i++) array.push(arr[i]); array.pop(); return array;&#125; 方法二：array.filter12345function truncate(arr)&#123; return arr.filter(function(e,index)&#123; // return arr.filter((e,index)=&gt;&#123;code&#125;); return index != arr.length-1; &#125;);&#125; 方法三：slice(),浅拷贝123function truncate(arr)&#123; return arr.slice(0,-1);&#125; 方法四：concat+pop();12345function truncate(arr)&#123; var array = arr.concat(); array.pop(); return array;&#125; 添加元素题目描述：在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：123456789function prepend(arr,item)&#123; var array = new Array(); for(var i=0,len=arr.length;i&lt;len;i++)&#123; if(i===0)&#123; array.push(item); &#125; array.push(arr[i]); &#125;&#125; 方法二：unshift12345function prepend(arr,item)&#123; var newArr = arr.slice(0);//浅拷贝 newArr.unshift(item); return newArr;&#125; 方法三1234function prepend(arr,item)&#123; var newArr = [item]; return newArr.concat(arr);&#125; 删除数组的第一个元素题目描述：删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 方法一：123456789function curtail(arr) &#123; var array = new Array(); for(var i = 0,len = arr.length;i&lt;len;i++)&#123; if(i === 1) array.pop(); array.push(arr[i]); &#125; return array;&#125; 方法二：123function curtail(arr)&#123; return arr.slice(1);&#125; 方法三：filter12345function curtail(arr)&#123; return arr.filter(function(e,index)&#123; return index != 0; &#125;);&#125; 数组合并题目描述：合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组123function concat(arr1,arr2)&#123; return arr1.concat(arr2);&#125; 添加元素 题目描述:在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组方法一：12345function inset(arr,item,index)&#123; var array = [].concat(arr); array.splice(index,0,item); return array;&#125; 方法二：concat123function inset(arr,item,index)&#123; return arr.slice(0,index).concat(item,arr.slice(index));&#125; 计数题目描述：统计数组 arr 中值等于 item 的元素出现的次数方法一：123456789function count(arr,item)&#123; var count = 0; for(var i=0,len = arr.length;i&lt;len;i++)&#123; if(arr[i] == item)&#123; count++; &#125; &#125; return count;&#125; 方法二：filter123456function count(arr,item)&#123; var count = 0; return arr.filter(function(e)&#123; // return arr.filter((e)=&gt;&#123;code&#125;); return e == item; &#125;).length&#125; 方法三：map123456789function count(arr,item)&#123; var count = 0; arr.map(function(e)&#123; // arr.map((e)=&gt;&#123;code&#125;); if(e===item)&#123; count++; &#125; &#125;); return count;&#125; 查找重复元素题目描述：找出数组 arr 中重复出现过的元素方法一：123456789101112function duplicates(arr)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var array = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i]==arr[i+1]&amp;&amp;arr[i]!=arr[i-1])&#123; // if(arr[i]==arr[i+1]&amp;&amp;array.indexOf(arr[i])==-1) array.push(arr[i]); &#125; &#125; return array;&#125; 方法二：1234567891011function duplicates(arr)&#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var array = []; for(var obj in arr)&#123; if(arr[obj]==arr[obj-1]&amp;&amp;array.indexOf(arr[obj])==-1)&#123; //for-in遍历时不能取到arr[obj+1]，其为undefined，循环每次将一个可枚举的属性名赋值给循环变量，不存在的索引不会遍历到 array.push(arr[obj]); &#125; &#125;&#125; 方法三：索引值（index）123456789function duplicates(arr)&#123; var array = []; arr.forEach((item,index)=&gt;&#123; if(arr.indexOf(item) != arr.lastIndexOf(item)&amp;&amp; array.indexOf(item) == -1)&#123; array.push(item); &#125; &#125;); return array;&#125; 方法四：123456789101112131415161718192021function duplicates(arr) &#123; arr.sort(function(a,b)&#123; return a-b; &#125;); var obj = &#123;&#125;; var result = []; //遍历数组，将数组的值作为obj的索引，出现次数为值 arr.forEach(function(item)&#123; if(obj[item])&#123; obj[item] += 1; &#125;else&#123; obj[item] = 1; &#125; &#125;); for(var item in obj)&#123; //遍历对象，将重复的元素取出 if(obj[item]&gt;1)&#123; result.push(parseInt(item)); &#125; &#125; return result;&#125; 求二次方题目描述：为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组方法一：map12345function square(arr) &#123; return arr.map((e)=&gt;&#123; // return arr.map(function(e)&#123;code&#125;) return Number(e)*Number(e); //return Math.pow(Number(e),2); &#125;);&#125; 方法二：forEach1234567function square(arr)&#123; var array = []; arr.forEach((item)=&gt;&#123; array.push(Math.pow(Number(item),2)); &#125;); return array;&#125; 查找元素位置题目描述：在数组 arr 中，查找值与 item 相等的元素出现的所有位置1234567891011function findAllOccurrences(arr, target) &#123; var arr1=[]; var j=0; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===target)&#123; arr1.push(arr.indexOf(arr[i],j)); j++; &#125; &#125; return arr1;&#125; 编码规范避免全局变量题目描述：给定的 js 代码中存在全局变量，请修复1234567function globals() &#123; var myObject = &#123; name : &apos;Jory&apos; &#125;; return myObject;&#125; 正确的函数定义题目描述: 请修复给定的 js 代码中，函数定义存在的问题12345678function functions(flag) &#123; if (flag) &#123; return &apos;a&apos;; &#125; else &#123; return &apos;b&apos;; &#125; return;&#125; 正确的使用parseInt()题目描述：修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例123function parse2Int(num) &#123; return parseInt(num,10);&#125; 完全等同题目描述：判断val1和val2是否完全相同123456function identity(val1, val2) &#123; if(val1 === val2)&#123; return true; &#125; return false;&#125; 计数计时器题目描述：实现一个打点计时器，要求1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 1234567891011121314function count(start, end) &#123; console.log(start); var timer = setInterval(function()&#123; if(start&lt;end)&#123; console.log(++start); &#125; &#125;,100); function cancel()&#123; clearInterval(timer); &#125; //在外部用来clearInterval停止操作 return &#123; cancel:cancel &#125; //返回Object&#125; 流程控制流程控制题目描述：实现 fizzBuzz 函数，参数 num 与返回值的关系如下：1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz2、如果 num 能被 3 整除，返回字符串 fizz3、如果 num 能被 5 整除，返回字符串 buzz4、如果参数为空或者不是 Number 类型，返回 false5、其余情况，返回参数 num1234567891011121314function fizzBuzz(num) &#123; if(num%3==0&amp;&amp;num%5==0)&#123; return &apos;fizzbuzz&apos;; &#125;else if(num%3==0)&#123; return &apos;fizz&apos;; &#125;else if(num%5==0)&#123; return &apos;buzz&apos;; &#125;else if(num==undefined||typeof(num)!=&apos;number&apos;)&#123; //不能使用 num instanceof Number,因为num是数字，不是对象类型 ，instanceof 是只会给对象返回true or false; return false; &#125;else&#123; return num; &#125;&#125; 函数函数传参题目描述：将数组 arr 中的元素作为调用函数 fn 的参数123function argsAsArray(fn, arr) &#123; return fn.apply(this,arr);//this 指代当前对象&#125; 在ES5的严格模式中call(),apply()的第一个实参是调用函数的母对象，在函数体内通过调用this来获得对它的引用，对于call()第一个调用上下文实参之后的所有实参就是要传入待调用函数的值，例如以对象o的方法的形式调用函数f()，并传入两个参数，f.call(0,1,2);apply()与call()类似，但传入实参是一个数组形式 f.apply(o,[1,2]); 函数的上下文题目描述：将函数 fn 的执行上下文改为 obj 对象123function speak(fn, obj) &#123; return fn.apply(obj,obj);// return fn.apply(obj);&#125; 返回函数题目描述：实现函数 functionFunction，调用之后满足如下条件：1、返回值为一个函数 f2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘3、所有函数的参数数量为 1，且均为 String 类型输入：1functionFunction(&apos;Hello&apos;)(&apos;world&apos;) 输出：1Hello, world 12345function functionFunction(str) &#123; return function(str1)&#123; return str+&quot;, &quot;+str1; // 最好加上 if(typeof(str)==&quot;string&quot; &amp;&amp; typeof(str1)==&quot;string&quot;)&#123;code&#125; &#125;&#125; 使用闭包题目描述实现函数 makeClosures，调用之后满足如下条件：1、返回一个函数数组 result，长度与 arr 相同2、运行 result 中第 i 个函数，即 result[i]（）,结果与 fn(arr[i]) 相同输入：123[1, 2, 3], function (x) &#123; return x * x; &#125; 输出：14 1234567function makeClosures(arr, fn) &#123; return arr.map(function(e)&#123; // return arr.map((e)=&gt;&#123;code&#125;); return function&#123; return fn(e); &#125; &#125;);&#125; 二次封装函数题目描述：已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：1、返回一个函数 result，该函数接受一个参数2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致输入：1var sayIt = function(greeting, name, punctuation) &#123; return greeting + &apos;, &apos; + name + (punctuation || &apos;!&apos;); &#125;; partial(sayIt, &apos;Hello&apos;, &apos;Ellie&apos;)(&apos;!!!&apos;); 输出：1Hello, Ellie!!! 12345function partial(fn,str1,str2)&#123; return function(str3)&#123; return fn(str1,str2,str3); &#125;&#125; 执行partial(sayIt,’Hello’,Ellie’)方法的时候，返回的是一个function()，其中这个function需要一个参数(‘str3’),然后执行function函数的调用函数 fn(str1.str2,str3); 使用arguments题目描述：函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。输入：11,2,3,4 输出：110 1234567function useArguments()&#123; var sum = 0; for(var i=0,len=arguments.length;i&lt;len;i++)&#123; sum += argumnets[i]; &#125; return sum;&#125; 调用此函数的时候给了参数，但是我们function中并没有将参数写入，就使用arguments数组将参数依依读取 使用apply调用函数题目描述：实现函数 callIt，调用之后满足如下条件1、返回的结果为调用 fn 之后的结果2、fn 的调用参数为 callIt 的第一个参数之后的全部参数123function callIt(fn)&#123; return fn.apply(this,Array.prototype.slice.call(arguments,1)); // typeof arguments == Object&#125; Array.prototype.slice(),Array.prototype是一个空数组，调用slice()，会返回一个数组，并且slice()是一个数组方法，所以使用call(),或者apply()将arguments 传入slice 方法中，并返回给数组原型 二次封装函数_2题目描述：实现函数 partialUsingArguments，调用之后满足如下条件：1、返回一个函数 result2、调用 result 之后，返回的结果与调用函数 fn 的结果一致3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数1234567function partialUsingArguments(fn)&#123; var arr = []; var args = arr.slice.call(arguments,1); return function()&#123; return fn.apply(this,args.concat(array.slice.call(arguments,0))); &#125;&#125; 柯里化题目描述：已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 13、调用 b 之后，返回一个函数 c, c 的 length 属性值为 14、调用 c 之后，返回的结果与调用 fn 的返回值一致5、fn 的参数依次为函数 a, b, c 的调用参数输入：1var fn = function (a, b, c) &#123;return a + b + c&#125;; curryIt(fn)(1)(2)(3); 输出：16 123456789101112function curryIt(fn)&#123; var len = fn.length; var args = []; return function(arg)&#123; args.push(arg); if(args.length&lt;len)&#123; return arguments.callee //callee指代当前执行的函数，在当前匿名函数中通过callee来递归调用自身 &#125;else&#123; return fn.apply(this,args); &#125; &#125;&#125; 逻辑操作或运算题目描述：返回参数 a 和 b 的逻辑或运算结果输入：1false true 输出：1true 123function or(a,b)&#123; return a||b;&#125; 且运算题目描述：返回参数a和b的逻辑且运算结果输入：1false true 输出：1true 123function and(a,b)&#123; return a&amp;&amp;b;&#125; 模块模块题目描述:完成函数 createModule，调用之后满足如下要求：1、返回一个对象2、对象的 greeting 属性值等于 str1， name 属性值等于 str23、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值123456789function createModule(str1,str2)&#123; var obj = new Object(); obj.greeting = str1; obj.name = str2; obj.sayIt = function()&#123; return this.greeting+&apos;, &apos;+this.name; &#125; return obj;&#125; Number二进制转换_1题目描述：获取数字 num 二进制形式第 bit 位的值。注意：1、bit 从 1 开始2、返回 0 或 13、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1输入：1128,8 输出：11 12345function valueBit(num,bit)&#123; var str = num.toString(2); var value = str.split(&quot;&quot;); return value.(value.length-bit);&#125; 二进制转换_2题目描述：给定二进制字符串，将其换算成对应的十进制数字输入：1&apos;11000000&apos; 输出1192 123function base10(str)&#123; return parseInt(str.toString(2),2);&#125; 二进制转换_3题目描述：将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。输入：165 输出：101000001 1234567function convertToBinary(num)&#123; var str = num.toString(2); if(str.length&lt;8)&#123; return (&apos;00000000&apos;+str).substr(-8); //假如&apos;00000000&apos;+str 有12位，那么substr(-8)表示从截取12-8 = 4处开始截取（仅当负数小于总长度） &#125; return str;&#125; 乘法题目描述：求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题输入：13,0.0001 输出：10.0003 12345function multiply(a,b)&#123; var str_a = a.toString; var str_b = b.toString; var len = Math.max(str_a.length-str_a.indexOf(&apos;.&apos;)-1,str_b.length-str_b.indexOf(&apos;.&apos;)-1)&#125; 对象改变上下文题目描述：将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值输入：1alterContext(function() &#123;return this.greeting + &apos;, &apos; + this.name + &apos;!&apos;; &#125;, &#123;name: &apos;Rebecca&apos;, greeting: &apos;Yo&apos; &#125;) 输出：1Yo, Rebecca! 123456function alertContext(fn,obj)&#123; return fn.apply(obj,obj); //return fn.apply(obj); //return fn.call(obj); //return fn.call(obj,obj)&#125; 批量改变对象的属性题目描述：给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。输入：123var C = function(name) &#123;this.name = name; return this;&#125;; var obj1 = new C(&apos;Rebecca&apos;); alterObjects(C, &apos;What\&apos;s up&apos;); obj1.greeting; 输出:1What&apos;s up 123function alterObjects(constructor, greeting) &#123; constructor.prototype.greeting = greeting;&#125; 属性遍历题目描述：找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)1、返回数组，格式为 key: value2、结果数组不要求顺序输入：123var C = function() &#123;this.foo = &apos;bar&apos;; this.baz = &apos;bim&apos;;&#125;; C.prototype.bop = &apos;bip&apos;; iterate(new C()); 输出：1[&quot;foo: bar&quot;, &quot;baz: bim&quot;] 123456789function iterate(obj)&#123; var arr = []; for(var i in obj)&#123; if(obj.hasOwnProperty(i))&#123; // for-in 遍历object， hasOwnPropetry判断是否在原型 arr.push(i+&quot;: &quot;+obj[i]); &#125; &#125; return arr;&#125; 正则判断是否包含数字题目描述：给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false输入：1&apos;abc123&apos; 输出：1true 1234function containsNumber(str) &#123; var b = /\d/; return b.test(str);&#125; 检查重复字符串题目描述：给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false输入：1&apos;rattler&apos; 输出：1true 1234function containsRepeatingLetter(str) &#123; var b = /([a-zA-Z])\1/; return b.test(str);&#125; 判断是否以元音字母结尾题目描述：给定字符串 str，检查其是否以元音字母结尾1、元音字母包括 a，e，i，o，u，以及对应的大写2、包含返回 true，否则返回 false输入：12&apos;gorilla&apos;` 输出：1true 1234function endsWithVowel(str) &#123; var b = /[a,e,i,o,u]$/i; return b.test(str);&#125; 获取指定字符串题目描述：给定字符串 str，检查其是否包含 连续3个数字1、如果包含，返回最新出现的 3 个数字的字符串2、如果不包含，返回 false输入：1&apos;9876543&apos; 输出:1987 12345678function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false;&#125; 判断是否符合指定格式题目描述：给定字符串 str，检查其是否符合如下格式1、XXX-XXX-XXXX2、其中 X 为 Number 类型输入：1&apos;800-555-1212&apos; 输出：1true 123function matchesPattern(str) &#123; return /^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 判断是否符合USD格式题目描述：给定字符串 str，检查其是否符合美元书写格式1、以 $ 开始2、整数部分，从个位起，满 3 个数字用 , 分隔3、如果为小数，则小数部分长度为 24、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3输入：1&apos;$20,933,209.93&apos; 输出：1true 123function isUSD(str) &#123; return /^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/.test(str);&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scroll]]></title>
    <url>%2F2018%2F09%2F07%2Ftext-4%2F</url>
    <content type="text"><![CDATA[纯JS滚动（给控件注册锚点）犀牛书15.8 (P390)查询窗口滚动条的位置12345678910111213141516// 以一个对象的x,y属性的方式返回滚动条的偏移量function getScrollOffsets(window)&#123; //使用指定窗口，如果不带参数则使用当前窗口 window = window || window; //除了IE8及更早版本以外，其他浏览器都能使用 if(window.pageXOffset!=null)&#123; return &#123;x:window.pageXOffset,y:window.pageYOffset&#125;; &#125; //对标准模式下的IE(或任何浏览器) var d = window.document; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; return&#123;x:d.documentElement.scrollLeft,y:d.documentElement.scrollTop&#125;; &#125; //对于怪异模式下的浏览器 return &#123;x:d.body.scrollLeft,y:d.body.scrollTop&#125;;&#125; 获取之后可以注册监听器实时监控滚动条的位置 判定元素在某点getBoundingClientRect() 方法使我们能在视口中判定元素的位置，如果判定视口中的指定位置有什么元素可以使用Document对象的elementFromPoint()方法来判定。传递X和Y坐标（使用视口坐标而非文档坐标），该方法返回在一个指定位置的元素上 滚动在主窗口 window中如果知道scrollLeft、scrollTop属性可以设置让浏览器滚动123456789101112131415161718192021222324252627282930313233// HTML&lt;button id=&quot;button_id_Click&quot;&gt;点击&lt;/button&gt;// 点击button从顶部到&lt;div&gt;456&lt;/div&gt;处&lt;div style=&quot;height: 1000px;&quot;&gt;123&lt;/div&gt;// 设置div高度为1000px;&lt;div style=&quot;height: 300px;&quot; id=&quot;div_id_Height&quot;&gt;456&lt;/div&gt;&lt;button id=&quot;button_id_ClickBack&quot;&gt;返回&lt;/button&gt;// 点击button从任意位置返回到顶部//JSvar height = document.getElementById(&quot;div_id_Height&quot;).getBoundingClientRect();console.log(height);document.getElementById(&quot;button_id_Click&quot;).onclick = function()&#123; window.scrollTo(0,height.y);&#125;document.getElementById(&quot;button_id_ClickBack&quot;).onclick = function()&#123; var obj = new Object(); obj = getScrollOffsets(window); console.log(obj.y);//观察滚动条的偏移量 window.scrollTo(0,0);&#125;// 以一个对象的x,y属性的方式返回滚动条的偏移量function getScrollOffsets(window)&#123; //使用指定窗口，如果不带参数则使用当前窗口 window = window || window; //除了IE8及更早版本以外，其他浏览器都能使用 if(window.pageXOffset!=null)&#123; return &#123;x:window.pageXOffset,y:window.pageYOffset&#125;; &#125; //对标准模式下的IE(或任何浏览器) var d = window.document; if(document.compatMode == &apos;CSS1Compat&apos;)&#123; return&#123;x:d.documentElement.scrollLeft,y:d.documentElement.scrollTop&#125;; &#125; //对于怪异模式下的浏览器 return &#123;x:d.body.scrollLeft,y:d.body.scrollTop&#125;;&#125; 但其实这种滑动效果不是很好，没有过渡效果，那么用js如何使用加载过渡效果呢？ 注 MDN web docs123456789//将以上window.scrollTo(x-coord,y-coord)的代码更改为window.scrollTo(&#123; top:0, // 从浏览器任意位置返回至0 behavior:&quot;smooth&quot;,&#125;);window.scrollTo(&#123; top:height.y，// 返回注册锚点处 behavior:&quot;smooth&quot;,&#125;); 注 window.scrollTo中 参数 x-coord 是文档中的横轴坐标。 y-coord 是文档中的纵轴坐标。 options 是一个包含三个属性的对象: top 等同于 y-coord left 等同于 x-coord behavior 类型String,表示滚动行为,支持参数 smooth(平滑滚动),instant(瞬间滚动),默认值auto,实测效果等同于instant该函数实际上和 window.scroll是一样的。 相对滚动可以参考 window.scrollBy，window.scrollByLines，和 window.scrollByPages。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用javaScript,ajax,SpringBoot 实现前后台交互]]></title>
    <url>%2F2018%2F08%2F13%2Ftext-3%2F</url>
    <content type="text"><![CDATA[使用JavaScript配合ajax响应GET请求本地服务器url是http://localhost:8080（因为我的浏览器是IE7+，所以创建XMLHttpRequest对象） 注：首先实现前后台互通 12345678910111213// 前台js&lt;script&gt;var xmlHttp;function getRequest()&#123; var url = &apos;http://localhost:8080/hello&apos;; xmlHttp = new XMLHttpRequest();//ie7+以上支持 xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState == 4 &amp;&amp;xmlHttp.status == 200)&#123; //状态正常时 console.log(xmlHttp.responseText); // 返回服务器返回的数据 &#125; &#125;&#125;&lt;/script&gt; 12345678910//后台spring boot//HelloController@RestControllerpublic class HelloController&#123; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) public String say()&#123; return &quot;hello world&quot; &#125;&#125; 前台请求之后会出现跨域问题 在console里会出现1Failed to load http://localhost:8080/hello: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://127.0.0.1:8020&apos; is therefore not allowed access. 解决跨域问题的博客 附上修改之后的代码1234567891011121314151617//创建一个Class WebMvcConfig@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; /** * 跨域支持 * @return */ @Bean public WebMvcConfigurer corsConfigurer()&#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;).allowedMethods(&quot;*&quot;); &#125; &#125;; &#125;&#125; 然后请求服务器在console里就会返回”hello world” 配置数据库 mysql 数据库 在pom.xml 添加数据库的相关依赖，并在application.properties 文件里构建相关属性 123456789101112//application.properties#spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/wuxiaonashabispring.datasource.username=rootspring.datasource.password=****** //这里填入你的mysql的密码#spring.jpa.database = MYSQLspring.jpa.hibernate.ddl-auto=update // update 每次启动项目不会新建表spring.jpa.show-sql=true#spring.jackson.serialization.indent_output=true 创建一个类 Girl12345678910111213141516171819202122232425262728293031323334353637383940// class Girl@Entity public class Girl &#123; @Id @GeneratedValue private Integer id; private String name; private String age; public Girl()&#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 1234//创建 名为GirlRepository 接口public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt; &#123;&#125; 重启服务器，并刷新数据库会创建一个名为girl的表 由于我之前post添加了数据所以数据库里存在两条数据,如果测试get请求，findAll()方法，在数据库里手动添加数据 从数据库返回数据列表给前台12345678910111213// js&lt;script&gt;var xmlHttp;function getRequest()&#123; var url = &quot;http://localhost:8080/girls&quot;; xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState == 4 &amp;&amp;xmlHttp.status == 200)&#123; //状态正常时 console.log(xmlHttp.responseText); // 返回服务器返回的数据 &#125; &#125;&#125;&lt;/script&gt; 1234567891011// spring boot//创建一个class GirlControllerpublic class GirlController&#123; @Autowired private GirlRepository girlRespository; @GetMapping(value = &quot;/girls&quot;) public List&lt;Girl&gt; girlList()&#123; return girlRespository.findAll(); &#125;&#125; 前台console显示 使用JavaScript配合ajax响应POST请求问题：怎样向后台发送json格式数据，单纯将object对象转换为json格式就可以吗？前台js代码123456789101112131415161718192021222324//js&lt;script type=&quot;text/javascript&quot;&gt; var xmlHttp; var data; function getRequest() &#123; var url = &apos;http://localhost:8080/girls&apos;; xmlHttp = new XMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; data = xmlHttp.responseText; console.log(data); &#125; &#125; var obj = new Object(); obj = &#123; name: &quot;Bob&quot;, age: &quot;22&quot;, &#125; xmlHttp.open(&apos;POST&apos;, url); xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/Json&quot;);//添加请求头 obj = JSON.stringify(obj); xmlHttp.send(obj); &#125; 后台java代码123456789101112131415161718192021222324// spring bootpublic class GirlController&#123; @Autowired private GirlRepository girlRespository; @GetMapping(value = &quot;/girls&quot;) public List&lt;Girl&gt; girlList()&#123; return girlRespository.findAll(); &#125; /** * * @param name * @param age * @return */// @RequestMapping(value=&quot;/girls&quot;,method = RequestMethod.POST) @PostMapping(value=&quot;/girls&quot;) public Girl girlAdd(@RequestBody Girl cgirl)&#123; Girl girl = new Girl(); girl.setName(cgirl.getName()); girl.setAge(cgirl.getAge()); return girlRespository.save(girl); &#125;&#125; 响应结果 前端包装数据存在的问题json数据包后端接收数据是json格式，在前台传送数据的时候将object对象转换成json格式123456var obj = new Object(); obj = &#123; name: &quot;Bob&quot;, age: &quot;22&quot;, &#125;obj = JSON.stringify(obj); 错误原因这个表是传送的数据格式不正确，后台希望的是一个json格式，而不是一个文本“text/plain” 解决方案 需要传送的数据更改为application/Json12345// jsxmlHttp.open(&apos;POST&apos;, url);xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/Json&quot;);//添加请求头obj = JSON.stringify(obj);xmlHttp.send(obj); 123456789101112131415//jQuery 处理方法$.ajax(&#123; type: &apos;POST&apos;, //请求方式 contentType: &quot;application/json&quot;, // 设置传输数据格式 url: &quot;http://localhost:8080/girls&quot;, data: JSON.stringify(obj), // 传送数据 dataType: &apos;json&apos;, //接收数据类型 cache: true, //异常处理 success: function(data)&#123; //回调 console.log(data); &#125;, error: function(e)&#123; //回调 console.log(e); &#125;&#125;);]]></content>
      <categories>
        <category>POST</category>
      </categories>
      <tags>
        <tag>-javaScript-ajax-SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue上使用sass]]></title>
    <url>%2F2018%2F06%2F27%2Ftest-2%2F</url>
    <content type="text"><![CDATA[如何安装SassSass、gem安装教程当安装完成后在终端输入1sass -v 如下sass常用更新、查看版本、帮助等命令12345678// 更新sassgem update sass//查看版本sass -v//查看sass帮助sass -h 如何在vue.js中安装sass的依赖的两种方法1. 在当前项目的目录下引入123cnpm install sass-loader -Dcnpm install node-sass -D 引入完成之后在package.json中会有如下两个依赖“node-sass”: “^4.9.0”,“sass-loader”: “^7.0.3”,这样这个项目就配置好了sass 如果运行项目之后不能使用sass那么就在webpack.base.conf.js中的module：的rules：[ ] 下添加：12345678910&#123; test: /\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; scss: &apos;style-loader!css-loader!sass-loader&apos;, sass: &apos;style-loader!css-loader!sass-loader?indentedSyntax&apos;, &#125;, &#125;, &#125;, 2. 官方Sass Loader的引入方法sass Loade官方仓库]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery配合vue.js注册锚点实现动画过渡效果]]></title>
    <url>%2F2018%2F06%2F23%2Ftext-1%2F</url>
    <content type="text"><![CDATA[问题：如何利用jQuery实现网页导航栏注册锚点并有过渡效果引言：jquery库 - 特性jQuery 是一个 JavaScript 函数库。 jQuery 库包含以下特性： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 为什么要实现点击导航栏到当前组件要有过渡效果：目前大多数官网首页都是各种炫酷的动画，如果仅仅只是在a标签的herf里添加#id,然后在组件里添加id，虽然会实现到滑到页面，但是是真的丑陋至极，毫无违和感，而且当你刷新的时候会自动在你的路由下添加一个路径，然后就出现空白，着实很烦。如何实现： 利用vue.js和jQuery，因为vue.js写好组件然后通过组件直接显示页面这样各个组件不会相互干扰。 在vue.js 里配置jQuery 和bootstrap（由于我需要bootstrap 做响应式布局这里我也介绍吧）jQuery 引用 第一步1cnpm install jquery --save 第二步在build/webpack.base.conf.js里加入1var webpack = require(&quot;webpack&quot;) 第三步同样build/webpack.base.conf.js中在module.exports的最后加入1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;) ], 第四步在main.js 引入import $ from ‘jquery’1import $ from &apos;jquery&apos; 第五步重启本地服务器1cnpm run dev bootstrap引用第一步1cnpm install bootstrap --save 第二步在main.js中直接引入 12import &apos;../node_modules/bootstrap/dist/css/bootstrap.min.css&apos;;import &apos;../node_modules/bootstrap/dist/js/bootstrap.min.js&apos;; 第三步1cnpm run dev 代码12345678910111213141516171819202122HTML:&lt;ul class=&quot;nav navbar-nav ul_class_after&quot; v-for=&quot;(item,index) in navigation&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; class = &quot;a_class_jump&quot; @click=&quot;jump(item.item)&quot;&gt;&#123;&#123;item.item&#125;&#125;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;About id=&quot;About&quot;&gt;&lt;/About&gt;&lt;div id = &quot;Services&quot; style=&quot;height: 1000px&quot;&gt;2222&lt;/div&gt;js:jump(item)&#123; var top = $(&apos;#&apos;+item).offset().top; //获取当前id距离顶部距离 if(item == &apos;Home&apos;)&#123; &#125; else if(item == &apos;About&apos;)&#123; $(&apos;html,body&apos;).animate(&#123;scrollTop:top&#125;,1500); &#125; else&#123; $(&apos;html,body&apos;).animate(&#123;scrollTop:top&#125;,2000); //滚动条跳到当前id的位置，完成此操作需要2s &#125;&#125; 这样就会有一个过渡效果并且在2s内完成跳转，然候如果第一次进入这个锚点会有一个动画效果 12345678910111213141516171819202122232425262728293031323334353637383940HTML: &lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item1&quot;&gt;内容&lt;/div&gt;&lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item2&quot;&gt;内容&lt;/div&gt;&lt;div class=&quot;div_class_item&quot; id = &quot;div_id_item3&quot;&gt;内容&lt;/div&gt;需要添加的css：.animate_positive&#123; animation:route 2s; animation-fill-mode:forwards; animation-direction:alternate;&#125;@-webkit-keyframes route&#123; from &#123; margin-left: -60em; &#125; to&#123;margin-left: 0em ; &#125;&#125;@keyframe route&#123; from &#123; margin-left: -60em; &#125; to&#123;margin-left: 0em ; &#125;&#125;js:function loadAnimation(container_Id,aimation_name,offset)&#123; var contain_To_Top,window_ScrooTop,window_height,offset_To_Top; offset_To_Top=$(container_Id).offset().top; ontain_To_Top=eval(offset_To_Top + offset); //字符串相加 window_ScrooTop =$(window).scrollTop(); //窗口滚动高度 window_height=$(window).height();//窗口高度 if(window_ScrooTop + window_height&gt;contain_To_Top)&#123; $((container_Id)).addClass((aimation_name)); &#125;&#125;$(document).ready(function(e)&#123; $(window).scroll(function()&#123; loadAnimation(&quot;#div_id_item3&quot;,&quot;animate_positive&quot;,0); loadAnimation(&quot;#div_id_item2&quot;,&quot;animate_positive&quot;,0); loadAnimation(&quot;#div_id_item1&quot;,&quot;animate_positive&quot;,0); &#125;);&#125;); 码云demo 以上就是做一个简单的jQuery配合vue.js 做的一个过渡效果]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F23%2FHello-World%2F</url>
    <content type="text"><![CDATA[前言经过一天的努力终于在github创建了自己的博客，那我就来一篇Hello World吧，分享分享小编的踩过的坑。(此博客是基于安装了node.js以及git哦) 过程小编今天写了一天的js代码，晚上开始配置，看了许多教程，都没能搞明白，所以请教了隔壁大佬，帮小编解决了这些问题。 注册GitHub账号官网创建仓库1.登陆GitHub2.点击创建仓库 3.填写仓库信息仓库名称必须是 用户名+github.io，比如我的username是byAaronLuo，name我的仓库名称就是byAaronLuo.github.io(小编这里偷懒，copy大佬的图片，因为现在真的很晚了。。。) 配置SSH1.设置username 和email : 注意：这里一定要安装git 12git config --global user.name &quot;your GitHub&apos;s username&quot;git config --global user.name &quot;your GitHub&apos;s E-mail&quot; 2生成SSH密钥1ssh-keygen -t rsa -C &quot;your GitHub&apos;s E-mail &quot; 一般这种情况下是不需要密码的，所以一直回车就好 成功后，在C盘用户-&gt;Administrator 文件夹下就会有一个新的文件夹 .ssh，里面就有刚刚创建的ssh密钥文件id_rsa和id_rsa_pub 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。 3.添加公钥到GitHub点击用户头像，然后再点击Settings选项 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key 将 id_rsa.pub 的内容复制到Key 文本框中，再点击Add SSH key 4.测试SSH1ssh -T git@github.com 接下来会显示出下面的确认信息 12345The authenticity of host &apos;github.com (192.30.255.112)&apos; can&apos;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 输入yes然后回车，你会看见 1Hi byAaronLuo! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Hexo安装hexo安装好Node.js环境后，就可以通过node的npm包管理工具安装Hexo，执行以下指令(当然cnpm可以换成npm，这里使用淘宝镜像会更快，因为小编学习vue.js时配置过node.js，无论实在Linux、Pc、Macos 都是很好配置的哦) 1cnpm install hexo-cli -g hexo全局安装一次就够了，后面可以直接使用hexo相关的操作。 创建博客文件夹在此目录下管理自己的博客代码 12mkdir blogcd blog 初始化Hexo1hexo init 安装依赖包1cnpm install 生成静态页面1hexo g 启动本地服务器（在本地的localhost:4000）查看代码1hexo s 上传GitHub 这里小编习惯用git命令上传至仓库 完成上述操作后，在根目录中会出现一个public文件，在终端进入public文件，然后执行以下操作1234git remote add origin &lt;url&gt;git add .git commit -m &quot;ss&quot;git push -u origin master 域名配置现在已经可以通过https://yourname.github.io 来访问自己的博客站点啦。这时可能有人会说了，大家都通过github.io来访问，好没个性，能不能配置用自己的域名来访问自己的站点。答案当然可以。 首先，你得有个自己的域名，如果还没，那就去买个。 1.进域名控制台在解析里面添加一条CNAME记录，指向yourname.github.io即可。 2.打开项目，选择 setting 3.找到GitHub Pages （每次deploy过后都需要修改一次） 这样你就可以通过自己的域名访问了 其他基础命令123456789101112131415hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo clean #清除生成内容hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到指定空间hexo help # 查看帮助hexo version #查看Hexo的版本 hexo 命令缩写1234567hexo g：hexo generatehexo c：hexo cleanhexo s：hexo serverhexo d：hexo deploy hexo 命令组合123hexo clean &amp;&amp; hexo g -s #清除、生成、启动hexo clean &amp;&amp; hexo g -d #清除、生成、部署]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
